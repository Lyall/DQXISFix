#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: JackGame

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "JackGame_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "AIModule_structs.hpp"
#include "AIModule_classes.hpp"
#include "SQEXSEAD_classes.hpp"
#include "SlateCore_structs.hpp"
#include "JackAnimNodeRuntime_structs.hpp"
#include "ApexDestruction_classes.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "Slate_structs.hpp"
#include "OSDKModule_classes.hpp"


namespace SDK
{

// Class JackGame.JackCharacter
// 0x0940 (0x10F0 - 0x07B0)
class AJackCharacter : public ACharacter
{
public:
	uint8                                         Pad_7B0[0x20];                                     // 0x07B0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPenetrationAdjustmentConstrainPrevWalkableFloor;  // 0x07D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AutoNavigationAnimMontageName;                     // 0x07D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E0[0x90];                                     // 0x07E0(0x0090)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        CoordinateDependencyObjects;                       // 0x0870(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	float                                         NavAgentLocationOffsetHeight;                      // 0x0880(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCompleteAnimNodeBlendOnStabilizePose;             // 0x0884(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSkipSnapToGroundOnTeleport;                       // 0x0885(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_886[0x2];                                      // 0x0886(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PathArrivalRadius;                                 // 0x0888(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_88C[0x4];                                      // 0x088C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontageTurnLeft;                               // 0x0890(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageTurnBackLeft;                           // 0x0898(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageTurnRight;                              // 0x08A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageTurnBackRight;                          // 0x08A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNpcEscape;                                      // 0x08B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8B1[0x3];                                      // 0x08B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpeedOfNpcEscapeStart;                             // 0x08B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceOfNpcEscapeStart;                          // 0x08B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDontApplyCoordinate;                              // 0x08BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8BD[0x3];                                      // 0x08BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLDT_Coordinate                    CoordinateID;                                      // 0x08C0(0x0010)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         CoordinateMeshesCachedMaxDrawDistance;             // 0x08D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D4[0x114];                                    // 0x08D4(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackTimeComponent*                     TimeComponent;                                     // 0x09E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackMatineeControlComponent*           MatineeControlComponent;                           // 0x09F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackReservedEffectComponent*           ReservedEffectComponent;                           // 0x09F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackVehicleRiderComponent*             VehicleRiderComponent;                             // 0x0A00(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackTalkComponent*                     TalkComponent;                                     // 0x0A08(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackAnimNotifyComponent*               AnimNotifyComponent;                               // 0x0A10(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackMaterialCoordinatorComponent*      MaterialCoordinatorComponent;                      // 0x0A18(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackInteractiveActorComponent*         CachedInteractiveActorComponent;                   // 0x0A20(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackInteractorComponent*               CachedInteractorComponent;                         // 0x0A28(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackRigidBodyComponent*                CachedRigidBodyComponent;                          // 0x0A30(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLookAtComponent*                   CachedLookAtComponent;                             // 0x0A38(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackEyeLookAtComponent*                CachedEyeLookAtComponent;                          // 0x0A40(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFootIKComponent*                   CachedFootIKComponent;                             // 0x0A48(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFacialControlComponent*            CachedFacialControlComponent;                      // 0x0A50(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLoadReductionComponent*            CachedLoadReductionComponent;                      // 0x0A58(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackPropsComponent*                    CachedPropsComponent;                              // 0x0A60(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackArmIKComponent*                    CachedArmIKComponent;                              // 0x0A68(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGroundAffectComponent*             CachedGroundAffectComponent;                       // 0x0A70(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackBattleAIComponent*                 CachedBattleAIComponent;                           // 0x0A78(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A80[0x10];                                     // 0x0A80(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJackGameCharacter>      GameCharacter;                                     // 0x0A90(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A98[0x1A];                                     // 0x0A98(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInRoom;                                           // 0x0AB2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AB3[0x7D];                                     // 0x0AB3(0x007D)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsInBattle;                                       // 0x0B30(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRotateToDamagedDirection;                         // 0x0B31(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B32[0xE];                                      // 0x0B32(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          LockOnTargetCharacter;                             // 0x0B40(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLockOnTroop;                                      // 0x0B48(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B49[0x3];                                      // 0x0B49(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LockOnLocation;                                    // 0x0B4C(0x000C)(Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B58[0x10];                                     // 0x0B58(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   AimAttackSocketName;                               // 0x0B68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B70[0x8];                                      // 0x0B70(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackRotationControl*                   RotationControl;                                   // 0x0B78(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B80[0x88];                                     // 0x0B80(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackParticleDict>              Particles;                                         // 0x0C08(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackSoundDict>                 Sounds;                                            // 0x0C18(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackProjectileClassDict>       ProjectileClasses;                                 // 0x0C28(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackWeaponClassDict>           WeaponClasses;                                     // 0x0C38(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackPropClassDict>             PropClasses;                                       // 0x0C48(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackCameraAnimDict>            CameraAnims;                                       // 0x0C58(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackCameraShakeDict>           CameraShakes;                                      // 0x0C68(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackForceFeedbackDict>         ForceFeedbacks;                                    // 0x0C78(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackCurveDict>                 Curves;                                            // 0x0C88(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackMaterialParameterCollectionDict> MaterialParameterCollections;                      // 0x0C98(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackCollideEffectDict>         CollideEffects;                                    // 0x0CA8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackStaticMeshDict>            StaticMeshes;                                      // 0x0CB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackSkeletalMeshDict>          SkeletalMeshes;                                    // 0x0CC8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackMaterialDict>              Materials;                                         // 0x0CD8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackTextureDict>               Textures;                                          // 0x0CE8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	struct FJackCharacterFootstepEffectContainer  FootstepEffectsContainer;                          // 0x0CF8(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FJackCharacterDamageEffectContainer    DamageEffectsContainer;                            // 0x0D08(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	struct FJackCharacterCoordEffectContainer     CoordSoundsContainer;                              // 0x0D18(0x0010)(Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_D28[0x38];                                     // 0x0D28(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               DeferredLoadAssetsHolder;                          // 0x0D60(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture*>                       DeferredStreamingTextures;                         // 0x0D68(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	bool                                          bWaitForFixupLooksUntilBecomeHighResolutionTextures; // 0x0D78(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_D79[0x37];                                     // 0x0D79(0x0037)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InjuryMinRate;                                     // 0x0DB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InjuryMaxRate;                                     // 0x0DB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         IgnoredAnimNotifyClasses;                          // 0x0DB8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bMeshReceivesDecals;                               // 0x0DC8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMeshPostProcessEdge;                              // 0x0DC9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DCA[0x12E];                                    // 0x0DCA(0x012E)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTeleportResetClothAndPhysics;                     // 0x0EF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_EF9[0x3];                                      // 0x0EF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayEnabledTeleportClothAndPhysics;               // 0x0EFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F00[0x8];                                      // 0x0F00(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SimulatePhysicsBoneNames;                          // 0x0F08(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   DefaultLookedAtSocketName;                         // 0x0F18(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F20[0x68];                                     // 0x0F20(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class UAnimSequenceBase*, struct FJackAnimCancelFrameInfo> CancelFrameInfos;                                  // 0x0F88(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_FD8[0x4];                                      // 0x0FD8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	ERootMotionMode                               BattleRootMotionMode;                              // 0x0FDC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_FDD[0xD3];                                     // 0x0FDD(0x00D3)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bMustBeAbleToCloseupWithCamera;                    // 0x10B0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDontCloseupWithCamera;                            // 0x10B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisplayDebugInfoEnabled;                          // 0x10B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowAttackCollision;                              // 0x10B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowClothCollisions;                              // 0x10B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10B5[0x2B];                                    // 0x10B5(0x002B)(Fixing Size After Last Property [ Dumper-7 ])
	class USQEXSEADAutoSeComponent*               AutoSeComponent;                                   // 0x10E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10E8[0x8];                                     // 0x10E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AbortLatentAction();
	void AsyncFixupLooks();
	void CompleteLookAtInterp();
	void DisableClothAndPhysics();
	void EnableClothAndPhysics();
	void EndBPControl();
	class UActorComponent* FindOrAddComponentByClass(TSubclassOf<class UActorComponent> ComponentClass);
	void FixupLooks();
	void ForceFullRecover();
	void GetBattleABPInfo(float InMovementRate, float* OutMovementRate, float* OutMovementRootMotionTranslationRate, EJackEquippedWeaponStyle* OutWeaponStyle, bool* OutWeaponEquipChange, bool* OutWeaponEquipChangeFlip, float* OutInjuryRate, bool* OutIsInBattle, bool* OutIsDefending, bool* OutIsEquippedBothHands);
	class UJackBattleAIComponent* GetBattleAIComponent();
	class AJackBattleCommandAI* GetBattleCommandAI();
	class AJackCharacter* GetCoffinActor();
	class UJackEquipmentControlComponent* GetJackEquipmentControlComponent();
	class UJackInteractiveActorComponent* GetJackInteractiveActorComponent();
	class UJackInteractorComponent* GetJackInteractorComponent();
	class UJackWeatherAffectComponent* GetJackWeatherAffectComponent();
	class AJackBattleSnowman* GetSnowmanActor();
	bool IsRecentlyRendered();
	void Latent_Animation(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class UAnimMontage* AnimMontage, int32 Minute, bool bWait);
	void Latent_MoveToActor(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AActor* Goal, float Speed, class UAnimMontage* AnimMontage);
	void Latent_MoveToLocation(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FVector& Goal, float Speed, class UAnimMontage* AnimMontage);
	void Latent_SimpleNavigationTo(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FVector& GoalLocation, const struct FRotator& GoalRotation, float Speed, float RotationSpeed, class UAnimMontage* AnimMontage);
	void Latent_TurnToActor(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AActor* Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void Latent_TurnToAngle(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float Angle, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void Latent_TurnToLocation(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FVector& Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void LookAtCharacter(class AJackCharacter* Character, class FName Socket);
	void LookAtEnd();
	void LookAtLocation(const struct FVector& Location);
	void OnBattleEndDelegate__DelegateSignature();
	void OnBattleStartDelegate__DelegateSignature();
	void OnCharacterCoordinateChanged();
	void OnFixupLooks();
	void OnPlayAnimMontageByKeyDelegate__DelegateSignature(class FName AnimMontageKey, class UAnimMontage* AnimMontage);
	void OnTeleported(bool bSucceeded);
	float PlayAnimMontageByKeyBP(class FName AnimMontageKey, float InPlayRate, class FName StartSectionName);
	void ResetCancelFrameControlCount();
	void SetActorBlockCollisonToOverlap(EJackCharacterIgnoreCollisionPurpose Purpose, bool bNewActorForceOverlapCollision);
	void SetActorIgnoreCollision(EJackCharacterIgnoreCollisionPurpose Purpose, bool bNewActorIgnoreCollision);
	void SetAnimDynamicsIdlingCount(int32 IdlingCount, bool bRequireResetDynamics);
	void SetAutoLookAtEnbaled(bool bEnabled);
	void SetAutonomicMovementDisabled(bool bDisabled, EJackCharacterControlChannel InChannel);
	void SetCharacterCoordinate(class FName InCoordinateID, EJackCharacterCoordinateLayer InCoordinateLayer, EJackCharacterCoordinateLoader LoaderType);
	void SetCollisionEnabledToBattlePawn(bool bEnabled);
	void SetDitherHiddenActor(EJackCharacterHiddenPurpose InPurpose, bool bNewHidden, class UCurveBase* Curve, float InRequiredSeconds, bool bIsParticleActiveChangeDisable);
	void SetHiddenControl(EJackCharacterHiddenPurpose Purpose, bool bNewHidden, bool bPreventCapsuleControl);
	void SetIgnoreLookAt(EJackCharacterLookAtPurpose Purpose, bool bIgnore);
	void SetInBattleForBunsin();
	void SetInRoom(bool bNewInRoom);
	void SetJumpDisabled(bool bDisabled, EJackCharacterControlChannel InChannel);
	void SetLookAtMobileRegion(float PitchUp, float PitchDown, float YawLeft, float YawRight);
	void SetLookAtSingleNode(bool bFlag, bool bRateToZeroIfNotLookAt);
	void SetLookAtTargetUpdateMoveOnly(bool bFlag);
	void SetMeshPostProcessEdge(bool bInPostProcessEdge);
	void SetMeshReceivesDecals(bool bInReceivesDecals);
	void SetMovementEnabled(bool bEnabled, EJackCharacterControlChannel InChannel);
	void SetOverrideLODInfo(EJackCharacterCoordinateLODInfo Type);
	void SetPause(EJackCharacterPausePurpose Purpose, bool bPause);
	void SetRootMotionMode(ERootMotionMode Mode, bool bConsumeRootMotion);
	void SimpleAutoNavigationTo(const struct FVector& InLocation, const struct FRotator& InRotation, float InSeconds, float InRotationSeconds);
	void SimpleAutoNavigationToWithSpeed(const struct FVector& InLocation, const struct FRotator& InRotation, float InSpeed);
	void SkipUpdateAnimation(float DeltaSeconds, bool bCallNotify);
	bool SnapToGround(EJackCharacterCollisionResponse CollisionResponseType);
	bool SnapToGroundLocationWithRotation(const struct FVector& Location, const struct FRotator& Rotation, float SearchDistance);
	void StabilizePose(bool bRequireResetDynamics);
	void StartBPControl();
	bool TeleportNoCollisionCheck(const struct FVector& DestLocation, const struct FRotator& DestRotation);

	class UAnimMontage* FindAnimMontage(const class FName InName, bool bWarnIfMissing) const;
	class UAnimMontage* FindAnimMontageChecked(const class FName InName) const;
	class UAnimMontage* FindAnimMontageWeaponStyle(const class FName InName, bool bWarnIfMissing) const;
	class UAnimMontage* FindAnimMontageWeaponStyleChecked(const class FName InName) const;
	class FName FindAnimMontageWeaponStyleName(const class FName InName) const;
	class AJackBattleCommandAI* FindBattleCommandAI(const class UClass* TargetClass) const;
	class UCameraAnim* FindCameraAnim(const class FName InName, bool bWarnIfMissing) const;
	class UCameraAnim* FindCameraAnimChecked(const class FName InName) const;
	TSubclassOf<class UCameraShake> FindCameraShake(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class UCameraShake> FindCameraShakeChecked(const class FName InName) const;
	TSubclassOf<class UJackCollideEffect> FindCollideEffect(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class UJackCollideEffect> FindCollideEffectChecked(const class FName InName) const;
	class UCurveBase* FindCurve(const class FName InName, bool bWarnIfMissing) const;
	class UCurveBase* FindCurveChecked(const class FName InName) const;
	class UForceFeedbackEffect* FindForceFeedback(const class FName InName, bool bWarnIfMissing) const;
	class UForceFeedbackEffect* FindForceFeedbackChecked(const class FName InName) const;
	class UMaterialInterface* FindMaterial(const class FName InName, bool bWarnIfMissing) const;
	class UMaterialInterface* FindMaterialChecked(const class FName InName) const;
	class UMaterialParameterCollection* FindMaterialParameterCollection(const class FName InName, bool bWarnIfMissing) const;
	class UMaterialParameterCollection* FindMaterialParameterCollectionChecked(const class FName InName) const;
	class UParticleSystem* FindParticle(const class FName InName, bool bWarnIfMissing) const;
	class UParticleSystem* FindParticleChecked(const class FName InName) const;
	TSubclassOf<class AJackProjectile> FindProjectileClass(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class AJackProjectile> FindProjectileClassChecked(const class FName InName) const;
	class USkeletalMesh* FindSkeletalMesh(const class FName InName, bool bWarnIfMissing) const;
	class USkeletalMesh* FindSkeletalMeshChecked(const class FName InName) const;
	class USoundBase* FindSound(const class FName InName, bool bWarnIfMissing) const;
	class USoundBase* FindSoundChecked(const class FName InName) const;
	class UStaticMesh* FindStaticMesh(const class FName InName, bool bWarnIfMissing) const;
	class UStaticMesh* FindStaticMeshChecked(const class FName InName) const;
	class UTexture* FindTexture(const class FName InName, bool bWarnIfMissing) const;
	class UTexture* FindTextureChecked(const class FName InName) const;
	TSubclassOf<class AJackWeaponBase> FindWeaponClass(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class AJackWeaponBase> FindWeaponClassChecked(const class FName InName) const;
	void GetActorBoundsWithoutMesh(struct FVector* OutOrigin, struct FVector* OutBoxExtent) const;
	float GetAdditiveAnimationRate() const;
	class FName GetAutoNavigationAnimMontageName() const;
	class FName GetCharacterCoordinate() const;
	class USkinnedMeshComponent* GetCoordinatePartsMeshComponent(EJackCharacterCoordinateParts PartsType) const;
	struct FVector GetDesiredMovementLocalDirection() const;
	EJackEquippedWeaponStyle GetEquippedWeaponStyle() const;
	class UJackArmIKComponent* GetJackArmIKComponent() const;
	class UJackFootIKComponent* GetJackFootIKComponent() const;
	class UJackPropsComponent* GetJackPropsComponent() const;
	float GetLookAtApplyRate() const;
	float GetLookAtApplySecondNodeRate() const;
	class UJackLookAtComponent* GetLookAtComponent() const;
	struct FVector GetLookAtInterpLocation() const;
	float GetMovementAnimationPlayRate() const;
	float GetMovementSpeedRate() const;
	TArray<class USkeletalMeshComponent*> GetOutlineSkeletalMeshComponents() const;
	struct FRotator GetRotationToDesired() const;
	float GetTurningAnimationPlayRate() const;
	bool IsBPControl() const;
	bool IsDead() const;
	bool IsDeclarationToUseMatinee() const;
	bool IsDefending() const;
	bool IsDitherHidden(EJackCharacterHiddenPurpose InPurpose) const;
	bool IsDitherHiddenAllPurpose() const;
	bool IsDitherRunning() const;
	bool IsEquippedBothHands() const;
	bool IsFloating() const;
	bool IsHiddenControl(EJackCharacterHiddenPurpose Purpose) const;
	bool IsInRoom() const;
	bool IsInTheAir() const;
	bool IsOpenWeapon() const;
	void StopAllMontageImmediately() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacter">();
	}
	static class AJackCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCharacter>();
	}
};
static_assert(alignof(AJackCharacter) == 0x000010, "Wrong alignment on AJackCharacter");
static_assert(sizeof(AJackCharacter) == 0x0010F0, "Wrong size on AJackCharacter");
static_assert(offsetof(AJackCharacter, bPenetrationAdjustmentConstrainPrevWalkableFloor) == 0x0007D0, "Member 'AJackCharacter::bPenetrationAdjustmentConstrainPrevWalkableFloor' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AutoNavigationAnimMontageName) == 0x0007D8, "Member 'AJackCharacter::AutoNavigationAnimMontageName' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CoordinateDependencyObjects) == 0x000870, "Member 'AJackCharacter::CoordinateDependencyObjects' has a wrong offset!");
static_assert(offsetof(AJackCharacter, NavAgentLocationOffsetHeight) == 0x000880, "Member 'AJackCharacter::NavAgentLocationOffsetHeight' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bCompleteAnimNodeBlendOnStabilizePose) == 0x000884, "Member 'AJackCharacter::bCompleteAnimNodeBlendOnStabilizePose' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bSkipSnapToGroundOnTeleport) == 0x000885, "Member 'AJackCharacter::bSkipSnapToGroundOnTeleport' has a wrong offset!");
static_assert(offsetof(AJackCharacter, PathArrivalRadius) == 0x000888, "Member 'AJackCharacter::PathArrivalRadius' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AnimMontageTurnLeft) == 0x000890, "Member 'AJackCharacter::AnimMontageTurnLeft' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AnimMontageTurnBackLeft) == 0x000898, "Member 'AJackCharacter::AnimMontageTurnBackLeft' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AnimMontageTurnRight) == 0x0008A0, "Member 'AJackCharacter::AnimMontageTurnRight' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AnimMontageTurnBackRight) == 0x0008A8, "Member 'AJackCharacter::AnimMontageTurnBackRight' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bIsNpcEscape) == 0x0008B0, "Member 'AJackCharacter::bIsNpcEscape' has a wrong offset!");
static_assert(offsetof(AJackCharacter, SpeedOfNpcEscapeStart) == 0x0008B4, "Member 'AJackCharacter::SpeedOfNpcEscapeStart' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DistanceOfNpcEscapeStart) == 0x0008B8, "Member 'AJackCharacter::DistanceOfNpcEscapeStart' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bDontApplyCoordinate) == 0x0008BC, "Member 'AJackCharacter::bDontApplyCoordinate' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CoordinateID) == 0x0008C0, "Member 'AJackCharacter::CoordinateID' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CoordinateMeshesCachedMaxDrawDistance) == 0x0008D0, "Member 'AJackCharacter::CoordinateMeshesCachedMaxDrawDistance' has a wrong offset!");
static_assert(offsetof(AJackCharacter, TimeComponent) == 0x0009E8, "Member 'AJackCharacter::TimeComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, MatineeControlComponent) == 0x0009F0, "Member 'AJackCharacter::MatineeControlComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, ReservedEffectComponent) == 0x0009F8, "Member 'AJackCharacter::ReservedEffectComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, VehicleRiderComponent) == 0x000A00, "Member 'AJackCharacter::VehicleRiderComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, TalkComponent) == 0x000A08, "Member 'AJackCharacter::TalkComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AnimNotifyComponent) == 0x000A10, "Member 'AJackCharacter::AnimNotifyComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, MaterialCoordinatorComponent) == 0x000A18, "Member 'AJackCharacter::MaterialCoordinatorComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedInteractiveActorComponent) == 0x000A20, "Member 'AJackCharacter::CachedInteractiveActorComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedInteractorComponent) == 0x000A28, "Member 'AJackCharacter::CachedInteractorComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedRigidBodyComponent) == 0x000A30, "Member 'AJackCharacter::CachedRigidBodyComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedLookAtComponent) == 0x000A38, "Member 'AJackCharacter::CachedLookAtComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedEyeLookAtComponent) == 0x000A40, "Member 'AJackCharacter::CachedEyeLookAtComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedFootIKComponent) == 0x000A48, "Member 'AJackCharacter::CachedFootIKComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedFacialControlComponent) == 0x000A50, "Member 'AJackCharacter::CachedFacialControlComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedLoadReductionComponent) == 0x000A58, "Member 'AJackCharacter::CachedLoadReductionComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedPropsComponent) == 0x000A60, "Member 'AJackCharacter::CachedPropsComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedArmIKComponent) == 0x000A68, "Member 'AJackCharacter::CachedArmIKComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedGroundAffectComponent) == 0x000A70, "Member 'AJackCharacter::CachedGroundAffectComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CachedBattleAIComponent) == 0x000A78, "Member 'AJackCharacter::CachedBattleAIComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacter, GameCharacter) == 0x000A90, "Member 'AJackCharacter::GameCharacter' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bInRoom) == 0x000AB2, "Member 'AJackCharacter::bInRoom' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bIsInBattle) == 0x000B30, "Member 'AJackCharacter::bIsInBattle' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bRotateToDamagedDirection) == 0x000B31, "Member 'AJackCharacter::bRotateToDamagedDirection' has a wrong offset!");
static_assert(offsetof(AJackCharacter, LockOnTargetCharacter) == 0x000B40, "Member 'AJackCharacter::LockOnTargetCharacter' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bLockOnTroop) == 0x000B48, "Member 'AJackCharacter::bLockOnTroop' has a wrong offset!");
static_assert(offsetof(AJackCharacter, LockOnLocation) == 0x000B4C, "Member 'AJackCharacter::LockOnLocation' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AimAttackSocketName) == 0x000B68, "Member 'AJackCharacter::AimAttackSocketName' has a wrong offset!");
static_assert(offsetof(AJackCharacter, RotationControl) == 0x000B78, "Member 'AJackCharacter::RotationControl' has a wrong offset!");
static_assert(offsetof(AJackCharacter, Particles) == 0x000C08, "Member 'AJackCharacter::Particles' has a wrong offset!");
static_assert(offsetof(AJackCharacter, Sounds) == 0x000C18, "Member 'AJackCharacter::Sounds' has a wrong offset!");
static_assert(offsetof(AJackCharacter, ProjectileClasses) == 0x000C28, "Member 'AJackCharacter::ProjectileClasses' has a wrong offset!");
static_assert(offsetof(AJackCharacter, WeaponClasses) == 0x000C38, "Member 'AJackCharacter::WeaponClasses' has a wrong offset!");
static_assert(offsetof(AJackCharacter, PropClasses) == 0x000C48, "Member 'AJackCharacter::PropClasses' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CameraAnims) == 0x000C58, "Member 'AJackCharacter::CameraAnims' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CameraShakes) == 0x000C68, "Member 'AJackCharacter::CameraShakes' has a wrong offset!");
static_assert(offsetof(AJackCharacter, ForceFeedbacks) == 0x000C78, "Member 'AJackCharacter::ForceFeedbacks' has a wrong offset!");
static_assert(offsetof(AJackCharacter, Curves) == 0x000C88, "Member 'AJackCharacter::Curves' has a wrong offset!");
static_assert(offsetof(AJackCharacter, MaterialParameterCollections) == 0x000C98, "Member 'AJackCharacter::MaterialParameterCollections' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CollideEffects) == 0x000CA8, "Member 'AJackCharacter::CollideEffects' has a wrong offset!");
static_assert(offsetof(AJackCharacter, StaticMeshes) == 0x000CB8, "Member 'AJackCharacter::StaticMeshes' has a wrong offset!");
static_assert(offsetof(AJackCharacter, SkeletalMeshes) == 0x000CC8, "Member 'AJackCharacter::SkeletalMeshes' has a wrong offset!");
static_assert(offsetof(AJackCharacter, Materials) == 0x000CD8, "Member 'AJackCharacter::Materials' has a wrong offset!");
static_assert(offsetof(AJackCharacter, Textures) == 0x000CE8, "Member 'AJackCharacter::Textures' has a wrong offset!");
static_assert(offsetof(AJackCharacter, FootstepEffectsContainer) == 0x000CF8, "Member 'AJackCharacter::FootstepEffectsContainer' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DamageEffectsContainer) == 0x000D08, "Member 'AJackCharacter::DamageEffectsContainer' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CoordSoundsContainer) == 0x000D18, "Member 'AJackCharacter::CoordSoundsContainer' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DeferredLoadAssetsHolder) == 0x000D60, "Member 'AJackCharacter::DeferredLoadAssetsHolder' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DeferredStreamingTextures) == 0x000D68, "Member 'AJackCharacter::DeferredStreamingTextures' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bWaitForFixupLooksUntilBecomeHighResolutionTextures) == 0x000D78, "Member 'AJackCharacter::bWaitForFixupLooksUntilBecomeHighResolutionTextures' has a wrong offset!");
static_assert(offsetof(AJackCharacter, InjuryMinRate) == 0x000DB0, "Member 'AJackCharacter::InjuryMinRate' has a wrong offset!");
static_assert(offsetof(AJackCharacter, InjuryMaxRate) == 0x000DB4, "Member 'AJackCharacter::InjuryMaxRate' has a wrong offset!");
static_assert(offsetof(AJackCharacter, IgnoredAnimNotifyClasses) == 0x000DB8, "Member 'AJackCharacter::IgnoredAnimNotifyClasses' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bMeshReceivesDecals) == 0x000DC8, "Member 'AJackCharacter::bMeshReceivesDecals' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bMeshPostProcessEdge) == 0x000DC9, "Member 'AJackCharacter::bMeshPostProcessEdge' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bTeleportResetClothAndPhysics) == 0x000EF8, "Member 'AJackCharacter::bTeleportResetClothAndPhysics' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DelayEnabledTeleportClothAndPhysics) == 0x000EFC, "Member 'AJackCharacter::DelayEnabledTeleportClothAndPhysics' has a wrong offset!");
static_assert(offsetof(AJackCharacter, SimulatePhysicsBoneNames) == 0x000F08, "Member 'AJackCharacter::SimulatePhysicsBoneNames' has a wrong offset!");
static_assert(offsetof(AJackCharacter, DefaultLookedAtSocketName) == 0x000F18, "Member 'AJackCharacter::DefaultLookedAtSocketName' has a wrong offset!");
static_assert(offsetof(AJackCharacter, CancelFrameInfos) == 0x000F88, "Member 'AJackCharacter::CancelFrameInfos' has a wrong offset!");
static_assert(offsetof(AJackCharacter, BattleRootMotionMode) == 0x000FDC, "Member 'AJackCharacter::BattleRootMotionMode' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bMustBeAbleToCloseupWithCamera) == 0x0010B0, "Member 'AJackCharacter::bMustBeAbleToCloseupWithCamera' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bDontCloseupWithCamera) == 0x0010B1, "Member 'AJackCharacter::bDontCloseupWithCamera' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bDisplayDebugInfoEnabled) == 0x0010B2, "Member 'AJackCharacter::bDisplayDebugInfoEnabled' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bShowAttackCollision) == 0x0010B3, "Member 'AJackCharacter::bShowAttackCollision' has a wrong offset!");
static_assert(offsetof(AJackCharacter, bShowClothCollisions) == 0x0010B4, "Member 'AJackCharacter::bShowClothCollisions' has a wrong offset!");
static_assert(offsetof(AJackCharacter, AutoSeComponent) == 0x0010E0, "Member 'AJackCharacter::AutoSeComponent' has a wrong offset!");

// Class JackGame.JackAnimDynamicsCharacter
// 0x0000 (0x10F0 - 0x10F0)
class AJackAnimDynamicsCharacter final : public AJackCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimDynamicsCharacter">();
	}
	static class AJackAnimDynamicsCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackAnimDynamicsCharacter>();
	}
};
static_assert(alignof(AJackAnimDynamicsCharacter) == 0x000010, "Wrong alignment on AJackAnimDynamicsCharacter");
static_assert(sizeof(AJackAnimDynamicsCharacter) == 0x0010F0, "Wrong size on AJackAnimDynamicsCharacter");

// Class JackGame.JackUMGWidgetBase
// 0x01A0 (0x0370 - 0x01D0)
class UJackUMGWidgetBase : public UUserWidget
{
public:
	uint8                                         Pad_1D0[0x20];                                     // 0x01D0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WidgetName;                                        // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x01F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreIsVisible;                                  // 0x01F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x01FA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFocusableWindow;                                // 0x01FB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForceFocusable;                                 // 0x01FC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForceHilite;                                    // 0x01FD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShowHilite;                                     // 0x01FE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBindMenuKey;                                    // 0x01FF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsKeyEvent;                                       // 0x0200(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableInput;                                     // 0x0201(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExceptionCategory;                                // 0x0202(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitCanvasPanelToParent;                           // 0x0203(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkipCalcLocalPosition;                          // 0x0204(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreLoging;                                   // 0x0205(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreSafeAreaCheck;                            // 0x0206(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGPresetAnim                            OpenPresetAnimOption;                              // 0x0207(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGPresetAnim                            ClosePresetAnimOption;                             // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGPresetAnim                            ShowPresetAnimOption;                              // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGPresetAnim                            HidePresetAnimOption;                              // 0x020A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRoot;                                           // 0x020B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTopMenu;                                        // 0x020C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForePage;                                       // 0x020D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIgnoreCancelKey;                                // 0x020E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEnterKeyEventCalling;                       // 0x020F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCancelKeyEventCalling;                      // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultAdjustResize;                               // 0x0214(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              LayoutOffset;                                      // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SnapOffset;                                        // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           RootPanelRef;                                      // 0x0230(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultPosition;                                   // 0x0238(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CurrentPosition;                                   // 0x0240(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Position;                                          // 0x0248(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0250(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0258(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WidgetSize;                                        // 0x025C(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RootPosition;                                      // 0x0264(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextBaseColor;                                     // 0x026C(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextBorderColor;                                   // 0x027C(0x0010)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class FName EventTag)>         JackOnWidgetBPActionDelegate;                      // 0x0290(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   JackOnWidgetNotificationDelegate;                  // 0x02A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(EJackKeys InKeyType, bool bIsPressed)> JackOnWidgetKeyEventDelegate;                      // 0x02B0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C0[0x8];                                      // 0x02C0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UPanelWidget*                           OptimizePanel;                                     // 0x02C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x60];                                     // 0x02D0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGWidgetBase*                     ChildWidget;                                       // 0x0330(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGWidgetBase*                     ParentWidget;                                      // 0x0338(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackUMGAnimBase*>               AnimList;                                          // 0x0340(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_350[0x20];                                     // 0x0350(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UTextBlock*> CreateRubyTextBlockStatic(const class FText& InText, const class UTextBlock* InTextBlock, const class UTextBlock* InRefRubyTextBlock, class UPanelWidget* InParentPanel);
	static int32 GetInvalidZOrderValue();
	static float GetPanelAlpha(class UWidget* InPanel);
	static struct FVector2D GetPanelPosition(class UWidget* InPanel);
	static struct FVector2D GetPanelScale(class UWidget* InPanel);
	static struct FVector2D GetPanelSize(class UWidget* InPanel);
	static const EJackUMGTextColorSet GetTextColorTypeHP(int32 HP, int32 MaxHP);
	static const EJackUMGTextColorSet GetTextColorTypeHPRate(float HPRate);
	static void SetPanelAlpha(class UWidget* InPanel, float InAlpha);
	static void SetPanelPosition(class UWidget* InPanel, const struct FVector2D& InPosition);
	static void SetPanelScale(class UWidget* InPanel, const struct FVector2D& InScale);
	static void SetPanelSize(class UWidget* InPanel, const struct FVector2D& InSize);
	static void SetPanelVisibility(class UWidget* InPanel, bool bIsVisible_0);
	static void SetTextFontColorOfPanelInCanvesPanelStatic(class UObject* WorldContextObject, class UCanvasPanel* InCanvesPanel, const EJackUMGTextColorSet InColorType);
	static void SetTextFontColorOfPanelStatic(class UObject* WorldContextObject, class UTextBlock* InTextPanel, const EJackUMGTextColorSet InColorType);

	void AddPanel(class UWidget* InPanel, class UUserWidget* AddChild);
	const struct FVector2D AdjustScreenPosition(const struct FVector2D& InPosition);
	void CancelAnimation();
	void CheckWidgetPosition();
	TArray<class UTextBlock*> CreateRubyTextBlock(const class FText& InText, const class UTextBlock* InTextBlock, const class UTextBlock* InRefRubyTextBlock, class UPanelWidget* InParentPanel);
	void DebugFunction(int32 InDebugValue, const class FString& InDebugText);
	void DispMenuMessageWithDebug(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& InString, const TArray<struct FJackMessageArgumentData>& InTagList, int32 DefaultIndex, bool bPlayPipipiSound);
	void DispMenuMessageWithString(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FString& InString, const TArray<struct FJackMessageArgumentData>& InTagList, int32 DefaultIndex, bool bPlayPipipiSound);
	void DispMenuMessageWithTextId(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FName InTextId, const TArray<struct FJackMessageArgumentData>& InTagList);
	void DispMenuMessageWithTextIdAndIndex(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FName InTextId, const TArray<struct FJackMessageArgumentData>& InTagList, int32 DefaultIndex);
	void DispMessageWithTextId(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FName InTextId, const TArray<struct FJackMessageArgumentData>& InTagList);
	void DispMessageWithTextIdAndIndex(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const class FName InTextId, const TArray<struct FJackMessageArgumentData>& InTagList, int32 DefaultIndex);
	void DoCancelEvent();
	void DoEnterEvent();
	void DoWidgetBPActionDelegate(const class FName EventTag, const class FName InTargetWidgetName);
	void DoWidgetNotificationDelegate(const class FName EventTag, class UObject* InObject, class UJackUMGWidgetBase* InCallWidgetBase);
	void EnableKeyEvent(bool bEnable);
	void EnableKeyPressedEvent(bool bEnable);
	void EnableKeyReleasedEvent(bool bEnable);
	void EndAnimation();
	EJackKeys ExchangeFaceButtonToEnterCancel(EJackKeys InKeyType);
	class UTextBlock* FindChildTextBlock(bool bWarningIfDontFind);
	void FinishHideWindowDelegate();
	void FocusSelfWidget();
	class UJackUMGItemBase* GetItemBaseFromItemId(const class FName InItemId);
	struct FLinearColor GetPanelColor(class UWidget* InPanel);
	class UWidget* GetPanelFromName(const class FName InPanelName);
	class FText GetTextFromTextId(const class FName TextID);
	void InitWidget(int32 ZOrder);
	bool IsReverseEnterCancelButton();
	void JackOnUMGWidgetBPActionDelegate__DelegateSignature(const class FName EventTag);
	void JackOnUMGWidgetKeyEventDelegate__DelegateSignature(EJackKeys InKeyType, bool bIsPressed);
	void JackOnUMGWidgetNotificationDelegate__DelegateSignature(const class FName InEventTag, class UJackUMGWidgetBase* InCallWidgetBase, class UObject* InObject);
	void MakeTextBlockArray(class UCanvasPanel* InCanvesPanel, TArray<class UTextBlock*>* InTextBlockArray);
	void OffsetDefaultPosition(const struct FVector2D& InOffset);
	void PlayUISound(class USoundBase* InSoundBase, int32 MonophonicId);
	void PlayUISoundWithParam(class USoundBase* InSoundBase, int32 MonophonicId, float InVolume, float InPitch, float InStartTime);
	void RemoveWidget();
	void RepositionLayout();
	class UTexture2D* SelectTexture(const TArray<class UTexture2D*>& TexList, int32 Select, class UWidget* InImagePanel);
	void SetAlphaAnim(int32 InGroup, class UCurveFloat* InCurve, const float Start, const float End);
	void SetAlphaAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const float Start, const float End);
	void SetAlphaToAnim(int32 InGroup, class UCurveFloat* InCurve, const float End);
	void SetAlphaToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const float End);
	void SetAnimDelay(int32 InGroup, float DelayTime, bool bInNotCancel);
	void SetAnimDelegate(int32 InGroup, TDelegate<void()> InDelegate);
	bool SetAnimSet(int32 InGroup, const struct FJackUMGAnimSet& InAnimSet, bool bInNotCancel);
	bool SetAnimSetOfPanel(class UWidget* InPanel, int32 InGroup, const struct FJackUMGAnimSet& InAnimSet);
	void SetCharacterSpacingToTextBlockArray(const TArray<class UTextBlock*>& InTextBlockArray, float InSpacing);
	void SetChildWidget(class UJackUMGWidgetBase* InChildWidget);
	void SetDefaultPosition(const struct FVector2D& InPosition);
	void SetIsFocusableWindow(bool IsFocusable);
	void SetIsForceHilite(bool bIsHilite);
	bool SetLoaddedTextureFromId(class UJackUMGAsyncLoad* InAsyncLoad, class UImage* InImagePanel, int32 InUniqueId);
	void SetMenuDecOfPanel(class UTextBlock* InTextPanel, int32 InValue, int32 InFig, bool bIsSign);
	void SetMoveAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetMoveAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetMoveToAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetMoveToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetNameTextFontColor(const EJackUMGTextColorSet InColorType);
	void SetOnCursor(bool bIsOnCursor);
	void SetPanelColor(class UWidget* InPanel, const struct FLinearColor& InColor);
	void SetScaleAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetScaleAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetScaleToAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetScaleToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetSendKeyEventWidget(class UJackUMGWidgetBase* InWidgetBase);
	void SetSnapToSpecifiedWidget(const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType);
	void SetTextByNameFromTextId(const class FName InPanelName, const class FName TextID);
	void SetTextFontColor(const EJackUMGTextColorSet InColorType);
	void SetTextFontColorAtHp(int32 HP, int32 MaxHP);
	void SetTextFontColorAtHpRate(float HPRate);
	void SetTextFontColorInCanvesPanel(const EJackUMGTextColorSet InColorType, class UCanvasPanel* InCanvesPanel);
	void SetTextFontColorOfPanel(class UTextBlock* InTextPanel, const EJackUMGTextColorSet InColorType);
	void SetTextFontColorOfPanelInCanvesPanel(class UCanvasPanel* InCanvesPanel, const EJackUMGTextColorSet InColorType);
	void SetTextFontColorOfWidget(const class FName InItemId, const EJackUMGTextColorSet InColorType);
	void SetTextFontColorToTextBlockArray(const TArray<class UTextBlock*>& InTextBlockArray, const EJackUMGTextColorSet InColorType);
	void SetTextFromTextId(class UWidget* InPanel, const class FName TextID);
	void SetTextFromTextIdWithColor(class UWidget* InTextPanel, const class FName InTextId, EJackUMGTextColorSet InFontColor);
	void SetTextIdOfPanelInCanvesPanel(class UCanvasPanel* InCanvesPanel, const TArray<class FName>& InTextIdList);
	void SetTextIdToTextBlockArray(const TArray<class UTextBlock*>& InTextBlockArray, const class FName InTextId);
	void SetTextJustification(ETextJustify InJustification);
	void SetTextJustificationInCanvesPanel(ETextJustify InJustification, class UCanvasPanel* InCanvesPanel);
	void SetupOptimizePanel();
	void SetVisibleToTextBlockArray(const TArray<class UTextBlock*>& InTextBlockArray, ESlateVisibility InVisibility);
	void SetWidgetActive(bool InIsActive);
	void SetWidgetAlpha(float InAlpha);
	void SetWidgetDisableColor(bool bIsDisable);
	void SetWidgetName(const class FName InWidgetName);
	void SetWidgetPosition(const struct FVector2D& InPosition);
	void SetWidgetScale(const struct FVector2D& InScale);
	void SetWidgetVisible(bool InIsVisible);
	void StopUISound(class USoundBase* InSoundBase);
	void UpdateCanvasPanelSize();
	void UpdateOptimizeBox();
	void UpdateOptimizePanel();
	void UpdateWidget(float DeltaTime);
	int32 ValueLooper(int32 InValue, int32 InAdd, int32 InMin, int32 InMax);
	void Wait(class UObject* WorldContextObject, float WaitTime, const struct FLatentActionInfo& LatentInfo);

	class UJackUMGAccessorBattle* GetAccessorBattle() const;
	class UJackUMGAccessorCommon* GetAccessorCommon() const;
	class UJackUMGAccessorCoordinate* GetAccessorCoordinate() const;
	class UJackUMGAccessorFusigiKazi* GetAccessorFusigiKazi() const;
	class UJackUMGAccessorItem* GetAccessorItem() const;
	class UJackUMGAccessorMembers* GetAccessorMembers() const;
	class UJackUMGAccessorSaveData* GetAccessorSaveData() const;
	class UJackUMGAccessorSenreki* GetAccessorSenreki() const;
	class UJackUMGAccessorShop* GetAccessorShop() const;
	class UJackUMGWidgetBase* GetChildWidget() const;
	class FText GetDecMenuText(int32 InValue, int32 InFig, bool IsSign) const;
	class FText GetDecMenuTextWithUnit(int32 InValue, int32 InFig, bool IsSign, const class FName InUnitTextId) const;
	class FString GetDecMessageString(int32 InValue, int32 InFig, bool IsSign) const;
	const struct FJackKeyStatus GetKeyStatus() const;
	int32 GetMenuMessageSelectIndex() const;
	float GetWidgetAlpha() const;
	TArray<class UJackUMGWidgetBase*> GetWidgetBaseListFromCanvasPanel(class UCanvasPanel* InCanvasPanel) const;
	struct FVector2D GetWidgetPosition() const;
	struct FVector2D GetWidgetScale() const;
	bool IsClosed() const;
	bool IsConstructed() const;
	bool IsFocusWidget() const;
	bool IsInFocus() const;
	bool IsInitWidget() const;
	bool IsRemovingWidget() const;
	bool IsWidgetActive() const;
	void MakeImagePanelArray(class UCanvasPanel* InCanvesPanel, TArray<class UImage*>* OutImagePanelArray) const;
	class FName MakeShopMenuTextID(const class FString& BaseTextID) const;
	void MakeTextPanelArray(class UCanvasPanel* InCanvesPanel, TArray<class UTextBlock*>* OutTextPanelArray) const;
	void MakeWidgePanelArray(class UCanvasPanel* InCanvesPanel, TArray<class UWidget*>* OutWidgePanelArray) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWidgetBase">();
	}
	static class UJackUMGWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWidgetBase>();
	}
};
static_assert(alignof(UJackUMGWidgetBase) == 0x000008, "Wrong alignment on UJackUMGWidgetBase");
static_assert(sizeof(UJackUMGWidgetBase) == 0x000370, "Wrong size on UJackUMGWidgetBase");
static_assert(offsetof(UJackUMGWidgetBase, WidgetName) == 0x0001F0, "Member 'UJackUMGWidgetBase::WidgetName' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsVisible) == 0x0001F8, "Member 'UJackUMGWidgetBase::bIsVisible' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIgnoreIsVisible) == 0x0001F9, "Member 'UJackUMGWidgetBase::bIgnoreIsVisible' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsActive) == 0x0001FA, "Member 'UJackUMGWidgetBase::bIsActive' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsFocusableWindow) == 0x0001FB, "Member 'UJackUMGWidgetBase::bIsFocusableWindow' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsForceFocusable) == 0x0001FC, "Member 'UJackUMGWidgetBase::bIsForceFocusable' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsForceHilite) == 0x0001FD, "Member 'UJackUMGWidgetBase::bIsForceHilite' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsShowHilite) == 0x0001FE, "Member 'UJackUMGWidgetBase::bIsShowHilite' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsBindMenuKey) == 0x0001FF, "Member 'UJackUMGWidgetBase::bIsBindMenuKey' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsKeyEvent) == 0x000200, "Member 'UJackUMGWidgetBase::bIsKeyEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bDisableInput) == 0x000201, "Member 'UJackUMGWidgetBase::bDisableInput' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bExceptionCategory) == 0x000202, "Member 'UJackUMGWidgetBase::bExceptionCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bFitCanvasPanelToParent) == 0x000203, "Member 'UJackUMGWidgetBase::bFitCanvasPanelToParent' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsSkipCalcLocalPosition) == 0x000204, "Member 'UJackUMGWidgetBase::bIsSkipCalcLocalPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsIgnoreLoging) == 0x000205, "Member 'UJackUMGWidgetBase::bIsIgnoreLoging' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsIgnoreSafeAreaCheck) == 0x000206, "Member 'UJackUMGWidgetBase::bIsIgnoreSafeAreaCheck' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, OpenPresetAnimOption) == 0x000207, "Member 'UJackUMGWidgetBase::OpenPresetAnimOption' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, ClosePresetAnimOption) == 0x000208, "Member 'UJackUMGWidgetBase::ClosePresetAnimOption' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, ShowPresetAnimOption) == 0x000209, "Member 'UJackUMGWidgetBase::ShowPresetAnimOption' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, HidePresetAnimOption) == 0x00020A, "Member 'UJackUMGWidgetBase::HidePresetAnimOption' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsRoot) == 0x00020B, "Member 'UJackUMGWidgetBase::bIsRoot' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsTopMenu) == 0x00020C, "Member 'UJackUMGWidgetBase::bIsTopMenu' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsForePage) == 0x00020D, "Member 'UJackUMGWidgetBase::bIsForePage' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bIsIgnoreCancelKey) == 0x00020E, "Member 'UJackUMGWidgetBase::bIsIgnoreCancelKey' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bEnableEnterKeyEventCalling) == 0x00020F, "Member 'UJackUMGWidgetBase::bEnableEnterKeyEventCalling' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, bEnableCancelKeyEventCalling) == 0x000210, "Member 'UJackUMGWidgetBase::bEnableCancelKeyEventCalling' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, DefaultAdjustResize) == 0x000214, "Member 'UJackUMGWidgetBase::DefaultAdjustResize' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, LayoutOffset) == 0x000218, "Member 'UJackUMGWidgetBase::LayoutOffset' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, SnapOffset) == 0x000220, "Member 'UJackUMGWidgetBase::SnapOffset' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, RootPanelRef) == 0x000230, "Member 'UJackUMGWidgetBase::RootPanelRef' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, DefaultPosition) == 0x000238, "Member 'UJackUMGWidgetBase::DefaultPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, CurrentPosition) == 0x000240, "Member 'UJackUMGWidgetBase::CurrentPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, Position) == 0x000248, "Member 'UJackUMGWidgetBase::Position' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, Scale) == 0x000250, "Member 'UJackUMGWidgetBase::Scale' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, Alpha) == 0x000258, "Member 'UJackUMGWidgetBase::Alpha' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, WidgetSize) == 0x00025C, "Member 'UJackUMGWidgetBase::WidgetSize' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, RootPosition) == 0x000264, "Member 'UJackUMGWidgetBase::RootPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, TextBaseColor) == 0x00026C, "Member 'UJackUMGWidgetBase::TextBaseColor' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, TextBorderColor) == 0x00027C, "Member 'UJackUMGWidgetBase::TextBorderColor' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, JackOnWidgetBPActionDelegate) == 0x000290, "Member 'UJackUMGWidgetBase::JackOnWidgetBPActionDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, JackOnWidgetNotificationDelegate) == 0x0002A0, "Member 'UJackUMGWidgetBase::JackOnWidgetNotificationDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, JackOnWidgetKeyEventDelegate) == 0x0002B0, "Member 'UJackUMGWidgetBase::JackOnWidgetKeyEventDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, OptimizePanel) == 0x0002C8, "Member 'UJackUMGWidgetBase::OptimizePanel' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, ChildWidget) == 0x000330, "Member 'UJackUMGWidgetBase::ChildWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, ParentWidget) == 0x000338, "Member 'UJackUMGWidgetBase::ParentWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetBase, AnimList) == 0x000340, "Member 'UJackUMGWidgetBase::AnimList' has a wrong offset!");

// Class JackGame.JackUMGListController
// 0x0010 (0x0380 - 0x0370)
class UJackUMGListController : public UJackUMGWidgetBase
{
public:
	int32                                         ItemsPerPage;                                      // 0x0370(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumData;                                           // 0x0374(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentNumber;                                     // 0x0378(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableKeyEvent;                                  // 0x037C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37D[0x3];                                      // 0x037D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGListController">();
	}
	static class UJackUMGListController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGListController>();
	}
};
static_assert(alignof(UJackUMGListController) == 0x000008, "Wrong alignment on UJackUMGListController");
static_assert(sizeof(UJackUMGListController) == 0x000380, "Wrong size on UJackUMGListController");
static_assert(offsetof(UJackUMGListController, ItemsPerPage) == 0x000370, "Member 'UJackUMGListController::ItemsPerPage' has a wrong offset!");
static_assert(offsetof(UJackUMGListController, NumData) == 0x000374, "Member 'UJackUMGListController::NumData' has a wrong offset!");
static_assert(offsetof(UJackUMGListController, CurrentNumber) == 0x000378, "Member 'UJackUMGListController::CurrentNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGListController, bDisableKeyEvent) == 0x00037C, "Member 'UJackUMGListController::bDisableKeyEvent' has a wrong offset!");

// Class JackGame.JackUMGPageController
// 0x0040 (0x03C0 - 0x0380)
class UJackUMGPageController : public UJackUMGListController
{
public:
	int32                                         CurrentPage;                                       // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPage;                                           // 0x0384(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   CurrentText;                                       // 0x0388(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MaxText;                                           // 0x03A0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         ItemsPerColumn;                                    // 0x03B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitPageController(int32 ZOrder);
	void SetDisableKeyEventFlag(bool InFlag);
	void SetItemsPerColumn(int32 InValue);
	void SetPage(int32 InPage);
	void SetupPageController(int32 InInitPage, int32 InItemsPerPage, int32 InNumData, int32 NumColumn);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPageController">();
	}
	static class UJackUMGPageController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPageController>();
	}
};
static_assert(alignof(UJackUMGPageController) == 0x000008, "Wrong alignment on UJackUMGPageController");
static_assert(sizeof(UJackUMGPageController) == 0x0003C0, "Wrong size on UJackUMGPageController");
static_assert(offsetof(UJackUMGPageController, CurrentPage) == 0x000380, "Member 'UJackUMGPageController::CurrentPage' has a wrong offset!");
static_assert(offsetof(UJackUMGPageController, MaxPage) == 0x000384, "Member 'UJackUMGPageController::MaxPage' has a wrong offset!");
static_assert(offsetof(UJackUMGPageController, CurrentText) == 0x000388, "Member 'UJackUMGPageController::CurrentText' has a wrong offset!");
static_assert(offsetof(UJackUMGPageController, MaxText) == 0x0003A0, "Member 'UJackUMGPageController::MaxText' has a wrong offset!");
static_assert(offsetof(UJackUMGPageController, ItemsPerColumn) == 0x0003B8, "Member 'UJackUMGPageController::ItemsPerColumn' has a wrong offset!");

// Class JackGame.JackActionEffect
// 0x03D8 (0x0770 - 0x0398)
class AJackActionEffect : public AActor
{
public:
	UMulticastDelegateProperty_                   OnMovementAttachProgressCompleteDelegate;          // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMovementCompleteDelegate;                        // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSpawnHitEffectDelegate;                          // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRequestDestroyDelegate;                          // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMovementAttachProgressStartDelegate;             // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EJackActionEffectSpawnHitEffectTiming         SpawnHitEffectTiming;                              // 0x03E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitEffectDelayTime;                                // 0x03EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackActionEffectNotifyActionHitTiming        NotifyActionHitTiming;                             // 0x03F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F1[0x3];                                      // 0x03F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NotifyActionHitDelayTime;                          // 0x03F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackActionEffectDeactivateDefaultEffectTiming DeactivateDefaultEffectsTiming;                    // 0x03F8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAutoDestroy;                                      // 0x03F9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FA[0x2];                                      // 0x03FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeTime;                                          // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DestroyDelayTime;                                  // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_404[0x4];                                      // 0x0404(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackActionEffectTimelineEventEntry> TimelineEventEntries;                              // 0x0408(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	struct FJackActionEffectMovementPosition      StartMovementPosition;                             // 0x0418(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackActionEffectMovementPosition      EndMovementPosition;                               // 0x0448(0x0030)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackActionEffectEffect>        MuzzleEffects;                                     // 0x0478(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackActionEffectEffect>        DefaultEffects;                                    // 0x0488(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackActionEffectEffect>        HitEffects;                                        // 0x0498(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackActionEffectEffect>        DamageEffects;                                     // 0x04A8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         PlayDelayTime;                                     // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4BC[0x4];                                      // 0x04BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionEffectDecal                 TrailEffect;                                       // 0x04C0(0x0018)(Edit, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class USphereComponent*                       SphereComp;                                        // 0x04D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     ActionEffectMovementComp;                          // 0x04E0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   StaticMeshComp;                                    // 0x04E8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> MuzzleParticleComps;                               // 0x04F0(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> DefaultParticleComps;                              // 0x0500(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> HitParticleComps;                                  // 0x0510(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> DamageParticleComps;                               // 0x0520(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class UAudioComponent>> DefaultLoopAudioComps;                             // 0x0530(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp1;                                   // 0x0540(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp2;                                   // 0x0548(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp3;                                   // 0x0550(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp4;                                   // 0x0558(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp5;                                   // 0x0560(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp6;                                   // 0x0568(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp7;                                   // 0x0570(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class USphereComponent*                       WorkSphereComp8;                                   // 0x0578(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp1;                                 // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp2;                                 // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp3;                                 // 0x0590(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp4;                                 // 0x0598(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp5;                                 // 0x05A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp6;                                 // 0x05A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp7;                                 // 0x05B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackActionEffectMovementComponent*     WorkMovementComp8;                                 // 0x05B8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSpawnHitEffectComplete;                           // 0x05C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTimelineEventComplete;                            // 0x05C1(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovementCompAttachProgressComplete;               // 0x05C2(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovementCompComplete;                             // 0x05C3(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeactivateDefaultEffectsComplete;                 // 0x05C4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestDestroyComplete;                           // 0x05C5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C6[0x2];                                      // 0x05C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  CasterActor;                                       // 0x05C8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  TargetActor;                                       // 0x05D0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ExposeCasterActor;                                 // 0x05D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AActor*                                 ExposeTargetActor;                                 // 0x05E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, ExposeOnSpawn, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E8[0x8];                                      // 0x05E8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimeline                              TimelineEvent;                                     // 0x05F0(0x00E0)(Edit, DisableEditOnTemplate, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentTimelineEventIndex;                         // 0x06D0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6D4[0x4];                                      // 0x06D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimerHandle>                   TimerHandles;                                      // 0x06D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	bool                                          bIsPlayStart;                                      // 0x06E8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsFireReservedEffect2;                            // 0x06E9(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6EA[0x2];                                      // 0x06EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TotalDecalAddSize;                                 // 0x06EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<float>                                 WorkTotalDecalAddSizes;                            // 0x06F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FVector                                DecalCacheLocation;                                // 0x0700(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_70C[0x4];                                      // 0x070C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FVector>                        WorkMoveDecalCacheLocations;                       // 0x0710(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	struct FVector                                PACheckCacheLocation;                              // 0x0720(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72C[0x4];                                      // 0x072C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          AttachActors;                                      // 0x0730(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          JumonhansyaTargets;                                // 0x0740(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	bool                                          bAbort;                                            // 0x0750(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_751[0x7];                                      // 0x0751(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBlendablePostProcessSettingsData> PostBlendableData;                                 // 0x0758(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddAttachActor(const class AActor* AttachActor);
	void AddJumonhansyaTarget(const class AActor* JumonhansyaTarget);
	void AttachToOtherActionEffect(class AActor* ParentActor, class FName SocketName, EAttachmentRule AttachRule, bool bWeldSimulatedBodies, bool bCallTeleport);
	void Delegate__DelegateSignature();
	TArray<class AActor*> GetAttachActors();
	bool GetBlurScreenV2(struct FVector2D* OutV2, EJackActionEffectCategory EffectCategory);
	class AActor* GetCasterActor();
	class AActor* GetTargetActor();
	void OnTimelineEvent();
	void SetCasterActor(const class AActor* InCasterActor);
	void SetFireReservedEfect2(bool bInFireReservedEffect2);
	void SetTargetActor(const class AActor* InTargetActor);

	class UJackActionEffectMovementComponent* GetActionEffectMovementComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionEffect">();
	}
	static class AJackActionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionEffect>();
	}
};
static_assert(alignof(AJackActionEffect) == 0x000010, "Wrong alignment on AJackActionEffect");
static_assert(sizeof(AJackActionEffect) == 0x000770, "Wrong size on AJackActionEffect");
static_assert(offsetof(AJackActionEffect, OnMovementAttachProgressCompleteDelegate) == 0x000398, "Member 'AJackActionEffect::OnMovementAttachProgressCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, OnMovementCompleteDelegate) == 0x0003A8, "Member 'AJackActionEffect::OnMovementCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, OnSpawnHitEffectDelegate) == 0x0003B8, "Member 'AJackActionEffect::OnSpawnHitEffectDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, OnRequestDestroyDelegate) == 0x0003C8, "Member 'AJackActionEffect::OnRequestDestroyDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, OnMovementAttachProgressStartDelegate) == 0x0003D8, "Member 'AJackActionEffect::OnMovementAttachProgressStartDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, SpawnHitEffectTiming) == 0x0003E8, "Member 'AJackActionEffect::SpawnHitEffectTiming' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, HitEffectDelayTime) == 0x0003EC, "Member 'AJackActionEffect::HitEffectDelayTime' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, NotifyActionHitTiming) == 0x0003F0, "Member 'AJackActionEffect::NotifyActionHitTiming' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, NotifyActionHitDelayTime) == 0x0003F4, "Member 'AJackActionEffect::NotifyActionHitDelayTime' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DeactivateDefaultEffectsTiming) == 0x0003F8, "Member 'AJackActionEffect::DeactivateDefaultEffectsTiming' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bAutoDestroy) == 0x0003F9, "Member 'AJackActionEffect::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, LifeTime) == 0x0003FC, "Member 'AJackActionEffect::LifeTime' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DestroyDelayTime) == 0x000400, "Member 'AJackActionEffect::DestroyDelayTime' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TimelineEventEntries) == 0x000408, "Member 'AJackActionEffect::TimelineEventEntries' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, StartMovementPosition) == 0x000418, "Member 'AJackActionEffect::StartMovementPosition' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, EndMovementPosition) == 0x000448, "Member 'AJackActionEffect::EndMovementPosition' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, MuzzleEffects) == 0x000478, "Member 'AJackActionEffect::MuzzleEffects' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DefaultEffects) == 0x000488, "Member 'AJackActionEffect::DefaultEffects' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, HitEffects) == 0x000498, "Member 'AJackActionEffect::HitEffects' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DamageEffects) == 0x0004A8, "Member 'AJackActionEffect::DamageEffects' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, PlayDelayTime) == 0x0004B8, "Member 'AJackActionEffect::PlayDelayTime' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TrailEffect) == 0x0004C0, "Member 'AJackActionEffect::TrailEffect' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, SphereComp) == 0x0004D8, "Member 'AJackActionEffect::SphereComp' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, ActionEffectMovementComp) == 0x0004E0, "Member 'AJackActionEffect::ActionEffectMovementComp' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, StaticMeshComp) == 0x0004E8, "Member 'AJackActionEffect::StaticMeshComp' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, MuzzleParticleComps) == 0x0004F0, "Member 'AJackActionEffect::MuzzleParticleComps' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DefaultParticleComps) == 0x000500, "Member 'AJackActionEffect::DefaultParticleComps' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, HitParticleComps) == 0x000510, "Member 'AJackActionEffect::HitParticleComps' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DamageParticleComps) == 0x000520, "Member 'AJackActionEffect::DamageParticleComps' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DefaultLoopAudioComps) == 0x000530, "Member 'AJackActionEffect::DefaultLoopAudioComps' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp1) == 0x000540, "Member 'AJackActionEffect::WorkSphereComp1' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp2) == 0x000548, "Member 'AJackActionEffect::WorkSphereComp2' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp3) == 0x000550, "Member 'AJackActionEffect::WorkSphereComp3' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp4) == 0x000558, "Member 'AJackActionEffect::WorkSphereComp4' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp5) == 0x000560, "Member 'AJackActionEffect::WorkSphereComp5' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp6) == 0x000568, "Member 'AJackActionEffect::WorkSphereComp6' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp7) == 0x000570, "Member 'AJackActionEffect::WorkSphereComp7' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkSphereComp8) == 0x000578, "Member 'AJackActionEffect::WorkSphereComp8' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp1) == 0x000580, "Member 'AJackActionEffect::WorkMovementComp1' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp2) == 0x000588, "Member 'AJackActionEffect::WorkMovementComp2' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp3) == 0x000590, "Member 'AJackActionEffect::WorkMovementComp3' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp4) == 0x000598, "Member 'AJackActionEffect::WorkMovementComp4' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp5) == 0x0005A0, "Member 'AJackActionEffect::WorkMovementComp5' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp6) == 0x0005A8, "Member 'AJackActionEffect::WorkMovementComp6' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp7) == 0x0005B0, "Member 'AJackActionEffect::WorkMovementComp7' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMovementComp8) == 0x0005B8, "Member 'AJackActionEffect::WorkMovementComp8' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bSpawnHitEffectComplete) == 0x0005C0, "Member 'AJackActionEffect::bSpawnHitEffectComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bTimelineEventComplete) == 0x0005C1, "Member 'AJackActionEffect::bTimelineEventComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bMovementCompAttachProgressComplete) == 0x0005C2, "Member 'AJackActionEffect::bMovementCompAttachProgressComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bMovementCompComplete) == 0x0005C3, "Member 'AJackActionEffect::bMovementCompComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bDeactivateDefaultEffectsComplete) == 0x0005C4, "Member 'AJackActionEffect::bDeactivateDefaultEffectsComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bRequestDestroyComplete) == 0x0005C5, "Member 'AJackActionEffect::bRequestDestroyComplete' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, CasterActor) == 0x0005C8, "Member 'AJackActionEffect::CasterActor' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TargetActor) == 0x0005D0, "Member 'AJackActionEffect::TargetActor' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, ExposeCasterActor) == 0x0005D8, "Member 'AJackActionEffect::ExposeCasterActor' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, ExposeTargetActor) == 0x0005E0, "Member 'AJackActionEffect::ExposeTargetActor' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TimelineEvent) == 0x0005F0, "Member 'AJackActionEffect::TimelineEvent' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, CurrentTimelineEventIndex) == 0x0006D0, "Member 'AJackActionEffect::CurrentTimelineEventIndex' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TimerHandles) == 0x0006D8, "Member 'AJackActionEffect::TimerHandles' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bIsPlayStart) == 0x0006E8, "Member 'AJackActionEffect::bIsPlayStart' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bIsFireReservedEffect2) == 0x0006E9, "Member 'AJackActionEffect::bIsFireReservedEffect2' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, TotalDecalAddSize) == 0x0006EC, "Member 'AJackActionEffect::TotalDecalAddSize' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkTotalDecalAddSizes) == 0x0006F0, "Member 'AJackActionEffect::WorkTotalDecalAddSizes' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, DecalCacheLocation) == 0x000700, "Member 'AJackActionEffect::DecalCacheLocation' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, WorkMoveDecalCacheLocations) == 0x000710, "Member 'AJackActionEffect::WorkMoveDecalCacheLocations' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, PACheckCacheLocation) == 0x000720, "Member 'AJackActionEffect::PACheckCacheLocation' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, AttachActors) == 0x000730, "Member 'AJackActionEffect::AttachActors' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, JumonhansyaTargets) == 0x000740, "Member 'AJackActionEffect::JumonhansyaTargets' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, bAbort) == 0x000750, "Member 'AJackActionEffect::bAbort' has a wrong offset!");
static_assert(offsetof(AJackActionEffect, PostBlendableData) == 0x000758, "Member 'AJackActionEffect::PostBlendableData' has a wrong offset!");

// Class JackGame.JackUMGAccessorSaveData
// 0x0168 (0x01A0 - 0x0038)
class UJackUMGAccessorSaveData final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnFinishVoiceChange;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	int32                                         SelectedSlot;                                      // 0x0048(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SaveSlotIndex;                                     // 0x004C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishGetStateAsync;                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishCreateAsync;                               // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishRestoreAsync;                              // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsCancelBack;                                     // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x3];                                       // 0x0081(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoSaveInterSlotIndex;                            // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGRestartMenuType                       RestartMenuResult;                                 // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RestartPointEventCaptionId;                        // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestartPointCaptionId;                             // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestartNoMessageId;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnFinishSaveAsync;                                 // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishLoadAsync;                                 // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishDeleteAsync;                               // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 ScenarioSelectJumon;                               // 0x0110(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishTrialLoadAsync;                            // 0x0120(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x30];                                     // 0x0130(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackGetArasuziDataResult*              GetArasuziDataResult;                              // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_168[0x38];                                     // 0x0168(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ArasuziTextureLoadComplate(int32 InResultCode, class UObject* InLoaddedObject, class UJackUMGAsyncLoad* InLoadInfo);
	void ExecuteCreateAsync(bool bForce);
	void ExecuteDeleteAsync(int32 SlotIndex);
	void ExecuteLoadAsync(int32 SlotIndex);
	void ExecuteRestoreAsync();
	void ExecuteSaveAsync(int32 SlotIndex, bool bFirstCreate);
	void ExecuteSaveAsyncForTensei(int32 SlotIndex);
	void ExecuteSystemSaveAsync();
	void ExecuteTrialLoadAsync(int32 SlotIndex);
	bool ExistOverwriteSaveDataInCached(int32 SlotIndex);
	void GetArasuziData(class UJackGetArasuziDataResult** Result);
	bool GetArasuziPlayFlag();
	EJackBattleCameraMode GetBattleCameraMode();
	const TArray<class UJackUMGItemData*> GetBoukenCommandList();
	EJackUMGBoukennoSyoAction GetBoukennoSyoAction();
	EJackUMGBoukennoSyoSubAction GetBoukennoSyoSubAction();
	const TArray<class UJackUMGItemData*> GetExSystemCommandListPC();
	bool GetFirstFlag();
	const TArray<class UJackUMGItemData*> GetKeyConfigItemListSteam();
	int32 GetOmoideCursorLeftIndex();
	int32 GetOmoideCursorRightIndex();
	int32 GetPlayGoInstallRemainTime(class UObject* WorldContextObject, bool bInitialOnly);
	class FName GetPlayGoMenuId(EJackPlayGoMenuType PlayGoMenuType);
	EJackPlayGoMenuType GetPlayGoMenuType(class FName PlayGoMenuId);
	EJackRenkeiSettei GetRenkeiSettei();
	bool GetReturnedArasuziFlag();
	EJackUMGSibariMode GetSibariMode();
	void GetStateAsync();
	void GetTrialStateAsync();
	int32 GetUsingSaveDataSlotIndex();
	void InitBattleCameraMode();
	void InitializeAntiAliasingQuality();
	void InitializeCamera();
	void InitializeDisplayGamma();
	void InitializeFrameRateLimit();
	void InitializeGraphicMode(EJackUMGGraphicOption InType);
	void InitializePostProcessingQuality();
	void InitializeScreenPercentage();
	void InitializeShadowQuality();
	void InitializeVolume(bool bApplyVolume, bool bVoiceMute);
	void InitializeVSyncEnabled();
	void InitializeWindowMode();
	void InitIkidukaiMode();
	void InitRenkeiSettei();
	bool IsClearedScenario(class FName InScenarioFlag);
	bool IsFindSaveDataInCached(int32 SlotIndex);
	bool IsOpenFukkatuNoJumonPlayGo();
	bool IsOutofDontGoArea();
	bool IsStartedFukkatuNoJumon();
	bool IsUseFukkatuNoJumonDQ12();
	bool IsUseFukkatuNoJumonNewGamePlus();
	bool IsUseFukkatuNoJumonSpecial();
	bool IsUseFukkatuNoJumonStoreOpen();
	bool IsValidArasuzi();
	void JackOnFinishCreateAsyncDelegate__DelegateSignature(EJackSaveLoadResult SaveLoadResult);
	void JackOnFinishDeleteAsyncDelegate__DelegateSignature(int32 SlotIndex, EJackSaveLoadResult SaveLoadResult);
	void JackOnFinishLoadAsyncDelegate__DelegateSignature(int32 SlotIndex, EJackSaveLoadResult SaveLoadResult);
	void JackOnFinishRestoreAsyncDelegate__DelegateSignature(EJackSaveLoadResult SaveLoadResult);
	void JackOnFinishSaveAsyncDelegate__DelegateSignature(int32 SlotIndex, EJackSaveLoadResult SaveLoadResult);
	void JackOnFinishVoiceChangeDelegate__DelegateSignature();
	void JackOnGetStateAsyncDelegate__DelegateSignature(EJackSaveLoadResult SaveLoadResult);
	void LoadSystemData(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void MakeCachedSaveDataHeaderList(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void PrivacyPolicyHasBeenAccepted();
	void RenamePlayerNameAfterLoad();
	void ResetKeyConfigAssign();
	void ResetSaveData();
	void SaveSystemData(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	EJackKeyboardType SelectKeyboard(bool IsLeft);
	void SetAntiAliasingQuality(int32 InValue);
	void SetArasuziInfo(class FName InArasuziId, EJackScenarioPlaythrough InPlayThrough);
	void SetArasuziPlayFlag(bool Value);
	void SetAutoFollowCamera(bool InFlag);
	void SetBattleCameraMode(EJackBattleCameraMode InMode);
	void SetBattleSpeedMode(EJackBattleSpeedMode InValue);
	void SetBGMDiscVersion(EJackBGMDiscVersion InBgmDiscType);
	void SetBGMVolume(EJackAudioVolume InVolume, bool bApplyVolume);
	void SetBoukennoSyoAction(EJackUMGBoukennoSyoAction InAction);
	void SetBoukennoSyoSubAction(EJackUMGBoukennoSyoSubAction InAction);
	void SetCameraSpeed(EJackCameraSpeed InSpeed);
	void SetCameraSpeedAuto(EJackCameraSpeed InSpeed);
	void SetCameraSpeedRoom(EJackCameraSpeed InSpeed);
	EJackKeyboardType SetDefaultKeyboard();
	void SetDefaultKeyConfigAssign();
	void SetDisplayableName(const class FString& InName);
	void SetDisplayableNameFlag(bool IsDisplayable);
	void SetDisplayFurigana(bool InValue);
	void SetDisplayGamma(EJackDisplayGamma InGamma);
	void SetEnableAutomaticFeedOfSpeech(bool bIsEnable);
	void SetFrameRateLimit(int32 InValue);
	void SetIkidukaiEnable(bool IsEnable, bool bApplyVolume);
	void SetInversHorizontalCamera(bool InFlag);
	void SetInversVerticalCamera(bool InFlag);
	void SetNewKeyConfigAssign();
	void SetOmoideCursorLeftIndex(int32 InValue);
	void SetOmoideCursorRightIndex(int32 InValue);
	void SetOmoideFadeAfterLimit(float InLimit);
	void SetOpenFukkatuNoJumonPlayGo(bool InFlag);
	void SetPlayGoResult(EJackPlayGoMenuResult Value);
	void SetPostProcessingQuality(int32 InValue);
	int32 SetPressedKeyInItemList(const int32 InIndex, const int32 InKeyNum, const class FName& InName);
	void SetRenkeiSettei(EJackRenkeiSettei InMode);
	void SetRestartMenuResult(EJackUMGRestartMenuType InMenuType);
	void SetReturnedArasuziFlag(bool InFlag);
	void SetSaveParameterFukkatuNoJumon(const struct FJackDecodeInfo& InDecodeInfo);
	void SetScreenPercentage(int32 InValue);
	void SetScreenResolution(int32 InResolutionX);
	EJackKeyboardType SetSelectedKeyboard();
	void SetSelectedVoiceType(const EJackVoice InType);
	void SetSEVolume(EJackAudioVolume InVolume, bool bApplyVolume);
	void SetShadowQuality(int32 InValue);
	void SetSibariMode(EJackUMGSibariMode InMode);
	void SetStartedFukkatuNoJumon(bool InFlag);
	void SetUseDQ8BGM(bool bInUseDQ8BGM);
	void SetUseFukkatuNoJumonDQ12(bool InFlag);
	void SetUseFukkatuNoJumonNewGamePlus(bool InFlag);
	void SetUseFukkatuNoJumonSpecial(bool InFlag);
	void SetUseFukkatuNoJumonStoreOpen(bool InFlag);
	void SetUserName(const class FString& InUserName);
	void SetUsingSaveDataSlotIndex(int32 Value);
	void SetVoiceType(EJackVoice InVoiceType, bool bDataLoad);
	void SetVoiceVolume(EJackAudioVolume InVolume, bool bApplyVolume);
	void SetVSyncEnabled(int32 InValue);
	void SetWindowMode(EWindowMode InValue);

	int32 CheckFukkatuLocation() const;
	int32 CountRuraList() const;
	int32 GetAntiAliasingQuality() const;
	EJackBattleSpeedMode GetBattleSpeedMode() const;
	EJackBGMDiscVersion GetBGMDiscVersion() const;
	EJackAudioVolume GetBGMVolume() const;
	EJackCameraSpeed GetCameraSpeed() const;
	EJackCameraSpeed GetCameraSpeedAuto() const;
	EJackCameraSpeed GetCameraSpeedRoom() const;
	struct FJackUMGDefaultSoundSetting GetDefaultSoundSetting() const;
	class FString GetDisplayableName() const;
	bool GetDisplayFurigana() const;
	EJackDisplayGamma GetDisplayGamma() const;
	bool GetEnableAutomaticFeedOfSpeech() const;
	int32 GetFrameRateLimit() const;
	TArray<struct FJackUMGRestartListData> GetFukkatuLocation2() const;
	float GetOmoideFadeAfterLimit() const;
	void GetOverwriteSaveDataInfoFromCached(int32 SlotIndex, class FString* PlayerName, class FString* PlayTime) const;
	EJackPlayGoMenuResult GetPlayGoResult() const;
	int32 GetPostProcessingQuality() const;
	EJackUMGRestartMenuType GetRestartMenuResult() const;
	const TArray<class UJackUMGItemData*> GetRuraList() const;
	const TArray<class UJackUMGItemData*> GetSaveDataListFromCached() const;
	class FString GetSaveTimeString(const class FString& InStr) const;
	int32 GetScreenPercentage() const;
	int32 GetScreenResolutionIndex() const;
	TArray<bool> GetScreenResolutionList() const;
	int32 GetScreenResolutionMax() const;
	int32 GetScreenResolutionX() const;
	int32 GetScreenResolutionY() const;
	const EJackKeyboardType GetSelectedKeyboard() const;
	const EJackVoice GetSelectedVoiceType() const;
	EJackAudioVolume GetSEVolume() const;
	int32 GetShadowQuality() const;
	int32 GetSibariNumInSlot(class UJackUMGItemData* InItemData) const;
	const TArray<class UJackUMGItemData*> GetSibariplayList() const;
	const TArray<class FString> GetSibariTasseiString(int32* OutIndex) const;
	const int32 GetSlotNumberInCondition(EJackUMGBoukennoSyoAction InType) const;
	const int32 GetSlotNumnerInSlotIndex(const TArray<class UJackUMGItemData*>& ItemList, const int32 InSlotIndex) const;
	const TArray<class UJackUMGItemData*> GetTrialSaveDataList() const;
	EJackVoice GetVoiceType() const;
	EJackAudioVolume GetVoiceVolume() const;
	int32 GetVSyncEnabled() const;
	EWindowMode GetWindowMode() const;
	bool IsAcquiredRura() const;
	bool IsAutoFollowCamera() const;
	bool IsAutoSaveData3D(bool IsTrial) const;
	bool IsBoukennosyoTrialRestertMsg() const;
	bool IsBrokenTrialSaveData() const;
	bool IsCachedSaveDataHeaderListEmpty() const;
	bool IsChangeKeyboard() const;
	bool IsClearSibariOfSystem(EJackSibari Type) const;
	bool IsDisplayableNameFlag() const;
	bool IsExistTrialSaveData() const;
	bool IsIkidukaiEnable() const;
	bool IsInversHorizontalCamera() const;
	bool IsInversVerticalCamera() const;
	bool IsNetworkAvailable() const;
	bool IsPlayedSibari() const;
	bool IsSaveDataEmptyInCached(bool bCountAutoSave) const;
	bool IsSaveDataFullInCached() const;
	bool IsScenarioAClearedScenarioB(const class FName& InScenarioA, const class FName& InScenarioB) const;
	bool IsSibariInSlot(class UJackUMGItemData* InItemData, EJackSibari InType) const;
	bool IsUseDQ8BGM() const;
	const TArray<class UJackUMGItemData*> MakeFukkatuItemList(const TArray<class FString>& InScenarioTitleList, const TArray<class FName>& InScenarioIdList) const;
	class FString MakePlayTime(const int32 InHour, const int32 InMinutes) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorSaveData">();
	}
	static class UJackUMGAccessorSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorSaveData>();
	}
};
static_assert(alignof(UJackUMGAccessorSaveData) == 0x000008, "Wrong alignment on UJackUMGAccessorSaveData");
static_assert(sizeof(UJackUMGAccessorSaveData) == 0x0001A0, "Wrong size on UJackUMGAccessorSaveData");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishVoiceChange) == 0x000038, "Member 'UJackUMGAccessorSaveData::OnFinishVoiceChange' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, SelectedSlot) == 0x000048, "Member 'UJackUMGAccessorSaveData::SelectedSlot' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, SaveSlotIndex) == 0x00004C, "Member 'UJackUMGAccessorSaveData::SaveSlotIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishGetStateAsync) == 0x000050, "Member 'UJackUMGAccessorSaveData::OnFinishGetStateAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishCreateAsync) == 0x000060, "Member 'UJackUMGAccessorSaveData::OnFinishCreateAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishRestoreAsync) == 0x000070, "Member 'UJackUMGAccessorSaveData::OnFinishRestoreAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, bIsCancelBack) == 0x000080, "Member 'UJackUMGAccessorSaveData::bIsCancelBack' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, AutoSaveInterSlotIndex) == 0x000084, "Member 'UJackUMGAccessorSaveData::AutoSaveInterSlotIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, RestartMenuResult) == 0x000088, "Member 'UJackUMGAccessorSaveData::RestartMenuResult' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, RestartPointEventCaptionId) == 0x000090, "Member 'UJackUMGAccessorSaveData::RestartPointEventCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, RestartPointCaptionId) == 0x000098, "Member 'UJackUMGAccessorSaveData::RestartPointCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, RestartNoMessageId) == 0x0000A0, "Member 'UJackUMGAccessorSaveData::RestartNoMessageId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishSaveAsync) == 0x0000E0, "Member 'UJackUMGAccessorSaveData::OnFinishSaveAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishLoadAsync) == 0x0000F0, "Member 'UJackUMGAccessorSaveData::OnFinishLoadAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishDeleteAsync) == 0x000100, "Member 'UJackUMGAccessorSaveData::OnFinishDeleteAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, ScenarioSelectJumon) == 0x000110, "Member 'UJackUMGAccessorSaveData::ScenarioSelectJumon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, OnFinishTrialLoadAsync) == 0x000120, "Member 'UJackUMGAccessorSaveData::OnFinishTrialLoadAsync' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveData, GetArasuziDataResult) == 0x000160, "Member 'UJackUMGAccessorSaveData::GetArasuziDataResult' has a wrong offset!");

// Class JackGame.JackAmbientOcclusionRadiusSkinTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackAmbientOcclusionRadiusSkinTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAmbientOcclusionRadiusSkinTrack">();
	}
	static class UJackAmbientOcclusionRadiusSkinTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAmbientOcclusionRadiusSkinTrack>();
	}
};
static_assert(alignof(UJackAmbientOcclusionRadiusSkinTrack) == 0x000008, "Wrong alignment on UJackAmbientOcclusionRadiusSkinTrack");
static_assert(sizeof(UJackAmbientOcclusionRadiusSkinTrack) == 0x0000B0, "Wrong size on UJackAmbientOcclusionRadiusSkinTrack");

// Class JackGame.JackUMGHpMpBase
// 0x00D8 (0x0448 - 0x0370)
class UJackUMGHpMpBase : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   HpChangeDelegate;                                  // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   HealEffectSetDelegate;                             // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SetHudAnimationDelegate;                           // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   HpSetAnimationDelegate;                            // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SetRenkeiHudAnimationDelegate;                     // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SenaHairDelegate;                                  // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x03D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullMember;                                      // 0x03D1(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGHpMpItemInfo>           HpMpItemList;                                      // 0x03D8(0x0010)(BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               ItemDataList;                                      // 0x03E8(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Unit_Index;                                        // 0x03F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num0_Index;                                        // 0x03FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num1_Index;                                        // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num2_Index;                                        // 0x0404(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasPanel*                           ItemListCanvasPanel;                               // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x38];                                     // 0x0410(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitHudStatus(class UCanvasPanel* ItemListCanvas, const TArray<class UJackUMGItemData*>& ItemList, bool AllMember, int32 InZOrder);
	void InitHudStatus4(class UCanvasPanel* ItemListCanvas, int32 InZOrder);
	void JackUMGHealEffectDelegate__DelegateSignature(int32 Type, int32 Index_0);
	void JackUMGHpChangeDelegate__DelegateSignature(int32 Index_0, int32 ColorNum);
	void JackUMGHpSetAnimationDelegate__DelegateSignature(int32 Index_0, EJackUMGHudAnimationAction AnimType);
	void JackUMGSenaHairDelegate__DelegateSignature(bool IsShort, EJackUIFaceIcon InType, int32 Index_0);
	void JackUMGSetHudAnimationDelegate__DelegateSignature(EJackUMGHudAnimationAction AnimType, bool IsFieldDamage);
	void JackUMGSetRenkeiHudAnimationDelegate__DelegateSignature(int32 Index_0, int32 Acion, EJackUMGHudAnimationAction AnimType);
	void RequestCloseWidget();
	void ResetAllHudPanel();
	void SetHudPanelAnim(EJackCharacter CharaType, EJackUMGHudPlateAnim AnimType);
	void SetHudStatusEffect(EJackCharacter CharaType, EJackPopupBalloon InBalloonType);
	void SetScaleAllHud(const float InScale);
	void SetSenaHairStyle(bool IsShortHair);

	EJackUMGHudInitQueued GetQueuedMemberInBattle(const int32 InIndex) const;
	bool IsTurnCharacter(const int32 InIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHpMpBase">();
	}
	static class UJackUMGHpMpBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHpMpBase>();
	}
};
static_assert(alignof(UJackUMGHpMpBase) == 0x000008, "Wrong alignment on UJackUMGHpMpBase");
static_assert(sizeof(UJackUMGHpMpBase) == 0x000448, "Wrong size on UJackUMGHpMpBase");
static_assert(offsetof(UJackUMGHpMpBase, HpChangeDelegate) == 0x000370, "Member 'UJackUMGHpMpBase::HpChangeDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, HealEffectSetDelegate) == 0x000380, "Member 'UJackUMGHpMpBase::HealEffectSetDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, SetHudAnimationDelegate) == 0x000390, "Member 'UJackUMGHpMpBase::SetHudAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, HpSetAnimationDelegate) == 0x0003A0, "Member 'UJackUMGHpMpBase::HpSetAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, SetRenkeiHudAnimationDelegate) == 0x0003B0, "Member 'UJackUMGHpMpBase::SetRenkeiHudAnimationDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, SenaHairDelegate) == 0x0003C0, "Member 'UJackUMGHpMpBase::SenaHairDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, IsFocusable) == 0x0003D0, "Member 'UJackUMGHpMpBase::IsFocusable' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, IsFullMember) == 0x0003D1, "Member 'UJackUMGHpMpBase::IsFullMember' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, HpMpItemList) == 0x0003D8, "Member 'UJackUMGHpMpBase::HpMpItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, ItemDataList) == 0x0003E8, "Member 'UJackUMGHpMpBase::ItemDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, Unit_Index) == 0x0003F8, "Member 'UJackUMGHpMpBase::Unit_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, Num0_Index) == 0x0003FC, "Member 'UJackUMGHpMpBase::Num0_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, Num1_Index) == 0x000400, "Member 'UJackUMGHpMpBase::Num1_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, Num2_Index) == 0x000404, "Member 'UJackUMGHpMpBase::Num2_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHpMpBase, ItemListCanvasPanel) == 0x000408, "Member 'UJackUMGHpMpBase::ItemListCanvasPanel' has a wrong offset!");

// Class JackGame.Jack3StepAnimActor
// 0x00C0 (0x0458 - 0x0398)
class AJack3StepAnimActor : public AActor
{
public:
	class UAnimMontage*                           FinishAnim;                                        // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FinishAnimWithName;                                // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishAnimActionSec;                               // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishInputOffSec;                                 // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FinishInputAllSec;                                 // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GmmickDropItemId;                                  // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RespawnSaveFlagName;                               // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C8[0x28];                                     // 0x03C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UsePropGadgetId;                                   // 0x03F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UsePropOugonTuruhasiGadgetId;                      // 0x03F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllwaysDrop;                                      // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x57];                                     // 0x0401(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ShakeCamera(class AJackCharacter* InAnimCharacter, class FName ShakeName, float Scale);

	void AddSpawnedKira(class AJackItemGettableObjectBase* Item);
	void AttachGadgetObject();
	void CallOnAction(class AJackCharacter* InAnimCharacter);
	void CallOnActionEnd(class AJackCharacter* InAnimCharacter);
	void DetachGadgetObject();
	void ForceSetReplacementSec(float Sec);
	class FName GetDropItemId();
	int32 GetDropItemNum();
	TArray<float> GetDropMoveParabolaParam(const struct FVector& Start, const struct FVector& End, float AddZ, float GravZ);
	void InitDropParams(float InGmmickDropItemSec, class FName SaveFlag, const TArray<class FName>& InDropItemIdArray, const TArray<int32>& InDropItemNumArray);
	bool IsActionEnd();
	bool IsDropOk();
	void OnAction(class AJackCharacter* InAnimCharacter, bool bFinish);
	void OnActionEnd(class AJackCharacter* InAnimCharacter, bool bFinish);
	void OnDebugRespawn();
	void OnInteractionEnable();
	void SetInput(class AJackCharacter* InAnimCharacter);
	void SpawnDropMoveParabolaEffect(class UParticleSystemComponent* Particle, const struct FVector& Start, const struct FVector& End, float AddZ, float GravZ);
	void SyncSaveData();
	void UpdateDropId();
	void UpdateDropIdEnd();

	void GetDropItemData(TArray<class FName>* OutId, TArray<int32>* OutNum) const;
	class FName GetUsePropGadgetId() const;
	bool IsUseOugonNoTuruhasi() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"Jack3StepAnimActor">();
	}
	static class AJack3StepAnimActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJack3StepAnimActor>();
	}
};
static_assert(alignof(AJack3StepAnimActor) == 0x000008, "Wrong alignment on AJack3StepAnimActor");
static_assert(sizeof(AJack3StepAnimActor) == 0x000458, "Wrong size on AJack3StepAnimActor");
static_assert(offsetof(AJack3StepAnimActor, FinishAnim) == 0x000398, "Member 'AJack3StepAnimActor::FinishAnim' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, FinishAnimWithName) == 0x0003A0, "Member 'AJack3StepAnimActor::FinishAnimWithName' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, FinishAnimActionSec) == 0x0003A8, "Member 'AJack3StepAnimActor::FinishAnimActionSec' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, FinishInputOffSec) == 0x0003AC, "Member 'AJack3StepAnimActor::FinishInputOffSec' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, FinishInputAllSec) == 0x0003B0, "Member 'AJack3StepAnimActor::FinishInputAllSec' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, GmmickDropItemId) == 0x0003B8, "Member 'AJack3StepAnimActor::GmmickDropItemId' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, RespawnSaveFlagName) == 0x0003C0, "Member 'AJack3StepAnimActor::RespawnSaveFlagName' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, UsePropGadgetId) == 0x0003F0, "Member 'AJack3StepAnimActor::UsePropGadgetId' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, UsePropOugonTuruhasiGadgetId) == 0x0003F8, "Member 'AJack3StepAnimActor::UsePropOugonTuruhasiGadgetId' has a wrong offset!");
static_assert(offsetof(AJack3StepAnimActor, bAllwaysDrop) == 0x000400, "Member 'AJack3StepAnimActor::bAllwaysDrop' has a wrong offset!");

// Class JackGame.JackUMGTuyosaSkillGroupData
// 0x0028 (0x0060 - 0x0038)
class UJackUMGTuyosaSkillGroupData final : public UObject
{
public:
	class FString                                 GroupName;                                         // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackSkillLine                                SkillLineType;                                     // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UsedSkillPoint;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               SkillList;                                         // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTuyosaSkillGroupData">();
	}
	static class UJackUMGTuyosaSkillGroupData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTuyosaSkillGroupData>();
	}
};
static_assert(alignof(UJackUMGTuyosaSkillGroupData) == 0x000008, "Wrong alignment on UJackUMGTuyosaSkillGroupData");
static_assert(sizeof(UJackUMGTuyosaSkillGroupData) == 0x000060, "Wrong size on UJackUMGTuyosaSkillGroupData");
static_assert(offsetof(UJackUMGTuyosaSkillGroupData, GroupName) == 0x000038, "Member 'UJackUMGTuyosaSkillGroupData::GroupName' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaSkillGroupData, SkillLineType) == 0x000048, "Member 'UJackUMGTuyosaSkillGroupData::SkillLineType' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaSkillGroupData, UsedSkillPoint) == 0x00004C, "Member 'UJackUMGTuyosaSkillGroupData::UsedSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaSkillGroupData, SkillList) == 0x000050, "Member 'UJackUMGTuyosaSkillGroupData::SkillList' has a wrong offset!");

// Class JackGame.JackFukkatunojumonManager
// 0x0060 (0x0098 - 0x0038)
class UJackFukkatunojumonManager : public UObject
{
public:
	class UDataTable*                             FukkatunojumonScenarioProgressDataTable;           // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FukkatunojumonRestartPointDataTable;               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x48];                                      // 0x0050(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeClearedSecondPlaythrough();
	bool FukkatunojumonDecode(const class FString& InStr, struct FJackDecodeInfo* OutDecodeInfo, TArray<struct FJackScenarioTitleInfo>* OutScenarioTitleInfoList);
	void FukkatunojumonDecodeInfoResetting(const struct FJackScenarioTitleInfo& InScenarioTitleInfo, const struct FJackDecodeInfo& InDecodeInfo, struct FJackDecodeInfo* OutDecodeInfo);
	bool FukkatunojumonEncode(class FString* OutStr, class FName InChurchId);
	void FukkatunojumonRun(const struct FJackDecodeInfo& InDecodeInfo);
	void GetCleaedScenarioList(TArray<class FString>* OutScenarioTitleList, TArray<class FName>* OutScenarioIdList);
	void SetSelectedScenarioId(const class FName InScenarioID);

	class FString GetScenarioDescription(const class FName& InScenarioID) const;
	int32 GetScenarioProgress() const;
	const TSoftObjectPtr<class UTexture> GetScenarioTexture() const;
	const class FName GetSelectedScenarioId() const;
	class FString GetTenseiScenarioDescription(const class FName& InScenarioID) const;
	const TSoftObjectPtr<class UTexture> GetTenseiScenarioTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFukkatunojumonManager">();
	}
	static class UJackFukkatunojumonManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFukkatunojumonManager>();
	}
};
static_assert(alignof(UJackFukkatunojumonManager) == 0x000008, "Wrong alignment on UJackFukkatunojumonManager");
static_assert(sizeof(UJackFukkatunojumonManager) == 0x000098, "Wrong size on UJackFukkatunojumonManager");
static_assert(offsetof(UJackFukkatunojumonManager, FukkatunojumonScenarioProgressDataTable) == 0x000038, "Member 'UJackFukkatunojumonManager::FukkatunojumonScenarioProgressDataTable' has a wrong offset!");
static_assert(offsetof(UJackFukkatunojumonManager, FukkatunojumonRestartPointDataTable) == 0x000048, "Member 'UJackFukkatunojumonManager::FukkatunojumonRestartPointDataTable' has a wrong offset!");

// Class JackGame.JackAmbientOcclusionRadiusSkinTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackAmbientOcclusionRadiusSkinTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAmbientOcclusionRadiusSkinTrackInst">();
	}
	static class UJackAmbientOcclusionRadiusSkinTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAmbientOcclusionRadiusSkinTrackInst>();
	}
};
static_assert(alignof(UJackAmbientOcclusionRadiusSkinTrackInst) == 0x000008, "Wrong alignment on UJackAmbientOcclusionRadiusSkinTrackInst");
static_assert(sizeof(UJackAmbientOcclusionRadiusSkinTrackInst) == 0x000038, "Wrong size on UJackAmbientOcclusionRadiusSkinTrackInst");

// Class JackGame.JackUMGStaffRollWindow
// 0x01E0 (0x0550 - 0x0370)
class UJackUMGStaffRollWindow : public UJackUMGWidgetBase
{
public:
	class UDataTable*                             DT_UIStaffRoll;                                    // 0x0370(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSelfUpdate;                                       // 0x0378(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_379[0x3];                                      // 0x0379(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartBuffer;                                       // 0x037C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndBuffer;                                         // 0x0380(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x2C];                                     // 0x0384(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     LoadedTextureValueList;                            // 0x03B0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 FadeImage;                                         // 0x03D8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UImage*                                 BackgroundImage;                                   // 0x03E0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ScrollPanel;                                       // 0x03E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ThreeRowsLeftPanel;                                // 0x03F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ThreeRowsCenterPanel;                              // 0x03F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           ThreeRowsRightPanel;                               // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           TwoRowsLeftPanel;                                  // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           TwoRowsRightPanel;                                 // 0x0410(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           CompanyPanel;                                      // 0x0418(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeThreeRowsLeftPanel;                            // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeThreeRowsCenterPanel;                          // 0x0428(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeThreeRowsRightPanel;                           // 0x0430(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeTwoRowsLeftPanel;                              // 0x0438(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeTwoRowsRightPanel;                             // 0x0440(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasPanel*                           FadeCompanyPanel;                                  // 0x0448(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0xA0];                                     // 0x0450(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         ImageList;                                         // 0x04F0(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_500[0x50];                                     // 0x0500(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTextBlock(class FName FontTypeKey, class UTextBlock* TextBlock);
	void AddTextBlockList(class FName FontTypeKey, const TArray<class UTextBlock*>& TextBlockList);
	void ConstructData(bool bInPlaythroughSecond);
	bool Execute(float InProgressTime);
	void TextureLoadComplate(int32 InResultCode, class UObject* InLoaddedObject, class UJackUMGAsyncLoad* InLoadInfo);
	void UseSelfUpdate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGStaffRollWindow">();
	}
	static class UJackUMGStaffRollWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGStaffRollWindow>();
	}
};
static_assert(alignof(UJackUMGStaffRollWindow) == 0x000008, "Wrong alignment on UJackUMGStaffRollWindow");
static_assert(sizeof(UJackUMGStaffRollWindow) == 0x000550, "Wrong size on UJackUMGStaffRollWindow");
static_assert(offsetof(UJackUMGStaffRollWindow, DT_UIStaffRoll) == 0x000370, "Member 'UJackUMGStaffRollWindow::DT_UIStaffRoll' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, bSelfUpdate) == 0x000378, "Member 'UJackUMGStaffRollWindow::bSelfUpdate' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, StartBuffer) == 0x00037C, "Member 'UJackUMGStaffRollWindow::StartBuffer' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, EndBuffer) == 0x000380, "Member 'UJackUMGStaffRollWindow::EndBuffer' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, LoadedTextureValueList) == 0x0003B0, "Member 'UJackUMGStaffRollWindow::LoadedTextureValueList' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeImage) == 0x0003D8, "Member 'UJackUMGStaffRollWindow::FadeImage' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, BackgroundImage) == 0x0003E0, "Member 'UJackUMGStaffRollWindow::BackgroundImage' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, ScrollPanel) == 0x0003E8, "Member 'UJackUMGStaffRollWindow::ScrollPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, ThreeRowsLeftPanel) == 0x0003F0, "Member 'UJackUMGStaffRollWindow::ThreeRowsLeftPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, ThreeRowsCenterPanel) == 0x0003F8, "Member 'UJackUMGStaffRollWindow::ThreeRowsCenterPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, ThreeRowsRightPanel) == 0x000400, "Member 'UJackUMGStaffRollWindow::ThreeRowsRightPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, TwoRowsLeftPanel) == 0x000408, "Member 'UJackUMGStaffRollWindow::TwoRowsLeftPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, TwoRowsRightPanel) == 0x000410, "Member 'UJackUMGStaffRollWindow::TwoRowsRightPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, CompanyPanel) == 0x000418, "Member 'UJackUMGStaffRollWindow::CompanyPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeThreeRowsLeftPanel) == 0x000420, "Member 'UJackUMGStaffRollWindow::FadeThreeRowsLeftPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeThreeRowsCenterPanel) == 0x000428, "Member 'UJackUMGStaffRollWindow::FadeThreeRowsCenterPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeThreeRowsRightPanel) == 0x000430, "Member 'UJackUMGStaffRollWindow::FadeThreeRowsRightPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeTwoRowsLeftPanel) == 0x000438, "Member 'UJackUMGStaffRollWindow::FadeTwoRowsLeftPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeTwoRowsRightPanel) == 0x000440, "Member 'UJackUMGStaffRollWindow::FadeTwoRowsRightPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, FadeCompanyPanel) == 0x000448, "Member 'UJackUMGStaffRollWindow::FadeCompanyPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGStaffRollWindow, ImageList) == 0x0004F0, "Member 'UJackUMGStaffRollWindow::ImageList' has a wrong offset!");

// Class JackGame.JackDR_DecreasesResolutionTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_DecreasesResolutionTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_DecreasesResolutionTrack">();
	}
	static class UJackDR_DecreasesResolutionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_DecreasesResolutionTrack>();
	}
};
static_assert(alignof(UJackDR_DecreasesResolutionTrack) == 0x000008, "Wrong alignment on UJackDR_DecreasesResolutionTrack");
static_assert(sizeof(UJackDR_DecreasesResolutionTrack) == 0x0000B0, "Wrong size on UJackDR_DecreasesResolutionTrack");

// Class JackGame.JackAchievementManager
// 0x06E8 (0x0720 - 0x0038)
class UJackAchievementManager : public UObject
{
public:
	class UDataTable*                             AchievementDataTable;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             AchievementPhoneticDataTable;                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackGameFlagCategory                         SuppressFlagCategory_PossessionItemCount;          // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SuppressFlag_PossessionItemCount;                  // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x6C8];                                     // 0x0058(0x06C8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcquireAchievementDirect(const struct FJackLDT_Achievement& LDT_Achievement);
	void CheckAcquiredAchievementTrophyList();
	void DisableAchievementAcquisition(bool bDisable);
	void EnableAcquisitionsTrophy();
	class FName GetAchievementQueue(EJackAchievementTiming Timing);
	void Latent_UnlockUE4Achievement(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName AchievementID);
	void LockAllAchievements();
	void NotUnlockUE4Achievements(bool bIsNotUnlock);
	void ReacquiredJackUE4Achievement(EJackAchievementCategory InCategory, EJackAchievementCondition InCondition);

	const class FString GetAchievementName(const struct FJackLDT_Achievement& LDT_Achievement) const;
	const class FString GetDescription(const struct FJackLDT_Achievement& LDT_Achievement) const;
	const int32 GetNumericalParameter(const struct FJackLDT_Achievement& LDT_Achievement) const;
	const TArray<class FName> GetSenrekiAchievementList() const;
	const class FString GetStringParameter(const struct FJackLDT_Achievement& LDT_Achievement) const;
	void GetTripleAchievementNoForUnacquiredTrophy(int32 InCategory, TArray<int32>* OutTripleAchievementNoList) const;
	bool IsAchievementSyinpaisyou() const;
	bool IsAcquiredAchievement(const struct FJackLDT_Achievement& LDT_Achievement) const;
	bool IsQueueingAchievement(EJackAchievementTiming Timing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAchievementManager">();
	}
	static class UJackAchievementManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAchievementManager>();
	}
};
static_assert(alignof(UJackAchievementManager) == 0x000008, "Wrong alignment on UJackAchievementManager");
static_assert(sizeof(UJackAchievementManager) == 0x000720, "Wrong size on UJackAchievementManager");
static_assert(offsetof(UJackAchievementManager, AchievementDataTable) == 0x000038, "Member 'UJackAchievementManager::AchievementDataTable' has a wrong offset!");
static_assert(offsetof(UJackAchievementManager, AchievementPhoneticDataTable) == 0x000040, "Member 'UJackAchievementManager::AchievementPhoneticDataTable' has a wrong offset!");
static_assert(offsetof(UJackAchievementManager, SuppressFlagCategory_PossessionItemCount) == 0x000048, "Member 'UJackAchievementManager::SuppressFlagCategory_PossessionItemCount' has a wrong offset!");
static_assert(offsetof(UJackAchievementManager, SuppressFlag_PossessionItemCount) == 0x000050, "Member 'UJackAchievementManager::SuppressFlag_PossessionItemCount' has a wrong offset!");

// Class JackGame.JackActionAIEvaluateScoreCheck
// 0x0178 (0x0510 - 0x0398)
class AJackActionAIEvaluateScoreCheck : public AActor
{
public:
	class FName                                   RenkeiID;                                          // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackPlayerAIActionControl                    ActionContrlType;                                  // 0x03A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A1[0x7];                                      // 0x03A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionData                        ActionData;                                        // 0x03A8(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackActionScoreResult                 ActionScoreResult;                                 // 0x0458(0x0068)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	struct FJackDataTableActionAIEvaluateScoreCheck ScoreCheckRow;                                     // 0x04C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      CasterGameCharacter;                               // 0x04F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FName>                           CasterActionHistory;                               // 0x04F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      TargetGameCharacter;                               // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	float GetActionHitPerCorrection();
	float GetCasterActionHistory();
	float GetCasterDazzleCorrectCoefficient();
	float GetCasterUseMpImpactCoefficient();
	float GetContinuedDamageCoefficient();
	float GetEnemyGroupGiveAttributeParam();
	float GetRandom();
	float GetResultAutoHpHeal();
	int32 GetResultDamage();
	float GetResultDamageHitRateMetal(TArray<struct FJackActionValue>* ValueList);
	float GetResultDamageRate(TArray<struct FJackActionCalcRate>* CalcList);
	float GetResultDamageRate2(TArray<struct FJackActionKill>* KillList, TArray<struct FJackActionCalcRate>* CalcList);
	float GetResultDamageRateMetal(TArray<struct FJackActionCalcRate>* CalcList);
	float GetResultDamageSuccessPer(TArray<struct FJackActionOddEffectCollect>* CollectList);
	int32 GetResultKill(TArray<struct FJackActionKill>* KillList);
	int32 GetResultKillMetal(TArray<struct FJackActionKill>* KillList);
	float GetResultKougekiryokuSlideChangeValue(TArray<struct FJackSlideActionCalc>* CalcList);
	float GetResultOddEffectSuccessPer(TArray<struct FJackActionOddEffectCollect>* CollectList);
	float GetResultRevive();
	float GetResultSyubiryokuSlideAddCoefficient(TArray<struct FJackSlideAction>* CalcList);
	float GetResultSyubiryokuSlideChangeValue(TArray<struct FJackSlideActionCalc>* CalcList);
	float GetResultTargetHpHealRate(TArray<struct FJackActionCalcRate>* CalcList);
	TArray<class UJackGameCharacter*> GetResultTargetList();
	float GetResultTargetMpHealRate(TArray<struct FJackActionCalcRate>* CalcList);
	int32 GetResultUseMp();
	float GetScoreCorrectionFactor();
	void GetTargetActionList(TArray<class FName>* OutActionList, bool InAliveOnly);
	float GetTargetActionRevive(const TArray<class FName>& InActionList);
	float GetTargetAttackRankCoefficient(TArray<struct FJackActionValue>* CalcValueList);
	float GetTargetHpRate(int32* OutHp, int32* OutMaxHp, TArray<struct FJackActionCalcRate>* CalcList);
	float GetTargetKougekiryoku(bool InSlide, TArray<struct FJackActionValue>* ValueList);
	float GetTargetMetalCoefficient(TArray<struct FJackActionValue>* ValueList);
	float GetTargetMetalExpCoefficient(TArray<struct FJackActionValue>* ValueList);
	float GetTargetMpRate(int32* OutMp, int32* OutMaxMp, TArray<struct FJackActionCalcRate>* CalcList);
	float GetTargetNemuriCoefficient(TArray<struct FJackActionValue>* ValueList);
	float GetTargetNemuriCorrectCoefficient(TArray<struct FJackActionValue>* ValueList);
	float GetTargetSyubiryoku(bool InSlide, TArray<struct FJackActionValue>* ValueList);
	float GetTargetZoneCoefficient(TArray<struct FJackActionValue>* ValueList);
	int32 IsActionClearConditionAbnormality();
	int32 IsActionClearDazzle();
	int32 IsActionClearNoact();
	int32 IsActionClearPoison();
	int32 IsCasterZone();
	int32 IsCriticalCertaintyAction();
	int32 IsMetalEnableAction();
	int32 IsRenkeiAction();
	int32 IsResultActionNormal();
	int32 IsResultDeath();
	int32 IsResultHit(TArray<struct FJackActionOddEffectCollect>* CollectList);
	int32 IsResultKill(TArray<struct FJackActionKill>* KillList);
	int32 IsResultMaxHpKill();
	int32 IsTargetActionHeal(const TArray<class FName>& InActionList);
	int32 IsTargetAttackUpEnable(struct FJackActionCalcValue* CalcValue, bool InSlide);
	int32 IsTargetButuriKanzenGuard(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetDazzleCureEnable(struct FJackActionCalcValue* CalcValue, bool InSlide);
	int32 IsTargetGiveAttribute();
	int32 IsTargetJumonHansya(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetJumonMukou(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetKougekiryokuSlideUp(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetMetal(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetOddEffect(class UJackGameCharacter* TargetCharacter, EJackOddEffectCategoryType InCategoryType);
	int32 IsTargetSyubiryokuSlideUp(class UJackGameCharacter* TargetCharacter);
	int32 IsTargetZone(class UJackGameCharacter* TargetCharacter);
	float SC_EvalScoreAddAbnormal();
	float SC_EvalScoreAttack();
	float SC_EvalScoreAttack2();
	float SC_EvalScoreAttackBig();
	float SC_EvalScoreAttackDown();
	float SC_EvalScoreAttackUp();
	float SC_EvalScoreContinuedDamage();
	float SC_EvalScoreContinuedDamageBig();
	float SC_EvalScoreCure();
	float SC_EvalScoreCureDazzle();
	float SC_EvalScoreCureNoact();
	float SC_EvalScoreCurePoison();
	float SC_EvalScoreCureVenom();
	float SC_EvalScoreDead();
	float SC_EvalScoreDefense();
	float SC_EvalScoreDefenseDown();
	float SC_EvalScoreDefenseUp();
	float SC_EvalScoreGiveAttribute();
	float SC_EvalScoreHealHp();
	float SC_EvalScoreHealMp();
	float SC_EvalScoreIceWave();
	float SC_EvalScoreMetalAttack();
	float SC_EvalScoreMetalUncertainAttack();
	float SC_EvalScoreRevival();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionAIEvaluateScoreCheck">();
	}
	static class AJackActionAIEvaluateScoreCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionAIEvaluateScoreCheck>();
	}
};
static_assert(alignof(AJackActionAIEvaluateScoreCheck) == 0x000008, "Wrong alignment on AJackActionAIEvaluateScoreCheck");
static_assert(sizeof(AJackActionAIEvaluateScoreCheck) == 0x000510, "Wrong size on AJackActionAIEvaluateScoreCheck");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, RenkeiID) == 0x000398, "Member 'AJackActionAIEvaluateScoreCheck::RenkeiID' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, ActionContrlType) == 0x0003A0, "Member 'AJackActionAIEvaluateScoreCheck::ActionContrlType' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, ActionData) == 0x0003A8, "Member 'AJackActionAIEvaluateScoreCheck::ActionData' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, ActionScoreResult) == 0x000458, "Member 'AJackActionAIEvaluateScoreCheck::ActionScoreResult' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, ScoreCheckRow) == 0x0004C0, "Member 'AJackActionAIEvaluateScoreCheck::ScoreCheckRow' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, CasterGameCharacter) == 0x0004F0, "Member 'AJackActionAIEvaluateScoreCheck::CasterGameCharacter' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, CasterActionHistory) == 0x0004F8, "Member 'AJackActionAIEvaluateScoreCheck::CasterActionHistory' has a wrong offset!");
static_assert(offsetof(AJackActionAIEvaluateScoreCheck, TargetGameCharacter) == 0x000508, "Member 'AJackActionAIEvaluateScoreCheck::TargetGameCharacter' has a wrong offset!");

// Class JackGame.JackDR_WaitFramesToUpperResolutionTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_WaitFramesToUpperResolutionTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_WaitFramesToUpperResolutionTrack">();
	}
	static class UJackDR_WaitFramesToUpperResolutionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_WaitFramesToUpperResolutionTrack>();
	}
};
static_assert(alignof(UJackDR_WaitFramesToUpperResolutionTrack) == 0x000008, "Wrong alignment on UJackDR_WaitFramesToUpperResolutionTrack");
static_assert(sizeof(UJackDR_WaitFramesToUpperResolutionTrack) == 0x0000B0, "Wrong size on UJackDR_WaitFramesToUpperResolutionTrack");

// Class JackGame.JackPlayableCharacter
// 0x0350 (0x1440 - 0x10F0)
#pragma pack(push, 0x1)
class alignas(0x10) AJackPlayableCharacter : public AJackCharacter
{
public:
	uint8                                         Pad_10F0[0x10];                                    // 0x10F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackInteractorComponent*               InteractorComponent;                               // 0x1100(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackAnimMontageWaiterComponent*        CachedAnimMontageWaiterComponent;                  // 0x1108(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoRunFlexibility;                                // 0x1110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementInputRate;                                 // 0x1114(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1118[0x18];                                    // 0x1118(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TurnRotationRate;                                  // 0x1130(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_113C[0x14];                                    // 0x113C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackPlayerCameraComponent*             PlayerCamera;                                      // 0x1150(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackCameraDataDict>            CameraDataClasses;                                 // 0x1158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1168[0x4];                                     // 0x1168(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseTurnRate;                                      // 0x116C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseLookUpRate;                                    // 0x1170(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1174[0x1A4];                                   // 0x1174(0x01A4)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanAutoRun;                                       // 0x1318(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanStopAutoRunOnCancelButton;                     // 0x1319(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCanControlPlayerCondition;                        // 0x131A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_131B[0x1];                                     // 0x131B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleStartCameraArmLength;                        // 0x131C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleStartCameraBasePitch;                        // 0x1320(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleStartCameraYawOffset;                        // 0x1324(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleMaxMoveSpeed;                                // 0x1328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleIgnoreLockOnTargetCharacterDistance;         // 0x132C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1330[0x18];                                    // 0x1330(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	EJackVehicle                                  ControlGuideUIType;                                // 0x1348(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1349[0x3];                                     // 0x1349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SimpleNavigationDefaultMovementSpeed;              // 0x134C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimpleNavigationDefaultRotationSpeed;              // 0x1350(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1354[0x1C];                                    // 0x1354(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLDT_NPCList                       UniqueID;                                          // 0x1370(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	EJackPipipiType                               PipipiType;                                        // 0x1380(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreWeaponStyleWhenAttack;                      // 0x1381(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractionCapsuleOverride;                       // 0x1382(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1383[0xD];                                     // 0x1383(0x000D)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InteractionCapsuleRelativeTransform;               // 0x1390(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         InteractionCapsuleHalfHeight;                      // 0x13C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InteractionCapsuleRadius;                          // 0x13C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C8[0x5A];                                    // 0x13C8(0x005A)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCameraFollowingInJump;                            // 0x1422(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpOnPressCancelButton;                          // 0x1423(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpJumpEyeViewLocationZ;                        // 0x1424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpZLocationInterpRateOnGroundSec;                // 0x1428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFPSEnableInJump;                                  // 0x142C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMugenJump;                                        // 0x142D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowToOpenMainMenuInTheAir;                      // 0x142E(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowToOpenWorldMapInTheAir;                      // 0x142F(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowToBenriButtonActionInTheAir;                 // 0x1430(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1431[0x7];                                     // 0x1431(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Latent_Falling(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bFallingOnGround);
	void Latent_FallingOnGround(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void Latent_NonWalking(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void Latent_NowIdling(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float TimeOutSec);
	void Latent_RootMotionEverything(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float TimeOutSec);
	void OnBeginTalk(class AActor* OtherActor);
	void OnChangePlayableMovementDefault(EJackPlayableMovementDefault Prev, EJackPlayableMovementDefault Next);
	void OnEndTalk(class AActor* OtherActor);
	void OnInputDisableChanged(bool bNewCondition);
	void OnMoveInputDisableChanged(bool bNewCondition);
	void OnPressJumpButton();
	void OnReleaseJumpButton();
	void OnTeleportSucceededSignature__DelegateSignature();
	void PopCameraData(float InterpSpeed);
	void PushCameraData(TSubclassOf<class UJackCameraData> CameraDataClass, float InterpSpeed);
	void SetNowIdle(bool bInIdle);
	void SimpleAutoNavigationWithEasingTo(const struct FVector& InLocation, const struct FRotator& InRotation, float InSeconds, EEasingFunc EasingFunc);

	class UJackAnimMontageWaiterComponent* GetJackAnimMontageWaiterComponent() const;
	EJackPlayableMovement GetPlayableMovementType() const;
	class UJackPlayerCameraComponent* GetPlayerCamera() const;
	bool IsAutoRun() const;
	bool IsEncountable() const;
	bool IsNowIdle() const;
	bool IsPlayableMovementType(EJackPlayableMovement Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableCharacter">();
	}
	static class AJackPlayableCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayableCharacter>();
	}
};
#pragma pack(pop)
static_assert(alignof(AJackPlayableCharacter) == 0x000010, "Wrong alignment on AJackPlayableCharacter");
static_assert(sizeof(AJackPlayableCharacter) == 0x001440, "Wrong size on AJackPlayableCharacter");
static_assert(offsetof(AJackPlayableCharacter, InteractorComponent) == 0x001100, "Member 'AJackPlayableCharacter::InteractorComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, CachedAnimMontageWaiterComponent) == 0x001108, "Member 'AJackPlayableCharacter::CachedAnimMontageWaiterComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, AutoRunFlexibility) == 0x001110, "Member 'AJackPlayableCharacter::AutoRunFlexibility' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, MovementInputRate) == 0x001114, "Member 'AJackPlayableCharacter::MovementInputRate' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, TurnRotationRate) == 0x001130, "Member 'AJackPlayableCharacter::TurnRotationRate' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, PlayerCamera) == 0x001150, "Member 'AJackPlayableCharacter::PlayerCamera' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, CameraDataClasses) == 0x001158, "Member 'AJackPlayableCharacter::CameraDataClasses' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BaseTurnRate) == 0x00116C, "Member 'AJackPlayableCharacter::BaseTurnRate' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BaseLookUpRate) == 0x001170, "Member 'AJackPlayableCharacter::BaseLookUpRate' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bCanAutoRun) == 0x001318, "Member 'AJackPlayableCharacter::bCanAutoRun' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bCanStopAutoRunOnCancelButton) == 0x001319, "Member 'AJackPlayableCharacter::bCanStopAutoRunOnCancelButton' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bCanControlPlayerCondition) == 0x00131A, "Member 'AJackPlayableCharacter::bCanControlPlayerCondition' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BattleStartCameraArmLength) == 0x00131C, "Member 'AJackPlayableCharacter::BattleStartCameraArmLength' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BattleStartCameraBasePitch) == 0x001320, "Member 'AJackPlayableCharacter::BattleStartCameraBasePitch' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BattleStartCameraYawOffset) == 0x001324, "Member 'AJackPlayableCharacter::BattleStartCameraYawOffset' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BattleMaxMoveSpeed) == 0x001328, "Member 'AJackPlayableCharacter::BattleMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, BattleIgnoreLockOnTargetCharacterDistance) == 0x00132C, "Member 'AJackPlayableCharacter::BattleIgnoreLockOnTargetCharacterDistance' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, ControlGuideUIType) == 0x001348, "Member 'AJackPlayableCharacter::ControlGuideUIType' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, SimpleNavigationDefaultMovementSpeed) == 0x00134C, "Member 'AJackPlayableCharacter::SimpleNavigationDefaultMovementSpeed' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, SimpleNavigationDefaultRotationSpeed) == 0x001350, "Member 'AJackPlayableCharacter::SimpleNavigationDefaultRotationSpeed' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, UniqueID) == 0x001370, "Member 'AJackPlayableCharacter::UniqueID' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, PipipiType) == 0x001380, "Member 'AJackPlayableCharacter::PipipiType' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bIgnoreWeaponStyleWhenAttack) == 0x001381, "Member 'AJackPlayableCharacter::bIgnoreWeaponStyleWhenAttack' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bInteractionCapsuleOverride) == 0x001382, "Member 'AJackPlayableCharacter::bInteractionCapsuleOverride' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, InteractionCapsuleRelativeTransform) == 0x001390, "Member 'AJackPlayableCharacter::InteractionCapsuleRelativeTransform' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, InteractionCapsuleHalfHeight) == 0x0013C0, "Member 'AJackPlayableCharacter::InteractionCapsuleHalfHeight' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, InteractionCapsuleRadius) == 0x0013C4, "Member 'AJackPlayableCharacter::InteractionCapsuleRadius' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bCameraFollowingInJump) == 0x001422, "Member 'AJackPlayableCharacter::bCameraFollowingInJump' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bJumpOnPressCancelButton) == 0x001423, "Member 'AJackPlayableCharacter::bJumpOnPressCancelButton' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, InterpJumpEyeViewLocationZ) == 0x001424, "Member 'AJackPlayableCharacter::InterpJumpEyeViewLocationZ' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, JumpZLocationInterpRateOnGroundSec) == 0x001428, "Member 'AJackPlayableCharacter::JumpZLocationInterpRateOnGroundSec' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bFPSEnableInJump) == 0x00142C, "Member 'AJackPlayableCharacter::bFPSEnableInJump' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bMugenJump) == 0x00142D, "Member 'AJackPlayableCharacter::bMugenJump' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bAllowToOpenMainMenuInTheAir) == 0x00142E, "Member 'AJackPlayableCharacter::bAllowToOpenMainMenuInTheAir' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bAllowToOpenWorldMapInTheAir) == 0x00142F, "Member 'AJackPlayableCharacter::bAllowToOpenWorldMapInTheAir' has a wrong offset!");
static_assert(offsetof(AJackPlayableCharacter, bAllowToBenriButtonActionInTheAir) == 0x001430, "Member 'AJackPlayableCharacter::bAllowToBenriButtonActionInTheAir' has a wrong offset!");

// Class JackGame.JackVehicle
// 0x0120 (0x1560 - 0x1440)
#pragma pack(push, 0x1)
class alignas(0x10) AJackVehicle : public AJackPlayableCharacter
{
public:
	TSoftObjectPtr<class UAnimMontage>            NoMountAnim;                                       // 0x1438(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnmountWaitSecForNoPossessControl;                 // 0x1450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1454[0x4];                                     // 0x1454(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UnmountMaterialAnimationName;                      // 0x1458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1460[0xD0];                                    // 0x1460(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          Rider;                                             // 0x1530(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackVehicle                                  VehicleType;                                       // 0x1538(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackVehicleModelId                           VehicleModelType;                                  // 0x1539(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_153A[0x6];                                     // 0x153A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RideSocketNames;                                   // 0x1540(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UJackMiniMapTargetComponent*            MiniMapTargetComponent;                            // 0x1550(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void Mount(class AJackCharacter* InRider, bool bImmediate);
	void OnBeginMoveOffBp();
	void OnEndMountBp();
	void OnMount(class AJackCharacter* InRider);
	void OnMountInteractionEnd();
	void OnUnmount(class AJackCharacter* InRider);
	void PlayOrStopNoMountAnim(bool bRun);
	void SetMiniMapArea();
	void SetMovementEnableForEvent(EJackCharacterControlChannel Channel, bool bEnable);
	void SetUnmountNaviCheckOff(bool bEnable, EJackUnmountNaviCheckOffPurpose InType);
	void SetUnmountParticle(class UParticleSystemComponent* Particle);
	void Unmount(bool bImmediate, bool bForce);

	class AJackPlayableCharacter* GetRiderToPlayableChracter() const;
	bool IsMovementEnabledBp() const;
	bool IsUnmountEnable(bool bForceUnmount, bool bDebug) const;
	bool IsUnmounting() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicle">();
	}
	static class AJackVehicle* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicle>();
	}
};
#pragma pack(pop)
static_assert(alignof(AJackVehicle) == 0x000010, "Wrong alignment on AJackVehicle");
static_assert(sizeof(AJackVehicle) == 0x001560, "Wrong size on AJackVehicle");
static_assert(offsetof(AJackVehicle, NoMountAnim) == 0x001438, "Member 'AJackVehicle::NoMountAnim' has a wrong offset!");
static_assert(offsetof(AJackVehicle, UnmountWaitSecForNoPossessControl) == 0x001450, "Member 'AJackVehicle::UnmountWaitSecForNoPossessControl' has a wrong offset!");
static_assert(offsetof(AJackVehicle, UnmountMaterialAnimationName) == 0x001458, "Member 'AJackVehicle::UnmountMaterialAnimationName' has a wrong offset!");
static_assert(offsetof(AJackVehicle, Rider) == 0x001530, "Member 'AJackVehicle::Rider' has a wrong offset!");
static_assert(offsetof(AJackVehicle, VehicleType) == 0x001538, "Member 'AJackVehicle::VehicleType' has a wrong offset!");
static_assert(offsetof(AJackVehicle, VehicleModelType) == 0x001539, "Member 'AJackVehicle::VehicleModelType' has a wrong offset!");
static_assert(offsetof(AJackVehicle, RideSocketNames) == 0x001540, "Member 'AJackVehicle::RideSocketNames' has a wrong offset!");
static_assert(offsetof(AJackVehicle, MiniMapTargetComponent) == 0x001550, "Member 'AJackVehicle::MiniMapTargetComponent' has a wrong offset!");

// Class JackGame.JackVehicleMonster
// 0x05D0 (0x1B30 - 0x1560)
class AJackVehicleMonster : public AJackVehicle
{
public:
	class UJackEncountTriggerCapsuleComponent*    EncountTriggerComponent;                           // 0x1558(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        MeshRootComponent;                                 // 0x1560(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1568[0x38];                                    // 0x1568(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSetMeshRootAttitude;                              // 0x15A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetMeshRootIK;                                    // 0x15A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDrawUnmountPoint;                            // 0x15A2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15A3[0x5];                                     // 0x15A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FirstMessageId;                                    // 0x15A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FirstMessageShowedSaveFlagId;                      // 0x15B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DestructibleMessageId;                             // 0x15B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DT_MotionSyncTable;                                // 0x15C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallSteeringParam;                                 // 0x15C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringRate;                                      // 0x15CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnRate;                                          // 0x15D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusMin;                                   // 0x15D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusMax;                                   // 0x15D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusChangeSpeedStart;                      // 0x15DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusChangeSpeedEnd;                        // 0x15E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatePitchStartSpeed;                             // 0x15E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatePitchStartSteeringRate;                      // 0x15E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotatePitchLimit;                                  // 0x15EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateDampRate;                                    // 0x15F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdditionalNowRotationPitchTargetLerpRate;          // 0x15F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15F8[0x4];                                     // 0x15F8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestroyDistance;                                   // 0x15FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSkipMotionEndBattle;                            // 0x1600(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1601[0x3];                                     // 0x1601(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MountMeshLocalLocation;                            // 0x1604(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageRiderTurnBackLeft;                      // 0x1610(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageRiderTurnBackRight;                     // 0x1618(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MountFadeWaitSec;                                  // 0x1620(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MountNaviSpeed;                                    // 0x1624(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnSplashCollisionClass;                         // 0x1628(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         SpawnSplashCollisionClassSubArray;                 // 0x1630(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   SpawnSplashCollisionSocketName;                    // 0x1640(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackVehcileMonsterSplashScoketType           SplashSnapType;                                    // 0x1648(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1649[0x7];                                     // 0x1649(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SpawnSplashSubDivNum;                              // 0x1650(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1654[0x4];                                     // 0x1654(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   AnimMontageSplash;                                 // 0x1658(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UAnimMontage*>                   AnimMontageRiderSplash;                            // 0x1668(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EJackMonsterFieldDamageReaction               SplashDamageReactionType;                          // 0x1678(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMovementDisableInSplash;                          // 0x1679(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_167A[0x1E];                                    // 0x167A(0x001E)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitObjectDownSpeedRate;                            // 0x1698(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusDash;                                  // 0x169C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TurnRotationRateDash;                              // 0x16A0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_16AC[0xC];                                     // 0x16AC(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             DashPlaySe;                                        // 0x16B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             DashPlaySeLoop;                                    // 0x16C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_16C8[0x8];                                     // 0x16C8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        DashLoopSE;                                        // 0x16D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16D8[0x88];                                    // 0x16D8(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDashRequest;                                    // 0x1760(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInDash;                                         // 0x1761(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDashEndRequest;                                 // 0x1762(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1763[0x1];                                     // 0x1763(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToDashEndInterpolationSpeed;                       // 0x1764(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackCameraData>            DashCameraData;                                    // 0x1768(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashCameraInterpSpeedStart;                        // 0x1770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashCameraInterpSpeedEnd;                          // 0x1774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1778[0x18];                                    // 0x1778(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnBackAngle;                                     // 0x1790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnInAngle;                                       // 0x1794(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnOutAngle;                                      // 0x1798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkForwardingRate;                                // 0x179C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunOutForwardingRate;                              // 0x17A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RunForwardingRate;                                 // 0x17A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToDashInterpolationSpeed;                          // 0x17A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToRunInterpolationSpeed;                           // 0x17AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToStopInterpolationSpeed;                          // 0x17B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToWalkInterpolationSpeed;                          // 0x17B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CanTurnMoveMotionBlendRate;                        // 0x17B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSteeringOn;                                       // 0x17BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTurnAnimOn;                                       // 0x17BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17BE[0x2];                                     // 0x17BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           TurnStartAnim;                                     // 0x17C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           TurnStartAnimP001;                                 // 0x17C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LimitTurnAnimSteeringRate;                         // 0x17D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SteeringMotionWait;                                // 0x17D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReverseSteeringMotionWait;                         // 0x17D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17DC[0x29C];                                   // 0x17DC(0x029C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TalkRotateSec;                                     // 0x1A78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TalkRotateAngle;                                   // 0x1A7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A80[0xB0];                                    // 0x1A80(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateDashParticle(bool bActive);
	void ApplySplashCollision();
	void CancelDash();
	void CapsuleControllOff();
	void ClearDash();
	void ForceDashOff(bool bOnlyDashStop);
	float InterpToSlowHigh(float Start, float Target, float Rate);
	void Latent_VehicleSimpleNavigation(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FVector& TargetLocation, const struct FRotator& TargetRotator, float MoveSec, bool bIgnoreExternCollision, bool bOverrideTargetLocationZ);
	void Latent_VehicleSplash(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void LerpToSetMountMeshLocation(class AJackCharacter* InRider, float LerpRate);
	void OnCallThroughCapsuleController(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnCallThroughCapsuleControllerBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnDashEndBp();
	void OnDashStartBp();
	void OnHitObject(class AActor* Actor, const struct FHitResult& HitResult);
	void OnMountStart();
	void OnPlayerMovementModeChanged(class AJackCharacter* JackCharacter, EMovementMode OldMovementMode, EMovementMode NewMovementMode);
	void OnSplashRequest();
	void OnTeleportedCallCore();
	void OnUnmountStart();
	void PlayDashSE(bool bPreloadOnly);
	void RemoveSplashCollision();
	void SetDashParticle(class UParticleSystemComponent* Particle);
	void SetFootIKAdjustMeshHeightZero(bool bOn);
	void SetIKAndHeightFadeOff(float InterpSec);
	void SetSkipSnapToGroundOnTeleport(bool bSkip);
	void SetWaitPause();
	void SetWaitResume();
	void StartTalk(const struct FVector& TalkPos);

	float GetNowRotationPitch() const;
	bool GetSkipSnapToGroundOnTeleport() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleMonster">();
	}
	static class AJackVehicleMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleMonster>();
	}
};
static_assert(alignof(AJackVehicleMonster) == 0x000010, "Wrong alignment on AJackVehicleMonster");
static_assert(sizeof(AJackVehicleMonster) == 0x001B30, "Wrong size on AJackVehicleMonster");
static_assert(offsetof(AJackVehicleMonster, EncountTriggerComponent) == 0x001558, "Member 'AJackVehicleMonster::EncountTriggerComponent' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, MeshRootComponent) == 0x001560, "Member 'AJackVehicleMonster::MeshRootComponent' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bSetMeshRootAttitude) == 0x0015A0, "Member 'AJackVehicleMonster::bSetMeshRootAttitude' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bSetMeshRootIK) == 0x0015A1, "Member 'AJackVehicleMonster::bSetMeshRootIK' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bDebugDrawUnmountPoint) == 0x0015A2, "Member 'AJackVehicleMonster::bDebugDrawUnmountPoint' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, FirstMessageId) == 0x0015A8, "Member 'AJackVehicleMonster::FirstMessageId' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, FirstMessageShowedSaveFlagId) == 0x0015B0, "Member 'AJackVehicleMonster::FirstMessageShowedSaveFlagId' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DestructibleMessageId) == 0x0015B8, "Member 'AJackVehicleMonster::DestructibleMessageId' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DT_MotionSyncTable) == 0x0015C0, "Member 'AJackVehicleMonster::DT_MotionSyncTable' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, FallSteeringParam) == 0x0015C8, "Member 'AJackVehicleMonster::FallSteeringParam' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SteeringRate) == 0x0015CC, "Member 'AJackVehicleMonster::SteeringRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnRate) == 0x0015D0, "Member 'AJackVehicleMonster::TurnRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateRadiusMin) == 0x0015D4, "Member 'AJackVehicleMonster::RotateRadiusMin' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateRadiusMax) == 0x0015D8, "Member 'AJackVehicleMonster::RotateRadiusMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateRadiusChangeSpeedStart) == 0x0015DC, "Member 'AJackVehicleMonster::RotateRadiusChangeSpeedStart' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateRadiusChangeSpeedEnd) == 0x0015E0, "Member 'AJackVehicleMonster::RotateRadiusChangeSpeedEnd' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotatePitchStartSpeed) == 0x0015E4, "Member 'AJackVehicleMonster::RotatePitchStartSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotatePitchStartSteeringRate) == 0x0015E8, "Member 'AJackVehicleMonster::RotatePitchStartSteeringRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotatePitchLimit) == 0x0015EC, "Member 'AJackVehicleMonster::RotatePitchLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateDampRate) == 0x0015F0, "Member 'AJackVehicleMonster::RotateDampRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, AdditionalNowRotationPitchTargetLerpRate) == 0x0015F4, "Member 'AJackVehicleMonster::AdditionalNowRotationPitchTargetLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DestroyDistance) == 0x0015FC, "Member 'AJackVehicleMonster::DestroyDistance' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bIsSkipMotionEndBattle) == 0x001600, "Member 'AJackVehicleMonster::bIsSkipMotionEndBattle' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, MountMeshLocalLocation) == 0x001604, "Member 'AJackVehicleMonster::MountMeshLocalLocation' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, AnimMontageRiderTurnBackLeft) == 0x001610, "Member 'AJackVehicleMonster::AnimMontageRiderTurnBackLeft' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, AnimMontageRiderTurnBackRight) == 0x001618, "Member 'AJackVehicleMonster::AnimMontageRiderTurnBackRight' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, MountFadeWaitSec) == 0x001620, "Member 'AJackVehicleMonster::MountFadeWaitSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, MountNaviSpeed) == 0x001624, "Member 'AJackVehicleMonster::MountNaviSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SpawnSplashCollisionClass) == 0x001628, "Member 'AJackVehicleMonster::SpawnSplashCollisionClass' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SpawnSplashCollisionClassSubArray) == 0x001630, "Member 'AJackVehicleMonster::SpawnSplashCollisionClassSubArray' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SpawnSplashCollisionSocketName) == 0x001640, "Member 'AJackVehicleMonster::SpawnSplashCollisionSocketName' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SplashSnapType) == 0x001648, "Member 'AJackVehicleMonster::SplashSnapType' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SpawnSplashSubDivNum) == 0x001650, "Member 'AJackVehicleMonster::SpawnSplashSubDivNum' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, AnimMontageSplash) == 0x001658, "Member 'AJackVehicleMonster::AnimMontageSplash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, AnimMontageRiderSplash) == 0x001668, "Member 'AJackVehicleMonster::AnimMontageRiderSplash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SplashDamageReactionType) == 0x001678, "Member 'AJackVehicleMonster::SplashDamageReactionType' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bMovementDisableInSplash) == 0x001679, "Member 'AJackVehicleMonster::bMovementDisableInSplash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, HitObjectDownSpeedRate) == 0x001698, "Member 'AJackVehicleMonster::HitObjectDownSpeedRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RotateRadiusDash) == 0x00169C, "Member 'AJackVehicleMonster::RotateRadiusDash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnRotationRateDash) == 0x0016A0, "Member 'AJackVehicleMonster::TurnRotationRateDash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashPlaySe) == 0x0016B8, "Member 'AJackVehicleMonster::DashPlaySe' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashPlaySeLoop) == 0x0016C0, "Member 'AJackVehicleMonster::DashPlaySeLoop' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashLoopSE) == 0x0016D0, "Member 'AJackVehicleMonster::DashLoopSE' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bIsDashRequest) == 0x001760, "Member 'AJackVehicleMonster::bIsDashRequest' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bIsInDash) == 0x001761, "Member 'AJackVehicleMonster::bIsInDash' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bIsDashEndRequest) == 0x001762, "Member 'AJackVehicleMonster::bIsDashEndRequest' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ToDashEndInterpolationSpeed) == 0x001764, "Member 'AJackVehicleMonster::ToDashEndInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashCameraData) == 0x001768, "Member 'AJackVehicleMonster::DashCameraData' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashCameraInterpSpeedStart) == 0x001770, "Member 'AJackVehicleMonster::DashCameraInterpSpeedStart' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, DashCameraInterpSpeedEnd) == 0x001774, "Member 'AJackVehicleMonster::DashCameraInterpSpeedEnd' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnBackAngle) == 0x001790, "Member 'AJackVehicleMonster::TurnBackAngle' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnInAngle) == 0x001794, "Member 'AJackVehicleMonster::TurnInAngle' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnOutAngle) == 0x001798, "Member 'AJackVehicleMonster::TurnOutAngle' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, WalkForwardingRate) == 0x00179C, "Member 'AJackVehicleMonster::WalkForwardingRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RunOutForwardingRate) == 0x0017A0, "Member 'AJackVehicleMonster::RunOutForwardingRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, RunForwardingRate) == 0x0017A4, "Member 'AJackVehicleMonster::RunForwardingRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ToDashInterpolationSpeed) == 0x0017A8, "Member 'AJackVehicleMonster::ToDashInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ToRunInterpolationSpeed) == 0x0017AC, "Member 'AJackVehicleMonster::ToRunInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ToStopInterpolationSpeed) == 0x0017B0, "Member 'AJackVehicleMonster::ToStopInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ToWalkInterpolationSpeed) == 0x0017B4, "Member 'AJackVehicleMonster::ToWalkInterpolationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, CanTurnMoveMotionBlendRate) == 0x0017B8, "Member 'AJackVehicleMonster::CanTurnMoveMotionBlendRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bSteeringOn) == 0x0017BC, "Member 'AJackVehicleMonster::bSteeringOn' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, bTurnAnimOn) == 0x0017BD, "Member 'AJackVehicleMonster::bTurnAnimOn' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnStartAnim) == 0x0017C0, "Member 'AJackVehicleMonster::TurnStartAnim' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TurnStartAnimP001) == 0x0017C8, "Member 'AJackVehicleMonster::TurnStartAnimP001' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, LimitTurnAnimSteeringRate) == 0x0017D0, "Member 'AJackVehicleMonster::LimitTurnAnimSteeringRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, SteeringMotionWait) == 0x0017D4, "Member 'AJackVehicleMonster::SteeringMotionWait' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, ReverseSteeringMotionWait) == 0x0017D8, "Member 'AJackVehicleMonster::ReverseSteeringMotionWait' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TalkRotateSec) == 0x001A78, "Member 'AJackVehicleMonster::TalkRotateSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleMonster, TalkRotateAngle) == 0x001A7C, "Member 'AJackVehicleMonster::TalkRotateAngle' has a wrong offset!");

// Class JackGame.JackVehicleV102
// 0x0020 (0x1B50 - 0x1B30)
class AJackVehicleV102 : public AJackVehicleMonster
{
public:
	float                                         AirDumpRate;                                       // 0x1B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B34[0x1C];                                    // 0x1B34(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV102">();
	}
	static class AJackVehicleV102* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV102>();
	}
};
static_assert(alignof(AJackVehicleV102) == 0x000010, "Wrong alignment on AJackVehicleV102");
static_assert(sizeof(AJackVehicleV102) == 0x001B50, "Wrong size on AJackVehicleV102");
static_assert(offsetof(AJackVehicleV102, AirDumpRate) == 0x001B30, "Member 'AJackVehicleV102::AirDumpRate' has a wrong offset!");

// Class JackGame.JackVehicleV104
// 0x00C0 (0x1C10 - 0x1B50)
class AJackVehicleV104 final : public AJackVehicleV102
{
public:
	float                                         ForceFallSec;                                      // 0x1B50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B54[0x4];                                     // 0x1B54(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCheckOffset;                                   // 0x1B58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxJumpZ;                                          // 0x1B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinJumpZ;                                          // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAttitudeRotationSpeed;                         // 0x1B64(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAddAttitudeRotation;                           // 0x1B70(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         JumpMaxVelocity;                                   // 0x1B7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMaxVelocity;                        // 0x1B80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMinAnimationRate;                   // 0x1B84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B88[0x88];                                    // 0x1B88(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInJumping();
	void Latent_Climbing(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bOn, bool bUp);
	bool SetClimbingTrigger(bool bOn, bool bUp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV104">();
	}
	static class AJackVehicleV104* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV104>();
	}
};
static_assert(alignof(AJackVehicleV104) == 0x000010, "Wrong alignment on AJackVehicleV104");
static_assert(sizeof(AJackVehicleV104) == 0x001C10, "Wrong size on AJackVehicleV104");
static_assert(offsetof(AJackVehicleV104, ForceFallSec) == 0x001B50, "Member 'AJackVehicleV104::ForceFallSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpCheckOffset) == 0x001B58, "Member 'AJackVehicleV104::JumpCheckOffset' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, MaxJumpZ) == 0x001B5C, "Member 'AJackVehicleV104::MaxJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, MinJumpZ) == 0x001B60, "Member 'AJackVehicleV104::MinJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpAttitudeRotationSpeed) == 0x001B64, "Member 'AJackVehicleV104::JumpAttitudeRotationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpAddAttitudeRotation) == 0x001B70, "Member 'AJackVehicleV104::JumpAddAttitudeRotation' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpMaxVelocity) == 0x001B7C, "Member 'AJackVehicleV104::JumpMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpStartMotionMaxVelocity) == 0x001B80, "Member 'AJackVehicleV104::JumpStartMotionMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleV104, JumpStartMotionMinAnimationRate) == 0x001B84, "Member 'AJackVehicleV104::JumpStartMotionMinAnimationRate' has a wrong offset!");

// Class JackGame.JackActionCalcDamage
// 0x0000 (0x0038 - 0x0038)
class UJackActionCalcDamage final : public UObject
{
public:
	static struct FJackActionCalcDamageResult CalcDamageBP(const class UJackGameCharacter* InAttacker, const class UJackGameCharacter* InDamager, struct FJackActionData& ActionData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionCalcDamage">();
	}
	static class UJackActionCalcDamage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionCalcDamage>();
	}
};
static_assert(alignof(UJackActionCalcDamage) == 0x000008, "Wrong alignment on UJackActionCalcDamage");
static_assert(sizeof(UJackActionCalcDamage) == 0x000038, "Wrong size on UJackActionCalcDamage");

// Class JackGame.JackUMGHudWindows
// 0x0018 (0x0050 - 0x0038)
class UJackUMGHudWindows : public UObject
{
public:
	class FName                                   GoldWindowWidgetName;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGWidgetBase*                     GoldWindowWidgetRef;                               // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseGoldWindow();
	void CloseRestartWindow();
	void OpenGoldWindow(bool IsDisplayedInFront);
	void OpenRestartWindow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHudWindows">();
	}
	static class UJackUMGHudWindows* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHudWindows>();
	}
};
static_assert(alignof(UJackUMGHudWindows) == 0x000008, "Wrong alignment on UJackUMGHudWindows");
static_assert(sizeof(UJackUMGHudWindows) == 0x000050, "Wrong size on UJackUMGHudWindows");
static_assert(offsetof(UJackUMGHudWindows, GoldWindowWidgetName) == 0x000038, "Member 'UJackUMGHudWindows::GoldWindowWidgetName' has a wrong offset!");
static_assert(offsetof(UJackUMGHudWindows, GoldWindowWidgetRef) == 0x000040, "Member 'UJackUMGHudWindows::GoldWindowWidgetRef' has a wrong offset!");

// Class JackGame.JackActionCameraDatabase
// 0x0000 (0x0038 - 0x0038)
class UJackActionCameraDatabase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionCameraDatabase">();
	}
	static class UJackActionCameraDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionCameraDatabase>();
	}
};
static_assert(alignof(UJackActionCameraDatabase) == 0x000008, "Wrong alignment on UJackActionCameraDatabase");
static_assert(sizeof(UJackActionCameraDatabase) == 0x000038, "Wrong size on UJackActionCameraDatabase");

// Class JackGame.JackUMGItemActionStatus
// 0x0070 (0x00A8 - 0x0038)
class UJackUMGItemActionStatus final : public UObject
{
public:
	EJackUMGUIActionFlow                          FlowType;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                CharType;                                          // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharName;                                          // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Number;                                            // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsParty;                                          // 0x005C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAlive;                                          // 0x005D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PresentHP;                                         // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresentMP;                                         // 0x0068(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMP;                                             // 0x006C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID;                                            // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TaneParam;                                         // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ConsumedTokugi;                                    // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTokugi;                                       // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OddEffectList;                                     // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           DisplayOddEffects;                                 // 0x0098(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	TArray<class FName> GetExecutableOddEffectList(const class UJackUMGUIActionInfo* UIActionInfo) const;
	bool IsExecutableAction(const class UJackUMGUIActionInfo* UIActionInfo) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemActionStatus">();
	}
	static class UJackUMGItemActionStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemActionStatus>();
	}
};
static_assert(alignof(UJackUMGItemActionStatus) == 0x000008, "Wrong alignment on UJackUMGItemActionStatus");
static_assert(sizeof(UJackUMGItemActionStatus) == 0x0000A8, "Wrong size on UJackUMGItemActionStatus");
static_assert(offsetof(UJackUMGItemActionStatus, FlowType) == 0x000038, "Member 'UJackUMGItemActionStatus::FlowType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, CharType) == 0x000039, "Member 'UJackUMGItemActionStatus::CharType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, CharName) == 0x000040, "Member 'UJackUMGItemActionStatus::CharName' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, Number) == 0x000058, "Member 'UJackUMGItemActionStatus::Number' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, bIsParty) == 0x00005C, "Member 'UJackUMGItemActionStatus::bIsParty' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, bIsAlive) == 0x00005D, "Member 'UJackUMGItemActionStatus::bIsAlive' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, PresentHP) == 0x000060, "Member 'UJackUMGItemActionStatus::PresentHP' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, MaxHP) == 0x000064, "Member 'UJackUMGItemActionStatus::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, PresentMP) == 0x000068, "Member 'UJackUMGItemActionStatus::PresentMP' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, MaxMP) == 0x00006C, "Member 'UJackUMGItemActionStatus::MaxMP' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, ItemID) == 0x000070, "Member 'UJackUMGItemActionStatus::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, TaneParam) == 0x000078, "Member 'UJackUMGItemActionStatus::TaneParam' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, ConsumedTokugi) == 0x00007C, "Member 'UJackUMGItemActionStatus::ConsumedTokugi' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, TotalTokugi) == 0x000080, "Member 'UJackUMGItemActionStatus::TotalTokugi' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, OddEffectList) == 0x000088, "Member 'UJackUMGItemActionStatus::OddEffectList' has a wrong offset!");
static_assert(offsetof(UJackUMGItemActionStatus, DisplayOddEffects) == 0x000098, "Member 'UJackUMGItemActionStatus::DisplayOddEffects' has a wrong offset!");

// Class JackGame.JackAnimControlTrack
// 0x0018 (0x00E8 - 0x00D0)
class UJackAnimControlTrack final : public UInterpTrackAnimControl
{
public:
	TArray<struct FJackAnimControlTrackKey>       AnimExtraKey;                                      // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultInterpSec;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimControlTrack">();
	}
	static class UJackAnimControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimControlTrack>();
	}
};
static_assert(alignof(UJackAnimControlTrack) == 0x000008, "Wrong alignment on UJackAnimControlTrack");
static_assert(sizeof(UJackAnimControlTrack) == 0x0000E8, "Wrong size on UJackAnimControlTrack");
static_assert(offsetof(UJackAnimControlTrack, AnimExtraKey) == 0x0000D0, "Member 'UJackAnimControlTrack::AnimExtraKey' has a wrong offset!");
static_assert(offsetof(UJackAnimControlTrack, DefaultInterpSec) == 0x0000E0, "Member 'UJackAnimControlTrack::DefaultInterpSec' has a wrong offset!");

// Class JackGame.JackActionCursorControllerComponent
// 0x0088 (0x01B0 - 0x0128)
class UJackActionCursorControllerComponent final : public UActorComponent
{
public:
	struct FJackInteractorRange                   FieldAttackShortRange;                             // 0x0128(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJackInteractorRange                   FieldAttackLongRange;                              // 0x013C(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJackInteractorRange                   FieldAttackBowgunRange;                            // 0x0150(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJackInteractorRange                   FieldAttackSearchRange;                            // 0x0164(0x0014)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x30];                                     // 0x0178(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DisplayActionGuideRadius;                          // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCompletedInteraction(class UJackInteractorComponent* InInteractorComponent, class UJackInteractiveActorComponent* InInteractiveActorComponent);
	void OnFocusedInteractiveActorComponentPropertyChanged();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionCursorControllerComponent">();
	}
	static class UJackActionCursorControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionCursorControllerComponent>();
	}
};
static_assert(alignof(UJackActionCursorControllerComponent) == 0x000008, "Wrong alignment on UJackActionCursorControllerComponent");
static_assert(sizeof(UJackActionCursorControllerComponent) == 0x0001B0, "Wrong size on UJackActionCursorControllerComponent");
static_assert(offsetof(UJackActionCursorControllerComponent, FieldAttackShortRange) == 0x000128, "Member 'UJackActionCursorControllerComponent::FieldAttackShortRange' has a wrong offset!");
static_assert(offsetof(UJackActionCursorControllerComponent, FieldAttackLongRange) == 0x00013C, "Member 'UJackActionCursorControllerComponent::FieldAttackLongRange' has a wrong offset!");
static_assert(offsetof(UJackActionCursorControllerComponent, FieldAttackBowgunRange) == 0x000150, "Member 'UJackActionCursorControllerComponent::FieldAttackBowgunRange' has a wrong offset!");
static_assert(offsetof(UJackActionCursorControllerComponent, FieldAttackSearchRange) == 0x000164, "Member 'UJackActionCursorControllerComponent::FieldAttackSearchRange' has a wrong offset!");
static_assert(offsetof(UJackActionCursorControllerComponent, DisplayActionGuideRadius) == 0x0001A8, "Member 'UJackActionCursorControllerComponent::DisplayActionGuideRadius' has a wrong offset!");

// Class JackGame.JackCharacterComponent
// 0x0078 (0x01A0 - 0x0128)
class UJackCharacterComponent : public UActorComponent
{
public:
	uint8                                         Pad_128[0x78];                                     // 0x0128(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterComponent">();
	}
	static class UJackCharacterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterComponent>();
	}
};
static_assert(alignof(UJackCharacterComponent) == 0x000008, "Wrong alignment on UJackCharacterComponent");
static_assert(sizeof(UJackCharacterComponent) == 0x0001A0, "Wrong size on UJackCharacterComponent");

// Class JackGame.JackFriendOptimizeComponent
// 0x0060 (0x0200 - 0x01A0)
class UJackFriendOptimizeComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x60];                                     // 0x01A0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendOptimizeComponent">();
	}
	static class UJackFriendOptimizeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFriendOptimizeComponent>();
	}
};
static_assert(alignof(UJackFriendOptimizeComponent) == 0x000008, "Wrong alignment on UJackFriendOptimizeComponent");
static_assert(sizeof(UJackFriendOptimizeComponent) == 0x000200, "Wrong size on UJackFriendOptimizeComponent");

// Class JackGame.JackAnimControlTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackAnimControlTrackInst final : public UInterpTrackInstAnimControl
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimControlTrackInst">();
	}
	static class UJackAnimControlTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimControlTrackInst>();
	}
};
static_assert(alignof(UJackAnimControlTrackInst) == 0x000008, "Wrong alignment on UJackAnimControlTrackInst");
static_assert(sizeof(UJackAnimControlTrackInst) == 0x000050, "Wrong size on UJackAnimControlTrackInst");

// Class JackGame.JackUMGTokugiParts
// 0x0010 (0x01E0 - 0x01D0)
class UJackUMGTokugiParts : public UUserWidget
{
public:
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiParts">();
	}
	static class UJackUMGTokugiParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiParts>();
	}
};
static_assert(alignof(UJackUMGTokugiParts) == 0x000008, "Wrong alignment on UJackUMGTokugiParts");
static_assert(sizeof(UJackUMGTokugiParts) == 0x0001E0, "Wrong size on UJackUMGTokugiParts");

// Class JackGame.JackUMGTokugiFlash005
// 0x0048 (0x0228 - 0x01E0)
class UJackUMGTokugiFlash005 final : public UJackUMGTokugiParts
{
public:
	uint8                                         Pad_1E0[0x28];                                     // 0x01E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     StarMaterial;                                      // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RenderScaleExp;                                    // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0x14];                                     // 0x0214(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNativeAnim();
	void SetElements(class UCanvasPanel* InRootPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiFlash005">();
	}
	static class UJackUMGTokugiFlash005* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiFlash005>();
	}
};
static_assert(alignof(UJackUMGTokugiFlash005) == 0x000008, "Wrong alignment on UJackUMGTokugiFlash005");
static_assert(sizeof(UJackUMGTokugiFlash005) == 0x000228, "Wrong size on UJackUMGTokugiFlash005");
static_assert(offsetof(UJackUMGTokugiFlash005, StarMaterial) == 0x000208, "Member 'UJackUMGTokugiFlash005::StarMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiFlash005, RenderScaleExp) == 0x000210, "Member 'UJackUMGTokugiFlash005::RenderScaleExp' has a wrong offset!");

// Class JackGame.JackDR_DecreasesResolutionMaxCountTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_DecreasesResolutionMaxCountTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_DecreasesResolutionMaxCountTrack">();
	}
	static class UJackDR_DecreasesResolutionMaxCountTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_DecreasesResolutionMaxCountTrack>();
	}
};
static_assert(alignof(UJackDR_DecreasesResolutionMaxCountTrack) == 0x000008, "Wrong alignment on UJackDR_DecreasesResolutionMaxCountTrack");
static_assert(sizeof(UJackDR_DecreasesResolutionMaxCountTrack) == 0x0000B0, "Wrong size on UJackDR_DecreasesResolutionMaxCountTrack");

// Class JackGame.JackActionDatabase
// 0x0000 (0x0038 - 0x0038)
class UJackActionDatabase final : public UObject
{
public:
	static struct FJackDataTableActionDamage GetDTActionDamageRow(struct FJackActionData& ActionData);
	static struct FJackDataTableActionHitOrder GetDTActionHitOrderRow(struct FJackActionData& ActionData);
	static struct FJackDataTableActionMultiAttack GetDTActionMultiAttackRow(struct FJackActionData& ActionData);
	static struct FJackDataTableActionOddEffect GetDTActionOddEffectRow(struct FJackActionData& ActionData);
	static struct FJackDataTableAction GetDTActionRow(struct FJackActionData& ActionData);
	static class FName GetDTActionSecondCheckID(struct FJackActionData& ActionData, EJackBattleIntelligenceType IntelligenceType);
	static struct FJackDataTableActionSecondCheck GetDTActionSecondCheckRow(struct FJackActionData& ActionData, EJackBattleIntelligenceType IntelligenceType);

	struct FJackActionData GetActionData(class FName ActionID, bool bWarnIfMissing) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionDatabase">();
	}
	static class UJackActionDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionDatabase>();
	}
};
static_assert(alignof(UJackActionDatabase) == 0x000008, "Wrong alignment on UJackActionDatabase");
static_assert(sizeof(UJackActionDatabase) == 0x000038, "Wrong size on UJackActionDatabase");

// Class JackGame.JackGameDatabase
// 0x0020 (0x0058 - 0x0038)
class UJackGameDatabase : public UObject
{
public:
	class UJackActionDatabase*                    ActionDatabase;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackOddEffectDatabase*                 OddEffectDatabase;                                 // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackMonsterDatabase*                   MonsterDatabase;                                   // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackActionCameraDatabase*              ActionCameraDatabase;                              // 0x0050(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	const float FindParameterFloat(class FName InName, bool* bOutResult) const;
	const float FindParameterFloatChecked(class FName InName) const;
	const int32 FindParameterInt(class FName InName, bool* bOutResult) const;
	const int32 FindParameterIntChecked(class FName InName) const;
	const class FName FindParameterText(class FName InName, bool* bOutResult) const;
	const class FName FindParameterTextChecked(class FName InName) const;
	const struct FVector FindParameterVector(class FName InName, bool* bOutResult) const;
	const struct FVector FindParameterVectorChecked(class FName InName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameDatabase">();
	}
	static class UJackGameDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameDatabase>();
	}
};
static_assert(alignof(UJackGameDatabase) == 0x000008, "Wrong alignment on UJackGameDatabase");
static_assert(sizeof(UJackGameDatabase) == 0x000058, "Wrong size on UJackGameDatabase");
static_assert(offsetof(UJackGameDatabase, ActionDatabase) == 0x000038, "Member 'UJackGameDatabase::ActionDatabase' has a wrong offset!");
static_assert(offsetof(UJackGameDatabase, OddEffectDatabase) == 0x000040, "Member 'UJackGameDatabase::OddEffectDatabase' has a wrong offset!");
static_assert(offsetof(UJackGameDatabase, MonsterDatabase) == 0x000048, "Member 'UJackGameDatabase::MonsterDatabase' has a wrong offset!");
static_assert(offsetof(UJackGameDatabase, ActionCameraDatabase) == 0x000050, "Member 'UJackGameDatabase::ActionCameraDatabase' has a wrong offset!");

// Class JackGame.JackToggleBaseTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackToggleBaseTrack : public UInterpTrack
{
public:
	TArray<struct FJackToggleBaseTrackKey>        ToggleBaseTrack;                                   // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bAvailableWhenForwards : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvailableWhenBackwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackToggleBaseTrack">();
	}
	static class UJackToggleBaseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackToggleBaseTrack>();
	}
};
static_assert(alignof(UJackToggleBaseTrack) == 0x000008, "Wrong alignment on UJackToggleBaseTrack");
static_assert(sizeof(UJackToggleBaseTrack) == 0x0000A8, "Wrong size on UJackToggleBaseTrack");
static_assert(offsetof(UJackToggleBaseTrack, ToggleBaseTrack) == 0x000090, "Member 'UJackToggleBaseTrack::ToggleBaseTrack' has a wrong offset!");

// Class JackGame.JackAnimDynamicsMoveForceTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackAnimDynamicsMoveForceTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimDynamicsMoveForceTrack">();
	}
	static class UJackAnimDynamicsMoveForceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimDynamicsMoveForceTrack>();
	}
};
static_assert(alignof(UJackAnimDynamicsMoveForceTrack) == 0x000008, "Wrong alignment on UJackAnimDynamicsMoveForceTrack");
static_assert(sizeof(UJackAnimDynamicsMoveForceTrack) == 0x0000A8, "Wrong size on UJackAnimDynamicsMoveForceTrack");

// Class JackGame.JackUMGTokugiMatomeIcon
// 0x0088 (0x0268 - 0x01E0)
class UJackUMGTokugiMatomeIcon final : public UJackUMGTokugiParts
{
public:
	uint8                                         Pad_1E0[0x50];                                     // 0x01E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             CircleTexture;                                     // 0x0230(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CircleGlowMaterial;                                // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CheckTexture;                                      // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CheckGlowMaterial;                                 // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LockTexture;                                       // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StarTexture;                                       // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SecretTexture;                                     // 0x0260(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayNativeAnim(EJackTokugiMatomeIconAnim AnimType, bool bReverse);
	void SetElements(class UCanvasPanel* InRootPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiMatomeIcon">();
	}
	static class UJackUMGTokugiMatomeIcon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiMatomeIcon>();
	}
};
static_assert(alignof(UJackUMGTokugiMatomeIcon) == 0x000008, "Wrong alignment on UJackUMGTokugiMatomeIcon");
static_assert(sizeof(UJackUMGTokugiMatomeIcon) == 0x000268, "Wrong size on UJackUMGTokugiMatomeIcon");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, CircleTexture) == 0x000230, "Member 'UJackUMGTokugiMatomeIcon::CircleTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, CircleGlowMaterial) == 0x000238, "Member 'UJackUMGTokugiMatomeIcon::CircleGlowMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, CheckTexture) == 0x000240, "Member 'UJackUMGTokugiMatomeIcon::CheckTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, CheckGlowMaterial) == 0x000248, "Member 'UJackUMGTokugiMatomeIcon::CheckGlowMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, LockTexture) == 0x000250, "Member 'UJackUMGTokugiMatomeIcon::LockTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, StarTexture) == 0x000258, "Member 'UJackUMGTokugiMatomeIcon::StarTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiMatomeIcon, SecretTexture) == 0x000260, "Member 'UJackUMGTokugiMatomeIcon::SecretTexture' has a wrong offset!");

// Class JackGame.JackDR_WaitFramesToLowerResolutionTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_WaitFramesToLowerResolutionTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_WaitFramesToLowerResolutionTrack">();
	}
	static class UJackDR_WaitFramesToLowerResolutionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_WaitFramesToLowerResolutionTrack>();
	}
};
static_assert(alignof(UJackDR_WaitFramesToLowerResolutionTrack) == 0x000008, "Wrong alignment on UJackDR_WaitFramesToLowerResolutionTrack");
static_assert(sizeof(UJackDR_WaitFramesToLowerResolutionTrack) == 0x0000B0, "Wrong size on UJackDR_WaitFramesToLowerResolutionTrack");

// Class JackGame.JackActionEffectData
// 0x00A8 (0x00E0 - 0x0038)
class UJackActionEffectData final : public UObject
{
public:
	TArray<struct FJackActionAttachedParticle>    CastParticles;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    CastParticles_H;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    CastParticles_S;                                   // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    CastParticles_M;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    CastParticles_L;                                   // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    CastParticles_LL;                                  // 0x0088(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AJackActionEffect>>  ShotActionEffectClasses;                           // 0x0098(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, UObjectWrapper, NativeAccessSpecifierPublic)
	EJackActionEffectBehaviorType                 ShotBehavior;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBurstEffectSnapToGround;                          // 0x00A9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackActionSpawnedProjectile>   ShotProjectiles;                                   // 0x00B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionSpawnedBurstEffect>  ShotBurstEffects;                                  // 0x00C0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackActionAttachedParticle>    ShotParticles;                                     // 0x00D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionEffectData">();
	}
	static class UJackActionEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionEffectData>();
	}
};
static_assert(alignof(UJackActionEffectData) == 0x000008, "Wrong alignment on UJackActionEffectData");
static_assert(sizeof(UJackActionEffectData) == 0x0000E0, "Wrong size on UJackActionEffectData");
static_assert(offsetof(UJackActionEffectData, CastParticles) == 0x000038, "Member 'UJackActionEffectData::CastParticles' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, CastParticles_H) == 0x000048, "Member 'UJackActionEffectData::CastParticles_H' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, CastParticles_S) == 0x000058, "Member 'UJackActionEffectData::CastParticles_S' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, CastParticles_M) == 0x000068, "Member 'UJackActionEffectData::CastParticles_M' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, CastParticles_L) == 0x000078, "Member 'UJackActionEffectData::CastParticles_L' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, CastParticles_LL) == 0x000088, "Member 'UJackActionEffectData::CastParticles_LL' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, ShotActionEffectClasses) == 0x000098, "Member 'UJackActionEffectData::ShotActionEffectClasses' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, ShotBehavior) == 0x0000A8, "Member 'UJackActionEffectData::ShotBehavior' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, bBurstEffectSnapToGround) == 0x0000A9, "Member 'UJackActionEffectData::bBurstEffectSnapToGround' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, ShotProjectiles) == 0x0000B0, "Member 'UJackActionEffectData::ShotProjectiles' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, ShotBurstEffects) == 0x0000C0, "Member 'UJackActionEffectData::ShotBurstEffects' has a wrong offset!");
static_assert(offsetof(UJackActionEffectData, ShotParticles) == 0x0000D0, "Member 'UJackActionEffectData::ShotParticles' has a wrong offset!");

// Class JackGame.JackGameFlagDataBase
// 0x0108 (0x0140 - 0x0038)
class UJackGameFlagDataBase : public UObject
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackGameFlagListBase*                  FlagDefinitions;                                   // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E8[0x58];                                      // 0x00E8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataBase">();
	}
	static class UJackGameFlagDataBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataBase>();
	}
};
static_assert(alignof(UJackGameFlagDataBase) == 0x000008, "Wrong alignment on UJackGameFlagDataBase");
static_assert(sizeof(UJackGameFlagDataBase) == 0x000140, "Wrong size on UJackGameFlagDataBase");
static_assert(offsetof(UJackGameFlagDataBase, FlagDefinitions) == 0x0000E0, "Member 'UJackGameFlagDataBase::FlagDefinitions' has a wrong offset!");

// Class JackGame.JackGameFlagDataScenario
// 0x0000 (0x0140 - 0x0140)
class UJackGameFlagDataScenario final : public UJackGameFlagDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataScenario">();
	}
	static class UJackGameFlagDataScenario* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataScenario>();
	}
};
static_assert(alignof(UJackGameFlagDataScenario) == 0x000008, "Wrong alignment on UJackGameFlagDataScenario");
static_assert(sizeof(UJackGameFlagDataScenario) == 0x000140, "Wrong size on UJackGameFlagDataScenario");

// Class JackGame.JackAnimExpressionBlendRateTrack
// 0x0018 (0x00C8 - 0x00B0)
class UJackAnimExpressionBlendRateTrack final : public UInterpTrackFloatBase
{
public:
	TArray<struct FJackLDT_Coordinate>            ApplyCoordinates;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUpperBody;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerBody;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBodyExtra;                                        // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHair;                                             // 0x00C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHairExtra;                                        // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMantle;                                           // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOther;                                            // 0x00C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimExpressionBlendRateTrack">();
	}
	static class UJackAnimExpressionBlendRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimExpressionBlendRateTrack>();
	}
};
static_assert(alignof(UJackAnimExpressionBlendRateTrack) == 0x000008, "Wrong alignment on UJackAnimExpressionBlendRateTrack");
static_assert(sizeof(UJackAnimExpressionBlendRateTrack) == 0x0000C8, "Wrong size on UJackAnimExpressionBlendRateTrack");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, ApplyCoordinates) == 0x0000B0, "Member 'UJackAnimExpressionBlendRateTrack::ApplyCoordinates' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bUpperBody) == 0x0000C0, "Member 'UJackAnimExpressionBlendRateTrack::bUpperBody' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bLowerBody) == 0x0000C1, "Member 'UJackAnimExpressionBlendRateTrack::bLowerBody' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bBodyExtra) == 0x0000C2, "Member 'UJackAnimExpressionBlendRateTrack::bBodyExtra' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bHair) == 0x0000C3, "Member 'UJackAnimExpressionBlendRateTrack::bHair' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bHairExtra) == 0x0000C4, "Member 'UJackAnimExpressionBlendRateTrack::bHairExtra' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bMantle) == 0x0000C5, "Member 'UJackAnimExpressionBlendRateTrack::bMantle' has a wrong offset!");
static_assert(offsetof(UJackAnimExpressionBlendRateTrack, bOther) == 0x0000C6, "Member 'UJackAnimExpressionBlendRateTrack::bOther' has a wrong offset!");

// Class JackGame.JackReelController
// 0x0020 (0x0058 - 0x0038)
class UJackReelController final : public UObject
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackReelController">();
	}
	static class UJackReelController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackReelController>();
	}
};
static_assert(alignof(UJackReelController) == 0x000008, "Wrong alignment on UJackReelController");
static_assert(sizeof(UJackReelController) == 0x000058, "Wrong size on UJackReelController");

// Class JackGame.JackVehicleWhale
// 0x0220 (0x1660 - 0x1440)
class AJackVehicleWhale final : public AJackPlayableCharacter
{
public:
	class USceneComponent*                        MeshRootComponent;                                 // 0x1438(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SteeringRate;                                      // 0x1440(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FlySpeedMax;                                       // 0x1444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSpeedMax;                                      // 0x1448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveUpperLimit;                                    // 0x144C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLowerLimit;                                    // 0x1450(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InvalidKeyHeight;                                  // 0x1454(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownAccRate;                                     // 0x1458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownSpeedRate;                                   // 0x145C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownSpeedMax;                                    // 0x1460(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownAccdDown;                                    // 0x1464(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownAccdDownInvalidKey;                          // 0x1468(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpDownSpeedDown;                                   // 0x146C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMax;                                          // 0x1470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchSpeed;                                        // 0x1474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchSpeedUp;                                      // 0x1478(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchSpeedDown;                                    // 0x147C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraHeightOffset;                                // 0x1480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraAngleMax;                                    // 0x1484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraUpperAngleLimit;                             // 0x1488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLowerAngleLimit;                             // 0x148C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhaleTurnRate;                                     // 0x1490(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWhaleMove;                                       // 0x1494(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1495[0x3];                                     // 0x1495(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WhaleRollDashTimeMax;                              // 0x1498(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WhaleUpDownAnimeTime;                              // 0x149C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNoUpDownAnime;                                  // 0x14A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugMoveing;                                   // 0x14A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSindo;                                       // 0x14A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSetAllEffects;                               // 0x14A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugSetSingleEffect;                             // 0x14A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14A5[0x3];                                     // 0x14A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnAndRotateYawLerpRate;                          // 0x14A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshRootLerpRate;                                  // 0x14AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnAngleRate;                                     // 0x14B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshRootYawRate;                                   // 0x14B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MeshRootRotateYawRate;                             // 0x14B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CameraOffsetVector;                                // 0x14BC(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLookAtArmLength;                             // 0x14C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartMeshRootForawrdVelocitySpeed;                 // 0x14CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxMeshRootForawrdVelocitySpeed;                   // 0x14D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchCenterMax;                              // 0x14D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchCenterMin;                              // 0x14D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraPitchCenterLerpRate;                         // 0x14DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14E0[0xFC];                                    // 0x14E0(0x00FC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WhaleMoveYawInputRate;                             // 0x15DC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhaleControlPitchVelocityChangeRate;               // 0x15E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhaleMeshRootRotateRate;                           // 0x15E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhaleMeshRootRotateC;                              // 0x15E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WhaleMeshRootRotateK;                              // 0x15EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_15F0[0x38];                                    // 0x15F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnWhalePushHelpButton;                             // 0x1628(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1638[0x28];                                    // 0x1638(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelDash();
	void Delegate__DelegateSignature();
	void Latent_StartVine(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void OnWhaleDashEndBp();
	void OnWhaleDashStartBp();
	void OnWhaleRollDashEffectEndBp();
	void OnWhaleRollDashEffectStartBp();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleWhale">();
	}
	static class AJackVehicleWhale* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleWhale>();
	}
};
static_assert(alignof(AJackVehicleWhale) == 0x000010, "Wrong alignment on AJackVehicleWhale");
static_assert(sizeof(AJackVehicleWhale) == 0x001660, "Wrong size on AJackVehicleWhale");
static_assert(offsetof(AJackVehicleWhale, MeshRootComponent) == 0x001438, "Member 'AJackVehicleWhale::MeshRootComponent' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, SteeringRate) == 0x001440, "Member 'AJackVehicleWhale::SteeringRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, FlySpeedMax) == 0x001444, "Member 'AJackVehicleWhale::FlySpeedMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, DashSpeedMax) == 0x001448, "Member 'AJackVehicleWhale::DashSpeedMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MoveUpperLimit) == 0x00144C, "Member 'AJackVehicleWhale::MoveUpperLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MoveLowerLimit) == 0x001450, "Member 'AJackVehicleWhale::MoveLowerLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, InvalidKeyHeight) == 0x001454, "Member 'AJackVehicleWhale::InvalidKeyHeight' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownAccRate) == 0x001458, "Member 'AJackVehicleWhale::UpDownAccRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownSpeedRate) == 0x00145C, "Member 'AJackVehicleWhale::UpDownSpeedRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownSpeedMax) == 0x001460, "Member 'AJackVehicleWhale::UpDownSpeedMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownAccdDown) == 0x001464, "Member 'AJackVehicleWhale::UpDownAccdDown' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownAccdDownInvalidKey) == 0x001468, "Member 'AJackVehicleWhale::UpDownAccdDownInvalidKey' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, UpDownSpeedDown) == 0x00146C, "Member 'AJackVehicleWhale::UpDownSpeedDown' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, PitchMax) == 0x001470, "Member 'AJackVehicleWhale::PitchMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, PitchSpeed) == 0x001474, "Member 'AJackVehicleWhale::PitchSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, PitchSpeedUp) == 0x001478, "Member 'AJackVehicleWhale::PitchSpeedUp' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, PitchSpeedDown) == 0x00147C, "Member 'AJackVehicleWhale::PitchSpeedDown' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraHeightOffset) == 0x001480, "Member 'AJackVehicleWhale::CameraHeightOffset' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraAngleMax) == 0x001484, "Member 'AJackVehicleWhale::CameraAngleMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraUpperAngleLimit) == 0x001488, "Member 'AJackVehicleWhale::CameraUpperAngleLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraLowerAngleLimit) == 0x00148C, "Member 'AJackVehicleWhale::CameraLowerAngleLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleTurnRate) == 0x001490, "Member 'AJackVehicleWhale::WhaleTurnRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, IsWhaleMove) == 0x001494, "Member 'AJackVehicleWhale::IsWhaleMove' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleRollDashTimeMax) == 0x001498, "Member 'AJackVehicleWhale::WhaleRollDashTimeMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleUpDownAnimeTime) == 0x00149C, "Member 'AJackVehicleWhale::WhaleUpDownAnimeTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, bIsNoUpDownAnime) == 0x0014A0, "Member 'AJackVehicleWhale::bIsNoUpDownAnime' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, bIsDebugMoveing) == 0x0014A1, "Member 'AJackVehicleWhale::bIsDebugMoveing' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, bDebugSindo) == 0x0014A2, "Member 'AJackVehicleWhale::bDebugSindo' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, bDebugSetAllEffects) == 0x0014A3, "Member 'AJackVehicleWhale::bDebugSetAllEffects' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, bDebugSetSingleEffect) == 0x0014A4, "Member 'AJackVehicleWhale::bDebugSetSingleEffect' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, TurnAndRotateYawLerpRate) == 0x0014A8, "Member 'AJackVehicleWhale::TurnAndRotateYawLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MeshRootLerpRate) == 0x0014AC, "Member 'AJackVehicleWhale::MeshRootLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, TurnAngleRate) == 0x0014B0, "Member 'AJackVehicleWhale::TurnAngleRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MeshRootYawRate) == 0x0014B4, "Member 'AJackVehicleWhale::MeshRootYawRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MeshRootRotateYawRate) == 0x0014B8, "Member 'AJackVehicleWhale::MeshRootRotateYawRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraOffsetVector) == 0x0014BC, "Member 'AJackVehicleWhale::CameraOffsetVector' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraLookAtArmLength) == 0x0014C8, "Member 'AJackVehicleWhale::CameraLookAtArmLength' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, StartMeshRootForawrdVelocitySpeed) == 0x0014CC, "Member 'AJackVehicleWhale::StartMeshRootForawrdVelocitySpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, MaxMeshRootForawrdVelocitySpeed) == 0x0014D0, "Member 'AJackVehicleWhale::MaxMeshRootForawrdVelocitySpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraPitchCenterMax) == 0x0014D4, "Member 'AJackVehicleWhale::CameraPitchCenterMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraPitchCenterMin) == 0x0014D8, "Member 'AJackVehicleWhale::CameraPitchCenterMin' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, CameraPitchCenterLerpRate) == 0x0014DC, "Member 'AJackVehicleWhale::CameraPitchCenterLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleMoveYawInputRate) == 0x0015DC, "Member 'AJackVehicleWhale::WhaleMoveYawInputRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleControlPitchVelocityChangeRate) == 0x0015E0, "Member 'AJackVehicleWhale::WhaleControlPitchVelocityChangeRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleMeshRootRotateRate) == 0x0015E4, "Member 'AJackVehicleWhale::WhaleMeshRootRotateRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleMeshRootRotateC) == 0x0015E8, "Member 'AJackVehicleWhale::WhaleMeshRootRotateC' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, WhaleMeshRootRotateK) == 0x0015EC, "Member 'AJackVehicleWhale::WhaleMeshRootRotateK' has a wrong offset!");
static_assert(offsetof(AJackVehicleWhale, OnWhalePushHelpButton) == 0x001628, "Member 'AJackVehicleWhale::OnWhalePushHelpButton' has a wrong offset!");

// Class JackGame.JackEquipmentControlComponent
// 0x0210 (0x03B0 - 0x01A0)
class UJackEquipmentControlComponent final : public UJackCharacterComponent
{
public:
	TSubclassOf<class UJackEquipmentControlComponentSettings> EquipmentControlComponentSettings;                 // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackEquipmentClassificationInfoDict   DefaultEquipmentClassificationInfoDict;            // 0x01A8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackEquipmentClassificationInfoDict> EquipmentClassificationInfoDict;                   // 0x01F8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, AdvancedDisplay, Protected, NativeAccessSpecifierProtected)
	bool                                          bUnsheathed;                                       // 0x0208(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209[0x7];                                      // 0x0209(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AJackWeaponBase*>                EquippedItems;                                     // 0x0210(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class AJackWeaponBase*>                EquippedSubItems;                                  // 0x0220(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_230[0x180];                                    // 0x0230(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsHandWeaponEquipmentInGame();
	void OnBattleEnd();
	void OnBattleStart();
	void SetWeaponAccessoryHiddenInGame(EJackEquipmentHiddenPurpose Purpose, bool bNewHiddenInGame);
	void SetWeaponBodyHiddenInGame(EJackEquipmentHiddenPurpose Purpose, bool bNewHiddenInGame);
	void SetWeaponHiddenInGame(EJackEquipmentHiddenPurpose Purpose, bool bNewHiddenInGame);

	class AJackWeaponBase* GetWeapon(EJackEquippedHand EquippedHand) const;
	class AJackWeaponBase* GetWeaponAccessary(EJackEquippedHand EquippedHand) const;
	bool IsLeftHandedness() const;
	bool IsWeaponAccessoryHiddenInGame() const;
	bool IsWeaponBodyHiddenInGame() const;
	struct FJackEquipmentClassificationInfoDict K2_GetEquipmentClassificationInfoDict(EJackItem_Classification InType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEquipmentControlComponent">();
	}
	static class UJackEquipmentControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEquipmentControlComponent>();
	}
};
static_assert(alignof(UJackEquipmentControlComponent) == 0x000008, "Wrong alignment on UJackEquipmentControlComponent");
static_assert(sizeof(UJackEquipmentControlComponent) == 0x0003B0, "Wrong size on UJackEquipmentControlComponent");
static_assert(offsetof(UJackEquipmentControlComponent, EquipmentControlComponentSettings) == 0x0001A0, "Member 'UJackEquipmentControlComponent::EquipmentControlComponentSettings' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponent, DefaultEquipmentClassificationInfoDict) == 0x0001A8, "Member 'UJackEquipmentControlComponent::DefaultEquipmentClassificationInfoDict' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponent, EquipmentClassificationInfoDict) == 0x0001F8, "Member 'UJackEquipmentControlComponent::EquipmentClassificationInfoDict' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponent, bUnsheathed) == 0x000208, "Member 'UJackEquipmentControlComponent::bUnsheathed' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponent, EquippedItems) == 0x000210, "Member 'UJackEquipmentControlComponent::EquippedItems' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponent, EquippedSubItems) == 0x000220, "Member 'UJackEquipmentControlComponent::EquippedSubItems' has a wrong offset!");

// Class JackGame.JackActionEffectMovementComponent
// 0x01C8 (0x0340 - 0x0178)
class UJackActionEffectMovementComponent final : public UMovementComponent
{
public:
	bool                                          bRotationFollowsVelocity;                          // 0x0178(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlanarMovementFrontRotation;                      // 0x0179(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_17A[0x6];                                      // 0x017A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AttachProgressCurve;                               // 0x0180(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AttachProgressCurveTimeScale;                      // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            MissileProgressCurve;                              // 0x0190(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           LocationCurve;                                     // 0x0198(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationCurveScale;                                // 0x01A0(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackRandomCalcType                           LocationRandomCalcTypeX;                           // 0x01AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackRandomCalcType                           LocationRandomCalcTypeY;                           // 0x01AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackRandomCalcType                           LocationRandomCalcTypeZ;                           // 0x01AE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AF[0x1];                                      // 0x01AF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           LocationRandomCurve;                               // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationRandomCurveScale;                          // 0x01B8(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           RotationCurve;                                     // 0x01C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           RotationPivotCurve;                                // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           OrbitSpeedCurve;                                   // 0x01D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveVector*                           OrbitRadiusCurve;                                  // 0x01E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                OrbitRadiusCurveScale;                             // 0x01E8(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OrbitInitialRotation;                              // 0x01F4(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UCurveVector*                           ScaleCurve;                                        // 0x0200(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                ScaleCurveScale;                                   // 0x0208(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseDistance;                                      // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttachWorld;                                      // 0x0218(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEndAttachGround;                                  // 0x0219(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOffRollByRotationFollowsVelocity;                 // 0x021A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_21B[0x1];                                      // 0x021B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         bPlaying;                                          // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackAttachInfo                        StartAttachInfo;                                   // 0x0220(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackAttachInfo                        EndAttachInfo;                                     // 0x0258(0x0038)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ProgressTime;                                      // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0xC];                                      // 0x0294(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             StartAttachTransform;                              // 0x02A0(0x0030)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FTransform                             StartUpdatedComponentTransform;                    // 0x02D0(0x0030)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FVector                                LocationRandomValue;                               // 0x0300(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_30C[0x4];                                      // 0x030C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  CurrentFrontQuat;                                  // 0x0310(0x0010)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentMovementFrontRotation;                      // 0x0320(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               CurrentOrbitRotation;                              // 0x032C(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_338[0x8];                                      // 0x0338(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Play(const struct FJackAttachInfo& StartAttachInfo_0, const struct FJackAttachInfo& EndAttachInfo_0);
	void Stop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionEffectMovementComponent">();
	}
	static class UJackActionEffectMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionEffectMovementComponent>();
	}
};
static_assert(alignof(UJackActionEffectMovementComponent) == 0x000010, "Wrong alignment on UJackActionEffectMovementComponent");
static_assert(sizeof(UJackActionEffectMovementComponent) == 0x000340, "Wrong size on UJackActionEffectMovementComponent");
static_assert(offsetof(UJackActionEffectMovementComponent, bRotationFollowsVelocity) == 0x000178, "Member 'UJackActionEffectMovementComponent::bRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, bPlanarMovementFrontRotation) == 0x000179, "Member 'UJackActionEffectMovementComponent::bPlanarMovementFrontRotation' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, AttachProgressCurve) == 0x000180, "Member 'UJackActionEffectMovementComponent::AttachProgressCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, AttachProgressCurveTimeScale) == 0x000188, "Member 'UJackActionEffectMovementComponent::AttachProgressCurveTimeScale' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, MissileProgressCurve) == 0x000190, "Member 'UJackActionEffectMovementComponent::MissileProgressCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationCurve) == 0x000198, "Member 'UJackActionEffectMovementComponent::LocationCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationCurveScale) == 0x0001A0, "Member 'UJackActionEffectMovementComponent::LocationCurveScale' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomCalcTypeX) == 0x0001AC, "Member 'UJackActionEffectMovementComponent::LocationRandomCalcTypeX' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomCalcTypeY) == 0x0001AD, "Member 'UJackActionEffectMovementComponent::LocationRandomCalcTypeY' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomCalcTypeZ) == 0x0001AE, "Member 'UJackActionEffectMovementComponent::LocationRandomCalcTypeZ' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomCurve) == 0x0001B0, "Member 'UJackActionEffectMovementComponent::LocationRandomCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomCurveScale) == 0x0001B8, "Member 'UJackActionEffectMovementComponent::LocationRandomCurveScale' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, RotationCurve) == 0x0001C8, "Member 'UJackActionEffectMovementComponent::RotationCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, RotationPivotCurve) == 0x0001D0, "Member 'UJackActionEffectMovementComponent::RotationPivotCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, OrbitSpeedCurve) == 0x0001D8, "Member 'UJackActionEffectMovementComponent::OrbitSpeedCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, OrbitRadiusCurve) == 0x0001E0, "Member 'UJackActionEffectMovementComponent::OrbitRadiusCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, OrbitRadiusCurveScale) == 0x0001E8, "Member 'UJackActionEffectMovementComponent::OrbitRadiusCurveScale' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, OrbitInitialRotation) == 0x0001F4, "Member 'UJackActionEffectMovementComponent::OrbitInitialRotation' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, ScaleCurve) == 0x000200, "Member 'UJackActionEffectMovementComponent::ScaleCurve' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, ScaleCurveScale) == 0x000208, "Member 'UJackActionEffectMovementComponent::ScaleCurveScale' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, BaseDistance) == 0x000214, "Member 'UJackActionEffectMovementComponent::BaseDistance' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, bAttachWorld) == 0x000218, "Member 'UJackActionEffectMovementComponent::bAttachWorld' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, bEndAttachGround) == 0x000219, "Member 'UJackActionEffectMovementComponent::bEndAttachGround' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, bOffRollByRotationFollowsVelocity) == 0x00021A, "Member 'UJackActionEffectMovementComponent::bOffRollByRotationFollowsVelocity' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, bPlaying) == 0x00021C, "Member 'UJackActionEffectMovementComponent::bPlaying' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, StartAttachInfo) == 0x000220, "Member 'UJackActionEffectMovementComponent::StartAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, EndAttachInfo) == 0x000258, "Member 'UJackActionEffectMovementComponent::EndAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, ProgressTime) == 0x000290, "Member 'UJackActionEffectMovementComponent::ProgressTime' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, StartAttachTransform) == 0x0002A0, "Member 'UJackActionEffectMovementComponent::StartAttachTransform' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, StartUpdatedComponentTransform) == 0x0002D0, "Member 'UJackActionEffectMovementComponent::StartUpdatedComponentTransform' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, LocationRandomValue) == 0x000300, "Member 'UJackActionEffectMovementComponent::LocationRandomValue' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, CurrentFrontQuat) == 0x000310, "Member 'UJackActionEffectMovementComponent::CurrentFrontQuat' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, CurrentMovementFrontRotation) == 0x000320, "Member 'UJackActionEffectMovementComponent::CurrentMovementFrontRotation' has a wrong offset!");
static_assert(offsetof(UJackActionEffectMovementComponent, CurrentOrbitRotation) == 0x00032C, "Member 'UJackActionEffectMovementComponent::CurrentOrbitRotation' has a wrong offset!");

// Class JackGame.JackAnimExpressionBlendRateTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackAnimExpressionBlendRateTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimExpressionBlendRateTrackInst">();
	}
	static class UJackAnimExpressionBlendRateTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimExpressionBlendRateTrackInst>();
	}
};
static_assert(alignof(UJackAnimExpressionBlendRateTrackInst) == 0x000008, "Wrong alignment on UJackAnimExpressionBlendRateTrackInst");
static_assert(sizeof(UJackAnimExpressionBlendRateTrackInst) == 0x000038, "Wrong size on UJackAnimExpressionBlendRateTrackInst");

// Class JackGame.JackUMGAccessorBase
// 0x0008 (0x0040 - 0x0038)
class UJackUMGAccessorBase : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorBase">();
	}
	static class UJackUMGAccessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorBase>();
	}
};
static_assert(alignof(UJackUMGAccessorBase) == 0x000008, "Wrong alignment on UJackUMGAccessorBase");
static_assert(sizeof(UJackUMGAccessorBase) == 0x000040, "Wrong size on UJackUMGAccessorBase");

// Class JackGame.JackUMGAccessorSenreki
// 0x03B8 (0x03F8 - 0x0040)
class UJackUMGAccessorSenreki final : public UJackUMGAccessorBase
{
public:
	TArray<class UJackUMGItemData*>               MonsterList;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   MonsterTitle;                                      // 0x0050(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   MonsterName;                                       // 0x0068(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   MonsterID;                                         // 0x0080(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListIndex;                                         // 0x0088(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   SelectedClassificationName;                        // 0x0090(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   SelectedClassificationNameInListTitle;             // 0x00A8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   SelectedRecipeCategory;                            // 0x00C0(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedCutSceneTitle;                             // 0x00C8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountItemAll;                                      // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBuki;                                         // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBukiAll;                                      // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBougu;                                        // 0x00DC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBouguAll;                                     // 0x00E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountAccessory;                                    // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountAccessoryAll;                                 // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDougu;                                        // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDouguAll;                                     // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMaterial;                                     // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMaterialAll;                                  // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountRecipeBook;                                   // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountRecipeBookAll;                                // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDaizinamono;                                  // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDaizinamonoAll;                               // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSword;                                        // 0x010C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSwordAll;                                     // 0x0110(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDoubleSword;                                  // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDoubleSwordAll;                               // 0x0118(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDagger;                                       // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountDaggerAll;                                    // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBoomerang;                                    // 0x0124(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountBoomerangAll;                                 // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountStick;                                        // 0x012C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountStickAll;                                     // 0x0130(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountStaff;                                        // 0x0134(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountStaffAll;                                     // 0x0138(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSpear;                                        // 0x013C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSpearAll;                                     // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountWhip;                                         // 0x0144(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountWhipAll;                                      // 0x0148(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountClaw;                                         // 0x014C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountClawAll;                                      // 0x0150(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountAx;                                           // 0x0154(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountAxAll;                                        // 0x0158(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountShield;                                       // 0x015C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountShieldAll;                                    // 0x0160(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountLargeShield;                                  // 0x0164(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountLargeShieldAll;                               // 0x0168(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHat;                                          // 0x016C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHatAll;                                       // 0x0170(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHelmet;                                       // 0x0174(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHelmetAll;                                    // 0x0178(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountClothes;                                      // 0x017C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountClothesAll;                                   // 0x0180(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountArmor;                                        // 0x0184(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountArmorAll;                                     // 0x0188(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountRobe;                                         // 0x018C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountRobeAll;                                      // 0x0190(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFaceAccessory;                                // 0x0194(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFaceAccessoryAll;                             // 0x0198(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountNeckAccessory;                                // 0x019C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountNeckAccessoryAll;                             // 0x01A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFingerAccessory;                              // 0x01A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFingerAccessoryAll;                           // 0x01A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHandAccessory;                                // 0x01AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountHandAccessoryAll;                             // 0x01B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountArmAccessory;                                 // 0x01B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountArmAccessoryAll;                              // 0x01B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountShoesAccessory;                               // 0x01BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountShoesAccessoryAll;                            // 0x01C0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFootAccessory;                                // 0x01C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountFootAccessoryAll;                             // 0x01C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountEtcAccessory;                                 // 0x01CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountEtcAccessoryAll;                              // 0x01D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x54];                                     // 0x01D4(0x0054)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountMonsterTypeAll;                               // 0x0228(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountMonsterTypeKill;                              // 0x022C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ZukanSlime;                                        // 0x0230(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanSlimeAll;                                     // 0x0240(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanAkuma;                                        // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanAkumaAll;                                     // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanKemono;                                       // 0x0260(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanKemonoAll;                                    // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanElement;                                      // 0x0278(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanElementAll;                                   // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28C[0x4];                                      // 0x028C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanZombie;                                       // 0x0290(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanZombieAll;                                    // 0x02A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanDragon;                                       // 0x02A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanDragonAll;                                    // 0x02B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2BC[0x4];                                      // 0x02BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanTori;                                         // 0x02C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanToriAll;                                      // 0x02D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanKaizin;                                       // 0x02D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanKaizinAll;                                    // 0x02E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2EC[0x4];                                      // 0x02EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanBussitu;                                      // 0x02F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanBussituAll;                                   // 0x0300(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_304[0x4];                                      // 0x0304(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanSizen;                                        // 0x0308(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanSizenAll;                                     // 0x0318(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31C[0x4];                                      // 0x031C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanMachine;                                      // 0x0320(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanMachineAll;                                   // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ZukanMaou;                                         // 0x0338(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ZukanMaouAll;                                      // 0x0348(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackAchievementCategory                      SyougouCategory;                                   // 0x034C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34D[0x3];                                      // 0x034D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountSyougouAll;                                   // 0x0350(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouScenario;                              // 0x0354(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouBattle;                                // 0x0358(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouKazi;                                  // 0x035C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouCasino;                                // 0x0360(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouItem;                                  // 0x0364(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountSyougouEtc;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackTutorialCategory                         KokoroeCategory;                                   // 0x036C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36D[0x3];                                      // 0x036D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CountKokoroeAll;                                   // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeBasic;                                 // 0x0374(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeMenu;                                  // 0x0378(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeField;                                 // 0x037C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeBattle;                                // 0x0380(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeItem;                                  // 0x0384(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeKaji;                                  // 0x0388(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CountKokoroeMiniGame;                              // 0x038C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x68];                                     // 0x0390(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CalcItemsCount();
	void ClearItemDataNameList();
	void CountSenrekiTutorialCategoryNumber();
	void CountSyougouCategory();
	void ExistsQuestMemoData(class FName MapVolumeID, bool* bExists, bool* bHighlight);
	const TArray<class UJackUMGItemData*> GetCutSceneList(const class FName InTitle);
	const TArray<class UJackUMGItemData*> GetCutSceneTitleList();
	TArray<struct FJackUMGFusigiPossibleList> GetFusigiPossibleList();
	const TArray<class UJackUMGItemData*> GetKuwasiiKirokuDataList();
	TArray<class FName> GetMonsterMapIdList(const class FName InMonsterId);
	void GetQuestDataCount(int32* AllCount, int32* ClearCount);
	void GetQuestDataList(TArray<class UJackUMGItemData*>* ItemDataList, int32* ClearCount);
	void GetQuestMemoDataList(class FName MapVolumeID, TArray<class UJackUMGItemData*>* ItemDataList, const struct FSlateFontInfo& FontInfo, float QuestTitleSizeX);
	void GetQuestRewardData(class FName QuestId, bool Border, class FName* TitleId, class FString* Title, class FString* Description, struct FJackQuestReward* RewardData);
	void GetQuestRewardEventItemData(class FName EventItemId, class FString* ItemName, class UTexture2D** IconTexture, int32* ItemCount, class FName* UnitNameID, int32* Gold, bool* bIsMedal, bool* bIsRecipeBook);
	const TArray<class UJackUMGItemData*> GetSenrekiLearningRecipeList(const EJackItem_Classification InType, const EJackSenreki_ItemCategory InCategory);
	const TArray<class UJackUMGItemData*> GetSenrekiSeisokutiList();
	int32 GetSenrekiSeisokutiListNumber();
	const TArray<class UJackUMGItemData*> GetSenrekiTutorialList(const EJackTutorialCategory InCategory);
	const TArray<class UJackUMGItemData*> GetWorldMapMonsterList();
	void GetYochiCount(int32* AllCount, int32* ClearCount);
	const TArray<class UJackUMGItemData*> GetYochiDataList();
	bool IsNoMonsterLocationNow();
	void MakeItemsNameList(EJackSenreki_ItemCategory InItemCategory, EJackItem_Classification InClassification);
	int32 MakeReturnSyousaiItemsList(const int32 SelectedNumber);
	void MakeSenrekiMonsterInfo();
	void MakeSenrekiMonsterTypeSortList(const EJackMonsterRace InType);
	const int32 MakeSenrekiMonsterVisitSortList(const class FName InMapId);
	void MakeSyogouIdList(EJackAchievementCategory InType);
	void SetDefaultSenrekiSortMode(const EJackUMGSenrekiSortMode InMode);
	void SetSelectedClassification(const EJackItem_Classification InClassification);
	void SetSelectedItemCategory(const EJackSenreki_ItemCategory InCategory);
	void SetSelectedMonsterMode(const EJackUMGSenrekiMonsterMode InMode);
	EJackUMGSenrekiSortMode SetSenrekiSortMode(const EJackUMGSenrekiSortBamen InSortBamen, const EJackUMGSenrekiSortMode InMode);
	void SortItemsNameList(EJackUMGSenrekiSortMode InSortType, bool bEnablePlusValue, bool bEnableSort, bool bSyousai);
	void SortMonsterDataList(EJackUMGSenrekiSortMode InSortType);
	void SortSyougouIdList(EJackUMGSenrekiSortMode InSortType);

	int32 ChangeIndexListToSyousai(const class FName InItemId) const;
	const TArray<class UJackUMGSenrekiData*> GetCanMakeItems(const class FName InItemId) const;
	const int32 GetCountSenrekiMonsterTypeAll() const;
	const TArray<class UJackUMGSenrekiData*> GetDropAreaByItem(const class FName InItemId) const;
	bool GetDropItemFromMonsterId(const class FName InMonsterId, class FName* OutNormalItemId, class FName* OutRareItemId, int32* OutExp, int32* OutGold) const;
	const TArray<class UJackUMGSenrekiData*> GetDropMonsterByItem(const class FName InItemId) const;
	const TArray<struct FJackUMGItemListInfo> GetFusigiSyousaiList(const TArray<class UJackUMGItemData*>& InItemDataList) const;
	int32 GetMonsterCountInSyousaiList() const;
	const int32 GetMonsterCountPlusEventBattle(const class FName InZukanId) const;
	const class FText GetMonsterRaceText(const EJackMonsterRace InMonsterRace) const;
	float GetOverSizeTextPanel(class UWidget* InPanel, const struct FSlateFontInfo& FontInfo, const class FString& InString) const;
	const TArray<struct FJackUMGRecipeParam> GetRecipeMajorParameterList(const class FName InItemId) const;
	int32 GetRecipeNumber(const EJackSenreki_ItemCategory InCategory, const EJackItem_Classification InClassification) const;
	const EJackMonsterActiveScenario GetScenarioFlag() const;
	EJackItem_Classification GetSelectedClassification() const;
	EJackSenreki_ItemCategory GetSelectedItemCategory() const;
	EJackUMGSenrekiMonsterMode GetSelectedMonsterMode() const;
	const TArray<class UJackUMGItemData*> GetSenrekiAllMonsterList() const;
	void GetSenrekiCategoryMonsterCountAll() const;
	void GetSenrekiCategoryMonsterList() const;
	const int32 GetSenrekiListIndexFromMonsterId(const class FName InMonsterId) const;
	void GetSenrekiMonsterCountAllAndKill(const class FName InMapId, int32* OutKillCount, int32* OutAllCount) const;
	EJackUMGSenrekiSortMode GetSenrekiSortMode(const EJackUMGSenrekiSortBamen InSortBamen) const;
	const TArray<class UJackUMGItemData*> GetSenrekiSyougouList(EJackAchievementCategory InType) const;
	class UTexture2D* GetSmallIconTexture(const class FName& InItemId) const;
	class FString GetStringAlignDigits(const class FString& InStr) const;
	class FString GetStringReplaceTagToStr(const class FName InTextId, const class FString& InTag1, const class FString& InStr1, const class FString& InTag2, const class FString& InStr2) const;
	const class FString GetSyougouDescription(class FName AchievementID) const;
	const TSoftObjectPtr<class UTexture> GetZukan2DMonsterTexture(const class FName InMonsterId) const;
	const TArray<class UJackUMGItemData*> GetZukanItemList() const;
	const class FString GetZukanMemo(const class FName InZukanId) const;
	bool IsKilledMonsterInList(const int32 InIndex) const;
	bool IsOpenFusigiKaji() const;
	bool IsRecipeFromItemId(const class FName InItemId) const;
	void RequestGC() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorSenreki">();
	}
	static class UJackUMGAccessorSenreki* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorSenreki>();
	}
};
static_assert(alignof(UJackUMGAccessorSenreki) == 0x000008, "Wrong alignment on UJackUMGAccessorSenreki");
static_assert(sizeof(UJackUMGAccessorSenreki) == 0x0003F8, "Wrong size on UJackUMGAccessorSenreki");
static_assert(offsetof(UJackUMGAccessorSenreki, MonsterList) == 0x000040, "Member 'UJackUMGAccessorSenreki::MonsterList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, MonsterTitle) == 0x000050, "Member 'UJackUMGAccessorSenreki::MonsterTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, MonsterName) == 0x000068, "Member 'UJackUMGAccessorSenreki::MonsterName' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, MonsterID) == 0x000080, "Member 'UJackUMGAccessorSenreki::MonsterID' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ListIndex) == 0x000088, "Member 'UJackUMGAccessorSenreki::ListIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, SelectedClassificationName) == 0x000090, "Member 'UJackUMGAccessorSenreki::SelectedClassificationName' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, SelectedClassificationNameInListTitle) == 0x0000A8, "Member 'UJackUMGAccessorSenreki::SelectedClassificationNameInListTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, SelectedRecipeCategory) == 0x0000C0, "Member 'UJackUMGAccessorSenreki::SelectedRecipeCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, SelectedCutSceneTitle) == 0x0000C8, "Member 'UJackUMGAccessorSenreki::SelectedCutSceneTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountItemAll) == 0x0000D0, "Member 'UJackUMGAccessorSenreki::CountItemAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBuki) == 0x0000D4, "Member 'UJackUMGAccessorSenreki::CountBuki' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBukiAll) == 0x0000D8, "Member 'UJackUMGAccessorSenreki::CountBukiAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBougu) == 0x0000DC, "Member 'UJackUMGAccessorSenreki::CountBougu' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBouguAll) == 0x0000E0, "Member 'UJackUMGAccessorSenreki::CountBouguAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountAccessory) == 0x0000E4, "Member 'UJackUMGAccessorSenreki::CountAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountAccessoryAll) == 0x0000E8, "Member 'UJackUMGAccessorSenreki::CountAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDougu) == 0x0000EC, "Member 'UJackUMGAccessorSenreki::CountDougu' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDouguAll) == 0x0000F0, "Member 'UJackUMGAccessorSenreki::CountDouguAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountMaterial) == 0x0000F4, "Member 'UJackUMGAccessorSenreki::CountMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountMaterialAll) == 0x0000F8, "Member 'UJackUMGAccessorSenreki::CountMaterialAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountRecipeBook) == 0x0000FC, "Member 'UJackUMGAccessorSenreki::CountRecipeBook' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountRecipeBookAll) == 0x000100, "Member 'UJackUMGAccessorSenreki::CountRecipeBookAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDaizinamono) == 0x000104, "Member 'UJackUMGAccessorSenreki::CountDaizinamono' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDaizinamonoAll) == 0x000108, "Member 'UJackUMGAccessorSenreki::CountDaizinamonoAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSword) == 0x00010C, "Member 'UJackUMGAccessorSenreki::CountSword' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSwordAll) == 0x000110, "Member 'UJackUMGAccessorSenreki::CountSwordAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDoubleSword) == 0x000114, "Member 'UJackUMGAccessorSenreki::CountDoubleSword' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDoubleSwordAll) == 0x000118, "Member 'UJackUMGAccessorSenreki::CountDoubleSwordAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDagger) == 0x00011C, "Member 'UJackUMGAccessorSenreki::CountDagger' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountDaggerAll) == 0x000120, "Member 'UJackUMGAccessorSenreki::CountDaggerAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBoomerang) == 0x000124, "Member 'UJackUMGAccessorSenreki::CountBoomerang' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountBoomerangAll) == 0x000128, "Member 'UJackUMGAccessorSenreki::CountBoomerangAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountStick) == 0x00012C, "Member 'UJackUMGAccessorSenreki::CountStick' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountStickAll) == 0x000130, "Member 'UJackUMGAccessorSenreki::CountStickAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountStaff) == 0x000134, "Member 'UJackUMGAccessorSenreki::CountStaff' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountStaffAll) == 0x000138, "Member 'UJackUMGAccessorSenreki::CountStaffAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSpear) == 0x00013C, "Member 'UJackUMGAccessorSenreki::CountSpear' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSpearAll) == 0x000140, "Member 'UJackUMGAccessorSenreki::CountSpearAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountWhip) == 0x000144, "Member 'UJackUMGAccessorSenreki::CountWhip' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountWhipAll) == 0x000148, "Member 'UJackUMGAccessorSenreki::CountWhipAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountClaw) == 0x00014C, "Member 'UJackUMGAccessorSenreki::CountClaw' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountClawAll) == 0x000150, "Member 'UJackUMGAccessorSenreki::CountClawAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountAx) == 0x000154, "Member 'UJackUMGAccessorSenreki::CountAx' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountAxAll) == 0x000158, "Member 'UJackUMGAccessorSenreki::CountAxAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountShield) == 0x00015C, "Member 'UJackUMGAccessorSenreki::CountShield' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountShieldAll) == 0x000160, "Member 'UJackUMGAccessorSenreki::CountShieldAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountLargeShield) == 0x000164, "Member 'UJackUMGAccessorSenreki::CountLargeShield' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountLargeShieldAll) == 0x000168, "Member 'UJackUMGAccessorSenreki::CountLargeShieldAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHat) == 0x00016C, "Member 'UJackUMGAccessorSenreki::CountHat' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHatAll) == 0x000170, "Member 'UJackUMGAccessorSenreki::CountHatAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHelmet) == 0x000174, "Member 'UJackUMGAccessorSenreki::CountHelmet' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHelmetAll) == 0x000178, "Member 'UJackUMGAccessorSenreki::CountHelmetAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountClothes) == 0x00017C, "Member 'UJackUMGAccessorSenreki::CountClothes' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountClothesAll) == 0x000180, "Member 'UJackUMGAccessorSenreki::CountClothesAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountArmor) == 0x000184, "Member 'UJackUMGAccessorSenreki::CountArmor' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountArmorAll) == 0x000188, "Member 'UJackUMGAccessorSenreki::CountArmorAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountRobe) == 0x00018C, "Member 'UJackUMGAccessorSenreki::CountRobe' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountRobeAll) == 0x000190, "Member 'UJackUMGAccessorSenreki::CountRobeAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFaceAccessory) == 0x000194, "Member 'UJackUMGAccessorSenreki::CountFaceAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFaceAccessoryAll) == 0x000198, "Member 'UJackUMGAccessorSenreki::CountFaceAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountNeckAccessory) == 0x00019C, "Member 'UJackUMGAccessorSenreki::CountNeckAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountNeckAccessoryAll) == 0x0001A0, "Member 'UJackUMGAccessorSenreki::CountNeckAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFingerAccessory) == 0x0001A4, "Member 'UJackUMGAccessorSenreki::CountFingerAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFingerAccessoryAll) == 0x0001A8, "Member 'UJackUMGAccessorSenreki::CountFingerAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHandAccessory) == 0x0001AC, "Member 'UJackUMGAccessorSenreki::CountHandAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountHandAccessoryAll) == 0x0001B0, "Member 'UJackUMGAccessorSenreki::CountHandAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountArmAccessory) == 0x0001B4, "Member 'UJackUMGAccessorSenreki::CountArmAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountArmAccessoryAll) == 0x0001B8, "Member 'UJackUMGAccessorSenreki::CountArmAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountShoesAccessory) == 0x0001BC, "Member 'UJackUMGAccessorSenreki::CountShoesAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountShoesAccessoryAll) == 0x0001C0, "Member 'UJackUMGAccessorSenreki::CountShoesAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFootAccessory) == 0x0001C4, "Member 'UJackUMGAccessorSenreki::CountFootAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountFootAccessoryAll) == 0x0001C8, "Member 'UJackUMGAccessorSenreki::CountFootAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountEtcAccessory) == 0x0001CC, "Member 'UJackUMGAccessorSenreki::CountEtcAccessory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountEtcAccessoryAll) == 0x0001D0, "Member 'UJackUMGAccessorSenreki::CountEtcAccessoryAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountMonsterTypeAll) == 0x000228, "Member 'UJackUMGAccessorSenreki::CountMonsterTypeAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountMonsterTypeKill) == 0x00022C, "Member 'UJackUMGAccessorSenreki::CountMonsterTypeKill' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanSlime) == 0x000230, "Member 'UJackUMGAccessorSenreki::ZukanSlime' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanSlimeAll) == 0x000240, "Member 'UJackUMGAccessorSenreki::ZukanSlimeAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanAkuma) == 0x000248, "Member 'UJackUMGAccessorSenreki::ZukanAkuma' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanAkumaAll) == 0x000258, "Member 'UJackUMGAccessorSenreki::ZukanAkumaAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanKemono) == 0x000260, "Member 'UJackUMGAccessorSenreki::ZukanKemono' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanKemonoAll) == 0x000270, "Member 'UJackUMGAccessorSenreki::ZukanKemonoAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanElement) == 0x000278, "Member 'UJackUMGAccessorSenreki::ZukanElement' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanElementAll) == 0x000288, "Member 'UJackUMGAccessorSenreki::ZukanElementAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanZombie) == 0x000290, "Member 'UJackUMGAccessorSenreki::ZukanZombie' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanZombieAll) == 0x0002A0, "Member 'UJackUMGAccessorSenreki::ZukanZombieAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanDragon) == 0x0002A8, "Member 'UJackUMGAccessorSenreki::ZukanDragon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanDragonAll) == 0x0002B8, "Member 'UJackUMGAccessorSenreki::ZukanDragonAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanTori) == 0x0002C0, "Member 'UJackUMGAccessorSenreki::ZukanTori' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanToriAll) == 0x0002D0, "Member 'UJackUMGAccessorSenreki::ZukanToriAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanKaizin) == 0x0002D8, "Member 'UJackUMGAccessorSenreki::ZukanKaizin' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanKaizinAll) == 0x0002E8, "Member 'UJackUMGAccessorSenreki::ZukanKaizinAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanBussitu) == 0x0002F0, "Member 'UJackUMGAccessorSenreki::ZukanBussitu' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanBussituAll) == 0x000300, "Member 'UJackUMGAccessorSenreki::ZukanBussituAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanSizen) == 0x000308, "Member 'UJackUMGAccessorSenreki::ZukanSizen' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanSizenAll) == 0x000318, "Member 'UJackUMGAccessorSenreki::ZukanSizenAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanMachine) == 0x000320, "Member 'UJackUMGAccessorSenreki::ZukanMachine' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanMachineAll) == 0x000330, "Member 'UJackUMGAccessorSenreki::ZukanMachineAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanMaou) == 0x000338, "Member 'UJackUMGAccessorSenreki::ZukanMaou' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, ZukanMaouAll) == 0x000348, "Member 'UJackUMGAccessorSenreki::ZukanMaouAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, SyougouCategory) == 0x00034C, "Member 'UJackUMGAccessorSenreki::SyougouCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouAll) == 0x000350, "Member 'UJackUMGAccessorSenreki::CountSyougouAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouScenario) == 0x000354, "Member 'UJackUMGAccessorSenreki::CountSyougouScenario' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouBattle) == 0x000358, "Member 'UJackUMGAccessorSenreki::CountSyougouBattle' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouKazi) == 0x00035C, "Member 'UJackUMGAccessorSenreki::CountSyougouKazi' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouCasino) == 0x000360, "Member 'UJackUMGAccessorSenreki::CountSyougouCasino' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouItem) == 0x000364, "Member 'UJackUMGAccessorSenreki::CountSyougouItem' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountSyougouEtc) == 0x000368, "Member 'UJackUMGAccessorSenreki::CountSyougouEtc' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, KokoroeCategory) == 0x00036C, "Member 'UJackUMGAccessorSenreki::KokoroeCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeAll) == 0x000370, "Member 'UJackUMGAccessorSenreki::CountKokoroeAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeBasic) == 0x000374, "Member 'UJackUMGAccessorSenreki::CountKokoroeBasic' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeMenu) == 0x000378, "Member 'UJackUMGAccessorSenreki::CountKokoroeMenu' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeField) == 0x00037C, "Member 'UJackUMGAccessorSenreki::CountKokoroeField' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeBattle) == 0x000380, "Member 'UJackUMGAccessorSenreki::CountKokoroeBattle' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeItem) == 0x000384, "Member 'UJackUMGAccessorSenreki::CountKokoroeItem' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeKaji) == 0x000388, "Member 'UJackUMGAccessorSenreki::CountKokoroeKaji' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSenreki, CountKokoroeMiniGame) == 0x00038C, "Member 'UJackUMGAccessorSenreki::CountKokoroeMiniGame' has a wrong offset!");

// Class JackGame.JackActionExec
// 0x0548 (0x08E0 - 0x0398)
#pragma pack(push, 0x1)
class alignas(0x10) AJackActionExec : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPlayDelegate;                                    // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayCameraDelegate;                              // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCastEnterDelegate;                               // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShotEnterDelegate;                               // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitDelegate;                                     // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnHitCompleteDelegate;                             // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBPStateDelegate;                                 // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPlayCompleteDelegate;                            // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_420[0xE0];                                     // 0x0420(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJackGameCharacter>      Caster;                                            // 0x0500(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   ActionID;                                          // 0x0508(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackActionData                        ActionData;                                        // 0x0510(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackActionPlayParam                   ActionPlayParam;                                   // 0x05C0(0x0290)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, Transient, Protected, NativeAccessSpecifierProtected)
	struct FVector                                CasterOriginLocation;                              // 0x0850(0x000C)(Edit, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConsumeDouguDisable;                              // 0x085C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayCameraFrame;                                  // 0x085D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bShotStarted;                                      // 0x085E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHitComplete;                                      // 0x085F(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayJumonHansyaEffect;                            // 0x0860(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayedCamera;                                     // 0x0861(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBackJumpPlaying;                                  // 0x0862(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFreeMoveOriginLocationCanceled;                   // 0x0863(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_864[0x4];                                      // 0x0864(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackActionExecStateType>              StateTransitions;                                  // 0x0868(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, Protected, NativeAccessSpecifierProtected)
	bool                                          bBPStateComplete;                                  // 0x0878(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_879[0x7];                                      // 0x0879(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionMessageArg                  MessageArg;                                        // 0x0880(0x0020)(Edit, DisableEditOnTemplate, Transient, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackActionMessageInfo>  MessageInfo_Koudou;                                // 0x08A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackActionWaitChecker*                 ActionWaitChecker;                                 // 0x08A8(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackStreamObjectsHolder*               ResourceHolder;                                    // 0x08B0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontageCast;                                   // 0x08B8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontageShot;                                   // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C8[0x10];                                     // 0x08C8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BattleActionCameraPlayStart(class FName ActionCameraID);
	void ChangeState(EJackActionExecStateType StateType);
	void ConsumeMP();
	void Delegate__DelegateSignature();
	class AJackCharacter* GetCasterCharacter();
	class UJackGameCharacter* GetCasterGameCharacter();
	class FName GetShotAnimMontageKey();
	TArray<class AJackCharacter*> GetSynchronizeCharacters();
	class AJackCharacter* GetTargetCharacter();
	TArray<class AJackCharacter*> GetTargetCharacters();
	class UJackGameCharacter* GetTargetGameCharacter();
	TArray<class UJackGameCharacter*> GetTargetGameCharacters();
	void InsertStateTransition(EJackActionExecStateType StateType, EJackActionExecStateType InsertPositionStateType);
	EJackActionExecStateType NextStateTransition(bool bBack);
	void NotifyActionHit();
	void NotifyFireReservedEffect(bool bInActionEffect, bool bInProjectile, bool bInBurstEffect, bool bInParticleSystem);
	void PlayActionMessage(EJackActionTextType TextType);
	void PlayActionMessageWithTextId(class FName TextID);
	void PlayBattleVoice(class AJackCharacter* InTarget, const class FName InVoiceID);
	void PushStateTransition(EJackActionExecStateType StateType, bool bHead);
	void RegisterReservedEffect(bool bCastOrShot, bool bActionEffect2Only);
	void RegisterTextDelegate(class UJackUMGSerifuWindowController* InController, class AJackCharacter* InTarget);
	void RemoveBattleCharacterCompletely(class UJackGameCharacter* GameCharacter, bool bToubatsuEnable);
	void RemoveStateTransition(EJackActionExecStateType StateType);
	void ResetStateTransition();
	void SendCommandNakamayobi(class AJackCharacter* Actor);
	void SerifuScriptDelegate(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, EJackMessageScriptEventType DelegateType, const class FString& StringParam);
	void SerifuWindowMessageDelegate(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, EJackTextDelegateType DelegateType, int32 Page, int32 Line, int32 Index_0);
	void SetBPStateComplete();
	void SetNifuramuCasterCharacter();
	void SetNifuramuCharacter(class UJackGameCharacter* GameCharacter, bool bToubatsuEnable);
	void SetNifuramuCharacterArray(const TArray<class UJackGameCharacter*>& GameCharacterArray);
	void SetupFieldModeStateTransition(bool bOnlyInField);
	class AJackMonsterCharacter* SpawnZouenMonster(class FName MonsterID, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotation);
	void SubtractItemInActionPlayParam();

	struct FJackActionPlayParam GetActionPlayParamBP() const;
	float GetBattleParameterInoriNoYubiwaProb() const;
	bool GetCasterChangeVariantForm() const;
	TArray<struct FJackMessageArgumentData> GetMessageArgs() const;
	TArray<EJackActionExecStateType> GetStateTransitionBP() const;
	int32 GetStateTransitionNum() const;
	bool IsConsumeAction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec">();
	}
	static class AJackActionExec* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec>();
	}
};
#pragma pack(pop)
static_assert(alignof(AJackActionExec) == 0x000010, "Wrong alignment on AJackActionExec");
static_assert(sizeof(AJackActionExec) == 0x0008E0, "Wrong size on AJackActionExec");
static_assert(offsetof(AJackActionExec, OnPlayDelegate) == 0x0003A0, "Member 'AJackActionExec::OnPlayDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnPlayCameraDelegate) == 0x0003B0, "Member 'AJackActionExec::OnPlayCameraDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnCastEnterDelegate) == 0x0003C0, "Member 'AJackActionExec::OnCastEnterDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnShotEnterDelegate) == 0x0003D0, "Member 'AJackActionExec::OnShotEnterDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnHitDelegate) == 0x0003E0, "Member 'AJackActionExec::OnHitDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnHitCompleteDelegate) == 0x0003F0, "Member 'AJackActionExec::OnHitCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnBPStateDelegate) == 0x000400, "Member 'AJackActionExec::OnBPStateDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, OnPlayCompleteDelegate) == 0x000410, "Member 'AJackActionExec::OnPlayCompleteDelegate' has a wrong offset!");
static_assert(offsetof(AJackActionExec, Caster) == 0x000500, "Member 'AJackActionExec::Caster' has a wrong offset!");
static_assert(offsetof(AJackActionExec, ActionID) == 0x000508, "Member 'AJackActionExec::ActionID' has a wrong offset!");
static_assert(offsetof(AJackActionExec, ActionData) == 0x000510, "Member 'AJackActionExec::ActionData' has a wrong offset!");
static_assert(offsetof(AJackActionExec, ActionPlayParam) == 0x0005C0, "Member 'AJackActionExec::ActionPlayParam' has a wrong offset!");
static_assert(offsetof(AJackActionExec, CasterOriginLocation) == 0x000850, "Member 'AJackActionExec::CasterOriginLocation' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bConsumeDouguDisable) == 0x00085C, "Member 'AJackActionExec::bConsumeDouguDisable' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bPlayCameraFrame) == 0x00085D, "Member 'AJackActionExec::bPlayCameraFrame' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bShotStarted) == 0x00085E, "Member 'AJackActionExec::bShotStarted' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bHitComplete) == 0x00085F, "Member 'AJackActionExec::bHitComplete' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bPlayJumonHansyaEffect) == 0x000860, "Member 'AJackActionExec::bPlayJumonHansyaEffect' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bPlayedCamera) == 0x000861, "Member 'AJackActionExec::bPlayedCamera' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bBackJumpPlaying) == 0x000862, "Member 'AJackActionExec::bBackJumpPlaying' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bFreeMoveOriginLocationCanceled) == 0x000863, "Member 'AJackActionExec::bFreeMoveOriginLocationCanceled' has a wrong offset!");
static_assert(offsetof(AJackActionExec, StateTransitions) == 0x000868, "Member 'AJackActionExec::StateTransitions' has a wrong offset!");
static_assert(offsetof(AJackActionExec, bBPStateComplete) == 0x000878, "Member 'AJackActionExec::bBPStateComplete' has a wrong offset!");
static_assert(offsetof(AJackActionExec, MessageArg) == 0x000880, "Member 'AJackActionExec::MessageArg' has a wrong offset!");
static_assert(offsetof(AJackActionExec, MessageInfo_Koudou) == 0x0008A0, "Member 'AJackActionExec::MessageInfo_Koudou' has a wrong offset!");
static_assert(offsetof(AJackActionExec, ActionWaitChecker) == 0x0008A8, "Member 'AJackActionExec::ActionWaitChecker' has a wrong offset!");
static_assert(offsetof(AJackActionExec, ResourceHolder) == 0x0008B0, "Member 'AJackActionExec::ResourceHolder' has a wrong offset!");
static_assert(offsetof(AJackActionExec, AnimMontageCast) == 0x0008B8, "Member 'AJackActionExec::AnimMontageCast' has a wrong offset!");
static_assert(offsetof(AJackActionExec, AnimMontageShot) == 0x0008C0, "Member 'AJackActionExec::AnimMontageShot' has a wrong offset!");

// Class JackGame.JackTextData
// 0x0000 (0x0038 - 0x0038)
class UJackTextData : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextData">();
	}
	static class UJackTextData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextData>();
	}
};
static_assert(alignof(UJackTextData) == 0x000008, "Wrong alignment on UJackTextData");
static_assert(sizeof(UJackTextData) == 0x000038, "Wrong size on UJackTextData");

// Class JackGame.JackTextSetKyoukai
// 0x0000 (0x0038 - 0x0038)
class UJackTextSetKyoukai final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextSetKyoukai">();
	}
	static class UJackTextSetKyoukai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextSetKyoukai>();
	}
};
static_assert(alignof(UJackTextSetKyoukai) == 0x000008, "Wrong alignment on UJackTextSetKyoukai");
static_assert(sizeof(UJackTextSetKyoukai) == 0x000038, "Wrong size on UJackTextSetKyoukai");

// Class JackGame.JackDressupCoordinateManager
// 0x00F0 (0x0128 - 0x0038)
class UJackDressupCoordinateManager final : public UObject
{
public:
	uint8                                         Pad_38[0xF0];                                      // 0x0038(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDressupCoordinateManager">();
	}
	static class UJackDressupCoordinateManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDressupCoordinateManager>();
	}
};
static_assert(alignof(UJackDressupCoordinateManager) == 0x000008, "Wrong alignment on UJackDressupCoordinateManager");
static_assert(sizeof(UJackDressupCoordinateManager) == 0x000128, "Wrong size on UJackDressupCoordinateManager");

// Class JackGame.JackActionExec_ActionHit
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_ActionHit final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_ActionHit">();
	}
	static class AJackActionExec_ActionHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_ActionHit>();
	}
};
static_assert(alignof(AJackActionExec_ActionHit) == 0x000010, "Wrong alignment on AJackActionExec_ActionHit");
static_assert(sizeof(AJackActionExec_ActionHit) == 0x0008E0, "Wrong size on AJackActionExec_ActionHit");

// Class JackGame.JackActionExec_NoShot
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_NoShot : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_NoShot">();
	}
	static class AJackActionExec_NoShot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_NoShot>();
	}
};
static_assert(alignof(AJackActionExec_NoShot) == 0x000010, "Wrong alignment on AJackActionExec_NoShot");
static_assert(sizeof(AJackActionExec_NoShot) == 0x0008E0, "Wrong size on AJackActionExec_NoShot");

// Class JackGame.JackUMGTokugiPanelWindow
// 0x0020 (0x0390 - 0x0370)
class UJackUMGTokugiPanelWindow : public UJackUMGWidgetBase
{
public:
	TArray<class UJackUMGTokugiPanelData*>        PanelDataList;                                     // 0x0370(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UJackUMGTokugiPanelData*                CurrentSelectPanelData;                            // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              CursorPosition;                                    // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ChangeSelectState(class UJackUMGTokugiPanelData* PanelData, bool bSelected, bool bIsMoveCursorInput);
	void CreateTokugiPanel(class UJackUMGTokugiPanelData* PanelData);
	class UJackUMGTokugiPanelData* FindDataAtCursorPos(const struct FVector2D& CursorPos);
	void InitTokugiPanelWindow(int32 ZOrder);
	void MoveCursorDrawPosition(const struct FVector2D& CursorPos);
	void OnEnter();
	void SetCursorPosition(const struct FVector2D& CursorPos, bool bIsMoveCursorInput);
	void SetDisplayScale(float DisplayScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPanelWindow">();
	}
	static class UJackUMGTokugiPanelWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPanelWindow>();
	}
};
static_assert(alignof(UJackUMGTokugiPanelWindow) == 0x000008, "Wrong alignment on UJackUMGTokugiPanelWindow");
static_assert(sizeof(UJackUMGTokugiPanelWindow) == 0x000390, "Wrong size on UJackUMGTokugiPanelWindow");
static_assert(offsetof(UJackUMGTokugiPanelWindow, PanelDataList) == 0x000370, "Member 'UJackUMGTokugiPanelWindow::PanelDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelWindow, CurrentSelectPanelData) == 0x000380, "Member 'UJackUMGTokugiPanelWindow::CurrentSelectPanelData' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelWindow, CursorPosition) == 0x000388, "Member 'UJackUMGTokugiPanelWindow::CursorPosition' has a wrong offset!");

// Class JackGame.JackDR_ScreenPercentageTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_ScreenPercentageTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_ScreenPercentageTrack">();
	}
	static class UJackDR_ScreenPercentageTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_ScreenPercentageTrack>();
	}
};
static_assert(alignof(UJackDR_ScreenPercentageTrack) == 0x000008, "Wrong alignment on UJackDR_ScreenPercentageTrack");
static_assert(sizeof(UJackDR_ScreenPercentageTrack) == 0x0000B0, "Wrong size on UJackDR_ScreenPercentageTrack");

// Class JackGame.JackActionExec_BunnyNoMamori
// 0x0010 (0x08F0 - 0x08E0)
class AJackActionExec_BunnyNoMamori final : public AJackActionExec_NoShot
{
public:
	uint8                                         Pad_8E0[0x10];                                     // 0x08E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHitComplete();
	void OnPlay();
	void OnTenNoKoeMessageEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_BunnyNoMamori">();
	}
	static class AJackActionExec_BunnyNoMamori* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_BunnyNoMamori>();
	}
};
static_assert(alignof(AJackActionExec_BunnyNoMamori) == 0x000010, "Wrong alignment on AJackActionExec_BunnyNoMamori");
static_assert(sizeof(AJackActionExec_BunnyNoMamori) == 0x0008F0, "Wrong size on AJackActionExec_BunnyNoMamori");

// Class JackGame.JackActionExec_Bunsin
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_Bunsin : public AJackActionExec
{
public:
	TWeakObjectPtr<class UJackBunsinComponent>    CasterBunsinComp;                                  // 0x08D8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_Bunsin">();
	}
	static class AJackActionExec_Bunsin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_Bunsin>();
	}
};
static_assert(alignof(AJackActionExec_Bunsin) == 0x000010, "Wrong alignment on AJackActionExec_Bunsin");
static_assert(sizeof(AJackActionExec_Bunsin) == 0x0008E0, "Wrong size on AJackActionExec_Bunsin");
static_assert(offsetof(AJackActionExec_Bunsin, CasterBunsinComp) == 0x0008D8, "Member 'AJackActionExec_Bunsin::CasterBunsinComp' has a wrong offset!");

// Class JackGame.JackTextureStreamingSlaveDummyActor
// 0x0008 (0x03A0 - 0x0398)
class AJackTextureStreamingSlaveDummyActor final : public AActor
{
public:
	float                                         BoostFactor;                                       // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextureStreamingSlaveDummyActor">();
	}
	static class AJackTextureStreamingSlaveDummyActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTextureStreamingSlaveDummyActor>();
	}
};
static_assert(alignof(AJackTextureStreamingSlaveDummyActor) == 0x000008, "Wrong alignment on AJackTextureStreamingSlaveDummyActor");
static_assert(sizeof(AJackTextureStreamingSlaveDummyActor) == 0x0003A0, "Wrong size on AJackTextureStreamingSlaveDummyActor");
static_assert(offsetof(AJackTextureStreamingSlaveDummyActor, BoostFactor) == 0x000398, "Member 'AJackTextureStreamingSlaveDummyActor::BoostFactor' has a wrong offset!");

// Class JackGame.JackUMGTouchPadScrollContent
// 0x0188 (0x0358 - 0x01D0)
class UJackUMGTouchPadScrollContent : public UUserWidget
{
public:
	bool                                          bAutoBindTouchpadEvent;                            // 0x01D0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bControlable;                                      // 0x01D1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D2[0x6];                                      // 0x01D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackUMGTouchPadScrollContentData      ContentData;                                       // 0x01D8(0x0088)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGTouchPadScrollContentData      ContentData2;                                      // 0x0260(0x0088)(ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ScrollableMargin;                                  // 0x02E8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTouchPadButtonValid;                              // 0x02EC(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseContent2;                                      // 0x02ED(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2EE[0x2];                                      // 0x02EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TouchPoint;                                        // 0x02F0(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PrevTouchPoint;                                    // 0x02FC(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TouchStartPosition;                                // 0x0308(0x000C)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bScrollStarted;                                    // 0x0314(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_315[0x3];                                      // 0x0315(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UImage*                                 TouchCursor;                                       // 0x0318(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TouchCursorPoint;                                  // 0x0320(0x0008)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              TouchCursorBasePosition;                           // 0x0328(0x0008)(IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Text;                                              // 0x0330(0x0010)(ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUMGTextColorSet                          ColorType;                                         // 0x0340(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_341[0x17];                                     // 0x0341(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindTouchpadEvent();
	void ChangeContent(bool bInUseContent2);
	void SetControlable(bool bValue);
	void SetFontColor(EJackUMGTextColorSet InColorType);
	void SetScrollableMargin(float Value);
	void SetScrollContent(class UPanelWidget* MainPanel, class UTextBlock* ScrollContent, class UImage* ScrollBarImage, class UPanelWidget* TouchPadInfoPanel);
	void SetScrollContent2(class UPanelWidget* MainPanel, class UTextBlock* ScrollContent, class UImage* ScrollBarImage, class UPanelWidget* TouchPadInfoPanel);
	void SetScrollContentEx(class UPanelWidget* MainPanel, class UCanvasPanel* ScrollContent, class UTextBlock* MainTextBlock, class UImage* MainImage, class UImage* ScrollBarImage, class UPanelWidget* TouchPadInfoPanel, float LineHeight, int32 LineTextLabelCount, int32 LineImageCount);
	void SetScrollContentEx2(class UPanelWidget* MainPanel, class UCanvasPanel* ScrollContent, class UTextBlock* MainTextBlock, class UImage* ScrollBarImage, class UPanelWidget* TouchPadInfoPanel, float LineHeight, int32 LineTextLabelCount);
	void SetText(const class FString& InText);
	void UnbindTouchpadEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTouchPadScrollContent">();
	}
	static class UJackUMGTouchPadScrollContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTouchPadScrollContent>();
	}
};
static_assert(alignof(UJackUMGTouchPadScrollContent) == 0x000008, "Wrong alignment on UJackUMGTouchPadScrollContent");
static_assert(sizeof(UJackUMGTouchPadScrollContent) == 0x000358, "Wrong size on UJackUMGTouchPadScrollContent");
static_assert(offsetof(UJackUMGTouchPadScrollContent, bAutoBindTouchpadEvent) == 0x0001D0, "Member 'UJackUMGTouchPadScrollContent::bAutoBindTouchpadEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, bControlable) == 0x0001D1, "Member 'UJackUMGTouchPadScrollContent::bControlable' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, ContentData) == 0x0001D8, "Member 'UJackUMGTouchPadScrollContent::ContentData' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, ContentData2) == 0x000260, "Member 'UJackUMGTouchPadScrollContent::ContentData2' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, ScrollableMargin) == 0x0002E8, "Member 'UJackUMGTouchPadScrollContent::ScrollableMargin' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, bTouchPadButtonValid) == 0x0002EC, "Member 'UJackUMGTouchPadScrollContent::bTouchPadButtonValid' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, bUseContent2) == 0x0002ED, "Member 'UJackUMGTouchPadScrollContent::bUseContent2' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, TouchPoint) == 0x0002F0, "Member 'UJackUMGTouchPadScrollContent::TouchPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, PrevTouchPoint) == 0x0002FC, "Member 'UJackUMGTouchPadScrollContent::PrevTouchPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, TouchStartPosition) == 0x000308, "Member 'UJackUMGTouchPadScrollContent::TouchStartPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, bScrollStarted) == 0x000314, "Member 'UJackUMGTouchPadScrollContent::bScrollStarted' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, TouchCursor) == 0x000318, "Member 'UJackUMGTouchPadScrollContent::TouchCursor' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, TouchCursorPoint) == 0x000320, "Member 'UJackUMGTouchPadScrollContent::TouchCursorPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, TouchCursorBasePosition) == 0x000328, "Member 'UJackUMGTouchPadScrollContent::TouchCursorBasePosition' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, Text) == 0x000330, "Member 'UJackUMGTouchPadScrollContent::Text' has a wrong offset!");
static_assert(offsetof(UJackUMGTouchPadScrollContent, ColorType) == 0x000340, "Member 'UJackUMGTouchPadScrollContent::ColorType' has a wrong offset!");

// Class JackGame.JackCapsuleComponent
// 0x0020 (0x0780 - 0x0760)
class UJackCapsuleComponent : public UCapsuleComponent
{
public:
	class FString                                 AutoAttachComponentName;                           // 0x0760(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AutoAttachSocketName;                              // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               AutoAttachType;                                    // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCapsuleComponent">();
	}
	static class UJackCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCapsuleComponent>();
	}
};
static_assert(alignof(UJackCapsuleComponent) == 0x000010, "Wrong alignment on UJackCapsuleComponent");
static_assert(sizeof(UJackCapsuleComponent) == 0x000780, "Wrong size on UJackCapsuleComponent");
static_assert(offsetof(UJackCapsuleComponent, AutoAttachComponentName) == 0x000760, "Member 'UJackCapsuleComponent::AutoAttachComponentName' has a wrong offset!");
static_assert(offsetof(UJackCapsuleComponent, AutoAttachSocketName) == 0x000770, "Member 'UJackCapsuleComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UJackCapsuleComponent, AutoAttachType) == 0x000778, "Member 'UJackCapsuleComponent::AutoAttachType' has a wrong offset!");

// Class JackGame.JackEncountTriggerCapsuleComponent
// 0x0020 (0x07A0 - 0x0780)
class UJackEncountTriggerCapsuleComponent final : public UJackCapsuleComponent
{
public:
	uint8                                         Pad_780[0x9];                                      // 0x0780(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDispRandomEncountDistance;                        // 0x0789(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomEncountImmediately;                         // 0x078A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78B[0x1];                                      // 0x078B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SplashWeight;                                      // 0x078C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SplashDiffLevel;                                   // 0x0790(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_794[0x4];                                      // 0x0794(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SplashSpeed;                                       // 0x0798(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79C[0x4];                                      // 0x079C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnEncountTriggerComponentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEncountTriggerCapsuleComponent">();
	}
	static class UJackEncountTriggerCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEncountTriggerCapsuleComponent>();
	}
};
static_assert(alignof(UJackEncountTriggerCapsuleComponent) == 0x000010, "Wrong alignment on UJackEncountTriggerCapsuleComponent");
static_assert(sizeof(UJackEncountTriggerCapsuleComponent) == 0x0007A0, "Wrong size on UJackEncountTriggerCapsuleComponent");
static_assert(offsetof(UJackEncountTriggerCapsuleComponent, bDispRandomEncountDistance) == 0x000789, "Member 'UJackEncountTriggerCapsuleComponent::bDispRandomEncountDistance' has a wrong offset!");
static_assert(offsetof(UJackEncountTriggerCapsuleComponent, bRandomEncountImmediately) == 0x00078A, "Member 'UJackEncountTriggerCapsuleComponent::bRandomEncountImmediately' has a wrong offset!");
static_assert(offsetof(UJackEncountTriggerCapsuleComponent, SplashWeight) == 0x00078C, "Member 'UJackEncountTriggerCapsuleComponent::SplashWeight' has a wrong offset!");
static_assert(offsetof(UJackEncountTriggerCapsuleComponent, SplashDiffLevel) == 0x000790, "Member 'UJackEncountTriggerCapsuleComponent::SplashDiffLevel' has a wrong offset!");
static_assert(offsetof(UJackEncountTriggerCapsuleComponent, SplashSpeed) == 0x000798, "Member 'UJackEncountTriggerCapsuleComponent::SplashSpeed' has a wrong offset!");

// Class JackGame.JackActionExec_Destruction
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_Destruction final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_Destruction">();
	}
	static class AJackActionExec_Destruction* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_Destruction>();
	}
};
static_assert(alignof(AJackActionExec_Destruction) == 0x000010, "Wrong alignment on AJackActionExec_Destruction");
static_assert(sizeof(AJackActionExec_Destruction) == 0x0008E0, "Wrong size on AJackActionExec_Destruction");

// Class JackGame.JackActionExec_DevilMode
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_DevilMode final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_DevilMode">();
	}
	static class AJackActionExec_DevilMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_DevilMode>();
	}
};
static_assert(alignof(AJackActionExec_DevilMode) == 0x000010, "Wrong alignment on AJackActionExec_DevilMode");
static_assert(sizeof(AJackActionExec_DevilMode) == 0x0008E0, "Wrong size on AJackActionExec_DevilMode");

// Class JackGame.JackActionExec_FieldMode
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_FieldMode final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_FieldMode">();
	}
	static class AJackActionExec_FieldMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_FieldMode>();
	}
};
static_assert(alignof(AJackActionExec_FieldMode) == 0x000010, "Wrong alignment on AJackActionExec_FieldMode");
static_assert(sizeof(AJackActionExec_FieldMode) == 0x0008E0, "Wrong size on AJackActionExec_FieldMode");

// Class JackGame.JackActionExec_M_Nigeru
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_M_Nigeru final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_M_Nigeru">();
	}
	static class AJackActionExec_M_Nigeru* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_M_Nigeru>();
	}
};
static_assert(alignof(AJackActionExec_M_Nigeru) == 0x000010, "Wrong alignment on AJackActionExec_M_Nigeru");
static_assert(sizeof(AJackActionExec_M_Nigeru) == 0x0008E0, "Wrong size on AJackActionExec_M_Nigeru");

// Class JackGame.JackLastPositionInst
// 0x0008 (0x0040 - 0x0038)
class UJackLastPositionInst : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLastPositionInst">();
	}
	static class UJackLastPositionInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLastPositionInst>();
	}
};
static_assert(alignof(UJackLastPositionInst) == 0x000008, "Wrong alignment on UJackLastPositionInst");
static_assert(sizeof(UJackLastPositionInst) == 0x000040, "Wrong size on UJackLastPositionInst");

// Class JackGame.JackTimeLineJumperTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackTimeLineJumperTrackInst final : public UJackLastPositionInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTimeLineJumperTrackInst">();
	}
	static class UJackTimeLineJumperTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTimeLineJumperTrackInst>();
	}
};
static_assert(alignof(UJackTimeLineJumperTrackInst) == 0x000008, "Wrong alignment on UJackTimeLineJumperTrackInst");
static_assert(sizeof(UJackTimeLineJumperTrackInst) == 0x000040, "Wrong size on UJackTimeLineJumperTrackInst");

// Class JackGame.JackGameFlagDebugger
// 0x00F8 (0x0130 - 0x0038)
class UJackGameFlagDebugger final : public UObject
{
public:
	uint8                                         Pad_38[0xF8];                                      // 0x0038(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDebugger">();
	}
	static class UJackGameFlagDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDebugger>();
	}
};
static_assert(alignof(UJackGameFlagDebugger) == 0x000008, "Wrong alignment on UJackGameFlagDebugger");
static_assert(sizeof(UJackGameFlagDebugger) == 0x000130, "Wrong size on UJackGameFlagDebugger");

// Class JackGame.JackActionExec_Nusumu
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_Nusumu final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_Nusumu">();
	}
	static class AJackActionExec_Nusumu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_Nusumu>();
	}
};
static_assert(alignof(AJackActionExec_Nusumu) == 0x000010, "Wrong alignment on AJackActionExec_Nusumu");
static_assert(sizeof(AJackActionExec_Nusumu) == 0x0008E0, "Wrong size on AJackActionExec_Nusumu");

// Class JackGame.JackActionExec_Nusumu_Bunsin
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_Nusumu_Bunsin final : public AJackActionExec_Bunsin
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_Nusumu_Bunsin">();
	}
	static class AJackActionExec_Nusumu_Bunsin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_Nusumu_Bunsin>();
	}
};
static_assert(alignof(AJackActionExec_Nusumu_Bunsin) == 0x000010, "Wrong alignment on AJackActionExec_Nusumu_Bunsin");
static_assert(sizeof(AJackActionExec_Nusumu_Bunsin) == 0x0008E0, "Wrong size on AJackActionExec_Nusumu_Bunsin");

// Class JackGame.JackUMGPage
// 0x0010 (0x0048 - 0x0038)
class UJackUMGPage final : public UObject
{
public:
	class UJackUMGWidgetBase*                     WidgetBase;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPage">();
	}
	static class UJackUMGPage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPage>();
	}
};
static_assert(alignof(UJackUMGPage) == 0x000008, "Wrong alignment on UJackUMGPage");
static_assert(sizeof(UJackUMGPage) == 0x000048, "Wrong size on UJackUMGPage");
static_assert(offsetof(UJackUMGPage, WidgetBase) == 0x000038, "Member 'UJackUMGPage::WidgetBase' has a wrong offset!");

// Class JackGame.JackDynamicShadowDistanceMovableLightTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackDynamicShadowDistanceMovableLightTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDynamicShadowDistanceMovableLightTrackInst">();
	}
	static class UJackDynamicShadowDistanceMovableLightTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDynamicShadowDistanceMovableLightTrackInst>();
	}
};
static_assert(alignof(UJackDynamicShadowDistanceMovableLightTrackInst) == 0x000008, "Wrong alignment on UJackDynamicShadowDistanceMovableLightTrackInst");
static_assert(sizeof(UJackDynamicShadowDistanceMovableLightTrackInst) == 0x000048, "Wrong size on UJackDynamicShadowDistanceMovableLightTrackInst");

// Class JackGame.JackActionExec_RemoveTurnQueue
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_RemoveTurnQueue final : public AJackActionExec
{
public:
	void OnPlay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_RemoveTurnQueue">();
	}
	static class AJackActionExec_RemoveTurnQueue* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_RemoveTurnQueue>();
	}
};
static_assert(alignof(AJackActionExec_RemoveTurnQueue) == 0x000010, "Wrong alignment on AJackActionExec_RemoveTurnQueue");
static_assert(sizeof(AJackActionExec_RemoveTurnQueue) == 0x0008E0, "Wrong size on AJackActionExec_RemoveTurnQueue");

// Class JackGame.JackActionExec_RensouDan
// 0x0040 (0x0920 - 0x08E0)
class AJackActionExec_RensouDan final : public AJackActionExec
{
public:
	TArray<class FName>                           CallMonsterIDs;                                    // 0x08D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class FName                                   CallLocatorTagName;                                // 0x08E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         NeedToSpawnCount;                                  // 0x08F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F4[0x4];                                      // 0x08F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AJackLocator*>                   ZouenLocators;                                     // 0x08F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_908[0x18];                                     // 0x0908(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnPlay_CheckFirst();
	void SpawnZouen();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_RensouDan">();
	}
	static class AJackActionExec_RensouDan* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_RensouDan>();
	}
};
static_assert(alignof(AJackActionExec_RensouDan) == 0x000010, "Wrong alignment on AJackActionExec_RensouDan");
static_assert(sizeof(AJackActionExec_RensouDan) == 0x000920, "Wrong size on AJackActionExec_RensouDan");
static_assert(offsetof(AJackActionExec_RensouDan, CallMonsterIDs) == 0x0008D8, "Member 'AJackActionExec_RensouDan::CallMonsterIDs' has a wrong offset!");
static_assert(offsetof(AJackActionExec_RensouDan, CallLocatorTagName) == 0x0008E8, "Member 'AJackActionExec_RensouDan::CallLocatorTagName' has a wrong offset!");
static_assert(offsetof(AJackActionExec_RensouDan, NeedToSpawnCount) == 0x0008F0, "Member 'AJackActionExec_RensouDan::NeedToSpawnCount' has a wrong offset!");
static_assert(offsetof(AJackActionExec_RensouDan, ZouenLocators) == 0x0008F8, "Member 'AJackActionExec_RensouDan::ZouenLocators' has a wrong offset!");

// Class JackGame.JackToggleBaseTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackToggleBaseTrackInst : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackToggleBaseTrackInst">();
	}
	static class UJackToggleBaseTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackToggleBaseTrackInst>();
	}
};
static_assert(alignof(UJackToggleBaseTrackInst) == 0x000008, "Wrong alignment on UJackToggleBaseTrackInst");
static_assert(sizeof(UJackToggleBaseTrackInst) == 0x000040, "Wrong size on UJackToggleBaseTrackInst");
static_assert(offsetof(UJackToggleBaseTrackInst, LastUpdatePosition) == 0x000038, "Member 'UJackToggleBaseTrackInst::LastUpdatePosition' has a wrong offset!");

// Class JackGame.JackToBeContinuedTrackInst
// 0x0008 (0x0048 - 0x0040)
class UJackToBeContinuedTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackToBeContinuedTrackInst">();
	}
	static class UJackToBeContinuedTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackToBeContinuedTrackInst>();
	}
};
static_assert(alignof(UJackToBeContinuedTrackInst) == 0x000008, "Wrong alignment on UJackToBeContinuedTrackInst");
static_assert(sizeof(UJackToBeContinuedTrackInst) == 0x000048, "Wrong size on UJackToBeContinuedTrackInst");

// Class JackGame.JackUMGManagerSetting
// 0x06E0 (0x0718 - 0x0038)
class UJackUMGManagerSetting : public UObject
{
public:
	bool                                          IsEnableMenuWindowAnimation;                       // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           WidgetEnableColor;                                 // 0x003C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           WidgetDisableColor;                                // 0x004C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   SyougouColorTable;                                 // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	class UTexture2D*                             L1ButtonIcon;                                      // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             L2ButtonIcon;                                      // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             R1ButtonIcon;                                      // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             R2ButtonIcon;                                      // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceTopButtonIcon;                                 // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceBottomButtonIcon;                              // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceLeftButtonIcon;                                // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceRightButtonIcon;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             OptionsButtonIcon;                                 // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             L3ButtonIcon;                                      // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackSerifuPrintSpeedDict>      SerifuPrintSpeedList;                              // 0x00C0(0x0010)(ZeroConstructor, Deprecated, NativeAccessSpecifierPublic)
	float                                         SerifuFastModeMultiplier;                          // 0x00D0(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             SerifuPrintSpeedDataTable;                         // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJackKeys>                             KeyPermitListAtME;                                 // 0x00E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         DefaultFadeZOrder;                                 // 0x00F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ForegroundFadeZOrder;                              // 0x00F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MessageFadeZOrder;                                 // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CSSkipZOrder;                                      // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackUMGFontColorSet                   FontColorSet;                                      // 0x0100(0x060C)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CreateWidgetWarningTime;                           // 0x070C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateWidgetWarningTime;                           // 0x0710(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_714[0x4];                                      // 0x0714(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGManagerSetting">();
	}
	static class UJackUMGManagerSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGManagerSetting>();
	}
};
static_assert(alignof(UJackUMGManagerSetting) == 0x000008, "Wrong alignment on UJackUMGManagerSetting");
static_assert(sizeof(UJackUMGManagerSetting) == 0x000718, "Wrong size on UJackUMGManagerSetting");
static_assert(offsetof(UJackUMGManagerSetting, IsEnableMenuWindowAnimation) == 0x000038, "Member 'UJackUMGManagerSetting::IsEnableMenuWindowAnimation' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, WidgetEnableColor) == 0x00003C, "Member 'UJackUMGManagerSetting::WidgetEnableColor' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, WidgetDisableColor) == 0x00004C, "Member 'UJackUMGManagerSetting::WidgetDisableColor' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, SyougouColorTable) == 0x000060, "Member 'UJackUMGManagerSetting::SyougouColorTable' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, L1ButtonIcon) == 0x000070, "Member 'UJackUMGManagerSetting::L1ButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, L2ButtonIcon) == 0x000078, "Member 'UJackUMGManagerSetting::L2ButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, R1ButtonIcon) == 0x000080, "Member 'UJackUMGManagerSetting::R1ButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, R2ButtonIcon) == 0x000088, "Member 'UJackUMGManagerSetting::R2ButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, FaceTopButtonIcon) == 0x000090, "Member 'UJackUMGManagerSetting::FaceTopButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, FaceBottomButtonIcon) == 0x000098, "Member 'UJackUMGManagerSetting::FaceBottomButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, FaceLeftButtonIcon) == 0x0000A0, "Member 'UJackUMGManagerSetting::FaceLeftButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, FaceRightButtonIcon) == 0x0000A8, "Member 'UJackUMGManagerSetting::FaceRightButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, OptionsButtonIcon) == 0x0000B0, "Member 'UJackUMGManagerSetting::OptionsButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, L3ButtonIcon) == 0x0000B8, "Member 'UJackUMGManagerSetting::L3ButtonIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, SerifuPrintSpeedList) == 0x0000C0, "Member 'UJackUMGManagerSetting::SerifuPrintSpeedList' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, SerifuFastModeMultiplier) == 0x0000D0, "Member 'UJackUMGManagerSetting::SerifuFastModeMultiplier' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, SerifuPrintSpeedDataTable) == 0x0000D8, "Member 'UJackUMGManagerSetting::SerifuPrintSpeedDataTable' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, KeyPermitListAtME) == 0x0000E0, "Member 'UJackUMGManagerSetting::KeyPermitListAtME' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, DefaultFadeZOrder) == 0x0000F0, "Member 'UJackUMGManagerSetting::DefaultFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, ForegroundFadeZOrder) == 0x0000F4, "Member 'UJackUMGManagerSetting::ForegroundFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, MessageFadeZOrder) == 0x0000F8, "Member 'UJackUMGManagerSetting::MessageFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, CSSkipZOrder) == 0x0000FC, "Member 'UJackUMGManagerSetting::CSSkipZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, FontColorSet) == 0x000100, "Member 'UJackUMGManagerSetting::FontColorSet' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, CreateWidgetWarningTime) == 0x00070C, "Member 'UJackUMGManagerSetting::CreateWidgetWarningTime' has a wrong offset!");
static_assert(offsetof(UJackUMGManagerSetting, UpdateWidgetWarningTime) == 0x000710, "Member 'UJackUMGManagerSetting::UpdateWidgetWarningTime' has a wrong offset!");

// Class JackGame.JackGameFlagListBase
// 0x0000 (0x0038 - 0x0038)
class UJackGameFlagListBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagListBase">();
	}
	static class UJackGameFlagListBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagListBase>();
	}
};
static_assert(alignof(UJackGameFlagListBase) == 0x000008, "Wrong alignment on UJackGameFlagListBase");
static_assert(sizeof(UJackGameFlagListBase) == 0x000038, "Wrong size on UJackGameFlagListBase");

// Class JackGame.JackGameFlagListByMapInfo
// 0x0008 (0x0040 - 0x0038)
class UJackGameFlagListByMapInfo final : public UJackGameFlagListBase
{
public:
	class UDataTable*                             MapInfoDataTable;                                  // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagListByMapInfo">();
	}
	static class UJackGameFlagListByMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagListByMapInfo>();
	}
};
static_assert(alignof(UJackGameFlagListByMapInfo) == 0x000008, "Wrong alignment on UJackGameFlagListByMapInfo");
static_assert(sizeof(UJackGameFlagListByMapInfo) == 0x000040, "Wrong size on UJackGameFlagListByMapInfo");
static_assert(offsetof(UJackGameFlagListByMapInfo, MapInfoDataTable) == 0x000038, "Member 'UJackGameFlagListByMapInfo::MapInfoDataTable' has a wrong offset!");

// Class JackGame.JackActionExec_SwitchStance
// 0x0010 (0x08F0 - 0x08E0)
class AJackActionExec_SwitchStance final : public AJackActionExec
{
public:
	class FName                                   LocatorTagName;                                    // 0x08D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class AActor*>                         SwitchStanceLocators;                              // 0x08E0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyTroopLocations(const struct FVector& InMonsterTroop, const struct FVector& InPlayerTroop);
	void OnPlayActionExec();

	class AActor* GetSwitchLocator(class FName InTagName) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_SwitchStance">();
	}
	static class AJackActionExec_SwitchStance* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_SwitchStance>();
	}
};
static_assert(alignof(AJackActionExec_SwitchStance) == 0x000010, "Wrong alignment on AJackActionExec_SwitchStance");
static_assert(sizeof(AJackActionExec_SwitchStance) == 0x0008F0, "Wrong size on AJackActionExec_SwitchStance");
static_assert(offsetof(AJackActionExec_SwitchStance, LocatorTagName) == 0x0008D8, "Member 'AJackActionExec_SwitchStance::LocatorTagName' has a wrong offset!");
static_assert(offsetof(AJackActionExec_SwitchStance, SwitchStanceLocators) == 0x0008E0, "Member 'AJackActionExec_SwitchStance::SwitchStanceLocators' has a wrong offset!");

// Class JackGame.JackActionExec_TenkiYohou
// 0x0000 (0x08E0 - 0x08E0)
class AJackActionExec_TenkiYohou final : public AJackActionExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionExec_TenkiYohou">();
	}
	static class AJackActionExec_TenkiYohou* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionExec_TenkiYohou>();
	}
};
static_assert(alignof(AJackActionExec_TenkiYohou) == 0x000010, "Wrong alignment on AJackActionExec_TenkiYohou");
static_assert(sizeof(AJackActionExec_TenkiYohou) == 0x0008E0, "Wrong size on AJackActionExec_TenkiYohou");

// Class JackGame.JackUMGVoiceDrama
// 0x0498 (0x0808 - 0x0370)
class UJackUMGVoiceDrama final : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   VoiceDramaEventBPDelegate;                         // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   VoiceDramaTagEventBPDelegate;                      // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x410];                                    // 0x0390(0x0410)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterFadeSeconds;                              // 0x07A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterFeedSeconds;                              // 0x07A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharacterFeedRatio;                                // 0x07A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TalkerFadeSeconds;                                 // 0x07AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PageFadeSeconds;                                   // 0x07B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B4[0x4];                                      // 0x07B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpaceHeight;                                       // 0x07B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FastForwardFadeSeconds;                            // 0x07C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastForwardPageFadeSeconds;                        // 0x07C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FastForwardRatio;                                  // 0x07C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LogModeRatio;                                      // 0x07CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BGFadeSeconds;                                     // 0x07D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ImageFadeSeconds;                                  // 0x07D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BGMFadeSeconds;                                    // 0x07D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EnvFadeSeconds;                                    // 0x07DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_0_Short;                               // 0x07E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_1_Normal;                              // 0x07E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_2_Long;                                // 0x07E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_3_VeryLong;                            // 0x07EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_4_VeryVeryLong;                        // 0x07F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_5_VeryVeryVeryLong;                    // 0x07F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeSeconds_6_ImpossibleLong;                      // 0x07F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         StaffRollFadeSeconds;                              // 0x07FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundFadeSeconds;                                  // 0x0800(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          CurrentVoiceDramaCancelButtonChange;               // 0x0804(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_805[0x3];                                      // 0x0805(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeState(EJackVoiceDramaMode InMode);
	bool CheckInterruptionData(bool bInUseInterruption, int32* OutPage, int32* OutIndex);
	void ClearPage();
	bool DecrementLogPage(bool bInCurrentBottom);
	bool DecrementLogUnit();
	void DisableFastForward(bool bInDisable);
	void DisableInput(bool bInDisable);
	void EndPage();
	void EndVoiceDrama(bool bInInterruption);
	void ExecFootTag();
	void FinishMenu();
	class FString GetAssetName(const class FString& InAssetPath);
	int32 GetCurrentIndex();
	int32 GetCurrentLogIndex();
	int32 GetCurrentLogPage();
	int32 GetCurrentPage();
	float GetFastForwardRatio();
	float GetLogModeRatio();
	int32 GetMaxPageNum();
	EJackVoiceDramaMode GetMode();
	int32 GetReadMaxPage();
	class FString GetScenarioTitle();
	struct FJackDataTableVoiceDrama GetUnitData(int32 InIndex);
	bool HasStaffRoll();
	bool IncrementLogPage();
	bool IncrementLogUnit();
	void InputDelegate(struct FJackUIInputDelegateInfo* InDelegateInfo);
	bool IsDisableFastForward();
	bool IsDisableInput();
	bool IsFastBackward();
	bool IsFastForward();
	bool IsFeedEnd();
	bool IsPauseVoiceDrama();
	bool IsPauseVoiceDramaPurpose(EJackVoiceDramaPausePurpose InPausePurpose);
	bool IsPauseVoiceDramaTag();
	void JackUMGVoiceDramaEventBPDelegate__DelegateSignature(EJackVoiceDramaEvent EventType);
	void JackUMGVoiceDramaTagEventBPDelegate__DelegateSignature(EJackVoiceDramaTagEvent EventType, const struct FJackVoiceDramaTagData& TagData);
	void LogModeCancel();
	void PauseBGM();
	void PauseVoiceDrama(EJackVoiceDramaPausePurpose InPausePurpose);
	void PauseVoiceDramaTag(EJackVoiceDramaPausePurpose InPausePurpose);
	void RequestTextFade(float InFadeTime, bool InFadeIn);
	void RestartVoiceDrama(EJackVoiceDramaPausePurpose InPausePurpose);
	void RestartVoiceDramaTag(EJackVoiceDramaPausePurpose InPausePurpose);
	void ResumeBGM();
	void ReturnTagStatus(int32 InPage, int32 InIndex, bool bInToHead, bool bInNoWait);
	void SetTextOpacity(float InOpacity);
	void SetupEpisodeData(int32 InScenarioID);
	void SetupMenu();
	void SetupPageData(int32 InPage);
	void SetupScreenShotSetting();
	void StartPage(int32 InPage, int32 InIndex, bool bInBackward, bool bInTagArraySetup);
	bool StartTitle(bool bInUseInterruption);
	void StartVoiceDrama(bool bInUseInterruption, int32 InPage, int32 InIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGVoiceDrama">();
	}
	static class UJackUMGVoiceDrama* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGVoiceDrama>();
	}
};
static_assert(alignof(UJackUMGVoiceDrama) == 0x000008, "Wrong alignment on UJackUMGVoiceDrama");
static_assert(sizeof(UJackUMGVoiceDrama) == 0x000808, "Wrong size on UJackUMGVoiceDrama");
static_assert(offsetof(UJackUMGVoiceDrama, VoiceDramaEventBPDelegate) == 0x000370, "Member 'UJackUMGVoiceDrama::VoiceDramaEventBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, VoiceDramaTagEventBPDelegate) == 0x000380, "Member 'UJackUMGVoiceDrama::VoiceDramaTagEventBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, CharacterFadeSeconds) == 0x0007A0, "Member 'UJackUMGVoiceDrama::CharacterFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, CharacterFeedSeconds) == 0x0007A4, "Member 'UJackUMGVoiceDrama::CharacterFeedSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, CharacterFeedRatio) == 0x0007A8, "Member 'UJackUMGVoiceDrama::CharacterFeedRatio' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, TalkerFadeSeconds) == 0x0007AC, "Member 'UJackUMGVoiceDrama::TalkerFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, PageFadeSeconds) == 0x0007B0, "Member 'UJackUMGVoiceDrama::PageFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, SpaceHeight) == 0x0007B8, "Member 'UJackUMGVoiceDrama::SpaceHeight' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FastForwardFadeSeconds) == 0x0007C0, "Member 'UJackUMGVoiceDrama::FastForwardFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FastForwardPageFadeSeconds) == 0x0007C4, "Member 'UJackUMGVoiceDrama::FastForwardPageFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FastForwardRatio) == 0x0007C8, "Member 'UJackUMGVoiceDrama::FastForwardRatio' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, LogModeRatio) == 0x0007CC, "Member 'UJackUMGVoiceDrama::LogModeRatio' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, BGFadeSeconds) == 0x0007D0, "Member 'UJackUMGVoiceDrama::BGFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, ImageFadeSeconds) == 0x0007D4, "Member 'UJackUMGVoiceDrama::ImageFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, BGMFadeSeconds) == 0x0007D8, "Member 'UJackUMGVoiceDrama::BGMFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, EnvFadeSeconds) == 0x0007DC, "Member 'UJackUMGVoiceDrama::EnvFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_0_Short) == 0x0007E0, "Member 'UJackUMGVoiceDrama::FadeSeconds_0_Short' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_1_Normal) == 0x0007E4, "Member 'UJackUMGVoiceDrama::FadeSeconds_1_Normal' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_2_Long) == 0x0007E8, "Member 'UJackUMGVoiceDrama::FadeSeconds_2_Long' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_3_VeryLong) == 0x0007EC, "Member 'UJackUMGVoiceDrama::FadeSeconds_3_VeryLong' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_4_VeryVeryLong) == 0x0007F0, "Member 'UJackUMGVoiceDrama::FadeSeconds_4_VeryVeryLong' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_5_VeryVeryVeryLong) == 0x0007F4, "Member 'UJackUMGVoiceDrama::FadeSeconds_5_VeryVeryVeryLong' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, FadeSeconds_6_ImpossibleLong) == 0x0007F8, "Member 'UJackUMGVoiceDrama::FadeSeconds_6_ImpossibleLong' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, StaffRollFadeSeconds) == 0x0007FC, "Member 'UJackUMGVoiceDrama::StaffRollFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, SoundFadeSeconds) == 0x000800, "Member 'UJackUMGVoiceDrama::SoundFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDrama, CurrentVoiceDramaCancelButtonChange) == 0x000804, "Member 'UJackUMGVoiceDrama::CurrentVoiceDramaCancelButtonChange' has a wrong offset!");

// Class JackGame.JackTask
// 0x0008 (0x0040 - 0x0038)
class UJackTask : public UObject
{
public:
	int32                                         Scene;                                             // 0x0038(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SceneTime;                                         // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTask">();
	}
	static class UJackTask* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTask>();
	}
};
static_assert(alignof(UJackTask) == 0x000008, "Wrong alignment on UJackTask");
static_assert(sizeof(UJackTask) == 0x000040, "Wrong size on UJackTask");
static_assert(offsetof(UJackTask, Scene) == 0x000038, "Member 'UJackTask::Scene' has a wrong offset!");
static_assert(offsetof(UJackTask, SceneTime) == 0x00003C, "Member 'UJackTask::SceneTime' has a wrong offset!");

// Class JackGame.JackTaskActionHitExec
// 0x0030 (0x0070 - 0x0040)
class UJackTaskActionHitExec final : public UJackTask
{
public:
	TWeakObjectPtr<class UJackGameCharacter>      CasterGameCharacter;                               // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackActionEffect>       ActionEffect;                                      // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HitGroupCount;                                     // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackActionHitCharacterInfo>    HitCharacterInfos;                                 // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         CurrentHitCount;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HitInterval;                                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTaskActionHitExec">();
	}
	static class UJackTaskActionHitExec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTaskActionHitExec>();
	}
};
static_assert(alignof(UJackTaskActionHitExec) == 0x000008, "Wrong alignment on UJackTaskActionHitExec");
static_assert(sizeof(UJackTaskActionHitExec) == 0x000070, "Wrong size on UJackTaskActionHitExec");
static_assert(offsetof(UJackTaskActionHitExec, CasterGameCharacter) == 0x000040, "Member 'UJackTaskActionHitExec::CasterGameCharacter' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, ActionEffect) == 0x000048, "Member 'UJackTaskActionHitExec::ActionEffect' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, HitGroupCount) == 0x000050, "Member 'UJackTaskActionHitExec::HitGroupCount' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, bInitialized) == 0x000054, "Member 'UJackTaskActionHitExec::bInitialized' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, HitCharacterInfos) == 0x000058, "Member 'UJackTaskActionHitExec::HitCharacterInfos' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, CurrentHitCount) == 0x000068, "Member 'UJackTaskActionHitExec::CurrentHitCount' has a wrong offset!");
static_assert(offsetof(UJackTaskActionHitExec, HitInterval) == 0x00006C, "Member 'UJackTaskActionHitExec::HitInterval' has a wrong offset!");

// Class JackGame.JackSkipSuspendTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSkipSuspendTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipSuspendTrack">();
	}
	static class UJackSkipSuspendTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipSuspendTrack>();
	}
};
static_assert(alignof(UJackSkipSuspendTrack) == 0x000008, "Wrong alignment on UJackSkipSuspendTrack");
static_assert(sizeof(UJackSkipSuspendTrack) == 0x0000A8, "Wrong size on UJackSkipSuspendTrack");

// Class JackGame.JackFacialPresetTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackFacialPresetTrack final : public UInterpTrack
{
public:
	class UDataTable*                             PresetTable;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackFacialPresetTrackKey>      KeyArray;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFacialPresetTrack">();
	}
	static class UJackFacialPresetTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFacialPresetTrack>();
	}
};
static_assert(alignof(UJackFacialPresetTrack) == 0x000008, "Wrong alignment on UJackFacialPresetTrack");
static_assert(sizeof(UJackFacialPresetTrack) == 0x0000A8, "Wrong size on UJackFacialPresetTrack");
static_assert(offsetof(UJackFacialPresetTrack, PresetTable) == 0x000090, "Member 'UJackFacialPresetTrack::PresetTable' has a wrong offset!");
static_assert(offsetof(UJackFacialPresetTrack, KeyArray) == 0x000098, "Member 'UJackFacialPresetTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackParameterUpdater
// 0x00A8 (0x00E0 - 0x0038)
class UJackParameterUpdater : public UObject
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParameterUpdater">();
	}
	static class UJackParameterUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParameterUpdater>();
	}
};
static_assert(alignof(UJackParameterUpdater) == 0x000008, "Wrong alignment on UJackParameterUpdater");
static_assert(sizeof(UJackParameterUpdater) == 0x0000E0, "Wrong size on UJackParameterUpdater");

// Class JackGame.JackParameterUpdaterCurve
// 0x0040 (0x0120 - 0x00E0)
class UJackParameterUpdaterCurve final : public UJackParameterUpdater
{
public:
	uint8                                         Pad_E0[0x40];                                      // 0x00E0(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParameterUpdaterCurve">();
	}
	static class UJackParameterUpdaterCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParameterUpdaterCurve>();
	}
};
static_assert(alignof(UJackParameterUpdaterCurve) == 0x000008, "Wrong alignment on UJackParameterUpdaterCurve");
static_assert(sizeof(UJackParameterUpdaterCurve) == 0x000120, "Wrong size on UJackParameterUpdaterCurve");

// Class JackGame.JackUMGVoiceDramaHDPafuPafu
// 0x00D8 (0x0448 - 0x0370)
class UJackUMGVoiceDramaHDPafuPafu final : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   VoiceDramaHDPafuPafuCrossFadeBPDelegate;           // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   VoiceDramaHDPafuPafuShakeLeftBPDelegate;           // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   VoiceDramaHDPafuPafuShakeRightBPDelegate;          // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x38];                                     // 0x03A0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackVoiceDramaHDPafuPafuTargetNPC> NPCDataArray;                                      // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIsSetup;                                          // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsControllerDumped;                               // 0x03E9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3EA[0x2];                                      // 0x03EA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialChangeSpeed;                                 // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WaitVoicePlayTimer;                                // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeAnimationSpeed;                               // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ShakeAnimationMaxHeight;                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VoiceDistance;                                     // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PafuunVerticalNum;                                 // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PafuunHorizontalNum;                               // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PafuunLowScale;                                    // 0x0408(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PafuunHighScale;                                   // 0x0410(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PafuunMostHighScale;                               // 0x0418(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AJackPafuPafuMode*                      HDManager;                                         // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackVoiceDramaHDTutorial              TutorialData;                                      // 0x0430(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsTutorial;                                       // 0x0440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitVoicePlayTimerTutorial;                        // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BindWaitVoice();
	void ChangeImageBeforeAndAfter(const TArray<class UImage*>& ImageArray, int32 NPCIndex, EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	void ChangeImageOrder(const TArray<class UImage*>& ImageArray, class UTexture2D* ForwardTexture, class UTexture2D* BackwardTexture);
	void ClosePafuPafu();
	void ClosePafuPafuEvent();
	void CopyDataTableStatus();
	void FinishHDPafuPafu();
	TArray<class UImage*> GetNPCImageArray(EJackVoiceDramaHDPafuPafuLeftRight InLeftRight);
	TArray<struct FVector2D> GetPafuunRegionArray(const class UImage* Image, int32 DivX, int32 DivY, float OffsetX, float OffsetY);
	EJackVoiceDramaHDPafuPafuJoyConPower GetPinInsertJoyConPower(const EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	EJackVoiceDramaHDPafuPafuLeftRight GetPinInsertLeftRight(const EJackVoiceDramaHDPafuPafuLeftRight InLeftRight);
	int32 GetRandomPafuunRegionIndex(const TArray<struct FVector2D>& RegionArray, int32 PreviousRegionIndex);
	void InitBackgroundImage(class UImage* Image);
	void InitRoundImage(const TArray<class UImage*>& ImageArray, int32 NPCIndex);
	EJackVoiceDramaHDPafuPafuWhatRound IntegerToWhatRound(int32 InRound);
	void JackUMGVoiceDramaHDPafuPafuCrossFadeBPDelegate__DelegateSignature(EJackVoiceDramaHDPafuPafuLeftRight EventType);
	void JackUMGVoiceDramaHDPafuPafuShakeLeftBPDelegate__DelegateSignature(EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	void JackUMGVoiceDramaHDPafuPafuShakeRightBPDelegate__DelegateSignature(EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	void KnockoutNPC(class UImage* Image, class UImage* ImageBack, int32 NPCIndex);
	void KnockoutNPCAll();
	bool NPCDamage(int32 NPCIndex);
	void NPCFacialDamage(int32 NPCIndex, bool* bFacialChange, bool* bKnockout);
	void PlayImageShakeDelegate(const EJackVoiceDramaHDPafuPafuLeftRight InLeftRight, const EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	bool PlaySoundSE(const class FName& SoundLabelID, const int32 InLeftRightInteger);
	bool ProgressCountTutorial();
	bool SelectRequestVoice(const EJackVoiceDramaHDPafuPafuVoiceTag InVoiceTag, int32 NPCIndex, const EJackVoiceDramaHDPafuPafuJoyConPower InJoyConPower);
	bool SelectRequestVoiceTutorial(const EJackVoiceDramaHDPafuPafuVoiceTagTutorial InVoiceTag);
	void SetImageFade(class UImage* Image, class UImage* ImageBack, int32 NPCIndex);
	void SetImageShake(int32 NPCIndex);
	void SetJoyConMotorReactFlagAll(bool bIsMotorReact);
	void SetNPCData(struct FJackVoiceDramaHDPafuPafuTargetNPC* OutNPC, const EJackVoiceDramaHDPafuPafuWhatRound& InRound, const EJackVoiceDramaHDPafuPafuLeftRight InLeftRight);
	void SetNPCDataArray(const TArray<struct FJackVoiceDramaHDPafuPafuTargetNPC>& InNPCDataArray);
	void SetNPCShakeFlag(int32 NPCIndex, bool bIsShakeSetter);
	void SetRound(EJackVoiceDramaHDPafuPafuWhatRound InRound);
	void SetupHDPafuPafu();
	void SetupRound(const EJackVoiceDramaHDPafuPafuWhatRound& InRound);
	void SetupTutorial();
	void ShakePS4Controller(EJackVoiceDramaHDPafuPafuJoyConPower InStrength);
	void StartCountDown();
	void StartCountDownEvent();
	void StartTutorial();
	void StartTutorialEvent();
	void UnBindWaitVoice();

	ESlateVisibility DebugDoonEnable() const;
	class UTexture2D* Get3rdNetabareBackgroundTexture() const;
	class UTexture2D* GetNextFacialPath(int32 NPCIndex, int32 AddIndex) const;
	EJackVoiceDramaHDPafuPafuVoiceTag GetPafuPafuOrKnockoutVoice(int32 NPCIndex) const;
	class UAudioComponent* GetPlayingAudioComponent(int32 NPCIndex) const;
	class UAudioComponent* GetPlayingAudioComponentTutorial() const;
	EJackVoiceDramaHDPafuPafuWhatRound GetRound() const;
	class UTexture2D* GetRoundNetabareBackgroundTexture(const EJackVoiceDramaHDPafuPafuWhatRound InRound) const;
	EJackVoiceDramaHDPafuPafuJoyConPower IntegerToJoyConPower(int32 InJoyConPower) const;
	EJackVoiceDramaHDPafuPafuLeftRight IntegerToLeftRight(int32 No) const;
	bool IsFacialFade(int32 NPCIndex) const;
	bool IsKnockout(int32 NPCIndex) const;
	bool IsNotShipping() const;
	bool IsShake(int32 NPCIndex) const;
	int32 JoyConPowerToInteger(EJackVoiceDramaHDPafuPafuJoyConPower Power) const;
	int32 LeftRightToInteger(const EJackVoiceDramaHDPafuPafuLeftRight& InLeftRight) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGVoiceDramaHDPafuPafu">();
	}
	static class UJackUMGVoiceDramaHDPafuPafu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGVoiceDramaHDPafuPafu>();
	}
};
static_assert(alignof(UJackUMGVoiceDramaHDPafuPafu) == 0x000008, "Wrong alignment on UJackUMGVoiceDramaHDPafuPafu");
static_assert(sizeof(UJackUMGVoiceDramaHDPafuPafu) == 0x000448, "Wrong size on UJackUMGVoiceDramaHDPafuPafu");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, VoiceDramaHDPafuPafuCrossFadeBPDelegate) == 0x000370, "Member 'UJackUMGVoiceDramaHDPafuPafu::VoiceDramaHDPafuPafuCrossFadeBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, VoiceDramaHDPafuPafuShakeLeftBPDelegate) == 0x000380, "Member 'UJackUMGVoiceDramaHDPafuPafu::VoiceDramaHDPafuPafuShakeLeftBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, VoiceDramaHDPafuPafuShakeRightBPDelegate) == 0x000390, "Member 'UJackUMGVoiceDramaHDPafuPafu::VoiceDramaHDPafuPafuShakeRightBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, NPCDataArray) == 0x0003D8, "Member 'UJackUMGVoiceDramaHDPafuPafu::NPCDataArray' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, bIsSetup) == 0x0003E8, "Member 'UJackUMGVoiceDramaHDPafuPafu::bIsSetup' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, bIsControllerDumped) == 0x0003E9, "Member 'UJackUMGVoiceDramaHDPafuPafu::bIsControllerDumped' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, FacialChangeSpeed) == 0x0003EC, "Member 'UJackUMGVoiceDramaHDPafuPafu::FacialChangeSpeed' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, WaitVoicePlayTimer) == 0x0003F0, "Member 'UJackUMGVoiceDramaHDPafuPafu::WaitVoicePlayTimer' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, ShakeAnimationSpeed) == 0x0003F4, "Member 'UJackUMGVoiceDramaHDPafuPafu::ShakeAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, ShakeAnimationMaxHeight) == 0x0003F8, "Member 'UJackUMGVoiceDramaHDPafuPafu::ShakeAnimationMaxHeight' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, VoiceDistance) == 0x0003FC, "Member 'UJackUMGVoiceDramaHDPafuPafu::VoiceDistance' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, PafuunVerticalNum) == 0x000400, "Member 'UJackUMGVoiceDramaHDPafuPafu::PafuunVerticalNum' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, PafuunHorizontalNum) == 0x000404, "Member 'UJackUMGVoiceDramaHDPafuPafu::PafuunHorizontalNum' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, PafuunLowScale) == 0x000408, "Member 'UJackUMGVoiceDramaHDPafuPafu::PafuunLowScale' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, PafuunHighScale) == 0x000410, "Member 'UJackUMGVoiceDramaHDPafuPafu::PafuunHighScale' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, PafuunMostHighScale) == 0x000418, "Member 'UJackUMGVoiceDramaHDPafuPafu::PafuunMostHighScale' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, HDManager) == 0x000420, "Member 'UJackUMGVoiceDramaHDPafuPafu::HDManager' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, TutorialData) == 0x000430, "Member 'UJackUMGVoiceDramaHDPafuPafu::TutorialData' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, bIsTutorial) == 0x000440, "Member 'UJackUMGVoiceDramaHDPafuPafu::bIsTutorial' has a wrong offset!");
static_assert(offsetof(UJackUMGVoiceDramaHDPafuPafu, WaitVoicePlayTimerTutorial) == 0x000444, "Member 'UJackUMGVoiceDramaHDPafuPafu::WaitVoicePlayTimerTutorial' has a wrong offset!");

// Class JackGame.JackActionHitManager
// 0x0028 (0x0060 - 0x0038)
class UJackActionHitManager final : public UObject
{
public:
	class UJackTaskHolder*                        ActionHitExecTaskHolder;                           // 0x0038(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionHitManager">();
	}
	static class UJackActionHitManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionHitManager>();
	}
};
static_assert(alignof(UJackActionHitManager) == 0x000008, "Wrong alignment on UJackActionHitManager");
static_assert(sizeof(UJackActionHitManager) == 0x000060, "Wrong size on UJackActionHitManager");
static_assert(offsetof(UJackActionHitManager, ActionHitExecTaskHolder) == 0x000038, "Member 'UJackActionHitManager::ActionHitExecTaskHolder' has a wrong offset!");

// Class JackGame.JackActionManager
// 0x00B0 (0x0448 - 0x0398)
class AJackActionManager : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackActionMessageManager*              ActionMessageManager;                              // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackActionHitManager*                  ActionHitManager;                                  // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackActionNakamaYobiManager*           ActionNakamaYobiManager;                           // 0x03B0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AJackActionExec*>                ActionExecs;                                       // 0x03B8(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class AJackActionSecondCheck*                 SecondCheck;                                       // 0x03C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 SecondCheckClass;                                  // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackActionAIEvaluateScoreCheck*        ScoreCheck;                                        // 0x03D8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 ScoreCheckClass;                                   // 0x03E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<class FName, class UJackStreamObjectsHolder*> ActionResourceCache;                               // 0x03E8(0x0050)(Edit, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UJackActionPreviewExec*>         ActionPreviewExecs;                                // 0x0438(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static bool CalcFirstCheckBP(const class UJackGameCharacter* Caster, struct FJackActionData& ActionData, EJackBattleIntelligenceType IntelligenceType);
	static float CalcScoreCheckBP(const class FName& RenkeiID, EJackPlayerAIActionControl ActionContrlType, struct FJackActionData& ActionData, const struct FJackActionScoreResult& ActionScoreResult, const class FName& ScoreCheckID, const class UJackGameCharacter* CasterGameCharacter, const TArray<class FName>& CasterActionHistory, const class UJackGameCharacter* TargetGameCharacter);
	static bool CalcSecondCheckBP(const class UJackGameCharacter* CasterGameCharacter, const class UJackGameCharacter* TargetGameCharacter, struct FJackActionData& ActionData, EJackBattleIntelligenceType IntelligenceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionManager">();
	}
	static class AJackActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionManager>();
	}
};
static_assert(alignof(AJackActionManager) == 0x000008, "Wrong alignment on AJackActionManager");
static_assert(sizeof(AJackActionManager) == 0x000448, "Wrong size on AJackActionManager");
static_assert(offsetof(AJackActionManager, ActionMessageManager) == 0x0003A0, "Member 'AJackActionManager::ActionMessageManager' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ActionHitManager) == 0x0003A8, "Member 'AJackActionManager::ActionHitManager' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ActionNakamaYobiManager) == 0x0003B0, "Member 'AJackActionManager::ActionNakamaYobiManager' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ActionExecs) == 0x0003B8, "Member 'AJackActionManager::ActionExecs' has a wrong offset!");
static_assert(offsetof(AJackActionManager, SecondCheck) == 0x0003C8, "Member 'AJackActionManager::SecondCheck' has a wrong offset!");
static_assert(offsetof(AJackActionManager, SecondCheckClass) == 0x0003D0, "Member 'AJackActionManager::SecondCheckClass' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ScoreCheck) == 0x0003D8, "Member 'AJackActionManager::ScoreCheck' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ScoreCheckClass) == 0x0003E0, "Member 'AJackActionManager::ScoreCheckClass' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ActionResourceCache) == 0x0003E8, "Member 'AJackActionManager::ActionResourceCache' has a wrong offset!");
static_assert(offsetof(AJackActionManager, ActionPreviewExecs) == 0x000438, "Member 'AJackActionManager::ActionPreviewExecs' has a wrong offset!");

// Class JackGame.JackEyeCloseRateTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackEyeCloseRateTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEyeCloseRateTrack">();
	}
	static class UJackEyeCloseRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEyeCloseRateTrack>();
	}
};
static_assert(alignof(UJackEyeCloseRateTrack) == 0x000008, "Wrong alignment on UJackEyeCloseRateTrack");
static_assert(sizeof(UJackEyeCloseRateTrack) == 0x0000B0, "Wrong size on UJackEyeCloseRateTrack");

// Class JackGame.JackActionMessageManager
// 0x0060 (0x0098 - 0x0038)
class UJackActionMessageManager final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackBattlePlayerController> BattlePlayerController;                            // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UJackActionMessageInfo*>         MessageInfoQueue;                                  // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	class UJackActionMessageInfo*                 CurrentMessageInfo;                                // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         CurrentMessagePlayRemainTime;                      // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MessagePlayTime;                                   // 0x0064(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCloseRequest;                                     // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Scene;                                             // 0x006C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SceneTime;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMessageSkip;                                      // 0x0074(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_75[0x3];                                       // 0x0075(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TextKeepTime;                                      // 0x0078(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TextMinTime;                                       // 0x007C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 ConsumeMP0Message;                                 // 0x0080(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsBattleTurnStart;                                // 0x0090(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionMessageManager">();
	}
	static class UJackActionMessageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionMessageManager>();
	}
};
static_assert(alignof(UJackActionMessageManager) == 0x000008, "Wrong alignment on UJackActionMessageManager");
static_assert(sizeof(UJackActionMessageManager) == 0x000098, "Wrong size on UJackActionMessageManager");
static_assert(offsetof(UJackActionMessageManager, BattlePlayerController) == 0x000040, "Member 'UJackActionMessageManager::BattlePlayerController' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, MessageInfoQueue) == 0x000048, "Member 'UJackActionMessageManager::MessageInfoQueue' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, CurrentMessageInfo) == 0x000058, "Member 'UJackActionMessageManager::CurrentMessageInfo' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, CurrentMessagePlayRemainTime) == 0x000060, "Member 'UJackActionMessageManager::CurrentMessagePlayRemainTime' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, MessagePlayTime) == 0x000064, "Member 'UJackActionMessageManager::MessagePlayTime' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, bCloseRequest) == 0x000068, "Member 'UJackActionMessageManager::bCloseRequest' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, Scene) == 0x00006C, "Member 'UJackActionMessageManager::Scene' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, SceneTime) == 0x000070, "Member 'UJackActionMessageManager::SceneTime' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, bMessageSkip) == 0x000074, "Member 'UJackActionMessageManager::bMessageSkip' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, TextKeepTime) == 0x000078, "Member 'UJackActionMessageManager::TextKeepTime' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, TextMinTime) == 0x00007C, "Member 'UJackActionMessageManager::TextMinTime' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, ConsumeMP0Message) == 0x000080, "Member 'UJackActionMessageManager::ConsumeMP0Message' has a wrong offset!");
static_assert(offsetof(UJackActionMessageManager, bIsBattleTurnStart) == 0x000090, "Member 'UJackActionMessageManager::bIsBattleTurnStart' has a wrong offset!");

// Class JackGame.JackActionNakamaYobiManager
// 0x0050 (0x0088 - 0x0038)
class UJackActionNakamaYobiManager final : public UObject
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionNakamaYobiManager">();
	}
	static class UJackActionNakamaYobiManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionNakamaYobiManager>();
	}
};
static_assert(alignof(UJackActionNakamaYobiManager) == 0x000008, "Wrong alignment on UJackActionNakamaYobiManager");
static_assert(sizeof(UJackActionNakamaYobiManager) == 0x000088, "Wrong size on UJackActionNakamaYobiManager");

// Class JackGame.JackSlotUtils
// 0x0000 (0x0038 - 0x0038)
class UJackSlotUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSlotUtils">();
	}
	static class UJackSlotUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSlotUtils>();
	}
};
static_assert(alignof(UJackSlotUtils) == 0x000008, "Wrong alignment on UJackSlotUtils");
static_assert(sizeof(UJackSlotUtils) == 0x000038, "Wrong size on UJackSlotUtils");

// Class JackGame.JackFieldPlayerNakamaKaiwaController
// 0x0020 (0x03B8 - 0x0398)
class AJackFieldPlayerNakamaKaiwaController final : public AActor
{
public:
	uint8                                         Pad_398[0x20];                                     // 0x0398(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFieldPlayerNakamaKaiwaController">();
	}
	static class AJackFieldPlayerNakamaKaiwaController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFieldPlayerNakamaKaiwaController>();
	}
};
static_assert(alignof(AJackFieldPlayerNakamaKaiwaController) == 0x000008, "Wrong alignment on AJackFieldPlayerNakamaKaiwaController");
static_assert(sizeof(AJackFieldPlayerNakamaKaiwaController) == 0x0003B8, "Wrong size on AJackFieldPlayerNakamaKaiwaController");

// Class JackGame.JackTickableGameObject
// 0x0018 (0x0050 - 0x0038)
class UJackTickableGameObject : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAutoDestroyWhenFinished;                          // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDestoryUObject;                              // 0x0041(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeSpan;                                          // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTickableGameObject">();
	}
	static class UJackTickableGameObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTickableGameObject>();
	}
};
static_assert(alignof(UJackTickableGameObject) == 0x000008, "Wrong alignment on UJackTickableGameObject");
static_assert(sizeof(UJackTickableGameObject) == 0x000050, "Wrong size on UJackTickableGameObject");
static_assert(offsetof(UJackTickableGameObject, bAutoDestroyWhenFinished) == 0x000040, "Member 'UJackTickableGameObject::bAutoDestroyWhenFinished' has a wrong offset!");
static_assert(offsetof(UJackTickableGameObject, bForceDestoryUObject) == 0x000041, "Member 'UJackTickableGameObject::bForceDestoryUObject' has a wrong offset!");
static_assert(offsetof(UJackTickableGameObject, LifeSpan) == 0x000044, "Member 'UJackTickableGameObject::LifeSpan' has a wrong offset!");

// Class JackGame.JackActionPreviewExec
// 0x0340 (0x0390 - 0x0050)
class UJackActionPreviewExec final : public UJackTickableGameObject
{
public:
	int32                                         PreviewSceneID;                                    // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJackGameCharacter>      PreviewCasterGameCharacter;                        // 0x0054(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionSlot                        PreviewActionSlot;                                 // 0x0060(0x0040)(Edit, DisableEditOnTemplate, Transient, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   PreviewActionID;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x8];                                       // 0x00A8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionPlayParam                   PreviewActionPlayParam;                            // 0x00B0(0x0290)(Edit, DisableEditOnTemplate, Transient, NativeAccessSpecifierPrivate)
	class UJackStreamObjectsHolder*               PreviewActionResourceHolder;                       // 0x0340(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPreviewActionMotionLoadComplete;                  // 0x0348(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_349[0x47];                                     // 0x0349(0x0047)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionPreviewExec">();
	}
	static class UJackActionPreviewExec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionPreviewExec>();
	}
};
static_assert(alignof(UJackActionPreviewExec) == 0x000010, "Wrong alignment on UJackActionPreviewExec");
static_assert(sizeof(UJackActionPreviewExec) == 0x000390, "Wrong size on UJackActionPreviewExec");
static_assert(offsetof(UJackActionPreviewExec, PreviewSceneID) == 0x000050, "Member 'UJackActionPreviewExec::PreviewSceneID' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, PreviewCasterGameCharacter) == 0x000054, "Member 'UJackActionPreviewExec::PreviewCasterGameCharacter' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, PreviewActionSlot) == 0x000060, "Member 'UJackActionPreviewExec::PreviewActionSlot' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, PreviewActionID) == 0x0000A0, "Member 'UJackActionPreviewExec::PreviewActionID' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, PreviewActionPlayParam) == 0x0000B0, "Member 'UJackActionPreviewExec::PreviewActionPlayParam' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, PreviewActionResourceHolder) == 0x000340, "Member 'UJackActionPreviewExec::PreviewActionResourceHolder' has a wrong offset!");
static_assert(offsetof(UJackActionPreviewExec, bPreviewActionMotionLoadComplete) == 0x000348, "Member 'UJackActionPreviewExec::bPreviewActionMotionLoadComplete' has a wrong offset!");

// Class JackGame.JackFootIKTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackFootIKTrack final : public UJackToggleBaseTrack
{
public:
	bool                                          bIsKeepFootLock;                                   // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFootIKTrack">();
	}
	static class UJackFootIKTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFootIKTrack>();
	}
};
static_assert(alignof(UJackFootIKTrack) == 0x000008, "Wrong alignment on UJackFootIKTrack");
static_assert(sizeof(UJackFootIKTrack) == 0x0000B0, "Wrong size on UJackFootIKTrack");
static_assert(offsetof(UJackFootIKTrack, bIsKeepFootLock) == 0x0000A8, "Member 'UJackFootIKTrack::bIsKeepFootLock' has a wrong offset!");

// Class JackGame.JackUMGAsyncLoadUserWidgetResult
// 0x0010 (0x0048 - 0x0038)
class UJackUMGAsyncLoadUserWidgetResult final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            LoadedWidget;                                      // 0x0040(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAsyncLoadUserWidgetResult">();
	}
	static class UJackUMGAsyncLoadUserWidgetResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAsyncLoadUserWidgetResult>();
	}
};
static_assert(alignof(UJackUMGAsyncLoadUserWidgetResult) == 0x000008, "Wrong alignment on UJackUMGAsyncLoadUserWidgetResult");
static_assert(sizeof(UJackUMGAsyncLoadUserWidgetResult) == 0x000048, "Wrong size on UJackUMGAsyncLoadUserWidgetResult");
static_assert(offsetof(UJackUMGAsyncLoadUserWidgetResult, LoadedWidget) == 0x000040, "Member 'UJackUMGAsyncLoadUserWidgetResult::LoadedWidget' has a wrong offset!");

// Class JackGame.JackActionSecondCheck
// 0x00C8 (0x0460 - 0x0398)
class AJackActionSecondCheck : public AActor
{
public:
	struct FJackActionData                        ActionData;                                        // 0x0398(0x00B0)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      CasterGameCharacter;                               // 0x0448(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      TargetGameCharacter;                               // 0x0450(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<class UJackGameCharacter*> GetEnemyCharacters(const class UJackGameCharacter* InCasterGameCharacter, bool InAliveOnly, bool InStandBy, bool InGuest, bool InMiryou);
	static TArray<class UJackGameCharacter*> GetFriendCharacters(const class UJackGameCharacter* InCasterGameCharacter, bool InAliveOnly, bool InStandBy, bool InGuest, bool InMiryou, bool InAsutoron, bool InFuzai);
	static TArray<class UJackGameCharacter*> GetFriendCharactersByBattleAI(const class UJackGameCharacter* CasterGameCharacter_0, bool bAliveOnly);
	static TArray<class UJackGameCharacter*> GetTargetCharacters(struct FJackActionData* InActionData, class UJackGameCharacter* InCasterGameCharacter, class UJackGameCharacter* InTargetGameCharacter);

	bool IsCasterHp(int32 InHp, EJackEvaluateType InHpEval);
	bool IsCasterHpRate(float InHpRate, EJackEvaluateType InHpEval);
	bool IsCasterLevelCheckOfEnemyGroup(int32 InValue, EJackEvaluateType InValueEval, bool InAliveOnly, bool InStandBy);
	bool IsCasterMp(int32 InMP, EJackEvaluateType InMpEval);
	bool IsCasterMpRate(float InMpRate, EJackEvaluateType InMpEval);
	bool IsCasterOddEffect(EJackOddEffectCategoryType InCategoryType);
	bool IsCasterOddEffectByStatus(class FName InStatusId);
	bool IsEnemyGroupeAllHpRate(float InHpRate, EJackEvaluateType InHpEval, bool InStandBy);
	bool IsEnemyGroupeAllMpRate(float InMpRate, EJackEvaluateType InMpEval, bool InStandBy);
	bool IsEnemyGroupeAllOddEffect(EJackOddEffectCategoryType InCategoryType, bool InAliveOnly, bool InStandBy);
	bool IsEnemyGroupeAllOddEffectByStatus(class FName InStatusId, bool InAliveOnly, bool InStandBy);
	bool IsEnemyGroupeHpRate(float InHpRate, EJackEvaluateType InHpEval, float InRate, EJackEvaluateType InRateEval, bool InStandBy, bool InGuest);
	bool IsEnemyGroupeOddEffect(EJackOddEffectCategoryType InCategoryType, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy);
	bool IsEnemyGroupeOddEffectByStatus(class FName InStatusId, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy);
	bool IsEnemyNumber(int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy, bool InGuest);
	bool IsEnemyNumberMonsterId(class FName InMonsterId, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy, bool InGuest);
	bool IsFriendGroupeHpRate(float InHpRate, EJackEvaluateType InHpEval, float InRate, EJackEvaluateType InRateEval, bool InStandBy, bool InGuest);
	bool IsFriendGroupeMpRate(float InHpRate, EJackEvaluateType InHpEval, float InRate, EJackEvaluateType InRateEval, bool InStandBy, bool InGuest);
	bool IsFriendGroupeOddEffect(EJackOddEffectCategoryType InCategoryType, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy);
	bool IsFriendGroupeOddEffectByStatus(class FName InStatusId, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy);
	bool IsFriendGroupeOddEffectRate(EJackOddEffectCategoryType InCategoryType, float InRate, EJackEvaluateType InRateEval, bool InAliveOnly, bool InStandBy);
	bool IsFriendGroupeOddEffectRateByStatus(class FName InStatusId, float InRate, EJackEvaluateType InRateEval, bool InAliveOnly, bool InStandBy);
	bool IsFriendNumber(int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy, bool InGuest);
	bool IsFriendNumberMonsterId(class FName InMonsterId, int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InStandBy, bool InGuest);
	bool IsMonsterNumber(int32 InCount, EJackEvaluateType InCountEval, bool InAliveOnly, bool InIsOperational, bool InIsMovementEnabled);
	bool IsNakamaYobiCostOverF();
	bool IsTargetAttributeParamRate(EJackAttributeParam InAttributeParam, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetCharacter(EJackCharacter InCharacterType);
	bool IsTargetGender(EJackGender InGenderType);
	bool IsTargetGroupeAllAttributeParamRate(EJackAttributeParam InAttributeParam, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeAllHpRate(float InHpRate, EJackEvaluateType InHpEval);
	bool IsTargetGroupeAllMpRate(float InMpRate, EJackEvaluateType InMpEval);
	bool IsTargetGroupeAllOddEffect(EJackOddEffectCategoryType InCategoryType);
	bool IsTargetGroupeAllOddEffectByStatus(class FName InStatusId);
	bool IsTargetGroupeAllOddEffectSlide(EJackOddEffectCategoryType InCategoryType, int32 InSlideRank);
	bool IsTargetGroupeHpRate(float InHpRate, EJackEvaluateType InHpEval, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeMetal(int32 InCount, EJackEvaluateType InCountEval);
	bool IsTargetGroupeMpRate(float InMpRate, EJackEvaluateType InMpEval, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeOddEffect(EJackOddEffectCategoryType InCategoryType, int32 InCount, EJackEvaluateType InCountEval);
	bool IsTargetGroupeOddEffectByStatus(class FName InStatusId, int32 InCount, EJackEvaluateType InCountEval);
	bool IsTargetGroupeOddEffectCondition(int32 InCount, EJackEvaluateType InCountEval);
	bool IsTargetGroupeOddEffectRate(EJackOddEffectCategoryType InCategoryType, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeOddEffectRateByStatus(class FName InStatusId, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeOddEffectSlideRate(EJackOddEffectCategoryType InCategoryType, int32 InSlideRank, float InRate, EJackEvaluateType InRateEval);
	bool IsTargetGroupeSoseiCostIn(int32 InCount, EJackEvaluateType InCountEval);
	bool IsTargetHp(int32 InHp, EJackEvaluateType InHpEval);
	bool IsTargetHpRate(float InHpRate, EJackEvaluateType InHpEval);
	bool IsTargetKougekiDamage(int32 InTime, EJackEvaluateType InTimeEval);
	bool IsTargetKougekiDamageF(float InTime, EJackEvaluateType InTimeEval);
	bool IsTargetMetal();
	bool IsTargetMonsterIdName(const class FString& InCheckName);
	bool IsTargetMp(int32 InMP, EJackEvaluateType InMpEval);
	bool IsTargetMpRate(float InMpRate, EJackEvaluateType InMpEval);
	bool IsTargetOddEffect(EJackOddEffectCategoryType InCategoryType);
	bool IsTargetOddEffectAttributeF();
	bool IsTargetOddEffectByStatus(class FName InStatusId);
	bool IsTargetOddEffectF();
	bool IsTargetOddEffectOverwrite(EJackOddEffectCategoryType InCategoryType, EJackOddEffectOverwriteType InOverwriteType);
	bool IsTargetOddEffectOverwriteByStatus(class FName InStatusId, EJackOddEffectOverwriteType InOverwriteType);
	bool IsTargetOddEffectSlide(EJackOddEffectCategoryType InCategoryType, int32 InSlideRank);
	bool IsTargetOddEffectSlideMaxF();
	bool IsTargetOddEffectT();
	bool IsTargetOnaziMonsterId();
	bool IsTargetSoseiCostIn();
	bool SC_Hoimi();
	bool SC_M_Nigeru();
	bool SC_T_Failed();
	bool SC_T_Function();
	bool SC_T_HPRate_100();

	EJackActionExtentType GetActionExtent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionSecondCheck">();
	}
	static class AJackActionSecondCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackActionSecondCheck>();
	}
};
static_assert(alignof(AJackActionSecondCheck) == 0x000008, "Wrong alignment on AJackActionSecondCheck");
static_assert(sizeof(AJackActionSecondCheck) == 0x000460, "Wrong size on AJackActionSecondCheck");
static_assert(offsetof(AJackActionSecondCheck, ActionData) == 0x000398, "Member 'AJackActionSecondCheck::ActionData' has a wrong offset!");
static_assert(offsetof(AJackActionSecondCheck, CasterGameCharacter) == 0x000448, "Member 'AJackActionSecondCheck::CasterGameCharacter' has a wrong offset!");
static_assert(offsetof(AJackActionSecondCheck, TargetGameCharacter) == 0x000450, "Member 'AJackActionSecondCheck::TargetGameCharacter' has a wrong offset!");

// Class JackGame.JackActionMessageInfo
// 0x0070 (0x00A8 - 0x0038)
class UJackActionMessageInfo final : public UObject
{
public:
	struct FJackActionBattleTextInfo              BattleTextInfo;                                    // 0x0038(0x0010)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   TextID;                                            // 0x0048(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x0050(0x0010)(Edit, ZeroConstructor, EditConst, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackActionMessageArg                  MessageArg;                                        // 0x0060(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bWait;                                             // 0x0080(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionMessageCompactInfo          CompactInfo;                                       // 0x0088(0x0020)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionMessageInfo">();
	}
	static class UJackActionMessageInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionMessageInfo>();
	}
};
static_assert(alignof(UJackActionMessageInfo) == 0x000008, "Wrong alignment on UJackActionMessageInfo");
static_assert(sizeof(UJackActionMessageInfo) == 0x0000A8, "Wrong size on UJackActionMessageInfo");
static_assert(offsetof(UJackActionMessageInfo, BattleTextInfo) == 0x000038, "Member 'UJackActionMessageInfo::BattleTextInfo' has a wrong offset!");
static_assert(offsetof(UJackActionMessageInfo, TextID) == 0x000048, "Member 'UJackActionMessageInfo::TextID' has a wrong offset!");
static_assert(offsetof(UJackActionMessageInfo, Message) == 0x000050, "Member 'UJackActionMessageInfo::Message' has a wrong offset!");
static_assert(offsetof(UJackActionMessageInfo, MessageArg) == 0x000060, "Member 'UJackActionMessageInfo::MessageArg' has a wrong offset!");
static_assert(offsetof(UJackActionMessageInfo, bWait) == 0x000080, "Member 'UJackActionMessageInfo::bWait' has a wrong offset!");
static_assert(offsetof(UJackActionMessageInfo, CompactInfo) == 0x000088, "Member 'UJackActionMessageInfo::CompactInfo' has a wrong offset!");

// Class JackGame.JackSoundContext
// 0x0030 (0x0068 - 0x0038)
class UJackSoundContext : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundBase;                                         // 0x0048(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoundContext">();
	}
	static class UJackSoundContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoundContext>();
	}
};
static_assert(alignof(UJackSoundContext) == 0x000008, "Wrong alignment on UJackSoundContext");
static_assert(sizeof(UJackSoundContext) == 0x000068, "Wrong size on UJackSoundContext");
static_assert(offsetof(UJackSoundContext, SoundBase) == 0x000048, "Member 'UJackSoundContext::SoundBase' has a wrong offset!");

// Class JackGame.JackEnvSoundContext
// 0x0018 (0x0080 - 0x0068)
class UJackEnvSoundContext final : public UJackSoundContext
{
public:
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEnvSoundContext">();
	}
	static class UJackEnvSoundContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEnvSoundContext>();
	}
};
static_assert(alignof(UJackEnvSoundContext) == 0x000008, "Wrong alignment on UJackEnvSoundContext");
static_assert(sizeof(UJackEnvSoundContext) == 0x000080, "Wrong size on UJackEnvSoundContext");

// Class JackGame.JackFlagJumperTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackFlagJumperTrack final : public UInterpTrack
{
public:
	TArray<struct FJackFlagJumperKeyValue>        KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFlagJumperTrack">();
	}
	static class UJackFlagJumperTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFlagJumperTrack>();
	}
};
static_assert(alignof(UJackFlagJumperTrack) == 0x000008, "Wrong alignment on UJackFlagJumperTrack");
static_assert(sizeof(UJackFlagJumperTrack) == 0x0000A0, "Wrong size on UJackFlagJumperTrack");
static_assert(offsetof(UJackFlagJumperTrack, KeyArray) == 0x000090, "Member 'UJackFlagJumperTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackUMGMapResourceRequesterSet
// 0x0050 (0x0088 - 0x0038)
class UJackUMGMapResourceRequesterSet final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGMapResourceRequester*>   RequesterList;                                     // 0x0040(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapResourceRequesterSet">();
	}
	static class UJackUMGMapResourceRequesterSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapResourceRequesterSet>();
	}
};
static_assert(alignof(UJackUMGMapResourceRequesterSet) == 0x000008, "Wrong alignment on UJackUMGMapResourceRequesterSet");
static_assert(sizeof(UJackUMGMapResourceRequesterSet) == 0x000088, "Wrong size on UJackUMGMapResourceRequesterSet");
static_assert(offsetof(UJackUMGMapResourceRequesterSet, RequesterList) == 0x000040, "Member 'UJackUMGMapResourceRequesterSet::RequesterList' has a wrong offset!");

// Class JackGame.JackActionWaitChecker
// 0x0010 (0x0060 - 0x0050)
class UJackActionWaitChecker final : public UJackTickableGameObject
{
public:
	bool                                          bInitialized;                                      // 0x0050(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackActionWaitType                           ActionWaitType;                                    // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionWaitTime;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentActionWaitTime;                             // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNotifyReceived;                                   // 0x005C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionWaitChecker">();
	}
	static class UJackActionWaitChecker* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionWaitChecker>();
	}
};
static_assert(alignof(UJackActionWaitChecker) == 0x000008, "Wrong alignment on UJackActionWaitChecker");
static_assert(sizeof(UJackActionWaitChecker) == 0x000060, "Wrong size on UJackActionWaitChecker");
static_assert(offsetof(UJackActionWaitChecker, bInitialized) == 0x000050, "Member 'UJackActionWaitChecker::bInitialized' has a wrong offset!");
static_assert(offsetof(UJackActionWaitChecker, ActionWaitType) == 0x000051, "Member 'UJackActionWaitChecker::ActionWaitType' has a wrong offset!");
static_assert(offsetof(UJackActionWaitChecker, ActionWaitTime) == 0x000054, "Member 'UJackActionWaitChecker::ActionWaitTime' has a wrong offset!");
static_assert(offsetof(UJackActionWaitChecker, CurrentActionWaitTime) == 0x000058, "Member 'UJackActionWaitChecker::CurrentActionWaitTime' has a wrong offset!");
static_assert(offsetof(UJackActionWaitChecker, bNotifyReceived) == 0x00005C, "Member 'UJackActionWaitChecker::bNotifyReceived' has a wrong offset!");

// Class JackGame.JackActionTypes
// 0x0000 (0x0038 - 0x0038)
class UJackActionTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionTypes">();
	}
	static class UJackActionTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionTypes>();
	}
};
static_assert(alignof(UJackActionTypes) == 0x000008, "Wrong alignment on UJackActionTypes");
static_assert(sizeof(UJackActionTypes) == 0x000038, "Wrong size on UJackActionTypes");

// Class JackGame.JackActorComponentUserData
// 0x0000 (0x0038 - 0x0038)
class UJackActorComponentUserData final : public UActorComponentUserData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorComponentUserData">();
	}
	static class UJackActorComponentUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorComponentUserData>();
	}
};
static_assert(alignof(UJackActorComponentUserData) == 0x000008, "Wrong alignment on UJackActorComponentUserData");
static_assert(sizeof(UJackActorComponentUserData) == 0x000038, "Wrong size on UJackActorComponentUserData");

// Class JackGame.JackSoundMiscControlTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackSoundMiscControlTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoundMiscControlTrackInst">();
	}
	static class UJackSoundMiscControlTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoundMiscControlTrackInst>();
	}
};
static_assert(alignof(UJackSoundMiscControlTrackInst) == 0x000008, "Wrong alignment on UJackSoundMiscControlTrackInst");
static_assert(sizeof(UJackSoundMiscControlTrackInst) == 0x000040, "Wrong size on UJackSoundMiscControlTrackInst");

// Class JackGame.JackForceLoadReductionDisableForOuterNPCTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackForceLoadReductionDisableForOuterNPCTrackInst final : public UJackToggleBaseTrackInst
{
public:
	TArray<TWeakObjectPtr<class AJackScheduledNPC>> TargetNPCInstance;                                 // 0x0040(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForceLoadReductionDisableForOuterNPCTrackInst">();
	}
	static class UJackForceLoadReductionDisableForOuterNPCTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForceLoadReductionDisableForOuterNPCTrackInst>();
	}
};
static_assert(alignof(UJackForceLoadReductionDisableForOuterNPCTrackInst) == 0x000008, "Wrong alignment on UJackForceLoadReductionDisableForOuterNPCTrackInst");
static_assert(sizeof(UJackForceLoadReductionDisableForOuterNPCTrackInst) == 0x000050, "Wrong size on UJackForceLoadReductionDisableForOuterNPCTrackInst");
static_assert(offsetof(UJackForceLoadReductionDisableForOuterNPCTrackInst, TargetNPCInstance) == 0x000040, "Member 'UJackForceLoadReductionDisableForOuterNPCTrackInst::TargetNPCInstance' has a wrong offset!");

// Class JackGame.JackUMGMapSymbolInfoBase
// 0x0018 (0x0050 - 0x0038)
class UJackUMGMapSymbolInfoBase : public UObject
{
public:
	bool                                          bEnabled;                                          // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackNameTagDict>               Tags;                                              // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class FName Tag_None();
	static class FName Tag_NPCID();

	bool FindTag(class FName InName, struct FJackNameTagDict* RefTag);
	void SetAngle();
	void SetMapSymbol(EJackMapSymbol InMapSymbol);
	void SetMiniMapDrawOffset(const struct FVector2D& InOffset);
	void SetMiniMapDrawScale(float InScale);
	void SetOpacity(float InOpacity);
	void SetVisible(bool InVisible);
	void SetWorldMapDrawOffset(const struct FVector2D& InOffset);
	void SetWorldMapDrawScale(float InScale);
	void SetWorldPosition(const struct FVector& InPosition);

	float GetAngle() const;
	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	EJackMapSymbol GetMapSymbol() const;
	struct FVector2D GetMapSymbolCustomAlignment() const;
	struct FVector2D GetMapSymbolCustomSize() const;
	class UTexture2D* GetMapSymbolCustomTexture() const;
	struct FVector2D GetMiniMapDrawOffset() const;
	float GetMiniMapDrawScale() const;
	float GetOpacity() const;
	int32 GetUniqueNo() const;
	struct FVector2D GetWorldMapDrawOffset() const;
	float GetWorldMapDrawScale() const;
	struct FVector GetWorldPosition() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapSymbolInfoBase">();
	}
	static class UJackUMGMapSymbolInfoBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapSymbolInfoBase>();
	}
};
static_assert(alignof(UJackUMGMapSymbolInfoBase) == 0x000008, "Wrong alignment on UJackUMGMapSymbolInfoBase");
static_assert(sizeof(UJackUMGMapSymbolInfoBase) == 0x000050, "Wrong size on UJackUMGMapSymbolInfoBase");
static_assert(offsetof(UJackUMGMapSymbolInfoBase, bEnabled) == 0x000038, "Member 'UJackUMGMapSymbolInfoBase::bEnabled' has a wrong offset!");
static_assert(offsetof(UJackUMGMapSymbolInfoBase, Tags) == 0x000040, "Member 'UJackUMGMapSymbolInfoBase::Tags' has a wrong offset!");

// Class JackGame.JackUMGComponentBasedMapSymbolInfo
// 0x0010 (0x0060 - 0x0050)
class UJackUMGComponentBasedMapSymbolInfo : public UJackUMGMapSymbolInfoBase
{
public:
	TWeakObjectPtr<class UJackMiniMapTargetComponent> MiniMapTargetComponent;                            // 0x0050(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOpacity(float InOpacity);

	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	EJackMapSymbol GetMapSymbol() const;
	struct FVector2D GetMiniMapDrawOffset() const;
	float GetMiniMapDrawScale() const;
	float GetOpacity() const;
	int32 GetUniqueNo() const;
	struct FVector2D GetWorldMapDrawOffset() const;
	float GetWorldMapDrawScale() const;
	struct FVector GetWorldPosition() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGComponentBasedMapSymbolInfo">();
	}
	static class UJackUMGComponentBasedMapSymbolInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGComponentBasedMapSymbolInfo>();
	}
};
static_assert(alignof(UJackUMGComponentBasedMapSymbolInfo) == 0x000008, "Wrong alignment on UJackUMGComponentBasedMapSymbolInfo");
static_assert(sizeof(UJackUMGComponentBasedMapSymbolInfo) == 0x000060, "Wrong size on UJackUMGComponentBasedMapSymbolInfo");
static_assert(offsetof(UJackUMGComponentBasedMapSymbolInfo, MiniMapTargetComponent) == 0x000050, "Member 'UJackUMGComponentBasedMapSymbolInfo::MiniMapTargetComponent' has a wrong offset!");

// Class JackGame.JackActorInRoomTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackActorInRoomTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorInRoomTrack">();
	}
	static class UJackActorInRoomTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorInRoomTrack>();
	}
};
static_assert(alignof(UJackActorInRoomTrack) == 0x000008, "Wrong alignment on UJackActorInRoomTrack");
static_assert(sizeof(UJackActorInRoomTrack) == 0x0000A8, "Wrong size on UJackActorInRoomTrack");

// Class JackGame.JackFootSoundTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackFootSoundTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackAnimNotify_FootstepSoundType*      Notify;                                            // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFootSoundTrackInst">();
	}
	static class UJackFootSoundTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFootSoundTrackInst>();
	}
};
static_assert(alignof(UJackFootSoundTrackInst) == 0x000008, "Wrong alignment on UJackFootSoundTrackInst");
static_assert(sizeof(UJackFootSoundTrackInst) == 0x000048, "Wrong size on UJackFootSoundTrackInst");
static_assert(offsetof(UJackFootSoundTrackInst, Notify) == 0x000040, "Member 'UJackFootSoundTrackInst::Notify' has a wrong offset!");

// Class JackGame.JackUMGMapTextImageSymbolInfo
// 0x0018 (0x0068 - 0x0050)
class UJackUMGMapTextImageSymbolInfo final : public UJackUMGMapSymbolInfoBase
{
public:
	uint8                                         Pad_50[0x18];                                      // 0x0050(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetWorldPosition(const struct FVector& InPosition);

	float GetAngle() const;
	EJackMapSymbol GetMapSymbol() const;
	struct FVector2D GetMapSymbolCustomAlignment() const;
	struct FVector2D GetMapSymbolCustomSize() const;
	class UTexture2D* GetMapSymbolCustomTexture() const;
	float GetOpacity() const;
	struct FVector GetWorldPosition() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapTextImageSymbolInfo">();
	}
	static class UJackUMGMapTextImageSymbolInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapTextImageSymbolInfo>();
	}
};
static_assert(alignof(UJackUMGMapTextImageSymbolInfo) == 0x000008, "Wrong alignment on UJackUMGMapTextImageSymbolInfo");
static_assert(sizeof(UJackUMGMapTextImageSymbolInfo) == 0x000068, "Wrong size on UJackUMGMapTextImageSymbolInfo");

// Class JackGame.JackActorInRoomTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackActorInRoomTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorInRoomTrackInst">();
	}
	static class UJackActorInRoomTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorInRoomTrackInst>();
	}
};
static_assert(alignof(UJackActorInRoomTrackInst) == 0x000008, "Wrong alignment on UJackActorInRoomTrackInst");
static_assert(sizeof(UJackActorInRoomTrackInst) == 0x000040, "Wrong size on UJackActorInRoomTrackInst");

// Class JackGame.JackFloatMaterialParameterTrack
// 0x0008 (0x00D0 - 0x00C8)
class UJackFloatMaterialParameterTrack final : public UInterpTrackFloatMaterialParam
{
public:
	bool                                          bApplyToAllMaterial;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFloatMaterialParameterTrack">();
	}
	static class UJackFloatMaterialParameterTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFloatMaterialParameterTrack>();
	}
};
static_assert(alignof(UJackFloatMaterialParameterTrack) == 0x000008, "Wrong alignment on UJackFloatMaterialParameterTrack");
static_assert(sizeof(UJackFloatMaterialParameterTrack) == 0x0000D0, "Wrong size on UJackFloatMaterialParameterTrack");
static_assert(offsetof(UJackFloatMaterialParameterTrack, bApplyToAllMaterial) == 0x0000C8, "Member 'UJackFloatMaterialParameterTrack::bApplyToAllMaterial' has a wrong offset!");

// Class JackGame.JackActorPauseTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackActorPauseTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorPauseTrack">();
	}
	static class UJackActorPauseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorPauseTrack>();
	}
};
static_assert(alignof(UJackActorPauseTrack) == 0x000008, "Wrong alignment on UJackActorPauseTrack");
static_assert(sizeof(UJackActorPauseTrack) == 0x0000A8, "Wrong size on UJackActorPauseTrack");

// Class JackGame.JackActorPauseTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackActorPauseTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorPauseTrackInst">();
	}
	static class UJackActorPauseTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorPauseTrackInst>();
	}
};
static_assert(alignof(UJackActorPauseTrackInst) == 0x000008, "Wrong alignment on UJackActorPauseTrackInst");
static_assert(sizeof(UJackActorPauseTrackInst) == 0x000040, "Wrong size on UJackActorPauseTrackInst");

// Class JackGame.JackUMGItemData
// 0x0050 (0x0088 - 0x0038)
class UJackUMGItemData : public UObject
{
public:
	int32                                         DataNumber;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextID;                                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeneralValue;                                      // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGDataContainer*>          ContainerList;                                     // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bResidentData;                                     // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllocatedData;                                    // 0x0069(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6A[0x1E];                                      // 0x006A(0x001E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddItemMaterialContainer(const class FName& InTag, class UMaterial* InImage, bool InIsVisible);
	void AddItemObjectContainer(const class FName& InTag, const class UObject* InObject, bool InIsVisible);
	void AddItemTextContainer(const class FName& InTag, const class FText& InText, bool InIsVisible);
	void AddItemTextureContainer(const class FName& InTag, class UTexture2D* InTexture, bool InIsVisible);
	void AddItemValueContainer(const class FName& InTag, int32 InValue, bool InIsVisible);
	void AddItemVisibilityContainer(const class FName& InTag, bool InIsVisible);
	void ClearContainer();
	void GetBagNameString(class FString* OutBagName);
	void GetBagNameText(class FText* OutBagName);
	void GetCharacterNameString(class FString* OutCharacterName);
	void GetCharacterNameText(class FText* OutCharacterName);
	class UJackUMGDataContainer* GetDataContainerObject(const class FName InTag, bool bAllowNoData);
	void SetSortNo(int32 InTypeSortNo, int32 InNameSortNo, int32 InParamSortNo, int32 InRegion);

	EJackItem_Bag GetBagType() const;
	EJackCharacter GetCharacterType() const;
	int32 GetDataIndex() const;
	int32 GetGeneralValue() const;
	const struct FJackUMGItemContainer GetItemContainer(const class FName InTag, bool bAllowNoData) const;
	const class FName GetItemId() const;
	int32 GetNameSortNo() const;
	int32 GetParamSortNo() const;
	int32 GetRegion() const;
	int32 GetSortNo() const;
	const class FName GetTextId() const;
	int32 GetTypeSortNo() const;
	bool HasItemContainer(const class FName InTag) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemData">();
	}
	static class UJackUMGItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemData>();
	}
};
static_assert(alignof(UJackUMGItemData) == 0x000008, "Wrong alignment on UJackUMGItemData");
static_assert(sizeof(UJackUMGItemData) == 0x000088, "Wrong size on UJackUMGItemData");
static_assert(offsetof(UJackUMGItemData, DataNumber) == 0x000038, "Member 'UJackUMGItemData::DataNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, ItemID) == 0x000040, "Member 'UJackUMGItemData::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, TextID) == 0x000048, "Member 'UJackUMGItemData::TextID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, GeneralValue) == 0x000050, "Member 'UJackUMGItemData::GeneralValue' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, ContainerList) == 0x000058, "Member 'UJackUMGItemData::ContainerList' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, bResidentData) == 0x000068, "Member 'UJackUMGItemData::bResidentData' has a wrong offset!");
static_assert(offsetof(UJackUMGItemData, bAllocatedData) == 0x000069, "Member 'UJackUMGItemData::bAllocatedData' has a wrong offset!");

// Class JackGame.JackActorPhysicsSuppressionTrack
// 0x0010 (0x00C0 - 0x00B0)
class UJackActorPhysicsSuppressionTrack final : public UInterpTrackFloatBase
{
public:
	float                                         SuppressionMultiplyFactor;                         // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SuppressionSec;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationSec;                                    // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorPhysicsSuppressionTrack">();
	}
	static class UJackActorPhysicsSuppressionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorPhysicsSuppressionTrack>();
	}
};
static_assert(alignof(UJackActorPhysicsSuppressionTrack) == 0x000008, "Wrong alignment on UJackActorPhysicsSuppressionTrack");
static_assert(sizeof(UJackActorPhysicsSuppressionTrack) == 0x0000C0, "Wrong size on UJackActorPhysicsSuppressionTrack");
static_assert(offsetof(UJackActorPhysicsSuppressionTrack, SuppressionMultiplyFactor) == 0x0000B0, "Member 'UJackActorPhysicsSuppressionTrack::SuppressionMultiplyFactor' has a wrong offset!");
static_assert(offsetof(UJackActorPhysicsSuppressionTrack, SuppressionSec) == 0x0000B4, "Member 'UJackActorPhysicsSuppressionTrack::SuppressionSec' has a wrong offset!");
static_assert(offsetof(UJackActorPhysicsSuppressionTrack, AttenuationSec) == 0x0000B8, "Member 'UJackActorPhysicsSuppressionTrack::AttenuationSec' has a wrong offset!");

// Class JackGame.JackDistributionExponentTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackDistributionExponentTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDistributionExponentTrackInst">();
	}
	static class UJackDistributionExponentTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDistributionExponentTrackInst>();
	}
};
static_assert(alignof(UJackDistributionExponentTrackInst) == 0x000008, "Wrong alignment on UJackDistributionExponentTrackInst");
static_assert(sizeof(UJackDistributionExponentTrackInst) == 0x000048, "Wrong size on UJackDistributionExponentTrackInst");

// Class JackGame.JackUMGMenu
// 0x0028 (0x0060 - 0x0038)
class UJackUMGMenu final : public UObject
{
public:
	class UJackUMGWidgetBase*                     WidgetBase;                                        // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x20];                                      // 0x0040(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMenu">();
	}
	static class UJackUMGMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMenu>();
	}
};
static_assert(alignof(UJackUMGMenu) == 0x000008, "Wrong alignment on UJackUMGMenu");
static_assert(sizeof(UJackUMGMenu) == 0x000060, "Wrong size on UJackUMGMenu");
static_assert(offsetof(UJackUMGMenu, WidgetBase) == 0x000038, "Member 'UJackUMGMenu::WidgetBase' has a wrong offset!");

// Class JackGame.JackActorPhysicsSuppressionTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackActorPhysicsSuppressionTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActorPhysicsSuppressionTrackInst">();
	}
	static class UJackActorPhysicsSuppressionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActorPhysicsSuppressionTrackInst>();
	}
};
static_assert(alignof(UJackActorPhysicsSuppressionTrackInst) == 0x000008, "Wrong alignment on UJackActorPhysicsSuppressionTrackInst");
static_assert(sizeof(UJackActorPhysicsSuppressionTrackInst) == 0x000040, "Wrong size on UJackActorPhysicsSuppressionTrackInst");

// Class JackGame.JackDisableDesiredMaxDrawDistanceTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackDisableDesiredMaxDrawDistanceTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   TargetActorTag;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDisableDesiredMaxDrawDistanceTrack">();
	}
	static class UJackDisableDesiredMaxDrawDistanceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDisableDesiredMaxDrawDistanceTrack>();
	}
};
static_assert(alignof(UJackDisableDesiredMaxDrawDistanceTrack) == 0x000008, "Wrong alignment on UJackDisableDesiredMaxDrawDistanceTrack");
static_assert(sizeof(UJackDisableDesiredMaxDrawDistanceTrack) == 0x0000B0, "Wrong size on UJackDisableDesiredMaxDrawDistanceTrack");
static_assert(offsetof(UJackDisableDesiredMaxDrawDistanceTrack, TargetActorTag) == 0x0000A8, "Member 'UJackDisableDesiredMaxDrawDistanceTrack::TargetActorTag' has a wrong offset!");

// Class JackGame.JackUMGMeosiSlotMessageWindow
// 0x0008 (0x0378 - 0x0370)
class UJackUMGMeosiSlotMessageWindow final : public UJackUMGWidgetBase
{
public:
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMessageText(const class FString& MessageText, const TArray<struct FJackMessageArgumentData>& Args);
	void SetMessageTextAtTextID(const class FName& TextID, const TArray<struct FJackMessageArgumentData>& Args);
	void SetupTextBlock(class UTextBlock* TextBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMeosiSlotMessageWindow">();
	}
	static class UJackUMGMeosiSlotMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMeosiSlotMessageWindow>();
	}
};
static_assert(alignof(UJackUMGMeosiSlotMessageWindow) == 0x000008, "Wrong alignment on UJackUMGMeosiSlotMessageWindow");
static_assert(sizeof(UJackUMGMeosiSlotMessageWindow) == 0x000378, "Wrong size on UJackUMGMeosiSlotMessageWindow");

// Class JackGame.JackAdditiveAnimPlayTrack
// 0x0000 (0x00D0 - 0x00D0)
class UJackAdditiveAnimPlayTrack final : public UInterpTrackAnimControl
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAdditiveAnimPlayTrack">();
	}
	static class UJackAdditiveAnimPlayTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAdditiveAnimPlayTrack>();
	}
};
static_assert(alignof(UJackAdditiveAnimPlayTrack) == 0x000008, "Wrong alignment on UJackAdditiveAnimPlayTrack");
static_assert(sizeof(UJackAdditiveAnimPlayTrack) == 0x0000D0, "Wrong size on UJackAdditiveAnimPlayTrack");

// Class JackGame.JackUMGPairingBase
// 0x0028 (0x0398 - 0x0370)
class UJackUMGPairingBase : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   PairingInputDelegate;                              // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   PairingInputXDelegate;                             // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_390[0x8];                                      // 0x0390(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetGameDisplayNameXbox();
	void JackUMGPairingInputDelegate__DelegateSignature(bool IsNeedPairing);
	void JackUMGPairingInputXDelegate__DelegateSignature(bool IsNeedPairing);
	void RestartGame();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPairingBase">();
	}
	static class UJackUMGPairingBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPairingBase>();
	}
};
static_assert(alignof(UJackUMGPairingBase) == 0x000008, "Wrong alignment on UJackUMGPairingBase");
static_assert(sizeof(UJackUMGPairingBase) == 0x000398, "Wrong size on UJackUMGPairingBase");
static_assert(offsetof(UJackUMGPairingBase, PairingInputDelegate) == 0x000370, "Member 'UJackUMGPairingBase::PairingInputDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGPairingBase, PairingInputXDelegate) == 0x000380, "Member 'UJackUMGPairingBase::PairingInputXDelegate' has a wrong offset!");

// Class JackGame.JackUMGPairingUser
// 0x0000 (0x0398 - 0x0398)
class UJackUMGPairingUser : public UJackUMGPairingBase
{
public:
	const class FText GetRemovedUserCaptionTextId();
	const class FText GetRemovedUserTextId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPairingUser">();
	}
	static class UJackUMGPairingUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPairingUser>();
	}
};
static_assert(alignof(UJackUMGPairingUser) == 0x000008, "Wrong alignment on UJackUMGPairingUser");
static_assert(sizeof(UJackUMGPairingUser) == 0x000398, "Wrong size on UJackUMGPairingUser");

// Class JackGame.JackForcedLODForParticleTrackInst
// 0x0018 (0x0050 - 0x0038)
class UJackForcedLODForParticleTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForcedLODForParticleTrackInst">();
	}
	static class UJackForcedLODForParticleTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForcedLODForParticleTrackInst>();
	}
};
static_assert(alignof(UJackForcedLODForParticleTrackInst) == 0x000008, "Wrong alignment on UJackForcedLODForParticleTrackInst");
static_assert(sizeof(UJackForcedLODForParticleTrackInst) == 0x000050, "Wrong size on UJackForcedLODForParticleTrackInst");

// Class JackGame.JackAdditiveAnimPlayTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackAdditiveAnimPlayTrackInst final : public UInterpTrackInstAnimControl
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAdditiveAnimPlayTrackInst">();
	}
	static class UJackAdditiveAnimPlayTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAdditiveAnimPlayTrackInst>();
	}
};
static_assert(alignof(UJackAdditiveAnimPlayTrackInst) == 0x000008, "Wrong alignment on UJackAdditiveAnimPlayTrackInst");
static_assert(sizeof(UJackAdditiveAnimPlayTrackInst) == 0x000040, "Wrong size on UJackAdditiveAnimPlayTrackInst");

// Class JackGame.JackAdditivePlayRateTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackAdditivePlayRateTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAdditivePlayRateTrack">();
	}
	static class UJackAdditivePlayRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAdditivePlayRateTrack>();
	}
};
static_assert(alignof(UJackAdditivePlayRateTrack) == 0x000008, "Wrong alignment on UJackAdditivePlayRateTrack");
static_assert(sizeof(UJackAdditivePlayRateTrack) == 0x0000B0, "Wrong size on UJackAdditivePlayRateTrack");

// Class JackGame.JackUMGAccessorItem
// 0x0460 (0x04A0 - 0x0040)
class UJackUMGAccessorItem : public UJackUMGAccessorBase
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackUMGBagEventTag                    BagEventTag;                                       // 0x0050(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGActionIcons                    ActionIcons;                                       // 0x0088(0x0078)(Edit, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        NoEquipmentHandednessIcon;                         // 0x0100(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        NoEquipmentHandIcon;                               // 0x0110(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentHeadIcon;                               // 0x0120(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentBodyIcon;                               // 0x0138(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentAccessoryIcon;                          // 0x0150(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        NoEquipmentItemHandednessIcon;                     // 0x0168(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        NoEquipmentItemHandIcon;                           // 0x0178(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentItemHeadIcon;                           // 0x0188(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentItemBodyIcon;                           // 0x01A0(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentItemAccessoryIcon;                      // 0x01B8(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                SecretItemBookIcon;                                // 0x01D0(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        CharaNumberIcons;                                  // 0x01E8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                OsyareType1Frame;                                  // 0x01F8(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                OsyareType1Stars;                                  // 0x0210(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                OsyareType2Frame;                                  // 0x0228(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                OsyareType2Stars;                                  // 0x0240(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        BagListBackground;                                 // 0x0258(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FJackUMGParamPercentFlags              ParamPercentFlags;                                 // 0x0268(0x0012)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_27A[0x2];                                      // 0x027A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SortMaxNumber;                                     // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGCanOnlyBuyOnceItem>     CanOnlyBuyOnceItemList;                            // 0x0280(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         ShopTradeLimitCount;                               // 0x0290(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackUMGItemClassRefineData            ClassRefineData;                                   // 0x0294(0x001F)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B3[0x5];                                      // 0x02B3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackUMGItemClassRefineName            ClassRefineName;                                   // 0x02B8(0x00A0)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EJackUMGItemClassRefineType>           SoubiClassRefineList;                              // 0x0358(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UDataTable*                             ScheduledKiraDataTable;                            // 0x0368(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             GmmickDropDataTable;                               // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGScenarioFlagName>       ShopVisitList;                                     // 0x0378(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGScenarioFlagName>       KiraVisitList;                                     // 0x0388(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     SyousaiVisitIcons;                                 // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class UTexture2D*                             EquippedMitameBuiIcon;                             // 0x03A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NoEquipmentMitameBuiIcon;                          // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             EquippedMitameListIcon;                            // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             NoEquipmentMitameListIcon;                         // 0x03C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCollectVisitMap;                                // 0x03C8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x7];                                      // 0x03C9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           ImageChangeRingItemId;                             // 0x03D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	struct FJackLDT_GameFlagDataScenario          SenaShortHairScenario1ID;                          // 0x03E0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackLDT_GameFlagDataScenario          SenaShortHairScenario2ID;                          // 0x03F0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairFalse1;                               // 0x0400(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairFalse2;                               // 0x0401(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairFalseFlag;                            // 0x0402(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairTrue1;                                // 0x0403(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairTrue2;                                // 0x0404(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SenaShortHairTrueFlag;                             // 0x0405(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_406[0x2];                                      // 0x0406(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           CanNotBulkBuyingItemList;                          // 0x0408(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x70];                                     // 0x0418(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	class UEnum*                                  EnumClassification;                                // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UEnum*                                  EnumJackItemBag;                                   // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static EJackCharacter BagTypeToCharType(EJackItem_Bag InBagType);
	static EJackItem_Bag CharTypeToBagType(EJackCharacter InCharType);

	int32 ActionBulkBuy(const TArray<struct FJackUIItemBulkBuyingInfo>& InBulkBuyingList, bool bIsCalculationOnly);
	int32 ActionItem(EJackUMGItemActionCommand InCommandType, int32 InArg1);
	void AsyncLoadItemPopIcon(class UObject* Target, const class FName& ItemID, TDelegate<void(class FName ItemID, class UObject* LoadedObject)> LoadedEvent);
	void JackUMGLoadedItemPopIconEvent__DelegateSignature(class FName ItemID, class UObject* LoadedObject);
	void CancelAsyncLoadItemPopIcon(class UObject* Target);
	EJackEquipmentRegion CheckAccessoryFreeRegion(EJackCharacter InCharaType, EJackEquipmentRegion InRegion, const class UJackUMGItemSyousai* InItemSyousai, const class UJackUMGUIActionInfo* InActionInfo);
	int32 CheckDetachReleaseItem(EJackCharacter InCharaType, const EJackEquipmentRegion InRegion, class FName* OutItemId, EJackEquipmentRegion* OutRegion);
	int32 CheckEquipmentReleaseItem(EJackCharacter InCharaType, const class FName& InItemId, class FName* GetItemId, EJackEquipmentRegion* GetRegionType);
	int32 CheckLeaveAtSort(EJackItem_Bag InBagType, TArray<class UJackUMGItemData*>* InRemoveList);
	void CheckShoppingAchievement(int32 InBuyPrice);
	int32 CountInBag(EJackItem_Bag InBagType);
	void DebugTest(int32 InMdoe);
	class UJackUMGSerifuWindowController* DisplayUseItemMessage();
	void FixupLooks(EJackCharacter InCharType);
	class UTexture2D* GetBagIconFromType(EJackItem_Bag InBagType);
	class UTexture2D* GetBagListBackground(int32 NumList);
	const TArray<class UJackUMGItemData*> GetCasinoItemList();
	class UTexture2D* GetCharaNumberIcon(int32 InNumber);
	bool GetDropMapList(const class FName& InItemId, int32 GettableMaxCount, TArray<struct FJackUMGItemGetInfo>* OutMapList);
	bool GetDropMonsterList(const class FName& InItemId, int32 GettableMaxCount, TArray<struct FJackUMGItemGetInfo>* OutMonsterList);
	void GetFieldUseItemCommonActionResult(bool* bValidCommonAction, bool* bSuccess);
	const class FName GetItemClassRefineTextId(EJackUMGItemClassRefineType InRefineType);
	int32 GetItemIndexFromRegion(EJackCharacter InCharType, EJackEquipmentRegion InRegionType);
	const TArray<class UJackUMGItemData*> GetMedaruItemList();
	class UTexture2D* GetNoEquipmentIcon(EJackCharacter InCharaType, EJackEquipmentRegion InRegionType, bool bIsItemIcon);
	const TArray<class UJackUMGItemData*> GetShopItemList();
	void RequestAsyncLoadItemPopIconCallback(const TArray<struct FSoftObjectPath>& TargetsToStream, const TArray<class UObject*>& LoadedObjects, class FName ItemID);
	void ResetUsingShopFlag();
	void SetActionCommandType(EJackUMGItemActionCommand InCommandType);
	void SetActionItemCount(int32 InCount);
	void SetActionItemId(const class FName InItemId);
	int32 SetBagItemListToWindow(class UJackUMGBrowserBase* InBrowserBase, EJackItem_Bag InBagType, EJackUMGItemClassRefineType InRefineType, int32 InDispIndex, bool bIsDispList);
	void SetBagListToWindow(class UJackUMGBrowserBase* InBrowserBase, int32 InDispIndex, bool IsHukuro, bool IsEquipment, bool IsDaizinamono);
	void SetBagSelectedName(const class FName InEnumName);
	void SetBagSelectedType(EJackItem_Bag InBagType);
	void SetBagSelectedTypeWithItemIndex(EJackItem_Bag InBagType, int32 InIndex);
	void SetBagTargetName(const class FName InEnumName);
	void SetBagTargetType(EJackItem_Bag InBagType);
	void SetBagTargetTypeWithItemIndex(EJackItem_Bag InBagType, int32 InIndex);
	void SetEquipmentRegion(EJackEquipmentRegion InRegionType);
	void SetPassItemId(const class FName& InPassItemId);
	void SetSelectedItemIndexInBag(int32 InIndex);
	void SetShopExchangeId(const class FName InExchangeId);
	void SetShopId(const class FName InShopId);
	void SetTargetItemIndexInBag(int32 InIndex);
	int32 SortBagItemList(EJackUMGItemSortType InSortType);
	int32 SortBagItemListByBagType(EJackUMGItemSortType InSortType, EJackItem_Bag InBagType);
	TArray<class UJackUMGItemData*> SortDisplayList(const TArray<class UJackUMGItemData*>& InItemDataList, EJackUMGItemSortType InSortType, EJackCharacter InCharacterType, bool bIsDoNotRenumbers);
	int32 SortItemList(EJackUMGItemSortType InSortType);

	int32 CalcItemPrice(int32 ItemBuyPrine) const;
	bool CanBeEquippedItemInChar(const class FName InItemId, EJackCharacter InCharType) const;
	int32 CountItemAllBag(const class FName InItemId, bool bWithCommonBag) const;
	int32 CountItemInBag(EJackItem_Bag InBagType, const class FName InItemId) const;
	class UJackUMGItemSyousai* CreateItemSyousai(const class FName& InItemId, const class FName& InTextId) const;
	int32 FindItemFromInBag(EJackItem_Bag InBagType, const class FName InItemId, EJackUMGItemFind InFindType) const;
	int32 FindNoEquipmentItemFromInBag(EJackItem_Bag InBagType, bool IsEmptyZero) const;
	EJackUMGItemActionCommand GetActionCommandType() const;
	class UTexture2D* GetActionIcon(EJackActionIconType IconType) const;
	int32 GetActionItemCount() const;
	const class FName GetActionItemId() const;
	const class FName GetAutoReleaseItemId() const;
	EJackEquipmentRegion GetAutoReleaseRegion() const;
	class UJackGameCharacter* GetBagCharacter(EJackItem_Bag InBagType) const;
	int32 GetBagCountBySelected() const;
	const TArray<class UJackUMGItemData*> GetBagEquipmentItemList(EJackCharacter InCharType, EJackEquipmentRegion InRegionType, bool bIsAllChara, bool bIsFukuro, bool IsOptimisation) const;
	const TArray<class UJackUMGItemData*> GetBagItemList(EJackItem_Bag InBagType, bool bIsRange, int32 InGetIndex, int32 InGetNumItem) const;
	const TArray<class UJackUMGItemData*> GetBagItemListBySoubiItemSwap(EJackItem_Bag InBagType, bool bIsNitouryuu) const;
	const TArray<class UJackUMGItemData*> GetBagList(bool IsHukuro, bool IsEquipment, bool IsDaizinamono) const;
	class FString GetBagName(EJackItem_Bag InBagType, bool IsList) const;
	void GetBagNameString(class FString* OutBagName, EJackItem_Bag InBagType, bool IsList, bool IsMotimono) const;
	void GetBagNameText(class FText* OutBagName, EJackItem_Bag InBagType, bool IsList, bool IsMotimono) const;
	EJackCharacter GetBagSelectedChar() const;
	int32 GetBagSelectedItemIndex() const;
	EJackItem_Bag GetBagSelectedType() const;
	EJackCharacter GetBagTargetChar() const;
	int32 GetBagTargetItemIndex() const;
	EJackItem_Bag GetBagTargetType() const;
	class UTexture2D* GetCategoryIcon(const class FName& InItemId) const;
	class FText GetClassificationTextFromType(EJackItem_Classification InClassType) const;
	TArray<class FString> GetCookItemListFromRecipe(const class FName& InItemId) const;
	const EJackItem_DiscardType GetDiscardType(const class FName InItemId) const;
	TArray<struct FJackUMGItemGetInfo> GetDropMapListExternal(const class FName& InItemId) const;
	EJackEquipmentRegion GetEquipmentRegion() const;
	const TSoftObjectPtr<class UTexture> GetItemBookIconAssetPtr(const class FName& InItemId) const;
	EJackUMGItemClassification GetItemClassification(const class FName& InItemId) const;
	class UJackUMGUIActionInfo* GetItemEquipmentInfo(EJackItem_Bag InBagType, int32 InIndex) const;
	int32 GetItemGettableCount(const class FName InItemId) const;
	int32 GetItemGettableCountInBag(EJackItem_Bag InBagType, const class FName InItemId) const;
	const class FName GetItemIdFromBagIndex(EJackItem_Bag InBagType, int32 InIndex) const;
	const TArray<class UJackUMGItemData*> GetItemListFromItemIDList(const TArray<class FName>& ItemIDList) const;
	const struct FJackUMGEquipmentParam GetItemMajorParameterType(const class FName InItemId) const;
	const class FText GetItemNameFromId(const class FName InItemId) const;
	class UTexture2D* GetItemOsyareIconTexture(EJackUMGItemOsyareType InOsyareType, bool bIsStars) const;
	EJackUMGItemOsyareType GetItemOsyareTypeFromAsset(const class FString& InAssetName) const;
	EJackUMGItemOsyareType GetItemOsyareTypeFromItemId(const class FName& InItemId) const;
	const struct FJackUMGGetItemData GetItemParameter(const class FName& InItemId, EJackUMGGetItemParam InParamType) const;
	class UTexture2D* GetItemPopIconTexture(const class FName& ItemID) const;
	class UJackUMGItemQualityInfo* GetItemQualityInfo(int32 InPictorialBookNo, const class FName& InItemId) const;
	class UJackUMGItemSyousai* GetItemSyousai(const class FName& InItemId, bool bIsEquipmentInfo, bool bIsCategoryIcon, bool bIsBookIcon) const;
	class UJackUMGItemSyousai* GetItemSyousaiFromBagTypeAndItemIndex(EJackItem_Bag InBagType, int32 InItemIndex, bool bIsEquipmentInfo, bool bIsCategoryIcon, bool bIsBookIcon) const;
	const TArray<struct FJackUMGItemListInfo> GetItemSyousaiList(EJackItem_Bag InBagType, EJackUMGItemClassRefineType InRefineType) const;
	const TArray<struct FJackUMGItemListInfo> GetItemSyousaiListByItemIdList(const TArray<class FName>& ItemIDList) const;
	const TArray<struct FJackUMGItemListInfo> GetItemSyousaiListInFusigiRecipe(const TArray<class UJackUMGItemData*>& InItemDataList) const;
	const TArray<struct FJackUMGItemListInfo> GetItemSyousaiListInSenreki(const TArray<class UJackUMGItemData*>& InItemDataList) const;
	class UJackUMGShopItemSyousai* GetItemSyousaiShop(const class FName& InItemId) const;
	class UJackUMGItemSyousai* GetItemSyousaiWithBagType(const class FName& InItemId, bool bIsEquipmentInfo, bool bIsCategoryIcon, bool bIsBookIcon, EJackItem_Bag InBagType) const;
	class UJackUMGUIActionInfo* GetItemUIActionInfo(const class FName& InItemId) const;
	const class FText GetListItemNameFromId(const class FName InItemId) const;
	const class FText GetParameterNameTextFromParamType(EJackItem_ParameterType InParamId) const;
	const class FName GetPassItemId() const;
	const TArray<class UJackUMGItemData*> GetPresentItemList() const;
	EJackUIScenarioNumber GetScenarioNo() const;
	struct FJackUMGActionBagInfo GetSelectedActionBagInfo() const;
	int32 GetShopCurrency() const;
	const TArray<class UJackUMGItemData*> GetShopEquipmentStateList(const class FName& InItemId) const;
	const class FName GetShopId() const;
	EJackUMGShopResult GetShopResult() const;
	const class FString GetShopTalkText(const class FName InMessageId, class FName* OutShopMessageId) const;
	void GetShopTalkTextId(const class FName InMessageId, class FName* OutTextId) const;
	EJackShop GetShopType() const;
	TArray<class FString> GetSpecialEffectsMessage(const class FName& InItemId) const;
	EJackItem_Bag GetStorageTypeFromItemClass(EJackUMGItemClassification InItemClassification) const;
	const class FName GetSwapItemId() const;
	class UTexture2D* GetSyousaiVisitIconTexture(EJackUMGItemPlacedAcquisition InIconType) const;
	struct FJackUMGActionBagInfo GetTargetActionBagInfo() const;
	class UJackUMGUIActionInfo* GetUIActionInfo(const class FName& InActionId) const;
	bool GetUsingShopFlag() const;
	bool IsAcquiredGoldPass() const;
	bool IsAcquisitionPictorialBookNoItem(int32 PictorialBookNo) const;
	bool IsActionMember(const class UJackUMGUIActionInfo* ActionInfo, EJackUMGMemberList InListType) const;
	bool IsAutoReleaseItem() const;
	bool IsBagOverflow() const;
	bool IsCharacterBag(EJackItem_Bag InBagType) const;
	bool IsCommonBag(EJackItem_Bag InBagType) const;
	bool IsEquippedItem(const class FName InItemId) const;
	bool IsEquippedItemInChar(const class FName& InItemId, EJackCharacter InCharType, EJackEquipmentRegion InRegionType) const;
	bool IsExecutableAction(const class UJackUMGUIActionInfo* ActionInfo, EJackCharacter InTargetCharType, EJackUMGMemberList InCheckType) const;
	bool IsItemsInBag(bool bIsEquipment) const;
	bool IsPercentParam(EJackItem_ParameterType InParamType) const;
	class UJackUMGItemSyousai* SetupItemSyousai(class UJackUMGItemSyousai* InItemSyousai, const class FName& InItemId, bool bIsEquipmentInfo, bool bIsCategoryIcon, bool bIsBookIcon) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorItem">();
	}
	static class UJackUMGAccessorItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorItem>();
	}
};
static_assert(alignof(UJackUMGAccessorItem) == 0x000008, "Wrong alignment on UJackUMGAccessorItem");
static_assert(sizeof(UJackUMGAccessorItem) == 0x0004A0, "Wrong size on UJackUMGAccessorItem");
static_assert(offsetof(UJackUMGAccessorItem, BagEventTag) == 0x000050, "Member 'UJackUMGAccessorItem::BagEventTag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ActionIcons) == 0x000088, "Member 'UJackUMGAccessorItem::ActionIcons' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentHandednessIcon) == 0x000100, "Member 'UJackUMGAccessorItem::NoEquipmentHandednessIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentHandIcon) == 0x000110, "Member 'UJackUMGAccessorItem::NoEquipmentHandIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentHeadIcon) == 0x000120, "Member 'UJackUMGAccessorItem::NoEquipmentHeadIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentBodyIcon) == 0x000138, "Member 'UJackUMGAccessorItem::NoEquipmentBodyIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentAccessoryIcon) == 0x000150, "Member 'UJackUMGAccessorItem::NoEquipmentAccessoryIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentItemHandednessIcon) == 0x000168, "Member 'UJackUMGAccessorItem::NoEquipmentItemHandednessIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentItemHandIcon) == 0x000178, "Member 'UJackUMGAccessorItem::NoEquipmentItemHandIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentItemHeadIcon) == 0x000188, "Member 'UJackUMGAccessorItem::NoEquipmentItemHeadIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentItemBodyIcon) == 0x0001A0, "Member 'UJackUMGAccessorItem::NoEquipmentItemBodyIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentItemAccessoryIcon) == 0x0001B8, "Member 'UJackUMGAccessorItem::NoEquipmentItemAccessoryIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SecretItemBookIcon) == 0x0001D0, "Member 'UJackUMGAccessorItem::SecretItemBookIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, CharaNumberIcons) == 0x0001E8, "Member 'UJackUMGAccessorItem::CharaNumberIcons' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, OsyareType1Frame) == 0x0001F8, "Member 'UJackUMGAccessorItem::OsyareType1Frame' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, OsyareType1Stars) == 0x000210, "Member 'UJackUMGAccessorItem::OsyareType1Stars' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, OsyareType2Frame) == 0x000228, "Member 'UJackUMGAccessorItem::OsyareType2Frame' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, OsyareType2Stars) == 0x000240, "Member 'UJackUMGAccessorItem::OsyareType2Stars' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, BagListBackground) == 0x000258, "Member 'UJackUMGAccessorItem::BagListBackground' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ParamPercentFlags) == 0x000268, "Member 'UJackUMGAccessorItem::ParamPercentFlags' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SortMaxNumber) == 0x00027C, "Member 'UJackUMGAccessorItem::SortMaxNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, CanOnlyBuyOnceItemList) == 0x000280, "Member 'UJackUMGAccessorItem::CanOnlyBuyOnceItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ShopTradeLimitCount) == 0x000290, "Member 'UJackUMGAccessorItem::ShopTradeLimitCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ClassRefineData) == 0x000294, "Member 'UJackUMGAccessorItem::ClassRefineData' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ClassRefineName) == 0x0002B8, "Member 'UJackUMGAccessorItem::ClassRefineName' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SoubiClassRefineList) == 0x000358, "Member 'UJackUMGAccessorItem::SoubiClassRefineList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ScheduledKiraDataTable) == 0x000368, "Member 'UJackUMGAccessorItem::ScheduledKiraDataTable' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, GmmickDropDataTable) == 0x000370, "Member 'UJackUMGAccessorItem::GmmickDropDataTable' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ShopVisitList) == 0x000378, "Member 'UJackUMGAccessorItem::ShopVisitList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, KiraVisitList) == 0x000388, "Member 'UJackUMGAccessorItem::KiraVisitList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SyousaiVisitIcons) == 0x000398, "Member 'UJackUMGAccessorItem::SyousaiVisitIcons' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, EquippedMitameBuiIcon) == 0x0003A8, "Member 'UJackUMGAccessorItem::EquippedMitameBuiIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentMitameBuiIcon) == 0x0003B0, "Member 'UJackUMGAccessorItem::NoEquipmentMitameBuiIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, EquippedMitameListIcon) == 0x0003B8, "Member 'UJackUMGAccessorItem::EquippedMitameListIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, NoEquipmentMitameListIcon) == 0x0003C0, "Member 'UJackUMGAccessorItem::NoEquipmentMitameListIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, bIsCollectVisitMap) == 0x0003C8, "Member 'UJackUMGAccessorItem::bIsCollectVisitMap' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, ImageChangeRingItemId) == 0x0003D0, "Member 'UJackUMGAccessorItem::ImageChangeRingItemId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairScenario1ID) == 0x0003E0, "Member 'UJackUMGAccessorItem::SenaShortHairScenario1ID' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairScenario2ID) == 0x0003F0, "Member 'UJackUMGAccessorItem::SenaShortHairScenario2ID' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairFalse1) == 0x000400, "Member 'UJackUMGAccessorItem::SenaShortHairFalse1' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairFalse2) == 0x000401, "Member 'UJackUMGAccessorItem::SenaShortHairFalse2' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairFalseFlag) == 0x000402, "Member 'UJackUMGAccessorItem::SenaShortHairFalseFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairTrue1) == 0x000403, "Member 'UJackUMGAccessorItem::SenaShortHairTrue1' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairTrue2) == 0x000404, "Member 'UJackUMGAccessorItem::SenaShortHairTrue2' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, SenaShortHairTrueFlag) == 0x000405, "Member 'UJackUMGAccessorItem::SenaShortHairTrueFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, CanNotBulkBuyingItemList) == 0x000408, "Member 'UJackUMGAccessorItem::CanNotBulkBuyingItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, EnumClassification) == 0x000488, "Member 'UJackUMGAccessorItem::EnumClassification' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorItem, EnumJackItemBag) == 0x000490, "Member 'UJackUMGAccessorItem::EnumJackItemBag' has a wrong offset!");

// Class JackGame.JackUMGSerifuWindow
// 0x01D0 (0x0540 - 0x0370)
class UJackUMGSerifuWindow : public UJackUMGWidgetBase
{
public:
	uint8                                         Pad_370[0x40];                                     // 0x0370(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   JackUMGSerifuWindowEvent;                          // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C0[0x80];                                     // 0x03C0(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasPanel*                           ContentCanvasPanel;                                // 0x0440(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTextBlock*>                     TextLabelList;                                     // 0x0448(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_458[0x40];                                     // 0x0458(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            AdditionalWidget;                                  // 0x0498(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A0[0x4];                                      // 0x04A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         EnableTextLabelCount;                              // 0x04A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultRootPanelPosY;                              // 0x04A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TextLabelRootPositionY;                            // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TextLabelOffsetY;                                  // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RubyLabelRootPositionY;                            // 0x04B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RubyLabelOffsetY;                                  // 0x04B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsCenteringMode;                                  // 0x04BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BD[0x3];                                      // 0x04BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharacterSizeX;                                    // 0x04C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         MaximumLengthOfTextLine;                           // 0x04C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TextLineLengthMax;                                 // 0x04C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4CC[0x14];                                     // 0x04CC(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackSerifuWindowMoveTextLabelInfo     MoveTextLabelInfo1;                                // 0x04E0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJackSerifuWindowMoveTextLabelInfo     MoveTextLabelInfo2;                                // 0x04F0(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x10];                                     // 0x0500(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackSerifuWindowShakeWindowInfo       ShakeSmallInfo;                                    // 0x0510(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	struct FJackSerifuWindowShakeWindowInfo       ShakeBigInfo;                                      // 0x0520(0x0010)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPrivate)
	bool                                          bDisableExcessTimeOfMoveLabel;                     // 0x0530(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_531[0xF];                                      // 0x0531(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsValidSerifuWindowControlKey(EJackKeys Key);

	void ChengePageMarkerShowState(bool bIsShow);
	bool ControllerKeyEvent(const struct FJackKeyStatus& Key);
	void ExecuteKeyEvent(EJackKeys Key);
	void JackUMGSerifuWindowEvent__DelegateSignature(class UJackUMGSerifuWindow* Sender, const class FName EventTag, float ExcessTime);
	void RunMoveTextLabel(int32 MoveCount, float DeltaTime);
	void SetContentCanvasPanel(class UCanvasPanel* Value);
	void SetImageListList(const TArray<class UImage*>& Value, int32 LineImageCount);
	void SetMessage(const class FString& Message);
	void SetRubyLabelList(const TArray<class UTextBlock*>& RefRubyTextBlockList);
	void SetTextLabelList(const TArray<class UTextBlock*>& Value);
	void SetTextLabelListList(const TArray<class UTextBlock*>& Value, int32 LineTextLabelCount);
	void SetupChoicesWindowShowMode(bool bIsShow, int32 TextLength);
	void SetupNameWindow(bool bIsShow, const class FText& DisplayName, const struct FVector2D& NameSize);
	void SetVisibleBackgroundImage(bool bValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSerifuWindow">();
	}
	static class UJackUMGSerifuWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSerifuWindow>();
	}
};
static_assert(alignof(UJackUMGSerifuWindow) == 0x000008, "Wrong alignment on UJackUMGSerifuWindow");
static_assert(sizeof(UJackUMGSerifuWindow) == 0x000540, "Wrong size on UJackUMGSerifuWindow");
static_assert(offsetof(UJackUMGSerifuWindow, JackUMGSerifuWindowEvent) == 0x0003B0, "Member 'UJackUMGSerifuWindow::JackUMGSerifuWindowEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, ContentCanvasPanel) == 0x000440, "Member 'UJackUMGSerifuWindow::ContentCanvasPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, TextLabelList) == 0x000448, "Member 'UJackUMGSerifuWindow::TextLabelList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, AdditionalWidget) == 0x000498, "Member 'UJackUMGSerifuWindow::AdditionalWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, EnableTextLabelCount) == 0x0004A4, "Member 'UJackUMGSerifuWindow::EnableTextLabelCount' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, DefaultRootPanelPosY) == 0x0004A8, "Member 'UJackUMGSerifuWindow::DefaultRootPanelPosY' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, TextLabelRootPositionY) == 0x0004AC, "Member 'UJackUMGSerifuWindow::TextLabelRootPositionY' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, TextLabelOffsetY) == 0x0004B0, "Member 'UJackUMGSerifuWindow::TextLabelOffsetY' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, RubyLabelRootPositionY) == 0x0004B4, "Member 'UJackUMGSerifuWindow::RubyLabelRootPositionY' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, RubyLabelOffsetY) == 0x0004B8, "Member 'UJackUMGSerifuWindow::RubyLabelOffsetY' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, bIsCenteringMode) == 0x0004BC, "Member 'UJackUMGSerifuWindow::bIsCenteringMode' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, CharacterSizeX) == 0x0004C0, "Member 'UJackUMGSerifuWindow::CharacterSizeX' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, MaximumLengthOfTextLine) == 0x0004C4, "Member 'UJackUMGSerifuWindow::MaximumLengthOfTextLine' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, TextLineLengthMax) == 0x0004C8, "Member 'UJackUMGSerifuWindow::TextLineLengthMax' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, MoveTextLabelInfo1) == 0x0004E0, "Member 'UJackUMGSerifuWindow::MoveTextLabelInfo1' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, MoveTextLabelInfo2) == 0x0004F0, "Member 'UJackUMGSerifuWindow::MoveTextLabelInfo2' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, ShakeSmallInfo) == 0x000510, "Member 'UJackUMGSerifuWindow::ShakeSmallInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, ShakeBigInfo) == 0x000520, "Member 'UJackUMGSerifuWindow::ShakeBigInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindow, bDisableExcessTimeOfMoveLabel) == 0x000530, "Member 'UJackUMGSerifuWindow::bDisableExcessTimeOfMoveLabel' has a wrong offset!");

// Class JackGame.JackDispersionManager
// 0x0070 (0x00A8 - 0x0038)
class UJackDispersionManager final : public UObject
{
public:
	uint8                                         Pad_38[0x70];                                      // 0x0038(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsDispersionExecutable(class UObject* TargetObject);

	void Register(class UObject* TargetObject, EJackDisperisonLayer Layer, class FName GroupName);
	void Unregister(class UObject* TargetObject);

	bool IsExecutable(class UObject* TargetObject) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDispersionManager">();
	}
	static class UJackDispersionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDispersionManager>();
	}
};
static_assert(alignof(UJackDispersionManager) == 0x000008, "Wrong alignment on UJackDispersionManager");
static_assert(sizeof(UJackDispersionManager) == 0x0000A8, "Wrong size on UJackDispersionManager");

// Class JackGame.JackAdjustRotateByMoveTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackAdjustRotateByMoveTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAdjustRotateByMoveTrack">();
	}
	static class UJackAdjustRotateByMoveTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAdjustRotateByMoveTrack>();
	}
};
static_assert(alignof(UJackAdjustRotateByMoveTrack) == 0x000008, "Wrong alignment on UJackAdjustRotateByMoveTrack");
static_assert(sizeof(UJackAdjustRotateByMoveTrack) == 0x0000A8, "Wrong size on UJackAdjustRotateByMoveTrack");

// Class JackGame.JackGameCharacter
// 0x0618 (0x0650 - 0x0038)
class UJackGameCharacter : public UObject
{
public:
	class FName                                   ID;                                                // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 Name_0;                                            // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 DisplayName;                                       // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FString                                 ListName;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackGender                                   Gender;                                            // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackJob                                      Job;                                               // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMight                                    Might;                                             // 0x0072(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackPosition                                 Position;                                          // 0x0073(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackGambit                                   Gambit;                                            // 0x0074(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackCharacter                                CharacterType;                                     // 0x0075(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_76[0x2];                                       // 0x0076(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HP;                                                // 0x007C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MP;                                                // 0x0080(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Tikara;                                            // 0x0084(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Minomamori;                                        // 0x0088(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Subayasa;                                          // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Kiyousa;                                           // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Miryoku;                                           // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KougekiMaryoku;                                    // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         KaifukuMaryoku;                                    // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxHP;                                             // 0x00A0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxMP;                                             // 0x00A4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZoneKeepRemainTurn;                                // 0x00A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ZoneKeepRemainBattle;                              // 0x00AC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Exp;                                               // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TokugiPoint;                                       // 0x00B4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ConsumedTokugiPoint;                               // 0x00B8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIncreaseTokugiPoint;                              // 0x00BC(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAcquiredAtariPanel;                               // 0x00BD(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NameIdentifier;                                    // 0x00C0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TroopIndex;                                        // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GroupIndex;                                        // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DropExp;                                           // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DropGold;                                          // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D4[0xF4];                                      // 0x00D4(0x00F4)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 BaseAttributeParams;                               // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UJackBattleCharacterInfo*               BattleCharacterInfo;                               // 0x01D8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackAttackInfo                        AttackInfo;                                        // 0x01E0(0x0180)(Edit, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UJackOddEffectExecHolder*               OddEffectExecHolder;                               // 0x0360(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackZonePointControl*                  ZonePointControl;                                  // 0x0368(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_370[0x2E0];                                    // 0x0370(0x02E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static struct FJackGameCharacterParameters MakeJackGameCharacterParameters();

	void ForceFullRecover(bool bRevive, bool bSHowHud, bool bSkipSpawnCharacter);
	int32 IncreaseSeedCorrectKaifukuMaryoku(int32 InIncrease);
	int32 IncreaseSeedCorrectKougekiMaryoku(int32 InIncrease);
	int32 IncreaseSeedCorrectMiryoku(int32 InIncrease);

	const TArray<class FName> GetAcquiredActiveTokugis() const;
	const TArray<class FName> GetAcquiredJumons() const;
	TArray<class FName> GetAcquiredPassiveTokugis() const;
	struct FJackGameCharacterParameters GetBasedParameters(bool bHandedness) const;
	EJackCharacter GetCharacterType() const;
	int32 GetConsumedTokugiPoint() const;
	class FName GetCoordinateID(EJackCharacterCoordinateLayer Layer) const;
	EJackDataTableReferType GetDataTableReferType() const;
	int32 GetDisplayExp() const;
	class FString GetDisplayName(bool ListFlag) const;
	int32 GetDropExp() const;
	int32 GetDropGold() const;
	class FName GetEffectiveCoordinateID() const;
	TArray<EJackMight> GetEnemyMightsBP() const;
	const TArray<struct FJackGameCharacterEquippedItem> GetEquippedItems() const;
	struct FJackGameCharacterParameters GetEquippedParameters(bool bHandedness) const;
	struct FJackGameCharacterParameters GetEquippedParametersWith(const TArray<struct FJackGameCharacterEquippedItem>& InEquipmentItems, bool bRequestChangeParametersOnly, bool bHandedness) const;
	EJackEquippedWeaponStyle GetEquippedWeaponStyle() const;
	TArray<class FName> GetExecutableActiveTokugis() const;
	TArray<class FName> GetExecutablePassiveTokugis(EJackPassiveTokugiType ExtractType) const;
	int32 GetExp() const;
	EJackGambit GetGambit() const;
	EJackGender GetGender() const;
	int32 GetGroupIndex() const;
	int32 GetHP() const;
	float GetHPRate() const;
	class FName GetId() const;
	class AJackCharacter* GetJackCharacter() const;
	EJackJob GetJob() const;
	int32 GetKaifukuMaryoku() const;
	int32 GetKiyousa() const;
	int32 GetKougekiMaryoku() const;
	int32 GetKougekiryoku(bool bHandedness, bool bIncludeOddEffect) const;
	int32 GetLevel() const;
	int32 GetMaxHP() const;
	int32 GetMaxMP() const;
	EJackMight GetMight() const;
	int32 GetMinomamori() const;
	int32 GetMiryoku() const;
	int32 GetMP() const;
	float GetMPRate() const;
	struct FJackGameCharacterParameters GetPassiveCorrectParameters() const;
	EJackPosition GetPosition() const;
	class FString GetRawDisplayName(bool ListFlag) const;
	class FString GetRawName() const;
	struct FJackGameCharacterParameters GetSeedCorrectParameters() const;
	int32 GetSubayasa() const;
	int32 GetSyubiryoku() const;
	int32 GetTikara(bool bHandedness) const;
	int32 GetTokugiPoint() const;
	int32 GetTroopIndex() const;
	float GetZonePoint() const;
	bool IsAcquiredAtariPanel() const;
	bool IsAcquiredNitouNoGokui() const;
	bool IsAcquiredNitouryuu() const;
	bool IsActiveWeaponStyleAction(class FName ActionID, EJackEquippedWeaponStyle WeaponStyle, bool bEquippedShield) const;
	bool IsBossMonster() const;
	bool IsCharacterType(EJackCharacter InCharacterType) const;
	bool IsConsumableMP(int32 InMP) const;
	bool IsDefending() const;
	bool IsEquippedShield() const;
	bool IsFriend() const;
	bool IsGambit(EJackGambit InGambit) const;
	bool IsGender(EJackGender InGender) const;
	bool IsGuestNPC() const;
	bool IsIncreaseTokugiPoint() const;
	bool IsInGroup(int32 InGroupIndex) const;
	bool IsInMight(EJackMight InMight) const;
	bool IsInTroop(int32 InTroopIndex) const;
	bool IsJob(EJackJob InJob) const;
	bool IsLeader() const;
	bool IsMonster() const;
	bool IsMovementEnabled() const;
	bool IsNitouryuu() const;
	bool IsOddEffect(class FName OddEffectID) const;
	bool IsOperational() const;
	bool IsOperationalWithIgnoreOddEffectIDs(const TArray<class FName>& IgnoreOddEffectIDs) const;
	bool IsPlayer() const;
	bool IsPosition(EJackPosition InPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameCharacter">();
	}
	static class UJackGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameCharacter>();
	}
};
static_assert(alignof(UJackGameCharacter) == 0x000008, "Wrong alignment on UJackGameCharacter");
static_assert(sizeof(UJackGameCharacter) == 0x000650, "Wrong size on UJackGameCharacter");
static_assert(offsetof(UJackGameCharacter, ID) == 0x000038, "Member 'UJackGameCharacter::ID' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Name_0) == 0x000040, "Member 'UJackGameCharacter::Name_0' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, DisplayName) == 0x000050, "Member 'UJackGameCharacter::DisplayName' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, ListName) == 0x000060, "Member 'UJackGameCharacter::ListName' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Gender) == 0x000070, "Member 'UJackGameCharacter::Gender' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Job) == 0x000071, "Member 'UJackGameCharacter::Job' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Might) == 0x000072, "Member 'UJackGameCharacter::Might' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Position) == 0x000073, "Member 'UJackGameCharacter::Position' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Gambit) == 0x000074, "Member 'UJackGameCharacter::Gambit' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, CharacterType) == 0x000075, "Member 'UJackGameCharacter::CharacterType' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Level) == 0x000078, "Member 'UJackGameCharacter::Level' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, HP) == 0x00007C, "Member 'UJackGameCharacter::HP' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, MP) == 0x000080, "Member 'UJackGameCharacter::MP' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Tikara) == 0x000084, "Member 'UJackGameCharacter::Tikara' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Minomamori) == 0x000088, "Member 'UJackGameCharacter::Minomamori' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Subayasa) == 0x00008C, "Member 'UJackGameCharacter::Subayasa' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Kiyousa) == 0x000090, "Member 'UJackGameCharacter::Kiyousa' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Miryoku) == 0x000094, "Member 'UJackGameCharacter::Miryoku' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, KougekiMaryoku) == 0x000098, "Member 'UJackGameCharacter::KougekiMaryoku' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, KaifukuMaryoku) == 0x00009C, "Member 'UJackGameCharacter::KaifukuMaryoku' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, MaxHP) == 0x0000A0, "Member 'UJackGameCharacter::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, MaxMP) == 0x0000A4, "Member 'UJackGameCharacter::MaxMP' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, ZoneKeepRemainTurn) == 0x0000A8, "Member 'UJackGameCharacter::ZoneKeepRemainTurn' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, ZoneKeepRemainBattle) == 0x0000AC, "Member 'UJackGameCharacter::ZoneKeepRemainBattle' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, Exp) == 0x0000B0, "Member 'UJackGameCharacter::Exp' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, TokugiPoint) == 0x0000B4, "Member 'UJackGameCharacter::TokugiPoint' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, ConsumedTokugiPoint) == 0x0000B8, "Member 'UJackGameCharacter::ConsumedTokugiPoint' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, bIncreaseTokugiPoint) == 0x0000BC, "Member 'UJackGameCharacter::bIncreaseTokugiPoint' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, bAcquiredAtariPanel) == 0x0000BD, "Member 'UJackGameCharacter::bAcquiredAtariPanel' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, NameIdentifier) == 0x0000C0, "Member 'UJackGameCharacter::NameIdentifier' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, TroopIndex) == 0x0000C4, "Member 'UJackGameCharacter::TroopIndex' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, GroupIndex) == 0x0000C8, "Member 'UJackGameCharacter::GroupIndex' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, DropExp) == 0x0000CC, "Member 'UJackGameCharacter::DropExp' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, DropGold) == 0x0000D0, "Member 'UJackGameCharacter::DropGold' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, BaseAttributeParams) == 0x0001C8, "Member 'UJackGameCharacter::BaseAttributeParams' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, BattleCharacterInfo) == 0x0001D8, "Member 'UJackGameCharacter::BattleCharacterInfo' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, AttackInfo) == 0x0001E0, "Member 'UJackGameCharacter::AttackInfo' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, OddEffectExecHolder) == 0x000360, "Member 'UJackGameCharacter::OddEffectExecHolder' has a wrong offset!");
static_assert(offsetof(UJackGameCharacter, ZonePointControl) == 0x000368, "Member 'UJackGameCharacter::ZonePointControl' has a wrong offset!");

// Class JackGame.JackVehicleUmaRace
// 0x03F0 (0x1F20 - 0x1B30)
class AJackVehicleUmaRace final : public AJackVehicleMonster
{
public:
	class UCurveFloat*                            DashCurveIn;                                       // 0x1B30(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DashCurveOut;                                      // 0x1B38(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DashSpeedOfTimeCurve;                              // 0x1B40(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationSpeedCurve;                                // 0x1B48(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationDashSpeedCurve;                            // 0x1B50(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            RotationOfSpeedRateCurve;                          // 0x1B58(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            GoalSnapCurve;                                     // 0x1B60(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            TimeScheduleSpeedChangeCurve;                      // 0x1B68(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            BrakeDecCurve;                                     // 0x1B70(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            MoveRightValueCurve;                               // 0x1B78(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSpeedRate;                                     // 0x1B80(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartBDashAddSpeedRate;                            // 0x1B84(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            StartBDashCurve;                                   // 0x1B88(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HeroHeroSpeedRate;                                 // 0x1B90(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDashMaxAccel;                                 // 0x1B94(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateAngleLimit;                                  // 0x1B98(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpeedBrakeRate;                                    // 0x1B9C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisableSnapTime;                                   // 0x1BA0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashRecoverTime;                                   // 0x1BA4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashOneSec;                                        // 0x1BA8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashIntervalTime;                                  // 0x1BAC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashPreIntervalTime;                               // 0x1BB0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NextHealTime;                                      // 0x1BB4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashIntervalTimeUsedEnergy;                        // 0x1BB8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoInputRotationInterpolate;                        // 0x1BBC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AIRotationSpeedYaw;                                // 0x1BC0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpactVelocityScale;                               // 0x1BC4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RecoveryStaminaGauge;                              // 0x1BC8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BCC[0x4];                                     // 0x1BCC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackCameraData>            DashCameraData2nd;                                 // 0x1BD0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCameraData>            DashCameraData3rd;                                 // 0x1BD8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashStartCameraInterpSpeed1st;                     // 0x1BE0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashStartCameraInterpSpeed2nd;                     // 0x1BE4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashStartCameraInterpSpeed3rd;                     // 0x1BE8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashEndCameraInterpSpeed;                          // 0x1BEC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedYaw;                                  // 0x1BF0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedYawDash;                              // 0x1BF4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDashJumpStaminaNoUse;                           // 0x1BF8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1BF9[0x3];                                     // 0x1BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReverseRunCheckAngle;                              // 0x1BFC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReverseRunCheckTime;                               // 0x1C00(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SnapPathDistance;                                  // 0x1C04(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSnapPathDistance;                              // 0x1C08(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashSteeringMultRate;                              // 0x1C0C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScheduleAddSpeedRateMax;                       // 0x1C10(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScheduleAddSpeedRateMin;                       // 0x1C14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeScheduleAddSpeedRateLerpRate;                  // 0x1C18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDisableSnapPathTime;                          // 0x1C1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaugeDamage;                                       // 0x1C20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GaugeDamageImpact;                                 // 0x1C24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DashEndRotationStartTime;                          // 0x1C28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoInputDashInterpolationMax;                       // 0x1C2C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationLerpTime;                                  // 0x1C30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForceImpactPriority;                            // 0x1C34(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C35[0x3];                                     // 0x1C35(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveRightReactionValue;                            // 0x1C38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartDashAvaibableTime;                            // 0x1C3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JumpMaxMoveSpeed;                                  // 0x1C40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GoalSnapPathDistance;                              // 0x1C44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C48[0x104];                                   // 0x1C48(0x0104)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceFallSec;                                      // 0x1D4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D50[0x4];                                     // 0x1D50(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               JumpAttitudeRotationSpeed;                         // 0x1D54(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAddAttitudeRotation;                           // 0x1D60(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         JumpMaxVelocity;                                   // 0x1D6C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMaxVelocity;                        // 0x1D70(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMinAnimationRate;                   // 0x1D74(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakeKeyValue;                                     // 0x1D78(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakeRotationMultiplyValue;                        // 0x1D7C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashBrakeRotationMultiplyValue;                    // 0x1D80(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TadunaBrakeRotationMultiplyValue;                  // 0x1D84(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TadunaDashBrakeRotationMultiplyValue;              // 0x1D88(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BrakeGaugeDownValue;                               // 0x1D8C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackCollideEffect>         EffectDashBrakeClass;                              // 0x1D90(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundDashBrake;                                    // 0x1D98(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackCollideEffect>         EffectBrakeClass;                                  // 0x1DA0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundBrake;                                        // 0x1DA8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DetouringTime;                                     // 0x1DB0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DB4[0x4];                                     // 0x1DB4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DT_MotionSyncTableP008;                            // 0x1DB8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DT_MotionSyncTableNormal;                          // 0x1DC0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DC8[0x98];                                    // 0x1DC8(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DT_TimeSchedule;                                   // 0x1E60(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E68[0x8];                                     // 0x1E68(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UArrowComponent*                        DetouringPointLeft;                                // 0x1E70(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UArrowComponent*                        DetouringPointRight;                               // 0x1E78(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E80[0xA0];                                    // 0x1E80(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddGimmick(class AJackUmaRaceGimmick* InGimmick);
	void BeginOtherVehicleOverlap(class AJackVehicleUmaRace* InOtherVehicle);
	void ChangeMovementRaceMode();
	bool CheckImpactPriority(class AJackVehicleUmaRace* InVehicle);
	void DashGaugeReset();
	void DashLevelDown();
	void DisableCanJump();
	void DisablePathChange();
	void DownGauge(float InDeltaTime);
	void DownGaugeImpact(float InSpeedRate, float InTime);
	void DownSpeed(float InDowSpeedRate, float InTime);
	void EnableCanJump();
	void EnablePathChange();
	void EndOtherVehicleOverlap(class AJackVehicleUmaRace* InOtherVehicle);
	void ForceIntersectionMovement(float AdditionalSpeedRate, float Seconds);
	void FullHealGauge();
	float GetDashLevelTime(EJackUmaRaceDash InDashType);
	TArray<class AJackUmaRaceGimmick*> GetGimmickObjects();
	EJackUmaRaceDash GetNowDashType();
	struct FVector GetPathDir();
	class AJackUmaRaceUnit* GetUnit();
	void HalfHealGauge();
	void HealGauge(float InHealTime, bool bForceStateChange, bool bForce);
	bool IsDashGaugeAvailable();
	bool IsDashMaxSpeed();
	bool IsDownSpeed();
	bool IsHeal(int32 GroupID);
	bool IsValidGimmick();
	void OnDashChangeBp(int32 InChangeLevel);
	void OnEndBrakeBp();
	void OnEndJumpBp();
	void OnEndRaceBp();
	void OnLapBp(int32 LapNo, bool bIsLastLap, bool bIsFinalLap, float FootStepVolume);
	void OnPauseBegin();
	void OnPauseEnd(bool bIsInRetire);
	void OnReverseRun();
	void OnStartBrakeBp();
	void OnStartJumpBp();
	void OnStartRaceBp();
	void OnVehicleHit(class AJackVehicleUmaRace* InVehicle, const struct FHitResult& InHitResult, float InDisableSnapPathTime);
	void RefleshDownSpeed();
	void RemoveGimmick(class AJackUmaRaceGimmick* InGimmick);
	void ResetReverseRun();
	void SetDetoruingLeftEnable(bool bEnable);
	void SetDetouringRightEnable(bool bEnable);
	void SetFootStepAnimEvent(bool bEnable);
	void SetGoalSpline(const TArray<class USplineComponent*>& InSpline);
	void SetHealGroupID(int32 GroupID);
	void SetSplineComponentArray(const TArray<class USplineComponent*>& SplineComponentArray);
	void StartAnimMontageWait();
	void StartBDash();
	void StartBrakeAI(float InTime);
	void StartChangeBaseSpeedAI(float SpeedRate);
	void StartDashAI(float InDashTime, bool bForce);
	void StopAnimMontageWait();
	void StopDash();
	void UpSpeed(float InUpSpeedRate, float InTime);

	float GetDashSpeedRate() const;
	float GetSpeedRate() const;
	bool IsAI() const;
	bool IsBrake() const;
	bool IsCanSePlay() const;
	bool IsDashFastState() const;
	bool IsDashState() const;
	bool IsEndRace() const;
	bool IsJumpState() const;
	bool IsReverseRun() const;
	bool IsStartRace() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleUmaRace">();
	}
	static class AJackVehicleUmaRace* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleUmaRace>();
	}
};
static_assert(alignof(AJackVehicleUmaRace) == 0x000010, "Wrong alignment on AJackVehicleUmaRace");
static_assert(sizeof(AJackVehicleUmaRace) == 0x001F20, "Wrong size on AJackVehicleUmaRace");
static_assert(offsetof(AJackVehicleUmaRace, DashCurveIn) == 0x001B30, "Member 'AJackVehicleUmaRace::DashCurveIn' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashCurveOut) == 0x001B38, "Member 'AJackVehicleUmaRace::DashCurveOut' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashSpeedOfTimeCurve) == 0x001B40, "Member 'AJackVehicleUmaRace::DashSpeedOfTimeCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationSpeedCurve) == 0x001B48, "Member 'AJackVehicleUmaRace::RotationSpeedCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationDashSpeedCurve) == 0x001B50, "Member 'AJackVehicleUmaRace::RotationDashSpeedCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationOfSpeedRateCurve) == 0x001B58, "Member 'AJackVehicleUmaRace::RotationOfSpeedRateCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, GoalSnapCurve) == 0x001B60, "Member 'AJackVehicleUmaRace::GoalSnapCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TimeScheduleSpeedChangeCurve) == 0x001B68, "Member 'AJackVehicleUmaRace::TimeScheduleSpeedChangeCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, BrakeDecCurve) == 0x001B70, "Member 'AJackVehicleUmaRace::BrakeDecCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, MoveRightValueCurve) == 0x001B78, "Member 'AJackVehicleUmaRace::MoveRightValueCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashSpeedRate) == 0x001B80, "Member 'AJackVehicleUmaRace::DashSpeedRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, StartBDashAddSpeedRate) == 0x001B84, "Member 'AJackVehicleUmaRace::StartBDashAddSpeedRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, StartBDashCurve) == 0x001B88, "Member 'AJackVehicleUmaRace::StartBDashCurve' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, HeroHeroSpeedRate) == 0x001B90, "Member 'AJackVehicleUmaRace::HeroHeroSpeedRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, StartDashMaxAccel) == 0x001B94, "Member 'AJackVehicleUmaRace::StartDashMaxAccel' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotateAngleLimit) == 0x001B98, "Member 'AJackVehicleUmaRace::RotateAngleLimit' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, SpeedBrakeRate) == 0x001B9C, "Member 'AJackVehicleUmaRace::SpeedBrakeRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DisableSnapTime) == 0x001BA0, "Member 'AJackVehicleUmaRace::DisableSnapTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashRecoverTime) == 0x001BA4, "Member 'AJackVehicleUmaRace::DashRecoverTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashOneSec) == 0x001BA8, "Member 'AJackVehicleUmaRace::DashOneSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashIntervalTime) == 0x001BAC, "Member 'AJackVehicleUmaRace::DashIntervalTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashPreIntervalTime) == 0x001BB0, "Member 'AJackVehicleUmaRace::DashPreIntervalTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, NextHealTime) == 0x001BB4, "Member 'AJackVehicleUmaRace::NextHealTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashIntervalTimeUsedEnergy) == 0x001BB8, "Member 'AJackVehicleUmaRace::DashIntervalTimeUsedEnergy' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, NoInputRotationInterpolate) == 0x001BBC, "Member 'AJackVehicleUmaRace::NoInputRotationInterpolate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, AIRotationSpeedYaw) == 0x001BC0, "Member 'AJackVehicleUmaRace::AIRotationSpeedYaw' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, ImpactVelocityScale) == 0x001BC4, "Member 'AJackVehicleUmaRace::ImpactVelocityScale' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RecoveryStaminaGauge) == 0x001BC8, "Member 'AJackVehicleUmaRace::RecoveryStaminaGauge' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashCameraData2nd) == 0x001BD0, "Member 'AJackVehicleUmaRace::DashCameraData2nd' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashCameraData3rd) == 0x001BD8, "Member 'AJackVehicleUmaRace::DashCameraData3rd' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashStartCameraInterpSpeed1st) == 0x001BE0, "Member 'AJackVehicleUmaRace::DashStartCameraInterpSpeed1st' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashStartCameraInterpSpeed2nd) == 0x001BE4, "Member 'AJackVehicleUmaRace::DashStartCameraInterpSpeed2nd' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashStartCameraInterpSpeed3rd) == 0x001BE8, "Member 'AJackVehicleUmaRace::DashStartCameraInterpSpeed3rd' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashEndCameraInterpSpeed) == 0x001BEC, "Member 'AJackVehicleUmaRace::DashEndCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationSpeedYaw) == 0x001BF0, "Member 'AJackVehicleUmaRace::RotationSpeedYaw' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationSpeedYawDash) == 0x001BF4, "Member 'AJackVehicleUmaRace::RotationSpeedYawDash' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, bIsDashJumpStaminaNoUse) == 0x001BF8, "Member 'AJackVehicleUmaRace::bIsDashJumpStaminaNoUse' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, ReverseRunCheckAngle) == 0x001BFC, "Member 'AJackVehicleUmaRace::ReverseRunCheckAngle' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, ReverseRunCheckTime) == 0x001C00, "Member 'AJackVehicleUmaRace::ReverseRunCheckTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, SnapPathDistance) == 0x001C04, "Member 'AJackVehicleUmaRace::SnapPathDistance' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashSnapPathDistance) == 0x001C08, "Member 'AJackVehicleUmaRace::DashSnapPathDistance' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashSteeringMultRate) == 0x001C0C, "Member 'AJackVehicleUmaRace::DashSteeringMultRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TimeScheduleAddSpeedRateMax) == 0x001C10, "Member 'AJackVehicleUmaRace::TimeScheduleAddSpeedRateMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TimeScheduleAddSpeedRateMin) == 0x001C14, "Member 'AJackVehicleUmaRace::TimeScheduleAddSpeedRateMin' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TimeScheduleAddSpeedRateLerpRate) == 0x001C18, "Member 'AJackVehicleUmaRace::TimeScheduleAddSpeedRateLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, StartDisableSnapPathTime) == 0x001C1C, "Member 'AJackVehicleUmaRace::StartDisableSnapPathTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, GaugeDamage) == 0x001C20, "Member 'AJackVehicleUmaRace::GaugeDamage' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, GaugeDamageImpact) == 0x001C24, "Member 'AJackVehicleUmaRace::GaugeDamageImpact' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashEndRotationStartTime) == 0x001C28, "Member 'AJackVehicleUmaRace::DashEndRotationStartTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, NoInputDashInterpolationMax) == 0x001C2C, "Member 'AJackVehicleUmaRace::NoInputDashInterpolationMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, RotationLerpTime) == 0x001C30, "Member 'AJackVehicleUmaRace::RotationLerpTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, bIsForceImpactPriority) == 0x001C34, "Member 'AJackVehicleUmaRace::bIsForceImpactPriority' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, MoveRightReactionValue) == 0x001C38, "Member 'AJackVehicleUmaRace::MoveRightReactionValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, StartDashAvaibableTime) == 0x001C3C, "Member 'AJackVehicleUmaRace::StartDashAvaibableTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpMaxMoveSpeed) == 0x001C40, "Member 'AJackVehicleUmaRace::JumpMaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, GoalSnapPathDistance) == 0x001C44, "Member 'AJackVehicleUmaRace::GoalSnapPathDistance' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, ForceFallSec) == 0x001D4C, "Member 'AJackVehicleUmaRace::ForceFallSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpAttitudeRotationSpeed) == 0x001D54, "Member 'AJackVehicleUmaRace::JumpAttitudeRotationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpAddAttitudeRotation) == 0x001D60, "Member 'AJackVehicleUmaRace::JumpAddAttitudeRotation' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpMaxVelocity) == 0x001D6C, "Member 'AJackVehicleUmaRace::JumpMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpStartMotionMaxVelocity) == 0x001D70, "Member 'AJackVehicleUmaRace::JumpStartMotionMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, JumpStartMotionMinAnimationRate) == 0x001D74, "Member 'AJackVehicleUmaRace::JumpStartMotionMinAnimationRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, BrakeKeyValue) == 0x001D78, "Member 'AJackVehicleUmaRace::BrakeKeyValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, BrakeRotationMultiplyValue) == 0x001D7C, "Member 'AJackVehicleUmaRace::BrakeRotationMultiplyValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DashBrakeRotationMultiplyValue) == 0x001D80, "Member 'AJackVehicleUmaRace::DashBrakeRotationMultiplyValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TadunaBrakeRotationMultiplyValue) == 0x001D84, "Member 'AJackVehicleUmaRace::TadunaBrakeRotationMultiplyValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, TadunaDashBrakeRotationMultiplyValue) == 0x001D88, "Member 'AJackVehicleUmaRace::TadunaDashBrakeRotationMultiplyValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, BrakeGaugeDownValue) == 0x001D8C, "Member 'AJackVehicleUmaRace::BrakeGaugeDownValue' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, EffectDashBrakeClass) == 0x001D90, "Member 'AJackVehicleUmaRace::EffectDashBrakeClass' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, SoundDashBrake) == 0x001D98, "Member 'AJackVehicleUmaRace::SoundDashBrake' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, EffectBrakeClass) == 0x001DA0, "Member 'AJackVehicleUmaRace::EffectBrakeClass' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, SoundBrake) == 0x001DA8, "Member 'AJackVehicleUmaRace::SoundBrake' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DetouringTime) == 0x001DB0, "Member 'AJackVehicleUmaRace::DetouringTime' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DT_MotionSyncTableP008) == 0x001DB8, "Member 'AJackVehicleUmaRace::DT_MotionSyncTableP008' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DT_MotionSyncTableNormal) == 0x001DC0, "Member 'AJackVehicleUmaRace::DT_MotionSyncTableNormal' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DT_TimeSchedule) == 0x001E60, "Member 'AJackVehicleUmaRace::DT_TimeSchedule' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DetouringPointLeft) == 0x001E70, "Member 'AJackVehicleUmaRace::DetouringPointLeft' has a wrong offset!");
static_assert(offsetof(AJackVehicleUmaRace, DetouringPointRight) == 0x001E78, "Member 'AJackVehicleUmaRace::DetouringPointRight' has a wrong offset!");

// Class JackGame.JackAIController
// 0x00F0 (0x0580 - 0x0490)
class AJackAIController : public AAIController
{
public:
	uint8                                         Pad_490[0xF0];                                     // 0x0490(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackCharacter* GetJackCharacter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAIController">();
	}
	static class AJackAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackAIController>();
	}
};
static_assert(alignof(AJackAIController) == 0x000008, "Wrong alignment on AJackAIController");
static_assert(sizeof(AJackAIController) == 0x000580, "Wrong size on AJackAIController");

// Class JackGame.JackFriendAIController
// 0x0668 (0x0BE8 - 0x0580)
class AJackFriendAIController final : public AJackAIController
{
public:
	uint8                                         Pad_580[0x648];                                    // 0x0580(0x0648)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           PlayAnimMontage;                                   // 0x0BC8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD0[0x18];                                     // 0x0BD0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendAIController">();
	}
	static class AJackFriendAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFriendAIController>();
	}
};
static_assert(alignof(AJackFriendAIController) == 0x000008, "Wrong alignment on AJackFriendAIController");
static_assert(sizeof(AJackFriendAIController) == 0x000BE8, "Wrong size on AJackFriendAIController");
static_assert(offsetof(AJackFriendAIController, PlayAnimMontage) == 0x000BC8, "Member 'AJackFriendAIController::PlayAnimMontage' has a wrong offset!");

// Class JackGame.JackAirBubbleComponent
// 0x0120 (0x02C0 - 0x01A0)
class UJackAirBubbleComponent final : public UJackCharacterComponent
{
public:
	struct FJackAirBubbleAsset                    AirBubbleAssets[0x3];                              // 0x01A0(0x0010)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPrivate)
	class FName                                   SpawnTargetSocketName;                             // 0x01D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAttachAirBubbleToSocket;                          // 0x01D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoActivateAirBubble;                            // 0x01D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DA[0xE6];                                     // 0x01DA(0x00E6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAirBubbleActivity(EJackAirBubbleControlPurpose Purpose, EJackAirBubbleActivity Activity);
	void SetAirBubbleHiddenInGame(EJackAirBubbleControlPurpose Purpose, bool bHidden);
	void SpawnAirBubble(EJackAirBubble Size);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAirBubbleComponent">();
	}
	static class UJackAirBubbleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAirBubbleComponent>();
	}
};
static_assert(alignof(UJackAirBubbleComponent) == 0x000008, "Wrong alignment on UJackAirBubbleComponent");
static_assert(sizeof(UJackAirBubbleComponent) == 0x0002C0, "Wrong size on UJackAirBubbleComponent");
static_assert(offsetof(UJackAirBubbleComponent, AirBubbleAssets) == 0x0001A0, "Member 'UJackAirBubbleComponent::AirBubbleAssets' has a wrong offset!");
static_assert(offsetof(UJackAirBubbleComponent, SpawnTargetSocketName) == 0x0001D0, "Member 'UJackAirBubbleComponent::SpawnTargetSocketName' has a wrong offset!");
static_assert(offsetof(UJackAirBubbleComponent, bAttachAirBubbleToSocket) == 0x0001D8, "Member 'UJackAirBubbleComponent::bAttachAirBubbleToSocket' has a wrong offset!");
static_assert(offsetof(UJackAirBubbleComponent, bAutoActivateAirBubble) == 0x0001D9, "Member 'UJackAirBubbleComponent::bAutoActivateAirBubble' has a wrong offset!");

// Class JackGame.JackFusigiKaziItemCountList
// 0x0108 (0x0140 - 0x0038)
class UJackFusigiKaziItemCountList final : public UObject
{
public:
	uint8                                         Pad_38[0x108];                                     // 0x0038(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziItemCountList">();
	}
	static class UJackFusigiKaziItemCountList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFusigiKaziItemCountList>();
	}
};
static_assert(alignof(UJackFusigiKaziItemCountList) == 0x000008, "Wrong alignment on UJackFusigiKaziItemCountList");
static_assert(sizeof(UJackFusigiKaziItemCountList) == 0x000140, "Wrong size on UJackFusigiKaziItemCountList");

// Class JackGame.JackAnimalCharacter
// 0x0010 (0x1100 - 0x10F0)
class AJackAnimalCharacter final : public AJackCharacter
{
public:
	EJackAnimal                                   AnimalType;                                        // 0x10F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_10F1[0xF];                                     // 0x10F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimalCharacter">();
	}
	static class AJackAnimalCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackAnimalCharacter>();
	}
};
static_assert(alignof(AJackAnimalCharacter) == 0x000010, "Wrong alignment on AJackAnimalCharacter");
static_assert(sizeof(AJackAnimalCharacter) == 0x001100, "Wrong size on AJackAnimalCharacter");
static_assert(offsetof(AJackAnimalCharacter, AnimalType) == 0x0010F0, "Member 'AJackAnimalCharacter::AnimalType' has a wrong offset!");

// Class JackGame.JackAnimDynamicsMoveForceTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackAnimDynamicsMoveForceTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimDynamicsMoveForceTrackInst">();
	}
	static class UJackAnimDynamicsMoveForceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimDynamicsMoveForceTrackInst>();
	}
};
static_assert(alignof(UJackAnimDynamicsMoveForceTrackInst) == 0x000008, "Wrong alignment on UJackAnimDynamicsMoveForceTrackInst");
static_assert(sizeof(UJackAnimDynamicsMoveForceTrackInst) == 0x000040, "Wrong size on UJackAnimDynamicsMoveForceTrackInst");

// Class JackGame.JackAnimInstance
// 0x07A8 (0x0BE0 - 0x0438)
#pragma pack(push, 0x1)
class alignas(0x10) UJackAnimInstance : public UAnimInstance
{
public:
	uint8                                         Pad_438[0x40];                                     // 0x0438(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AnimMontagesTable;                                 // 0x0478(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             DynamicAnimMontagesTable;                          // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AdditiveAnimMontagesTable;                         // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackAnimMontageDict>           AnimMontages;                                      // 0x0490(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSet<class UDataTable*>                       WeaponStyleAnimMontageTables;                      // 0x04A0(0x0050)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	TMap<class FName, struct FJackDataTableAnimMontage> DynamicAnimMontagesCache;                          // 0x04F0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_540[0x1];                                      // 0x0540(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCacheTurningState;                                // 0x0541(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_542[0x56];                                     // 0x0542(0x0056)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UClass*>                         IgnoredAnimNotifyClasses;                          // 0x0598(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x1A0];                                    // 0x05A8(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          FacePoseAnimation;                                 // 0x0748(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          AdditionalFacePoseAnimation;                       // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CutSceneFacePoseAnimation;                         // 0x0758(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          CutSceneAdditionalFacePoseAnimation;               // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackUpdatingDynamicsCondition         DynamicsUpdateFlags;                               // 0x0768(0x000A)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bHasAnimDynamics;                                  // 0x0772(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_773[0x1];                                      // 0x0773(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJackArmIKComponent>     CachedArmIKComponent;                              // 0x0774(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_77C[0xAC];                                     // 0x077C(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackAnimExp_DynamicBoneCacheState     DynamicsCalcCache;                                 // 0x0828(0x00B8)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_8E0[0xAC];                                     // 0x08E0(0x00AC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Frame_FA_Up_Blink;                                 // 0x098C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_Adjust_Up;                      // 0x0990(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_Adjust_Down;                    // 0x0994(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_Shout;                          // 0x0998(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Up_Default;                               // 0x099C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Default;                              // 0x09A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_A;                              // 0x09A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_I;                              // 0x09A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Low_Mouth_U;                              // 0x09AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Up_Eye_Horizontal_Right;                  // 0x09B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Up_Eye_Horizontal_Left;                   // 0x09B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Up_Eye_Vertical_Up;                       // 0x09B8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Frame_FA_Up_Eye_Vertical_Down;                     // 0x09BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUpperFacialAnimStateNone;                       // 0x09C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C1[0x3];                                      // 0x09C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftEyeBlinkPoseWeight;                            // 0x09C4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightEyeBlinkPoseWeight;                           // 0x09C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BlinkPoseEyeOffset;                                // 0x09CC(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EyeCloseRate;                                      // 0x09D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLowerFacialAnimStateNone;                       // 0x09DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9DD[0x3];                                      // 0x09DD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Emotion;                                           // 0x09E0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AbsEmotion;                                        // 0x09E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPositiveEmotion;                                  // 0x09E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9E9[0x3];                                      // 0x09E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Tone;                                              // 0x09EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LipSyncBlendWeight;                                // 0x09F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomLipSyncRunning;                             // 0x09F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackVowel                                    LastPhraseVowel;                                   // 0x09F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9F6[0x2];                                      // 0x09F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LipSyncBlendTime;                                  // 0x09F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VowelSecondNoteBlendWeight;                        // 0x09FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ManualLipSyncModeBlendWeight;                      // 0x0A00(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFacialControlEnabled;                             // 0x0A04(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHumanFace;                                        // 0x0A05(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanLipSync;                                       // 0x0A06(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A07[0x1];                                      // 0x0A07(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LeftArmFabrikAlpha;                                // 0x0A08(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0C[0x4];                                      // 0x0A0C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             LeftArmFabrikEffectorTransform;                    // 0x0A10(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RightArmFabrikAlpha;                               // 0x0A40(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A44[0xC];                                      // 0x0A44(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightArmFabrikEffectorTransform;                   // 0x0A50(0x0030)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bArmIKEnabled;                                     // 0x0A80(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHumanArm;                                         // 0x0A81(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bFootIKEnabled;                                    // 0x0A82(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLookAtEnabled;                                    // 0x0A83(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtInterpLocation;                              // 0x0A84(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackLookAtNodeParam                   LookAtNodeParam_Spine1;                            // 0x0A90(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackLookAtNodeParam                   LookAtNodeParam_Spine2;                            // 0x0AB8(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackLookAtNodeParam                   LookAtNodeParam_Neck;                              // 0x0AE0(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackLookAtNodeParam                   LookAtNodeParam_Head;                              // 0x0B08(0x0028)(BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bHumanLookAtBones;                                 // 0x0B30(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B31[0x3];                                      // 0x0B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeLookAtWeight;                                   // 0x0B34(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeHorizontalAnimationFrame;                       // 0x0B38(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbsEyeHorizontalWeight;                            // 0x0B3C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeVerticalAnimationFrame;                         // 0x0B40(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AbsEyeVerticalWeight;                              // 0x0B44(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FA_Up_Eye_Vertical_Value;                          // 0x0B48(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FA_Up_Eye_Vertical_AbsValue;                       // 0x0B4C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPositive_FA_Up_Eye_Vertical;                      // 0x0B50(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B51[0x3];                                      // 0x0B51(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FA_Up_Eye_Horizontal_Value;                        // 0x0B54(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FA_Up_Eye_Horizontal_AbsValue;                     // 0x0B58(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPositive_FA_Up_Eye_Horizontal;                    // 0x0B5C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHumanEyeLookAtBones;                              // 0x0B5D(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B5E[0x2];                                      // 0x0B5E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeLookAtWeightBlendTime;                          // 0x0B60(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         EyeLookAtWeightBlendInterpExp;                     // 0x0B64(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B68[0x70];                                     // 0x0B68(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallEvents(class FName FunctionName);
	void DebugInitializeAnimation();
	void GetArmIKParameter(struct FTransform* OutLeftArmFabrikEffector, struct FTransform* OutRightArmFabrikEffector, float* OutLeftArmFabrikAlpha, float* OutRightArmFabrikAlpha);
	bool GetDebugDrawBlendSpaceEvaluator();
	void GetScheduledNPCParameter(float* OutBlendSpaceRate1, float* OutBlendSpaceRate2, float* OutBlendSpaceRate3, float* OutBlendSpaceSpeed, float* OutAdditiveAnimationRate);
	bool GetUseSotredComponentSpacePoses();
	void HideBone(class FName BoneName, bool bHide, EPhysBodyOp PhysBodyOption);
	void InitializeAnimDynamicsState();
	void OnAnimationEnd(const class UAnimSequence* Sequence);
	void OnAnimationRewind(const class UAnimSequence* Sequence);
	void OnAttachObject();
	void OnCollisionSwitch(bool bEnable);
	void OnDetachObject();
	void OnFootIKAdvancedControl(bool bEnable, bool bAdjustMeshHeightEnable, bool bAdjustMeshHeightZero);
	void OnFootIKControl(bool bEnable);
	void OnLookAtModeSwitch(bool bSingle);
	void OnMeshVisibility(class FName ComponentName, bool bVisibility);
	void OnNPCInterruptControl(class UAnimSequenceBase* AnimBase, class FName RowName);
	void OnReplaceNPCTalkEndAnimation(class UAnimMontage* AnimMontage, bool bForceSkipAnimation);
	void OnSetExtraNPCCapsule(bool bEnable);
	void SetActorIgnoreCollision(EJackCharacterIgnoreCollisionPurpose Purpose, bool bNewActorIgnoreCollision);
	void SetCollisionIgnoreInPhysicsAsset(const class FName& BoneName, bool bIgnore);
	void SetDebugDrawBlendSpaceEvaluator(bool bEnable);
	void SetDebugDrawDynamicsAngularConstraint(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawDynamicsBonesAxis(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawDynamicsBonesName(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawDynamicsBonesSRT(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawDynamicsBoxExtents(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawDynamicsEnable(bool bEnable);
	void SetDebugDrawDynamicsPlanarLimits(class FName TargetSettingBoneName, int32 PlanarIndex, bool bEnable);
	void SetDebugDrawDynamicsSphericalLimits(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawFakeInertia(class FName TargetSettingBoneName, bool bEnable);
	void SetDebugDrawWind(class FName TargetSettingBoneName, bool bEnable);
	void SetForceNextAnimMontageBlendTime(float InForceBlendTime);
	void SetIgnoreUseControllerDesiredRotation(bool bIgnoreUseControllerDesiredRotation);
	void SetSkipWindEffectProcedure(bool bSkip);
	void SetUseSotredComponentSpacePoses(bool bUseSoredPose);
	void SyncVehicleABPParameter();
	bool TriggerEventInABP(class FName EventName);
	void UpdateDynamicBoneBlendWeight();

	bool CanChangeFromRemainingMotionCheckVehicle(float Remaining, float Left) const;
	class UAnimSequence* GetAdditionalFacePoseAnimation() const;
	bool GetBattleABPFlag(EJackBattleABPFlag ABPFlag) const;
	class UAnimSequence* GetCutSceneAdditionalFacePoseAnimation() const;
	class UAnimSequence* GetCutSceneFacePoseAnimation() const;
	float GetDamageAnimationApplyRate() const;
	bool GetDebugDrawDynamicsAngularConstraint(class FName TargetSettingBoneName) const;
	bool GetDebugDrawDynamicsBonesAxis(class FName TargetSettingBoneName) const;
	bool GetDebugDrawDynamicsBonesName(class FName TargetSettingBoneName) const;
	bool GetDebugDrawDynamicsBonesSRT(class FName TargetSettingBoneName) const;
	bool GetDebugDrawDynamicsBoxExtents(class FName TargetSettingBoneName) const;
	bool GetDebugDrawDynamicsEnable() const;
	bool GetDebugDrawDynamicsPlanarLimits(class FName TargetSettingBoneName, int32 PlanarIndex) const;
	bool GetDebugDrawDynamicsSphericalLimits(class FName TargetSettingBoneName) const;
	bool GetDebugDrawFakeInertia(class FName TargetSettingBoneName) const;
	bool GetDebugDrawWind(class FName TargetSettingBoneName) const;
	bool GetEnsureEvalAnimPerFrame() const;
	class UJackEyeLookAtComponent* GetEyeLookAtComponent() const;
	class UAnimSequence* GetFacePoseAnimation() const;
	class UJackFacialControlComponent* GetFacialControlComponent() const;
	struct FJackFootIKResult GetFootIKResult(class FName SocketName) const;
	float GetLookAtApplyRate() const;
	float GetLookAtApplySecondNodeRate() const;
	class UJackLookAtComponent* GetLookAtComponent() const;
	struct FVector GetLookAtInterpLocation() const;
	struct FVector GetLookAtInterpLocationNoLimit() const;
	float GetMatineeAdditiveAnimationApplyRate() const;
	float GetMatineeAnimationApplyRate() const;
	float GetMatineeBlendAnimationApplyRate() const;
	float GetMatineeCaptionBlendAnimationApplyRate() const;
	float GetMatineeMovementBlendApplyRate() const;
	class UBlendSpaceBase* GetMatineeMovementBlendSpace() const;
	float GetMatineeMovementBlendSpeedRate() const;
	float GetMatineeNodAnimationApplyRate() const;
	EJackVehicle GetRideVehicleId() const;
	class UJackRigidBodyComponent* GetRigidBodyComponent() const;
	void GetScheduledNPCParameterSpeedOnly(float* OutBlendSpaceSpeed) const;
	bool GetVehicleParameterBool(EJackVehicleParameterBool ID) const;
	bool GetVehicleParameterFlags(EJackVehicleParameterStateMachineFlags ID) const;
	float GetVehicleParameterFloat(EJackVehicleParameterFloat ID) const;
	bool IsCancelFrameControl() const;
	bool IsClosedEyesByBlink() const;
	bool IsCompatibleAnimMontage(const class UAnimMontage* InAnimMontage) const;
	bool IsCompatibleAnimSequence(const class UAnimSequence* InAnimSequence) const;
	bool IsFacialControlEnabled() const;
	bool IsFootIKEnabled() const;
	bool IsInTheAir() const;
	bool IsLookAtEnabled() const;
	bool IsMatineeControlled() const;
	bool IsSkipAnimDynamics() const;
	bool IsTurning() const;
	bool IsTurningLeft() const;
	bool IsTurningRight() const;
	bool IsValidAnimDynamicsBone(class FName TargetSettingBoneName) const;
	bool IsValidAnimExpressionBone(class FName TargetSettingBoneName) const;
	class AJackCharacter* TryGetJackCharacter() const;
	class AJackPlayableCharacter* TryGetJackPlayableCharacter() const;
	class UJackVehicleAnimInstance* TryGetJackVehicleAnimInstance() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimInstance">();
	}
	static class UJackAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackAnimInstance) == 0x000010, "Wrong alignment on UJackAnimInstance");
static_assert(sizeof(UJackAnimInstance) == 0x000BE0, "Wrong size on UJackAnimInstance");
static_assert(offsetof(UJackAnimInstance, AnimMontagesTable) == 0x000478, "Member 'UJackAnimInstance::AnimMontagesTable' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, DynamicAnimMontagesTable) == 0x000480, "Member 'UJackAnimInstance::DynamicAnimMontagesTable' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AdditiveAnimMontagesTable) == 0x000488, "Member 'UJackAnimInstance::AdditiveAnimMontagesTable' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AnimMontages) == 0x000490, "Member 'UJackAnimInstance::AnimMontages' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, WeaponStyleAnimMontageTables) == 0x0004A0, "Member 'UJackAnimInstance::WeaponStyleAnimMontageTables' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, DynamicAnimMontagesCache) == 0x0004F0, "Member 'UJackAnimInstance::DynamicAnimMontagesCache' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bCacheTurningState) == 0x000541, "Member 'UJackAnimInstance::bCacheTurningState' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, IgnoredAnimNotifyClasses) == 0x000598, "Member 'UJackAnimInstance::IgnoredAnimNotifyClasses' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, FacePoseAnimation) == 0x000748, "Member 'UJackAnimInstance::FacePoseAnimation' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AdditionalFacePoseAnimation) == 0x000750, "Member 'UJackAnimInstance::AdditionalFacePoseAnimation' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, CutSceneFacePoseAnimation) == 0x000758, "Member 'UJackAnimInstance::CutSceneFacePoseAnimation' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, CutSceneAdditionalFacePoseAnimation) == 0x000760, "Member 'UJackAnimInstance::CutSceneAdditionalFacePoseAnimation' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, DynamicsUpdateFlags) == 0x000768, "Member 'UJackAnimInstance::DynamicsUpdateFlags' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bHasAnimDynamics) == 0x000772, "Member 'UJackAnimInstance::bHasAnimDynamics' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, CachedArmIKComponent) == 0x000774, "Member 'UJackAnimInstance::CachedArmIKComponent' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, DynamicsCalcCache) == 0x000828, "Member 'UJackAnimInstance::DynamicsCalcCache' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Blink) == 0x00098C, "Member 'UJackAnimInstance::Frame_FA_Up_Blink' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_Adjust_Up) == 0x000990, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_Adjust_Up' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_Adjust_Down) == 0x000994, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_Adjust_Down' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_Shout) == 0x000998, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_Shout' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Default) == 0x00099C, "Member 'UJackAnimInstance::Frame_FA_Up_Default' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Default) == 0x0009A0, "Member 'UJackAnimInstance::Frame_FA_Low_Default' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_A) == 0x0009A4, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_A' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_I) == 0x0009A8, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_I' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Low_Mouth_U) == 0x0009AC, "Member 'UJackAnimInstance::Frame_FA_Low_Mouth_U' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Eye_Horizontal_Right) == 0x0009B0, "Member 'UJackAnimInstance::Frame_FA_Up_Eye_Horizontal_Right' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Eye_Horizontal_Left) == 0x0009B4, "Member 'UJackAnimInstance::Frame_FA_Up_Eye_Horizontal_Left' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Eye_Vertical_Up) == 0x0009B8, "Member 'UJackAnimInstance::Frame_FA_Up_Eye_Vertical_Up' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Frame_FA_Up_Eye_Vertical_Down) == 0x0009BC, "Member 'UJackAnimInstance::Frame_FA_Up_Eye_Vertical_Down' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bIsUpperFacialAnimStateNone) == 0x0009C0, "Member 'UJackAnimInstance::bIsUpperFacialAnimStateNone' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LeftEyeBlinkPoseWeight) == 0x0009C4, "Member 'UJackAnimInstance::LeftEyeBlinkPoseWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, RightEyeBlinkPoseWeight) == 0x0009C8, "Member 'UJackAnimInstance::RightEyeBlinkPoseWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, BlinkPoseEyeOffset) == 0x0009CC, "Member 'UJackAnimInstance::BlinkPoseEyeOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeCloseRate) == 0x0009D8, "Member 'UJackAnimInstance::EyeCloseRate' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bIsLowerFacialAnimStateNone) == 0x0009DC, "Member 'UJackAnimInstance::bIsLowerFacialAnimStateNone' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Emotion) == 0x0009E0, "Member 'UJackAnimInstance::Emotion' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AbsEmotion) == 0x0009E4, "Member 'UJackAnimInstance::AbsEmotion' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bPositiveEmotion) == 0x0009E8, "Member 'UJackAnimInstance::bPositiveEmotion' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, Tone) == 0x0009EC, "Member 'UJackAnimInstance::Tone' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LipSyncBlendWeight) == 0x0009F0, "Member 'UJackAnimInstance::LipSyncBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bRandomLipSyncRunning) == 0x0009F4, "Member 'UJackAnimInstance::bRandomLipSyncRunning' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LastPhraseVowel) == 0x0009F5, "Member 'UJackAnimInstance::LastPhraseVowel' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LipSyncBlendTime) == 0x0009F8, "Member 'UJackAnimInstance::LipSyncBlendTime' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, VowelSecondNoteBlendWeight) == 0x0009FC, "Member 'UJackAnimInstance::VowelSecondNoteBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, ManualLipSyncModeBlendWeight) == 0x000A00, "Member 'UJackAnimInstance::ManualLipSyncModeBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bFacialControlEnabled) == 0x000A04, "Member 'UJackAnimInstance::bFacialControlEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bHumanFace) == 0x000A05, "Member 'UJackAnimInstance::bHumanFace' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bCanLipSync) == 0x000A06, "Member 'UJackAnimInstance::bCanLipSync' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LeftArmFabrikAlpha) == 0x000A08, "Member 'UJackAnimInstance::LeftArmFabrikAlpha' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LeftArmFabrikEffectorTransform) == 0x000A10, "Member 'UJackAnimInstance::LeftArmFabrikEffectorTransform' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, RightArmFabrikAlpha) == 0x000A40, "Member 'UJackAnimInstance::RightArmFabrikAlpha' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, RightArmFabrikEffectorTransform) == 0x000A50, "Member 'UJackAnimInstance::RightArmFabrikEffectorTransform' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bArmIKEnabled) == 0x000A80, "Member 'UJackAnimInstance::bArmIKEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bHumanArm) == 0x000A81, "Member 'UJackAnimInstance::bHumanArm' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bFootIKEnabled) == 0x000A82, "Member 'UJackAnimInstance::bFootIKEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bLookAtEnabled) == 0x000A83, "Member 'UJackAnimInstance::bLookAtEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LookAtInterpLocation) == 0x000A84, "Member 'UJackAnimInstance::LookAtInterpLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LookAtNodeParam_Spine1) == 0x000A90, "Member 'UJackAnimInstance::LookAtNodeParam_Spine1' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LookAtNodeParam_Spine2) == 0x000AB8, "Member 'UJackAnimInstance::LookAtNodeParam_Spine2' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LookAtNodeParam_Neck) == 0x000AE0, "Member 'UJackAnimInstance::LookAtNodeParam_Neck' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, LookAtNodeParam_Head) == 0x000B08, "Member 'UJackAnimInstance::LookAtNodeParam_Head' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bHumanLookAtBones) == 0x000B30, "Member 'UJackAnimInstance::bHumanLookAtBones' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeLookAtWeight) == 0x000B34, "Member 'UJackAnimInstance::EyeLookAtWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeHorizontalAnimationFrame) == 0x000B38, "Member 'UJackAnimInstance::EyeHorizontalAnimationFrame' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AbsEyeHorizontalWeight) == 0x000B3C, "Member 'UJackAnimInstance::AbsEyeHorizontalWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeVerticalAnimationFrame) == 0x000B40, "Member 'UJackAnimInstance::EyeVerticalAnimationFrame' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, AbsEyeVerticalWeight) == 0x000B44, "Member 'UJackAnimInstance::AbsEyeVerticalWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, FA_Up_Eye_Vertical_Value) == 0x000B48, "Member 'UJackAnimInstance::FA_Up_Eye_Vertical_Value' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, FA_Up_Eye_Vertical_AbsValue) == 0x000B4C, "Member 'UJackAnimInstance::FA_Up_Eye_Vertical_AbsValue' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bPositive_FA_Up_Eye_Vertical) == 0x000B50, "Member 'UJackAnimInstance::bPositive_FA_Up_Eye_Vertical' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, FA_Up_Eye_Horizontal_Value) == 0x000B54, "Member 'UJackAnimInstance::FA_Up_Eye_Horizontal_Value' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, FA_Up_Eye_Horizontal_AbsValue) == 0x000B58, "Member 'UJackAnimInstance::FA_Up_Eye_Horizontal_AbsValue' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bPositive_FA_Up_Eye_Horizontal) == 0x000B5C, "Member 'UJackAnimInstance::bPositive_FA_Up_Eye_Horizontal' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, bHumanEyeLookAtBones) == 0x000B5D, "Member 'UJackAnimInstance::bHumanEyeLookAtBones' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeLookAtWeightBlendTime) == 0x000B60, "Member 'UJackAnimInstance::EyeLookAtWeightBlendTime' has a wrong offset!");
static_assert(offsetof(UJackAnimInstance, EyeLookAtWeightBlendInterpExp) == 0x000B64, "Member 'UJackAnimInstance::EyeLookAtWeightBlendInterpExp' has a wrong offset!");

// Class JackGame.JackRigidBodyComponent
// 0x0D60 (0x0F00 - 0x01A0)
#pragma pack(push, 0x1)
class alignas(0x10) UJackRigidBodyComponent : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x8];                                      // 0x01A0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackRigidBodyPhysicsBlendWeightInfo> PhysicsBlendWeightInfos;                           // 0x01A8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x78];                                     // 0x01B8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackAnimSimulationPartsInfo           AnimSimulationPartsInfos[0x7];                     // 0x0230(0x01B0)(Edit, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	class UDataTable*                             UpperAnimDynamicsStateTable;                       // 0x0E00(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             LowerAnimDynamicsStateTable;                       // 0x0E08(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             HairAnimDynamicsStateTable;                        // 0x0E10(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MantleAnimDynamicsStateTable;                      // 0x0E18(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             WindRandomizePresetTable;                          // 0x0E20(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             WindRandomizeVehiclePresetTable;                   // 0x0E28(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackAnimExp_DynamicsExpressionTables> DynamicsTableList;                                 // 0x0E30(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E40[0xB8];                                     // 0x0E40(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOnPredictedLODLevelChanged(class USkinnedMeshComponent* SkinndMeshComponent, int32 NewLODLevel, int32 MaxLODLevel);
	void IgnoreAnimDynamicsBlendWeightByAnimCurve(EJackDynamicBonePartsSlot Parts, EJackRigidBodyControlPurpose Purpose, bool bIgnore);
	void IgnoreAnimExpressionBlendWeightByAnimCurve(EJackDynamicBonePartsSlot Parts, EJackRigidBodyControlPurpose Purpose, bool bIgnore);
	void OnPredictedLODLevelChanged(class USkinnedMeshComponent* SkinndMeshComponent, int32 NewLODLevel, int32 MaxLODLevel);
	void OnSetupSkeletalMesh(class USkeletalMeshComponent* SkeletalMeshComponent);
	void SetAnimDynamicsBlendSpeed(EJackDynamicBonePartsSlot Parts, float BlendSpeed);
	void SetAnimDynamicsBlendWeight(EJackDynamicBonePartsSlot Parts, EJackRigidBodyControlPurpose Purpose, float BlendWeight);
	void SetAnimExpressionBlendSpeed(EJackDynamicBonePartsSlot Parts, float BlendSpeed);
	void SetAnimExpressionBlendWeight(EJackDynamicBonePartsSlot Parts, EJackRigidBodyControlPurpose Purpose, float BlendWeight);
	void SetPhysicsBlendWeightMultiplier(EJackRigidBodyControlPurpose Purpose, float Multiplier);

	float GetAnimDynamicsBlendSpeed(EJackDynamicBonePartsSlot Parts) const;
	float GetAnimDynamicsBlendWeight(EJackDynamicBonePartsSlot Parts) const;
	float GetAnimExpressionBlendSpeed(EJackDynamicBonePartsSlot Parts) const;
	float GetAnimExpressionBlendWeight(EJackDynamicBonePartsSlot Parts) const;
	float GetPhysicsBlendWeightMultiplier(EJackRigidBodyControlPurpose Purpose) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRigidBodyComponent">();
	}
	static class UJackRigidBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRigidBodyComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackRigidBodyComponent) == 0x000010, "Wrong alignment on UJackRigidBodyComponent");
static_assert(sizeof(UJackRigidBodyComponent) == 0x000F00, "Wrong size on UJackRigidBodyComponent");
static_assert(offsetof(UJackRigidBodyComponent, PhysicsBlendWeightInfos) == 0x0001A8, "Member 'UJackRigidBodyComponent::PhysicsBlendWeightInfos' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, AnimSimulationPartsInfos) == 0x000230, "Member 'UJackRigidBodyComponent::AnimSimulationPartsInfos' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, UpperAnimDynamicsStateTable) == 0x000E00, "Member 'UJackRigidBodyComponent::UpperAnimDynamicsStateTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, LowerAnimDynamicsStateTable) == 0x000E08, "Member 'UJackRigidBodyComponent::LowerAnimDynamicsStateTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, HairAnimDynamicsStateTable) == 0x000E10, "Member 'UJackRigidBodyComponent::HairAnimDynamicsStateTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, MantleAnimDynamicsStateTable) == 0x000E18, "Member 'UJackRigidBodyComponent::MantleAnimDynamicsStateTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, WindRandomizePresetTable) == 0x000E20, "Member 'UJackRigidBodyComponent::WindRandomizePresetTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, WindRandomizeVehiclePresetTable) == 0x000E28, "Member 'UJackRigidBodyComponent::WindRandomizeVehiclePresetTable' has a wrong offset!");
static_assert(offsetof(UJackRigidBodyComponent, DynamicsTableList) == 0x000E30, "Member 'UJackRigidBodyComponent::DynamicsTableList' has a wrong offset!");

// Class JackGame.JackAnimMontageWaiterComponent
// 0x00C8 (0x01F0 - 0x0128)
class UJackAnimMontageWaiterComponent final : public UActorComponent
{
public:
	bool                                          bPlayerMode;                                       // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0xC7];                                     // 0x0129(0x00C7)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddWaitAnim(class AJackCharacter* Character, const TArray<class FName>& ArrayOfAnimMontage);
	void Pause();
	void ResetWaitAnim();
	void Resume();
	void SetDisableWaiter(EJackWaiterDisablePurpose InType, bool bOn);
	void SetIdle(bool bInIdle);
	void SetSequencialMode(bool bOn, const TArray<float>& InSequenceSec);
	void SetWaitAnim(const TArray<class FName>& ArrayOfAnimMontage);
	void SetWaitSec(float WaitMinSec, float WaitMaxSec);
	void Start(bool bInOnlyNoMove);
	void Stop();

	bool HasAnim() const;
	bool IsNoWait() const;
	bool IsOnlyNoMove() const;
	bool IsPlayAnimMontage() const;
	bool IsTriggerPlayAnimMontageEnd() const;
	bool IsTriggerPlayAnimMontageStart() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimMontageWaiterComponent">();
	}
	static class UJackAnimMontageWaiterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimMontageWaiterComponent>();
	}
};
static_assert(alignof(UJackAnimMontageWaiterComponent) == 0x000008, "Wrong alignment on UJackAnimMontageWaiterComponent");
static_assert(sizeof(UJackAnimMontageWaiterComponent) == 0x0001F0, "Wrong size on UJackAnimMontageWaiterComponent");
static_assert(offsetof(UJackAnimMontageWaiterComponent, bPlayerMode) == 0x000128, "Member 'UJackAnimMontageWaiterComponent::bPlayerMode' has a wrong offset!");

// Class JackGame.JackUMGAnimBase
// 0x0020 (0x0058 - 0x0038)
class UJackUMGAnimBase : public UObject
{
public:
	class UJackUMGWidgetBase*                     Target;                                            // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UWidget*                                Panel;                                             // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimBase">();
	}
	static class UJackUMGAnimBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimBase>();
	}
};
static_assert(alignof(UJackUMGAnimBase) == 0x000008, "Wrong alignment on UJackUMGAnimBase");
static_assert(sizeof(UJackUMGAnimBase) == 0x000058, "Wrong size on UJackUMGAnimBase");
static_assert(offsetof(UJackUMGAnimBase, Target) == 0x000038, "Member 'UJackUMGAnimBase::Target' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimBase, Panel) == 0x000040, "Member 'UJackUMGAnimBase::Panel' has a wrong offset!");

// Class JackGame.JackAnimNotify
// 0x0000 (0x0048 - 0x0048)
class UJackAnimNotify : public UAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify">();
	}
	static class UJackAnimNotify* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify>();
	}
};
static_assert(alignof(UJackAnimNotify) == 0x000008, "Wrong alignment on UJackAnimNotify");
static_assert(sizeof(UJackAnimNotify) == 0x000048, "Wrong size on UJackAnimNotify");

// Class JackGame.JackUMGWindowBase
// 0x0090 (0x0400 - 0x0370)
class UJackUMGWindowBase : public UJackUMGWidgetBase
{
public:
	TSubclassOf<class UJackUMGWidgetBase>         CursorAsset;                                       // 0x0370(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInFocus;                                        // 0x0378(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_379[0x7];                                      // 0x0379(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemBase*>               SelectItemList;                                    // 0x0380(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemBase*>               SelectStaticItemList;                              // 0x0390(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UJackUMGItemBase*                       SelectedItem;                                      // 0x03A0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGItemBase*                       InFocusEventItem;                                  // 0x03A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UWidget*                                SelectedHighlightPanel;                            // 0x03B0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGWidgetBase*                     CursorWidget;                                      // 0x03B8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGWindowCursorMoveMode                  CursorHorizontalMoveMode;                          // 0x03C0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGWindowCursorMoveMode                  CursorHorizontalLoopMode;                          // 0x03C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGWindowCursorMoveMode                  CursorVerticalMoveMode;                            // 0x03C2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGWindowCursorMoveMode                  CursorVerticalLoopMode;                            // 0x03C3(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnItemListControlEvent;                            // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         CursorZOrderOffset;                                // 0x03D8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CursorFindAngle;                                   // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGMenuBGMode                            MenuBGMode;                                        // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E1[0xF];                                      // 0x03E1(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGCursorMoveSetting>      CursorMoveSettingList;                             // 0x03F0(0x0010)(ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	void AddCursorMoveSetting(const struct FJackUMGCursorMoveSetting& Data);
	void AddStaticItemList(class UJackUMGItemBase* InItemBase);
	void DoCancelBySelectedItem();
	void DoEnterBySelectedItem();
	void DoItemListControlEvent(const class FName& InEventTag, class UJackUMGItemBase* InItemBase);
	void EmptyCursorMoveSetting();
	void EmptyStaticItemList();
	void FinishShowWindowDelegate();
	void InitWindow(class UCanvasPanel* ItemListCanvas, int32 ZOrder);
	void JackOnItemListControlEventDelegate__DelegateSignature(class FName EventName, class UJackUMGItemBase* InItemBase);
	bool MoveCursor(int32 Direction, const struct FJackKeyStatus& InKey);
	void OnDidNotMoveCursor(class UJackUMGItemBase* InSelectedItem, int32 MoveDirection);
	void SelectItemFromId(const class FName ItemID);
	void SelectItemFromIndex(int32 Index_0);
	void SelectItemFromRef(class UJackUMGItemBase* Item);
	void SelectItemFromTextId(const class FName TextID);
	void SetActivateItemList(bool IsActivate, const class UJackUMGItemBase* HiliteItem);
	void SetCursorMoveMode(EJackUMGWindowCursorMoveMode InHorizontalMoveMode, EJackUMGWindowCursorMoveMode InHorizontalLoopMode, EJackUMGWindowCursorMoveMode InVerticalMoveMode, EJackUMGWindowCursorMoveMode InVerticalLoopMode);
	void SetCursorOffsetOfAllItemBase(const struct FVector2D& InOffset);
	void SetItemList(class UCanvasPanel* InItemListCanvas, class UJackUMGItemBase* InItemBase);
	void SetSelectedHighlightPanel(class UWidget* InHighlightPanel);
	void SetTextureOfPanelWithResize(class UTexture2D* InTexture, class UImage* InImagePanel, class UCanvasPanel* InFramePanel);
	void SetVisibleAllItem(bool InIsVisible);
	void UpdateCursorPosition();

	class UJackUMGItemBase* GetItemFromId(const class FName ItemID) const;
	class UJackUMGItemBase* GetItemFromTextId(const class FName TextID) const;
	int32 GetNumSelectItem() const;
	class UJackUMGItemBase* GetSelectedItem() const;
	float GetVisibleBottomFromItemList(bool bIsIgnoreVisibilty) const;
	class UJackUMGItemBase* GetVisibleBottomItemBase(bool bIsIgnoreVisibilty) const;
	const struct FVector2D GetVisibleSizeFromItemList() const;
	bool IsEmptyItemList() const;
	bool IsSelectiveItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWindowBase">();
	}
	static class UJackUMGWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWindowBase>();
	}
};
static_assert(alignof(UJackUMGWindowBase) == 0x000008, "Wrong alignment on UJackUMGWindowBase");
static_assert(sizeof(UJackUMGWindowBase) == 0x000400, "Wrong size on UJackUMGWindowBase");
static_assert(offsetof(UJackUMGWindowBase, CursorAsset) == 0x000370, "Member 'UJackUMGWindowBase::CursorAsset' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, bIsInFocus) == 0x000378, "Member 'UJackUMGWindowBase::bIsInFocus' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, SelectItemList) == 0x000380, "Member 'UJackUMGWindowBase::SelectItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, SelectStaticItemList) == 0x000390, "Member 'UJackUMGWindowBase::SelectStaticItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, SelectedItem) == 0x0003A0, "Member 'UJackUMGWindowBase::SelectedItem' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, InFocusEventItem) == 0x0003A8, "Member 'UJackUMGWindowBase::InFocusEventItem' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, SelectedHighlightPanel) == 0x0003B0, "Member 'UJackUMGWindowBase::SelectedHighlightPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorWidget) == 0x0003B8, "Member 'UJackUMGWindowBase::CursorWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorHorizontalMoveMode) == 0x0003C0, "Member 'UJackUMGWindowBase::CursorHorizontalMoveMode' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorHorizontalLoopMode) == 0x0003C1, "Member 'UJackUMGWindowBase::CursorHorizontalLoopMode' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorVerticalMoveMode) == 0x0003C2, "Member 'UJackUMGWindowBase::CursorVerticalMoveMode' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorVerticalLoopMode) == 0x0003C3, "Member 'UJackUMGWindowBase::CursorVerticalLoopMode' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, OnItemListControlEvent) == 0x0003C8, "Member 'UJackUMGWindowBase::OnItemListControlEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorZOrderOffset) == 0x0003D8, "Member 'UJackUMGWindowBase::CursorZOrderOffset' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorFindAngle) == 0x0003DC, "Member 'UJackUMGWindowBase::CursorFindAngle' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, MenuBGMode) == 0x0003E0, "Member 'UJackUMGWindowBase::MenuBGMode' has a wrong offset!");
static_assert(offsetof(UJackUMGWindowBase, CursorMoveSettingList) == 0x0003F0, "Member 'UJackUMGWindowBase::CursorMoveSettingList' has a wrong offset!");

// Class JackGame.JackUMGBrowserBase
// 0x0030 (0x0430 - 0x0400)
class UJackUMGBrowserBase : public UJackUMGWindowBase
{
public:
	class UJackUMGListController*                 ListController;                                    // 0x0400(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               ItemDataList;                                      // 0x0408(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_418[0x4];                                      // 0x0418(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsBPUpdateMode;                                   // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              AdjustRootSize;                                    // 0x0420(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_428[0x8];                                      // 0x0428(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustWindowSize(class UWidget* WindowFramePanel, float Magin, bool bIsIgnoreVisibilty);
	void AdjustWindowSizeWithPanel(class UWidget* InWindowFramePanel, float InFrameMagin, class UWidget* InAdjustPanel, float InPanelMagin, bool bIsIgnoreVisibilty);
	void AdjustWindowSizeWithPanelOnly(const TArray<class UWidget*>& InVisiblePanels, const TArray<class UWidget*>& InWindowFramePanels, int32 InSelectIndex, float InFrameMagin, bool bIsIgnoreVisibilty);
	void AdjustWindowSizeWithPanelSwitch(class UWidget* InFalseVisiblePanel, class UWidget* InTrueVisiblePanel, class UWidget* InFalseFramePanel, class UWidget* InTrueFramePanel, bool InSelectValue, float InFrameMagin, bool bIsIgnoreVisibilty);
	void ClearItemDataList();
	void ClearNewFlag();
	class UJackUMGItemData* CreateItemData(int32 InDataIndex, const class FName InItemId, const class FName InTextId);
	void DispItemList(int32 InPage);
	void DispItemList2(int32 InPage, int32 Index_0);
	void DispItemListFromId(const class FName ItemID, bool bIsForceUpdate);
	void DispItemListFromIndex(int32 InDataIndex, bool bIsForceUpdate);
	void DispItemListFromIndex2(int32 InDataIndex, bool bIsForceUpdate);
	void DoControllerKeyEvent(EJackKeys InKeyType);
	void DoNotificationItemBase(const class FName InNotifyTag, class UObject* InObject, int32 InValue, bool bIsAllItamBase);
	void FinishShowBrowserDelegate();
	TArray<class UJackUMGItemData*> GetItemListForUpdating();
	void InitBrowser(class UCanvasPanel* ItemListCanvas, class UJackUMGPageController* InPageController, int32 ZOrder);
	void InitBrowserWithPageController(class UCanvasPanel* ItemListCanvas, class UJackUMGPageController* InListController, int32 ZOrder);
	void InitBrowserWithScrollController(class UCanvasPanel* ItemListCanvas, class UJackUMGScrollController* InListController, int32 ZOrder);
	void RedrawItemList();
	void SetDisableKeyEventFlag(bool InFlag);
	void SetItemDataList(const TArray<class UJackUMGItemData*>& InItemDataList);
	void SetItemDataListWithDispIndex(const TArray<class UJackUMGItemData*>& InItemDataList, int32 DispIndex);
	void SetNumListItemsPerPage(int32 InItemsPerPage);
	void SetupPageController(int32 InInitPage, int32 InItemsPerPage, int32 InNumData);
	void SetupScrollController(int32 InInitPage, int32 InItemsPerPage, int32 InNumData);
	void SetVisibilityListController(bool IsVisible_0);
	void UpdateItemBase(class UJackUMGItemBase* InItemBase);
	void UpdateItemDataList(const TArray<class UJackUMGItemData*>& InItemDataList);
	void UpdateItemDataListWithDispIndex(int32 DispIndex);

	int32 GetCurrentPage() const;
	int32 GetDispEndIndex() const;
	int32 GetDispTopIndex() const;
	const struct FJackUMGItemContainer GetItemContainer(const class FName InContainerTag) const;
	const struct FJackUMGItemContainer GetItemContainerFromDataNumber(int32 DataNumber, const class FName InContainerTag) const;
	const struct FJackUMGItemContainer GetItemContainerFromSelected(const class FName InContainerTag, bool bAllowNoDataTag) const;
	class UJackUMGItemData* GetItemDataFromSelected() const;
	int32 GetItemsPerPage() const;
	int32 GetNumPage() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGBrowserBase">();
	}
	static class UJackUMGBrowserBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGBrowserBase>();
	}
};
static_assert(alignof(UJackUMGBrowserBase) == 0x000008, "Wrong alignment on UJackUMGBrowserBase");
static_assert(sizeof(UJackUMGBrowserBase) == 0x000430, "Wrong size on UJackUMGBrowserBase");
static_assert(offsetof(UJackUMGBrowserBase, ListController) == 0x000400, "Member 'UJackUMGBrowserBase::ListController' has a wrong offset!");
static_assert(offsetof(UJackUMGBrowserBase, ItemDataList) == 0x000408, "Member 'UJackUMGBrowserBase::ItemDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGBrowserBase, bIsBPUpdateMode) == 0x00041C, "Member 'UJackUMGBrowserBase::bIsBPUpdateMode' has a wrong offset!");
static_assert(offsetof(UJackUMGBrowserBase, AdjustRootSize) == 0x000420, "Member 'UJackUMGBrowserBase::AdjustRootSize' has a wrong offset!");

// Class JackGame.JackUMGVoiceDramaSelectStaffList
// 0x0010 (0x0440 - 0x0430)
class UJackUMGVoiceDramaSelectStaffList final : public UJackUMGBrowserBase
{
public:
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	const TArray<class UJackUMGItemData*> GetStaffListData();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGVoiceDramaSelectStaffList">();
	}
	static class UJackUMGVoiceDramaSelectStaffList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGVoiceDramaSelectStaffList>();
	}
};
static_assert(alignof(UJackUMGVoiceDramaSelectStaffList) == 0x000008, "Wrong alignment on UJackUMGVoiceDramaSelectStaffList");
static_assert(sizeof(UJackUMGVoiceDramaSelectStaffList) == 0x000440, "Wrong size on UJackUMGVoiceDramaSelectStaffList");

// Class JackGame.JackAnimNotify_ActionHit
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotify_ActionHit final : public UJackAnimNotify
{
public:
	bool                                          bUseMonsterDefaultHitSub;                          // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_ActionHit">();
	}
	static class UJackAnimNotify_ActionHit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_ActionHit>();
	}
};
static_assert(alignof(UJackAnimNotify_ActionHit) == 0x000008, "Wrong alignment on UJackAnimNotify_ActionHit");
static_assert(sizeof(UJackAnimNotify_ActionHit) == 0x000050, "Wrong size on UJackAnimNotify_ActionHit");
static_assert(offsetof(UJackAnimNotify_ActionHit, bUseMonsterDefaultHitSub) == 0x000048, "Member 'UJackAnimNotify_ActionHit::bUseMonsterDefaultHitSub' has a wrong offset!");

// Class JackGame.JackRouletteBetData
// 0x0050 (0x0088 - 0x0038)
class UJackRouletteBetData final : public UObject
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRouletteBetData">();
	}
	static class UJackRouletteBetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRouletteBetData>();
	}
};
static_assert(alignof(UJackRouletteBetData) == 0x000008, "Wrong alignment on UJackRouletteBetData");
static_assert(sizeof(UJackRouletteBetData) == 0x000088, "Wrong size on UJackRouletteBetData");

// Class JackGame.JackAnimNotify_AttachComponent
// 0x0018 (0x0060 - 0x0048)
class UJackAnimNotify_AttachComponent final : public UJackAnimNotify
{
public:
	class FName                                   ComponentName;                                     // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EAttachLocation                               AttachLocationType;                                // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_AttachComponent">();
	}
	static class UJackAnimNotify_AttachComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_AttachComponent>();
	}
};
static_assert(alignof(UJackAnimNotify_AttachComponent) == 0x000008, "Wrong alignment on UJackAnimNotify_AttachComponent");
static_assert(sizeof(UJackAnimNotify_AttachComponent) == 0x000060, "Wrong size on UJackAnimNotify_AttachComponent");
static_assert(offsetof(UJackAnimNotify_AttachComponent, ComponentName) == 0x000048, "Member 'UJackAnimNotify_AttachComponent::ComponentName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_AttachComponent, SocketName) == 0x000050, "Member 'UJackAnimNotify_AttachComponent::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_AttachComponent, AttachLocationType) == 0x000058, "Member 'UJackAnimNotify_AttachComponent::AttachLocationType' has a wrong offset!");

// Class JackGame.JackUMGAnimAlpha
// 0x0010 (0x0068 - 0x0058)
class UJackUMGAnimAlpha final : public UJackUMGAnimBase
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimAlpha">();
	}
	static class UJackUMGAnimAlpha* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimAlpha>();
	}
};
static_assert(alignof(UJackUMGAnimAlpha) == 0x000008, "Wrong alignment on UJackUMGAnimAlpha");
static_assert(sizeof(UJackUMGAnimAlpha) == 0x000068, "Wrong size on UJackUMGAnimAlpha");
static_assert(offsetof(UJackUMGAnimAlpha, Curve) == 0x000058, "Member 'UJackUMGAnimAlpha::Curve' has a wrong offset!");

// Class JackGame.JackAnimNotify_CancelLatentAction
// 0x0000 (0x0048 - 0x0048)
class UJackAnimNotify_CancelLatentAction final : public UJackAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_CancelLatentAction">();
	}
	static class UJackAnimNotify_CancelLatentAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_CancelLatentAction>();
	}
};
static_assert(alignof(UJackAnimNotify_CancelLatentAction) == 0x000008, "Wrong alignment on UJackAnimNotify_CancelLatentAction");
static_assert(sizeof(UJackAnimNotify_CancelLatentAction) == 0x000048, "Wrong size on UJackAnimNotify_CancelLatentAction");

// Class JackGame.JackAnimNotify_Command
// 0x0018 (0x0060 - 0x0048)
class UJackAnimNotify_Command final : public UJackAnimNotify
{
public:
	class FName                                   CommandName;                                       // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Parameters;                                        // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_Command">();
	}
	static class UJackAnimNotify_Command* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_Command>();
	}
};
static_assert(alignof(UJackAnimNotify_Command) == 0x000008, "Wrong alignment on UJackAnimNotify_Command");
static_assert(sizeof(UJackAnimNotify_Command) == 0x000060, "Wrong size on UJackAnimNotify_Command");
static_assert(offsetof(UJackAnimNotify_Command, CommandName) == 0x000048, "Member 'UJackAnimNotify_Command::CommandName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_Command, Parameters) == 0x000050, "Member 'UJackAnimNotify_Command::Parameters' has a wrong offset!");

// Class JackGame.JackWeaponBase
// 0x0048 (0x03E0 - 0x0398)
class AJackWeaponBase : public AActor
{
public:
	class AJackCharacter*                         OwnerCharacter;                                    // 0x0398(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponUnsheatheSocket;                             // 0x03A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   WeaponSheatheSocket;                               // 0x03A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHiddenOnSheathe;                                  // 0x03B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              EquipSound;                                        // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackItem_Classification                      ItemClassification;                                // 0x03C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackEquipmentRegion                          EquipmentRegion;                                   // 0x03C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C2[0xE];                                      // 0x03C2(0x000E)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackDitherHideComponent*               DitherHideComponent;                               // 0x03D0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         DefaultDitherTime;                                 // 0x03D8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnWeaponClose();
	void OnWeaponHidden(bool bNewHidden);
	void OnWeaponOpen();
	void SetDitherHiddenByCurve(EJackHideCompoHiddenPurpose InPurpose, bool bInHidden, class UCurveBase* InCurve);
	void SetDitherHiddenByTime(EJackHideCompoHiddenPurpose InPurpose, bool bInHidden, float InSeconds);
	void SetHiddenControl(EJackWeaponHiddenPurpose Purpose, bool bNewHidden);
	void SetSheatheStatus(EJackSheatheStatus SheatheStatus);

	class AJackCharacter* GetOwnerCharacter() const;
	bool IsHiddenControl(EJackWeaponHiddenPurpose Purpose) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponBase">();
	}
	static class AJackWeaponBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponBase>();
	}
};
static_assert(alignof(AJackWeaponBase) == 0x000008, "Wrong alignment on AJackWeaponBase");
static_assert(sizeof(AJackWeaponBase) == 0x0003E0, "Wrong size on AJackWeaponBase");
static_assert(offsetof(AJackWeaponBase, OwnerCharacter) == 0x000398, "Member 'AJackWeaponBase::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, WeaponUnsheatheSocket) == 0x0003A0, "Member 'AJackWeaponBase::WeaponUnsheatheSocket' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, WeaponSheatheSocket) == 0x0003A8, "Member 'AJackWeaponBase::WeaponSheatheSocket' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, bHiddenOnSheathe) == 0x0003B0, "Member 'AJackWeaponBase::bHiddenOnSheathe' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, EquipSound) == 0x0003B8, "Member 'AJackWeaponBase::EquipSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, ItemClassification) == 0x0003C0, "Member 'AJackWeaponBase::ItemClassification' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, EquipmentRegion) == 0x0003C1, "Member 'AJackWeaponBase::EquipmentRegion' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, DitherHideComponent) == 0x0003D0, "Member 'AJackWeaponBase::DitherHideComponent' has a wrong offset!");
static_assert(offsetof(AJackWeaponBase, DefaultDitherTime) == 0x0003D8, "Member 'AJackWeaponBase::DefaultDitherTime' has a wrong offset!");

// Class JackGame.JackWeaponSK
// 0x0028 (0x0408 - 0x03E0)
class AJackWeaponSK : public AJackWeaponBase
{
public:
	class USkeletalMeshComponent*                 WeaponMeshComp;                                    // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimMontage*                           EquipAnim;                                         // 0x03E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x8];                                      // 0x03F0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           CurrentAnimMontage;                                // 0x03F8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_400[0x8];                                      // 0x0400(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponSK">();
	}
	static class AJackWeaponSK* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponSK>();
	}
};
static_assert(alignof(AJackWeaponSK) == 0x000008, "Wrong alignment on AJackWeaponSK");
static_assert(sizeof(AJackWeaponSK) == 0x000408, "Wrong size on AJackWeaponSK");
static_assert(offsetof(AJackWeaponSK, WeaponMeshComp) == 0x0003E0, "Member 'AJackWeaponSK::WeaponMeshComp' has a wrong offset!");
static_assert(offsetof(AJackWeaponSK, EquipAnim) == 0x0003E8, "Member 'AJackWeaponSK::EquipAnim' has a wrong offset!");
static_assert(offsetof(AJackWeaponSK, CurrentAnimMontage) == 0x0003F8, "Member 'AJackWeaponSK::CurrentAnimMontage' has a wrong offset!");

// Class JackGame.JackWeaponBullet
// 0x00B0 (0x04B8 - 0x0408)
class AJackWeaponBullet final : public AJackWeaponSK
{
public:
	class FName                                   MuzzleSocket;                                      // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackBulletWeaponConfig                BulletWeaponConfig;                                // 0x0410(0x0028)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	class UAnimMontage*                           FireAnim;                                          // 0x0438(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopedFireAnim;                                   // 0x0440(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           ReloadAnim;                                        // 0x0448(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               FireCameraShake;                                   // 0x0450(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   FireForceFeedback;                                 // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystem*                        MuzzleEffect;                                      // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopedMuzzleEffect;                               // 0x0468(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_469[0x7];                                      // 0x0469(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              FireSound;                                         // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLoopedFireSound;                                  // 0x0478(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_479[0x7];                                      // 0x0479(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundCue*                              FireLoopSound;                                     // 0x0480(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              FireFinishSound;                                   // 0x0488(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundCue*                              ReloadSound;                                       // 0x0490(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               MuzzlePSC;                                         // 0x04A0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FireAudioComp;                                     // 0x04A8(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B0[0x8];                                      // 0x04B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Fire();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponBullet">();
	}
	static class AJackWeaponBullet* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponBullet>();
	}
};
static_assert(alignof(AJackWeaponBullet) == 0x000008, "Wrong alignment on AJackWeaponBullet");
static_assert(sizeof(AJackWeaponBullet) == 0x0004B8, "Wrong size on AJackWeaponBullet");
static_assert(offsetof(AJackWeaponBullet, MuzzleSocket) == 0x000408, "Member 'AJackWeaponBullet::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, BulletWeaponConfig) == 0x000410, "Member 'AJackWeaponBullet::BulletWeaponConfig' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireAnim) == 0x000438, "Member 'AJackWeaponBullet::FireAnim' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, bLoopedFireAnim) == 0x000440, "Member 'AJackWeaponBullet::bLoopedFireAnim' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, ReloadAnim) == 0x000448, "Member 'AJackWeaponBullet::ReloadAnim' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireCameraShake) == 0x000450, "Member 'AJackWeaponBullet::FireCameraShake' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireForceFeedback) == 0x000458, "Member 'AJackWeaponBullet::FireForceFeedback' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, MuzzleEffect) == 0x000460, "Member 'AJackWeaponBullet::MuzzleEffect' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, bLoopedMuzzleEffect) == 0x000468, "Member 'AJackWeaponBullet::bLoopedMuzzleEffect' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireSound) == 0x000470, "Member 'AJackWeaponBullet::FireSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, bLoopedFireSound) == 0x000478, "Member 'AJackWeaponBullet::bLoopedFireSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireLoopSound) == 0x000480, "Member 'AJackWeaponBullet::FireLoopSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireFinishSound) == 0x000488, "Member 'AJackWeaponBullet::FireFinishSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, ReloadSound) == 0x000490, "Member 'AJackWeaponBullet::ReloadSound' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, MuzzlePSC) == 0x0004A0, "Member 'AJackWeaponBullet::MuzzlePSC' has a wrong offset!");
static_assert(offsetof(AJackWeaponBullet, FireAudioComp) == 0x0004A8, "Member 'AJackWeaponBullet::FireAudioComp' has a wrong offset!");

// Class JackGame.JackGamePlayerCondition
// 0x01A8 (0x01E0 - 0x0038)
class UJackGamePlayerCondition final : public UObject
{
public:
	uint8                                         Pad_38[0x130];                                     // 0x0038(0x0130)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPossessPlayerControlDelegate;                    // 0x0168(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUnpossessPlayerControlDelegate;                  // 0x0178(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_188[0x10];                                     // 0x0188(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ToherosuLeftSec;                                   // 0x0198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeisuiLeftSec;                                     // 0x019C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToherosuRange;                                     // 0x01A0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ToherosuMaxSec;                                    // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShipToherosuSecRate;                               // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SeisuiMaxSec;                                      // 0x01AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ShipSeisuiSecRate;                                 // 0x01B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0x24];                                     // 0x01B4(0x0024)(Fixing Size After Last Property [ Dumper-7 ])
	EJackVehicle                                  RidingVehicleType;                                 // 0x01D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackVehicleModelId                           RidingVehicleModelType;                            // 0x01D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackPlayerControlCharacter                   PlayerControlCharacter;                            // 0x01DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackHeroCharacterForm                        HeroCharacterForm;                                 // 0x01DB(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackWhaleCharacterForm                       WhaleCharacterForm;                                // 0x01DC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackSenaHairStyle                            SenaHairStyle;                                     // 0x01DD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1DE[0x2];                                      // 0x01DE(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ConditionChangedSignature__DelegateSignature(bool bNewCondition);
	void OnPossessPlayerControlDelegate__DelegateSignature(EJackPlayerControlPossessor Possessor);
	void OnUnpossessPlayerControlDelegate__DelegateSignature();
	void SetCondition(EJackGamePlayerCondition InCondition, EJackGamePlayerConditionControlPurpose InPurpose, bool bTrue);
	void SetMenuCursorOnInpasu(bool bOn);
	void SetSeisui(bool bOn, bool bNoMessage);
	void SetToherosu(bool bOn, bool bNoMessage);

	bool IsCondition(EJackGamePlayerCondition InCondition) const;
	bool IsOugonNoTsume() const;
	bool IsRideMaidenDoll() const;
	bool IsSeisui() const;
	bool IsStealth() const;
	bool IsToherosu() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGamePlayerCondition">();
	}
	static class UJackGamePlayerCondition* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGamePlayerCondition>();
	}
};
static_assert(alignof(UJackGamePlayerCondition) == 0x000008, "Wrong alignment on UJackGamePlayerCondition");
static_assert(sizeof(UJackGamePlayerCondition) == 0x0001E0, "Wrong size on UJackGamePlayerCondition");
static_assert(offsetof(UJackGamePlayerCondition, OnPossessPlayerControlDelegate) == 0x000168, "Member 'UJackGamePlayerCondition::OnPossessPlayerControlDelegate' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, OnUnpossessPlayerControlDelegate) == 0x000178, "Member 'UJackGamePlayerCondition::OnUnpossessPlayerControlDelegate' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, ToherosuLeftSec) == 0x000198, "Member 'UJackGamePlayerCondition::ToherosuLeftSec' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, SeisuiLeftSec) == 0x00019C, "Member 'UJackGamePlayerCondition::SeisuiLeftSec' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, ToherosuRange) == 0x0001A0, "Member 'UJackGamePlayerCondition::ToherosuRange' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, ToherosuMaxSec) == 0x0001A4, "Member 'UJackGamePlayerCondition::ToherosuMaxSec' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, ShipToherosuSecRate) == 0x0001A8, "Member 'UJackGamePlayerCondition::ShipToherosuSecRate' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, SeisuiMaxSec) == 0x0001AC, "Member 'UJackGamePlayerCondition::SeisuiMaxSec' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, ShipSeisuiSecRate) == 0x0001B0, "Member 'UJackGamePlayerCondition::ShipSeisuiSecRate' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, RidingVehicleType) == 0x0001D8, "Member 'UJackGamePlayerCondition::RidingVehicleType' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, RidingVehicleModelType) == 0x0001D9, "Member 'UJackGamePlayerCondition::RidingVehicleModelType' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, PlayerControlCharacter) == 0x0001DA, "Member 'UJackGamePlayerCondition::PlayerControlCharacter' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, HeroCharacterForm) == 0x0001DB, "Member 'UJackGamePlayerCondition::HeroCharacterForm' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, WhaleCharacterForm) == 0x0001DC, "Member 'UJackGamePlayerCondition::WhaleCharacterForm' has a wrong offset!");
static_assert(offsetof(UJackGamePlayerCondition, SenaHairStyle) == 0x0001DD, "Member 'UJackGamePlayerCondition::SenaHairStyle' has a wrong offset!");

// Class JackGame.JackAnimNotify_CoordSoundType
// 0x0020 (0x0068 - 0x0048)
class UJackAnimNotify_CoordSoundType final : public UJackAnimNotify
{
public:
	EJackCoordSound                               CoordSoundType;                                    // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundPitch;                                        // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableInGame;                                // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableCutScene;                              // 0x0061(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAttached;                                       // 0x0062(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_CoordSoundType">();
	}
	static class UJackAnimNotify_CoordSoundType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_CoordSoundType>();
	}
};
static_assert(alignof(UJackAnimNotify_CoordSoundType) == 0x000008, "Wrong alignment on UJackAnimNotify_CoordSoundType");
static_assert(sizeof(UJackAnimNotify_CoordSoundType) == 0x000068, "Wrong size on UJackAnimNotify_CoordSoundType");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, CoordSoundType) == 0x000048, "Member 'UJackAnimNotify_CoordSoundType::CoordSoundType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, SocketName) == 0x000050, "Member 'UJackAnimNotify_CoordSoundType::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, SoundVolume) == 0x000058, "Member 'UJackAnimNotify_CoordSoundType::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, SoundPitch) == 0x00005C, "Member 'UJackAnimNotify_CoordSoundType::SoundPitch' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, bSoundEnableInGame) == 0x000060, "Member 'UJackAnimNotify_CoordSoundType::bSoundEnableInGame' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, bSoundEnableCutScene) == 0x000061, "Member 'UJackAnimNotify_CoordSoundType::bSoundEnableCutScene' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_CoordSoundType, bIsAttached) == 0x000062, "Member 'UJackAnimNotify_CoordSoundType::bIsAttached' has a wrong offset!");

// Class JackGame.JackAnimNotify_EquipAttachChange
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotify_EquipAttachChange final : public UJackAnimNotify
{
public:
	EJackEquippedHand                             EquippedHand;                                      // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEquippedStatus;                                // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackSheatheStatus                            EquippedStatus;                                    // 0x004A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHiddenChangeOnlyUnsheathe;                        // 0x004B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHidden;                                           // 0x004C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DitherTime;                                        // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestartDither;                                    // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_EquipAttachChange">();
	}
	static class UJackAnimNotify_EquipAttachChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_EquipAttachChange>();
	}
};
static_assert(alignof(UJackAnimNotify_EquipAttachChange) == 0x000008, "Wrong alignment on UJackAnimNotify_EquipAttachChange");
static_assert(sizeof(UJackAnimNotify_EquipAttachChange) == 0x000058, "Wrong size on UJackAnimNotify_EquipAttachChange");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, EquippedHand) == 0x000048, "Member 'UJackAnimNotify_EquipAttachChange::EquippedHand' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, bUseEquippedStatus) == 0x000049, "Member 'UJackAnimNotify_EquipAttachChange::bUseEquippedStatus' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, EquippedStatus) == 0x00004A, "Member 'UJackAnimNotify_EquipAttachChange::EquippedStatus' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, bHiddenChangeOnlyUnsheathe) == 0x00004B, "Member 'UJackAnimNotify_EquipAttachChange::bHiddenChangeOnlyUnsheathe' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, bHidden) == 0x00004C, "Member 'UJackAnimNotify_EquipAttachChange::bHidden' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, DitherTime) == 0x000050, "Member 'UJackAnimNotify_EquipAttachChange::DitherTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_EquipAttachChange, bRestartDither) == 0x000054, "Member 'UJackAnimNotify_EquipAttachChange::bRestartDither' has a wrong offset!");

// Class JackGame.JackPlayerController
// 0x01F0 (0x0930 - 0x0740)
class AJackPlayerController : public APlayerController
{
public:
	uint8                                         Pad_740[0x28];                                     // 0x0740(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackActionCursorControllerComponent*   CachedActionCursorControllerComponent;             // 0x0768(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   ReceiveMoveCompleted;                              // 0x0770(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_780[0x20];                                     // 0x0780(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               InitialControlRotation;                            // 0x07A0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ControlRotationInertia;                            // 0x07AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7B0[0xE0];                                     // 0x07B0(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AutoRunCancelThreshould;                           // 0x0890(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_894[0x9C];                                     // 0x0894(0x009C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DisableIndoorCamera(bool bForce, float InterpSec);
	void EnableIndoorCamera(float InterpSec);
	bool IsOperationToSinkWhenPlayerIsFish();
	void Latent_ChangeTimeCameraEndStop(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float Sec);
	void Latent_ChangeTimeCameraStartStop(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float Sec);
	EPathFollowingRequestResult MoveToActor(class AActor* Goal, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	EPathFollowingRequestResult MoveToLocation(const struct FVector& Dest, float AcceptanceRadius, bool bStopOnOverlap, bool bUsePathfinding, bool bProjectDestinationToNavigation, bool bCanStrafe, TSubclassOf<class UNavigationQueryFilter> FilterClass);
	void NotifyTeleportToCamera();
	void OnBeginTalk(class AActor* InOther, bool bInLocationUpdate);
	void OnEndTalk();
	void PopAllCameraMode(float InterpSeconds);
	void PopCameraMode(EJackCameraMode InMode, float InterpSeconds);
	void PushCameraMode(EJackCameraMode InMode, float InterpSeconds, bool bKeepOldCameraView);
	void SetBackPlayerCamera(const struct FRotator& AngleMax, const struct FRotator& AngleMin, float CenterYaw);
	void SetBackPlayerCameraStartLocation(const struct FVector& StartLocation);
	void SetCameraArmLength(float DesiredArmLength, float InterpSeconds);
	void SetCameraCollisionCheckDisable(EJackCameraMode CameraMode, bool bDisable);
	void SetCameraOverRideCheckOffInnterArmLength(float OverrideArmLength);
	void SetChangeTimeCameraMoveEndToStart(float Sec);
	void SetChangeTimeCameraMoveStartToEnd(float Sec);
	void SetChangeTimeCameraParam(const struct FVector& InActorOffset, float InPitchAngle);
	void SetControlRotationWithInterp(const struct FRotator& Rotation, float InterpSeconds, bool bRelativeRotation);
	void SetFixCamera(const struct FVector& CameraLocation, class AJackCharacter* Actor, const struct FVector& LookAtOffset);
	void SetFixCameraNoActor(const struct FVector& CameraLocation, const struct FVector& LookAtLocation);
	void SetFixCameraNowLocationRotation();
	void SetFriendTalkCameraData(const struct FVector& Location, const struct FRotator& Rotation);
	void SetSplinePathCameraData(class AJackCharacter* Actor, const class USplineComponent* Spline);
	void SetSplinePathCameraFirstPointFixed(bool bFixed);
	void SetSplinePathCameraOffset(const struct FVector& CameraOffset);
	void SetSplinePathCameraParams(float CameraUpdateLength, float UpdateRateMaxLength, float MaxSpeed);

	const class AJackHUD* GetJackHUD() const;
	EPathFollowingStatus GetMoveStatus() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerController">();
	}
	static class AJackPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayerController>();
	}
};
static_assert(alignof(AJackPlayerController) == 0x000008, "Wrong alignment on AJackPlayerController");
static_assert(sizeof(AJackPlayerController) == 0x000930, "Wrong size on AJackPlayerController");
static_assert(offsetof(AJackPlayerController, CachedActionCursorControllerComponent) == 0x000768, "Member 'AJackPlayerController::CachedActionCursorControllerComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerController, ReceiveMoveCompleted) == 0x000770, "Member 'AJackPlayerController::ReceiveMoveCompleted' has a wrong offset!");
static_assert(offsetof(AJackPlayerController, InitialControlRotation) == 0x0007A0, "Member 'AJackPlayerController::InitialControlRotation' has a wrong offset!");
static_assert(offsetof(AJackPlayerController, ControlRotationInertia) == 0x0007AC, "Member 'AJackPlayerController::ControlRotationInertia' has a wrong offset!");
static_assert(offsetof(AJackPlayerController, AutoRunCancelThreshould) == 0x000890, "Member 'AJackPlayerController::AutoRunCancelThreshould' has a wrong offset!");

// Class JackGame.JackTriplePlayerController
// 0x0000 (0x0930 - 0x0930)
class AJackTriplePlayerController final : public AJackPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTriplePlayerController">();
	}
	static class AJackTriplePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTriplePlayerController>();
	}
};
static_assert(alignof(AJackTriplePlayerController) == 0x000008, "Wrong alignment on AJackTriplePlayerController");
static_assert(sizeof(AJackTriplePlayerController) == 0x000930, "Wrong size on AJackTriplePlayerController");

// Class JackGame.JackAnimNotify_FallOnGround
// 0x0000 (0x0048 - 0x0048)
class UJackAnimNotify_FallOnGround final : public UJackAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FallOnGround">();
	}
	static class UJackAnimNotify_FallOnGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FallOnGround>();
	}
};
static_assert(alignof(UJackAnimNotify_FallOnGround) == 0x000008, "Wrong alignment on UJackAnimNotify_FallOnGround");
static_assert(sizeof(UJackAnimNotify_FallOnGround) == 0x000048, "Wrong size on UJackAnimNotify_FallOnGround");

// Class JackGame.JackAnimNotify_FireReservedEffect
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotify_FireReservedEffect final : public UJackAnimNotify
{
public:
	bool                                          bActionEffect;                                     // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bProjectile;                                       // 0x0049(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBurstEffect;                                      // 0x004A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bParticleSystem;                                   // 0x004B(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FireReservedEffect">();
	}
	static class UJackAnimNotify_FireReservedEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FireReservedEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_FireReservedEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_FireReservedEffect");
static_assert(sizeof(UJackAnimNotify_FireReservedEffect) == 0x000050, "Wrong size on UJackAnimNotify_FireReservedEffect");
static_assert(offsetof(UJackAnimNotify_FireReservedEffect, bActionEffect) == 0x000048, "Member 'UJackAnimNotify_FireReservedEffect::bActionEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FireReservedEffect, bProjectile) == 0x000049, "Member 'UJackAnimNotify_FireReservedEffect::bProjectile' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FireReservedEffect, bBurstEffect) == 0x00004A, "Member 'UJackAnimNotify_FireReservedEffect::bBurstEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FireReservedEffect, bParticleSystem) == 0x00004B, "Member 'UJackAnimNotify_FireReservedEffect::bParticleSystem' has a wrong offset!");

// Class JackGame.JackUMGMapFloorInfo
// 0x0090 (0x00C8 - 0x0038)
class UJackUMGMapFloorInfo final : public UObject
{
public:
	TArray<EJackUMGMapResourceType>               AvailableResources;                                // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLoadFinished;                                     // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapId;                                             // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapVolumeID;                                       // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentMapVolumeID;                                 // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 WorldMapTitle;                                     // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MLocationTitle;                                    // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SLocationTitle;                                    // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapOpenTexture;                                    // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MapMaskTexture;                                    // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             MiniMapTexture;                                    // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             JourneyTexture;                                    // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGMainMapOverlayWidgetBase> MapTextWidgetClass;                                // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapPCMarkerDisplayMethod                 PCMarkerDisplayMethod;                             // 0x00C0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapFieldType                             FieldType;                                         // 0x00C1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFloorLevel                               FloorLevel;                                        // 0x00C2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFloorArea                                FloorArea;                                         // 0x00C3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetPCMarkerDisplayMethod(EJackMapPCMarkerDisplayMethod DisplayMethod);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapFloorInfo">();
	}
	static class UJackUMGMapFloorInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapFloorInfo>();
	}
};
static_assert(alignof(UJackUMGMapFloorInfo) == 0x000008, "Wrong alignment on UJackUMGMapFloorInfo");
static_assert(sizeof(UJackUMGMapFloorInfo) == 0x0000C8, "Wrong size on UJackUMGMapFloorInfo");
static_assert(offsetof(UJackUMGMapFloorInfo, AvailableResources) == 0x000038, "Member 'UJackUMGMapFloorInfo::AvailableResources' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, bLoadFinished) == 0x000048, "Member 'UJackUMGMapFloorInfo::bLoadFinished' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MapId) == 0x000050, "Member 'UJackUMGMapFloorInfo::MapId' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MapVolumeID) == 0x000058, "Member 'UJackUMGMapFloorInfo::MapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, ParentMapVolumeID) == 0x000060, "Member 'UJackUMGMapFloorInfo::ParentMapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, WorldMapTitle) == 0x000068, "Member 'UJackUMGMapFloorInfo::WorldMapTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MLocationTitle) == 0x000078, "Member 'UJackUMGMapFloorInfo::MLocationTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, SLocationTitle) == 0x000088, "Member 'UJackUMGMapFloorInfo::SLocationTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MapOpenTexture) == 0x000098, "Member 'UJackUMGMapFloorInfo::MapOpenTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MapMaskTexture) == 0x0000A0, "Member 'UJackUMGMapFloorInfo::MapMaskTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MiniMapTexture) == 0x0000A8, "Member 'UJackUMGMapFloorInfo::MiniMapTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, JourneyTexture) == 0x0000B0, "Member 'UJackUMGMapFloorInfo::JourneyTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, MapTextWidgetClass) == 0x0000B8, "Member 'UJackUMGMapFloorInfo::MapTextWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, PCMarkerDisplayMethod) == 0x0000C0, "Member 'UJackUMGMapFloorInfo::PCMarkerDisplayMethod' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, FieldType) == 0x0000C1, "Member 'UJackUMGMapFloorInfo::FieldType' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, FloorLevel) == 0x0000C2, "Member 'UJackUMGMapFloorInfo::FloorLevel' has a wrong offset!");
static_assert(offsetof(UJackUMGMapFloorInfo, FloorArea) == 0x0000C3, "Member 'UJackUMGMapFloorInfo::FloorArea' has a wrong offset!");

// Class JackGame.JackGameFlagListByBoukenGuide
// 0x0008 (0x0040 - 0x0038)
class UJackGameFlagListByBoukenGuide final : public UJackGameFlagListBase
{
public:
	class UDataTable*                             BoukenGuideDataTable;                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagListByBoukenGuide">();
	}
	static class UJackGameFlagListByBoukenGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagListByBoukenGuide>();
	}
};
static_assert(alignof(UJackGameFlagListByBoukenGuide) == 0x000008, "Wrong alignment on UJackGameFlagListByBoukenGuide");
static_assert(sizeof(UJackGameFlagListByBoukenGuide) == 0x000040, "Wrong size on UJackGameFlagListByBoukenGuide");
static_assert(offsetof(UJackGameFlagListByBoukenGuide, BoukenGuideDataTable) == 0x000038, "Member 'UJackGameFlagListByBoukenGuide::BoukenGuideDataTable' has a wrong offset!");

// Class JackGame.JackAnimNotify_FireReservedEffect2
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotify_FireReservedEffect2 final : public UJackAnimNotify
{
public:
	bool                                          bActionEffect;                                     // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FireReservedEffect2">();
	}
	static class UJackAnimNotify_FireReservedEffect2* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FireReservedEffect2>();
	}
};
static_assert(alignof(UJackAnimNotify_FireReservedEffect2) == 0x000008, "Wrong alignment on UJackAnimNotify_FireReservedEffect2");
static_assert(sizeof(UJackAnimNotify_FireReservedEffect2) == 0x000050, "Wrong size on UJackAnimNotify_FireReservedEffect2");
static_assert(offsetof(UJackAnimNotify_FireReservedEffect2, bActionEffect) == 0x000048, "Member 'UJackAnimNotify_FireReservedEffect2::bActionEffect' has a wrong offset!");

// Class JackGame.JackAnimNotify_FireWeaponPropActor
// 0x0000 (0x0048 - 0x0048)
class UJackAnimNotify_FireWeaponPropActor final : public UJackAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FireWeaponPropActor">();
	}
	static class UJackAnimNotify_FireWeaponPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FireWeaponPropActor>();
	}
};
static_assert(alignof(UJackAnimNotify_FireWeaponPropActor) == 0x000008, "Wrong alignment on UJackAnimNotify_FireWeaponPropActor");
static_assert(sizeof(UJackAnimNotify_FireWeaponPropActor) == 0x000048, "Wrong size on UJackAnimNotify_FireWeaponPropActor");

// Class JackGame.JackUIMapManager
// 0x0080 (0x00B8 - 0x0038)
class UJackUIMapManager : public UObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              MapOpenTextureSizeMin;                             // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackMapSymbolTextureDic>       MapSymbolTexture;                                  // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EJackUMGTextColorSet                          VisitedNeighborMapItemColor;                       // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUMGTextColorSet                          NotVisitNeighborMapItemColor;                      // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUMGTextColorSet                          RecentlyNeighborMapItemColor;                      // 0x006A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHighlightRecentlyNeighborMapItem;                 // 0x006B(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x1C];                                      // 0x006C(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackMapJourneyInfo>            JourneyInfoList;                                   // 0x0088(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FJackMapUserData>               MapUserDataList;                                   // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x10];                                      // 0x00A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class UJackUMGNeighborMapInfo*> GetNeighborMapInfoList(class FName MapVolumeID, class FName RecentlyMapVolumeID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUIMapManager">();
	}
	static class UJackUIMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUIMapManager>();
	}
};
static_assert(alignof(UJackUIMapManager) == 0x000008, "Wrong alignment on UJackUIMapManager");
static_assert(sizeof(UJackUIMapManager) == 0x0000B8, "Wrong size on UJackUIMapManager");
static_assert(offsetof(UJackUIMapManager, MapOpenTextureSizeMin) == 0x000050, "Member 'UJackUIMapManager::MapOpenTextureSizeMin' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, MapSymbolTexture) == 0x000058, "Member 'UJackUIMapManager::MapSymbolTexture' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, VisitedNeighborMapItemColor) == 0x000068, "Member 'UJackUIMapManager::VisitedNeighborMapItemColor' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, NotVisitNeighborMapItemColor) == 0x000069, "Member 'UJackUIMapManager::NotVisitNeighborMapItemColor' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, RecentlyNeighborMapItemColor) == 0x00006A, "Member 'UJackUIMapManager::RecentlyNeighborMapItemColor' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, bHighlightRecentlyNeighborMapItem) == 0x00006B, "Member 'UJackUIMapManager::bHighlightRecentlyNeighborMapItem' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, JourneyInfoList) == 0x000088, "Member 'UJackUIMapManager::JourneyInfoList' has a wrong offset!");
static_assert(offsetof(UJackUIMapManager, MapUserDataList) == 0x000098, "Member 'UJackUIMapManager::MapUserDataList' has a wrong offset!");

// Class JackGame.JackGameModeBase
// 0x0180 (0x0608 - 0x0488)
class AJackGameModeBase : public AGameMode
{
public:
	class AJackCaptionTrackExecutor*              CaptionTrackExecutor;                              // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackCutSceneController*                CutSceneController;                                // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackCommandDispatcher*                 CommandDispatcher;                                 // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackDebugMenu*                         DebugMenu;                                         // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4A8[0x20];                                     // 0x04A8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   PrepareMapChangeDelegate;                          // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   MapChangeReadyDelegate;                            // 0x04D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   NewMapBeginPlayDelegate;                           // 0x04E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   MapChangeFinishedDelegate;                         // 0x04F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_508[0x78];                                     // 0x0508(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFlushEnlightenCommandsAfterMapJump;               // 0x0580(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_581[0x87];                                     // 0x0581(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackCaptionTrackExecutor* GetCaptionTrackExecutor();
	class AJackCutSceneController* GetCutSceneController();
	void MapChangeFinishedAfterFading();
	void MapChangeFinishedBeforeFading();
	void MapChangeFinishedPlayableStart();
	void MapChangeFinishedPreloadStart();

	const class UJackCommandDispatcher* GetCommandDispatcher() const;
	const class UJackGameFlag* GetGameFlag() const;
	const class UJackSaveData* GetSaveData() const;
	const class UJackSystemData* GetSystemData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameModeBase">();
	}
	static class AJackGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackGameModeBase>();
	}
};
static_assert(alignof(AJackGameModeBase) == 0x000008, "Wrong alignment on AJackGameModeBase");
static_assert(sizeof(AJackGameModeBase) == 0x000608, "Wrong size on AJackGameModeBase");
static_assert(offsetof(AJackGameModeBase, CaptionTrackExecutor) == 0x000488, "Member 'AJackGameModeBase::CaptionTrackExecutor' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, CutSceneController) == 0x000490, "Member 'AJackGameModeBase::CutSceneController' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, CommandDispatcher) == 0x000498, "Member 'AJackGameModeBase::CommandDispatcher' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, DebugMenu) == 0x0004A0, "Member 'AJackGameModeBase::DebugMenu' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, PrepareMapChangeDelegate) == 0x0004C8, "Member 'AJackGameModeBase::PrepareMapChangeDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, MapChangeReadyDelegate) == 0x0004D8, "Member 'AJackGameModeBase::MapChangeReadyDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, NewMapBeginPlayDelegate) == 0x0004E8, "Member 'AJackGameModeBase::NewMapBeginPlayDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, MapChangeFinishedDelegate) == 0x0004F8, "Member 'AJackGameModeBase::MapChangeFinishedDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameModeBase, bFlushEnlightenCommandsAfterMapJump) == 0x000580, "Member 'AJackGameModeBase::bFlushEnlightenCommandsAfterMapJump' has a wrong offset!");

// Class JackGame.JackGameMode
// 0x0848 (0x0E50 - 0x0608)
class AJackGameMode : public AJackGameModeBase
{
public:
	uint8                                         Pad_608[0x68];                                     // 0x0608(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJackGameEvent>             GameEventClass;                                    // 0x0670(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackPartyManager>          PartyManagerClass;                                 // 0x0678(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackMonsterPopManager>     MonsterPopManagerClass;                            // 0x0680(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackBattleManager>         BattleManagerClass;                                // 0x0688(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackBattlePlayerController> BattlePlayerControllerClass;                       // 0x0690(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackActionManager>         ActionManagerClass;                                // 0x0698(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackRenkeiManager>         RenkeiManagerClass;                                // 0x06A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackScheduledNPCManager>   ScheduledNPCManagerClass;                          // 0x06A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackCharacterTickIntervalManager> CharacterTickIntervalManagerClass;                 // 0x06B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackSafeAreaManager>       SafeAreaManagerClass;                              // 0x06B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackCategoryHiddenManager> CategoryHiddenManagerClass;                        // 0x06C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackPlayerMarker>          PlayerMarkerClass;                                 // 0x06C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackLazyMessageManager>    LazyMessageManagerClass;                           // 0x06D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackFieldAttackManager>    FieldAttackManagerClass;                           // 0x06D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackPhotoModeManager>      PhotoModeManagerClass;                             // 0x06E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AJackScheduledNPCManager*               ScheduledNPCManager;                               // 0x06E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackCharacterTickIntervalManager*      CharacterTickIntervalManager;                      // 0x06F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackBattleManager*                     BattleManager;                                     // 0x06F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackBattlePlayerController*            BattleController;                                  // 0x0700(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackEventBattleManager*                EventBattleManager;                                // 0x0708(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackActionManager*                     ActionManager;                                     // 0x0710(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackMonsterPopManager*                 MonsterPopManager;                                 // 0x0718(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackGameEvent*                         GameEvent;                                         // 0x0720(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackRenkeiManager*                     RenkeiManager;                                     // 0x0728(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackCharacterManager*                  CharacterManager;                                  // 0x0730(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackInteractiveActorManager*           InteractiveActorManager;                           // 0x0738(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackBowgunTargetManager*               BowgunTargetManager;                               // 0x0740(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackEffectManager*                     EffectManager;                                     // 0x0748(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackSafeAreaManager*                   SafeAreaManager;                                   // 0x0750(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackCategoryHiddenManager*             CategoryHiddenManager;                             // 0x0758(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFieldAttackManager*                FieldAttackManager;                                // 0x0760(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackReservedPlayerControlExecutor*     ReservedPlayerControlExecutor;                     // 0x0768(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackPlayerMarker*                      PlayerMarker;                                      // 0x0770(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMeosiSlotDataManagers*             MeosiSlotDataManagers;                             // 0x0778(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackLazyMessageManager*                LazyMessageManager;                                // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackPhotoModeManager*                  PhotoModeManager;                                  // 0x0788(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnRuraSuccessDelegate;                             // 0x0790(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A0[0x30];                                     // 0x07A0(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   WorldParticlesChangedDelegate;                     // 0x07D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	class AJackPartyManager*                      PartyManager;                                      // 0x07E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseControlledCharacterType;                       // 0x07E8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E9[0x567];                                    // 0x07E9(0x0567)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MiniMapMID;                                        // 0x0D50(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               MiniMapSymbolMID;                                  // 0x0D58(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               WorldMapMID;                                       // 0x0D60(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               WorldMapSymbolMID;                                 // 0x0D68(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               LocalMapMID;                                       // 0x0D70(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               LocalMapSymbolMID;                                 // 0x0D78(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UMaterialInstanceDynamic*>       MapTextArrowMIDList;                               // 0x0D80(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPublic)
	class UMaterial*                              MiniMapMaterial;                                   // 0x0D90(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MiniMapSymbolMaterial;                             // 0x0D98(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              WorldMapMaterial;                                  // 0x0DA0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              WorldMapSymbolMaterial;                            // 0x0DA8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MapTextArrowBlinkMaterial;                         // 0x0DB0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackCharacterCaptureCamera> DefaultCharacterCaptureCameraClass;                // 0x0DB8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackCharacterCaptureCamera*            CharacterCaptureCamera;                            // 0x0DC0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bEnlightenSystemUpdateImmediatelyOnlyInViewFrustum; // 0x0DC8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DC9[0x67];                                     // 0x0DC9(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bTripleMode;                                       // 0x0E30(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E31[0x1F];                                     // 0x0E31(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackLazyMessageManager* GetLazyMessageManager();
	class UJackPhotoModeManager* GetPhotoModeManager();
	void JackPlayerMovementModeChangedDelegate__DelegateSignature(class AJackCharacter* JackCharacter, EMovementMode OldMovementMode, EMovementMode NewMovementMode);
	void JackRuraSuccessDelegate__DelegateSignature();
	void SerifuScriptDelegate(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, EJackMessageScriptEventType DelegateType, const class FString& StringParam);
	class AJackCharacter* SpawnDebugFriendCharacter(const struct FVector& InLocation, const struct FRotator& InRotation);

	class UAnimMontage* FindAnimMontage(const class FName InName, bool bWarnIfMissing) const;
	class UAnimMontage* FindAnimMontageChecked(const class FName InName) const;
	class UClass* FindBlueprintClass(const class FName InName, bool bWarnIfMissing) const;
	class UClass* FindBlueprintClassChecked(const class FName InName) const;
	class UCameraAnim* FindCameraAnim(const class FName InName, bool bWarnIfMissing) const;
	class UCameraAnim* FindCameraAnimChecked(const class FName InName) const;
	TSubclassOf<class UCameraShake> FindCameraShake(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class UCameraShake> FindCameraShakeChecked(const class FName InName) const;
	TSubclassOf<class UJackCollideEffect> FindCollideEffect(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class UJackCollideEffect> FindCollideEffectChecked(const class FName InName) const;
	class UCurveBase* FindCurve(const class FName InName, bool bWarnIfMissing) const;
	class UCurveBase* FindCurveChecked(const class FName InName) const;
	class UForceFeedbackEffect* FindForceFeedback(const class FName InName, bool bWarnIfMissing) const;
	class UForceFeedbackEffect* FindForceFeedbackChecked(const class FName InName) const;
	class UMaterialInterface* FindMaterial(const class FName InName, bool bWarnIfMissing) const;
	class UMaterialInterface* FindMaterialChecked(const class FName InName) const;
	class UMaterialParameterCollection* FindMaterialParameterCollection(const class FName InName, bool bWarnIfMissing) const;
	class UMaterialParameterCollection* FindMaterialParameterCollectionChecked(const class FName InName) const;
	class UParticleSystem* FindParticle(const class FName InName, bool bWarnIfMissing) const;
	class UParticleSystem* FindParticleChecked(const class FName InName) const;
	TSubclassOf<class AJackProjectile> FindProjectileClass(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class AJackProjectile> FindProjectileClassChecked(const class FName InName) const;
	class USkeletalMesh* FindSkeletalMesh(const class FName InName, bool bWarnIfMissing) const;
	class USkeletalMesh* FindSkeletalMeshChecked(const class FName InName) const;
	class USoundBase* FindSound(const class FName InName, bool bWarnIfMissing) const;
	class USoundBase* FindSoundChecked(const class FName InName) const;
	class UStaticMesh* FindStaticMesh(const class FName InName, bool bWarnIfMissing) const;
	class UStaticMesh* FindStaticMeshChecked(const class FName InName) const;
	class UTexture* FindTexture(const class FName InName, bool bWarnIfMissing) const;
	class UTexture* FindTextureChecked(const class FName InName) const;
	TSubclassOf<class AJackWeaponBase> FindWeaponClass(const class FName InName, bool bWarnIfMissing) const;
	TSubclassOf<class AJackWeaponBase> FindWeaponClassChecked(const class FName InName) const;
	class UBlueprint* FindWidgetBlueprint(const class FName InName, bool bWarnIfMissing) const;
	class UBlueprint* FindWidgetBlueprintChecked(const class FName InName) const;
	const class AJackActionManager* GetActionManager() const;
	const class AJackBattlePlayerController* GetBattleController() const;
	const class AJackBattleManager* GetBattleManager() const;
	const class AJackBowgunTargetManager* GetBowgunTargetManager() const;
	const class AJackCategoryHiddenManager* GetCategoryHiddenManager() const;
	const class AJackCharacterManager* GetCharacterManager() const;
	const class UJackCharacterSystem* GetCharacterSystem() const;
	const class AJackCharacterTickIntervalManager* GetCharacterTickIntervalManager() const;
	const class AJackEffectManager* GetEffectManager() const;
	const class AJackEventBattleManager* GetEventBattleManager() const;
	const class UJackFieldAttackManager* GetFieldAttackManager() const;
	const class UJackGameDatabase* GetGameDatabase() const;
	const class AJackGameEvent* GetGameEvent() const;
	const class AJackInteractiveActorManager* GetInteractiveActorManager() const;
	const class AJackMonsterPopManager* GetMonsterPopManager() const;
	const class AJackRenkeiManager* GetRenkeiManager() const;
	const class AJackSafeAreaManager* GetSafeAreaManager() const;
	const class AJackScheduledNPCManager* GetScheduledNPCManager() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameMode">();
	}
	static class AJackGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackGameMode>();
	}
};
static_assert(alignof(AJackGameMode) == 0x000008, "Wrong alignment on AJackGameMode");
static_assert(sizeof(AJackGameMode) == 0x000E50, "Wrong size on AJackGameMode");
static_assert(offsetof(AJackGameMode, GameEventClass) == 0x000670, "Member 'AJackGameMode::GameEventClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PartyManagerClass) == 0x000678, "Member 'AJackGameMode::PartyManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MonsterPopManagerClass) == 0x000680, "Member 'AJackGameMode::MonsterPopManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, BattleManagerClass) == 0x000688, "Member 'AJackGameMode::BattleManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, BattlePlayerControllerClass) == 0x000690, "Member 'AJackGameMode::BattlePlayerControllerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, ActionManagerClass) == 0x000698, "Member 'AJackGameMode::ActionManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, RenkeiManagerClass) == 0x0006A0, "Member 'AJackGameMode::RenkeiManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, ScheduledNPCManagerClass) == 0x0006A8, "Member 'AJackGameMode::ScheduledNPCManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CharacterTickIntervalManagerClass) == 0x0006B0, "Member 'AJackGameMode::CharacterTickIntervalManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, SafeAreaManagerClass) == 0x0006B8, "Member 'AJackGameMode::SafeAreaManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CategoryHiddenManagerClass) == 0x0006C0, "Member 'AJackGameMode::CategoryHiddenManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PlayerMarkerClass) == 0x0006C8, "Member 'AJackGameMode::PlayerMarkerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, LazyMessageManagerClass) == 0x0006D0, "Member 'AJackGameMode::LazyMessageManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, FieldAttackManagerClass) == 0x0006D8, "Member 'AJackGameMode::FieldAttackManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PhotoModeManagerClass) == 0x0006E0, "Member 'AJackGameMode::PhotoModeManagerClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, ScheduledNPCManager) == 0x0006E8, "Member 'AJackGameMode::ScheduledNPCManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CharacterTickIntervalManager) == 0x0006F0, "Member 'AJackGameMode::CharacterTickIntervalManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, BattleManager) == 0x0006F8, "Member 'AJackGameMode::BattleManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, BattleController) == 0x000700, "Member 'AJackGameMode::BattleController' has a wrong offset!");
static_assert(offsetof(AJackGameMode, EventBattleManager) == 0x000708, "Member 'AJackGameMode::EventBattleManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, ActionManager) == 0x000710, "Member 'AJackGameMode::ActionManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MonsterPopManager) == 0x000718, "Member 'AJackGameMode::MonsterPopManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, GameEvent) == 0x000720, "Member 'AJackGameMode::GameEvent' has a wrong offset!");
static_assert(offsetof(AJackGameMode, RenkeiManager) == 0x000728, "Member 'AJackGameMode::RenkeiManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CharacterManager) == 0x000730, "Member 'AJackGameMode::CharacterManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, InteractiveActorManager) == 0x000738, "Member 'AJackGameMode::InteractiveActorManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, BowgunTargetManager) == 0x000740, "Member 'AJackGameMode::BowgunTargetManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, EffectManager) == 0x000748, "Member 'AJackGameMode::EffectManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, SafeAreaManager) == 0x000750, "Member 'AJackGameMode::SafeAreaManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CategoryHiddenManager) == 0x000758, "Member 'AJackGameMode::CategoryHiddenManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, FieldAttackManager) == 0x000760, "Member 'AJackGameMode::FieldAttackManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, ReservedPlayerControlExecutor) == 0x000768, "Member 'AJackGameMode::ReservedPlayerControlExecutor' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PlayerMarker) == 0x000770, "Member 'AJackGameMode::PlayerMarker' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MeosiSlotDataManagers) == 0x000778, "Member 'AJackGameMode::MeosiSlotDataManagers' has a wrong offset!");
static_assert(offsetof(AJackGameMode, LazyMessageManager) == 0x000780, "Member 'AJackGameMode::LazyMessageManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PhotoModeManager) == 0x000788, "Member 'AJackGameMode::PhotoModeManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, OnRuraSuccessDelegate) == 0x000790, "Member 'AJackGameMode::OnRuraSuccessDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameMode, WorldParticlesChangedDelegate) == 0x0007D0, "Member 'AJackGameMode::WorldParticlesChangedDelegate' has a wrong offset!");
static_assert(offsetof(AJackGameMode, PartyManager) == 0x0007E0, "Member 'AJackGameMode::PartyManager' has a wrong offset!");
static_assert(offsetof(AJackGameMode, bUseControlledCharacterType) == 0x0007E8, "Member 'AJackGameMode::bUseControlledCharacterType' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MiniMapMID) == 0x000D50, "Member 'AJackGameMode::MiniMapMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MiniMapSymbolMID) == 0x000D58, "Member 'AJackGameMode::MiniMapSymbolMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, WorldMapMID) == 0x000D60, "Member 'AJackGameMode::WorldMapMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, WorldMapSymbolMID) == 0x000D68, "Member 'AJackGameMode::WorldMapSymbolMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, LocalMapMID) == 0x000D70, "Member 'AJackGameMode::LocalMapMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, LocalMapSymbolMID) == 0x000D78, "Member 'AJackGameMode::LocalMapSymbolMID' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MapTextArrowMIDList) == 0x000D80, "Member 'AJackGameMode::MapTextArrowMIDList' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MiniMapMaterial) == 0x000D90, "Member 'AJackGameMode::MiniMapMaterial' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MiniMapSymbolMaterial) == 0x000D98, "Member 'AJackGameMode::MiniMapSymbolMaterial' has a wrong offset!");
static_assert(offsetof(AJackGameMode, WorldMapMaterial) == 0x000DA0, "Member 'AJackGameMode::WorldMapMaterial' has a wrong offset!");
static_assert(offsetof(AJackGameMode, WorldMapSymbolMaterial) == 0x000DA8, "Member 'AJackGameMode::WorldMapSymbolMaterial' has a wrong offset!");
static_assert(offsetof(AJackGameMode, MapTextArrowBlinkMaterial) == 0x000DB0, "Member 'AJackGameMode::MapTextArrowBlinkMaterial' has a wrong offset!");
static_assert(offsetof(AJackGameMode, DefaultCharacterCaptureCameraClass) == 0x000DB8, "Member 'AJackGameMode::DefaultCharacterCaptureCameraClass' has a wrong offset!");
static_assert(offsetof(AJackGameMode, CharacterCaptureCamera) == 0x000DC0, "Member 'AJackGameMode::CharacterCaptureCamera' has a wrong offset!");
static_assert(offsetof(AJackGameMode, bEnlightenSystemUpdateImmediatelyOnlyInViewFrustum) == 0x000DC8, "Member 'AJackGameMode::bEnlightenSystemUpdateImmediatelyOnlyInViewFrustum' has a wrong offset!");
static_assert(offsetof(AJackGameMode, bTripleMode) == 0x000E30, "Member 'AJackGameMode::bTripleMode' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepBase
// 0x0020 (0x0068 - 0x0048)
class UJackAnimNotify_FootstepBase : public UJackAnimNotify
{
public:
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectScale;                                       // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpNormalSize;                                    // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceFootstepMargin;                               // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceFootstepRadius;                               // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceSocketName;                                   // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepBase">();
	}
	static class UJackAnimNotify_FootstepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepBase>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepBase) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepBase");
static_assert(sizeof(UJackAnimNotify_FootstepBase) == 0x000068, "Wrong size on UJackAnimNotify_FootstepBase");
static_assert(offsetof(UJackAnimNotify_FootstepBase, SocketName) == 0x000048, "Member 'UJackAnimNotify_FootstepBase::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepBase, EffectScale) == 0x000050, "Member 'UJackAnimNotify_FootstepBase::EffectScale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepBase, BumpNormalSize) == 0x000054, "Member 'UJackAnimNotify_FootstepBase::BumpNormalSize' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepBase, TraceFootstepMargin) == 0x000058, "Member 'UJackAnimNotify_FootstepBase::TraceFootstepMargin' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepBase, TraceFootstepRadius) == 0x00005C, "Member 'UJackAnimNotify_FootstepBase::TraceFootstepRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepBase, TraceSocketName) == 0x000060, "Member 'UJackAnimNotify_FootstepBase::TraceSocketName' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepSoundBase
// 0x0030 (0x0078 - 0x0048)
class UJackAnimNotify_FootstepSoundBase : public UJackAnimNotify
{
public:
	class FName                                   SocketName;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumpNormalSize;                                    // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceFootstepMargin;                               // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceFootstepRadius;                               // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceSocketName;                                   // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundPitch;                                        // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableInGame;                                // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableCutScene;                              // 0x0071(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x6];                                       // 0x0072(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundBase">();
	}
	static class UJackAnimNotify_FootstepSoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundBase>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundBase) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundBase");
static_assert(sizeof(UJackAnimNotify_FootstepSoundBase) == 0x000078, "Wrong size on UJackAnimNotify_FootstepSoundBase");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, SocketName) == 0x000048, "Member 'UJackAnimNotify_FootstepSoundBase::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, BumpNormalSize) == 0x000050, "Member 'UJackAnimNotify_FootstepSoundBase::BumpNormalSize' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, TraceFootstepMargin) == 0x000054, "Member 'UJackAnimNotify_FootstepSoundBase::TraceFootstepMargin' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, TraceFootstepRadius) == 0x000058, "Member 'UJackAnimNotify_FootstepSoundBase::TraceFootstepRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, TraceSocketName) == 0x000060, "Member 'UJackAnimNotify_FootstepSoundBase::TraceSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, SoundVolume) == 0x000068, "Member 'UJackAnimNotify_FootstepSoundBase::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, SoundPitch) == 0x00006C, "Member 'UJackAnimNotify_FootstepSoundBase::SoundPitch' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, bSoundEnableInGame) == 0x000070, "Member 'UJackAnimNotify_FootstepSoundBase::bSoundEnableInGame' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_FootstepSoundBase, bSoundEnableCutScene) == 0x000071, "Member 'UJackAnimNotify_FootstepSoundBase::bSoundEnableCutScene' has a wrong offset!");

// Class JackGame.JackGameUserSettings
// 0x00A0 (0x01B8 - 0x0118)
class UJackGameUserSettings final : public UGameUserSettings
{
public:
	bool                                          bInversedVerticalCameraControl;                    // 0x0118(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInversedHorizontalCameraControl;                  // 0x0119(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAutoFollowCamera;                                 // 0x011A(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bMuteAudio;                                        // 0x011B(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftStickInputMin;                                 // 0x011C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         LeftStickInputMax;                                 // 0x0120(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightStickInputMin;                                // 0x0124(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RightStickInputMax;                                // 0x0128(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ScreenPercentage;                                  // 0x012C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PostProcessAAQuality;                              // 0x0130(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PostProcessQuality;                                // 0x0134(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ShadowQuality;                                     // 0x0138(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDecideButtonIsRightSide;                          // 0x013C(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_13D[0x3];                                      // 0x013D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UserSelectedKeyboardType;                          // 0x0140(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         KeyConfigVersion;                                  // 0x0144(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 KeyConfigNumber;                                   // 0x0148(0x0010)(ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInitGraphicsOption;                               // 0x0158(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayGamma;                                      // 0x015C(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         BgmVolume;                                         // 0x0160(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SeVolume;                                          // 0x0164(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         VoiceVolume;                                       // 0x0168(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x44];                                     // 0x016C(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInversedVerticalDebugCameraControl;               // 0x01B0(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bInversedHorizontalDebugCameraControl;             // 0x01B1(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B2[0x6];                                      // 0x01B2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameUserSettings">();
	}
	static class UJackGameUserSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameUserSettings>();
	}
};
static_assert(alignof(UJackGameUserSettings) == 0x000008, "Wrong alignment on UJackGameUserSettings");
static_assert(sizeof(UJackGameUserSettings) == 0x0001B8, "Wrong size on UJackGameUserSettings");
static_assert(offsetof(UJackGameUserSettings, bInversedVerticalCameraControl) == 0x000118, "Member 'UJackGameUserSettings::bInversedVerticalCameraControl' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bInversedHorizontalCameraControl) == 0x000119, "Member 'UJackGameUserSettings::bInversedHorizontalCameraControl' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bAutoFollowCamera) == 0x00011A, "Member 'UJackGameUserSettings::bAutoFollowCamera' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bMuteAudio) == 0x00011B, "Member 'UJackGameUserSettings::bMuteAudio' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, LeftStickInputMin) == 0x00011C, "Member 'UJackGameUserSettings::LeftStickInputMin' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, LeftStickInputMax) == 0x000120, "Member 'UJackGameUserSettings::LeftStickInputMax' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, RightStickInputMin) == 0x000124, "Member 'UJackGameUserSettings::RightStickInputMin' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, RightStickInputMax) == 0x000128, "Member 'UJackGameUserSettings::RightStickInputMax' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, ScreenPercentage) == 0x00012C, "Member 'UJackGameUserSettings::ScreenPercentage' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, PostProcessAAQuality) == 0x000130, "Member 'UJackGameUserSettings::PostProcessAAQuality' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, PostProcessQuality) == 0x000134, "Member 'UJackGameUserSettings::PostProcessQuality' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, ShadowQuality) == 0x000138, "Member 'UJackGameUserSettings::ShadowQuality' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bDecideButtonIsRightSide) == 0x00013C, "Member 'UJackGameUserSettings::bDecideButtonIsRightSide' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, UserSelectedKeyboardType) == 0x000140, "Member 'UJackGameUserSettings::UserSelectedKeyboardType' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, KeyConfigVersion) == 0x000144, "Member 'UJackGameUserSettings::KeyConfigVersion' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, KeyConfigNumber) == 0x000148, "Member 'UJackGameUserSettings::KeyConfigNumber' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bInitGraphicsOption) == 0x000158, "Member 'UJackGameUserSettings::bInitGraphicsOption' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, DisplayGamma) == 0x00015C, "Member 'UJackGameUserSettings::DisplayGamma' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, BgmVolume) == 0x000160, "Member 'UJackGameUserSettings::BgmVolume' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, SeVolume) == 0x000164, "Member 'UJackGameUserSettings::SeVolume' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, VoiceVolume) == 0x000168, "Member 'UJackGameUserSettings::VoiceVolume' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bInversedVerticalDebugCameraControl) == 0x0001B0, "Member 'UJackGameUserSettings::bInversedVerticalDebugCameraControl' has a wrong offset!");
static_assert(offsetof(UJackGameUserSettings, bInversedHorizontalDebugCameraControl) == 0x0001B1, "Member 'UJackGameUserSettings::bInversedHorizontalDebugCameraControl' has a wrong offset!");

// Class JackGame.JackUMGZukanWindow
// 0x0060 (0x0460 - 0x0400)
class UJackUMGZukanWindow final : public UJackUMGWindowBase
{
public:
	class UJackUMGValueController*                ValueController;                                   // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsComma;                                           // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsZenkaku;                                         // 0x0409(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40A[0x6];                                      // 0x040A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemData*>               ItemDataList;                                      // 0x0410(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UJackUMGPageController*                 PageController;                                    // 0x0420(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TotalText;                                         // 0x0428(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalPrice;                                        // 0x0440(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputValue;                                        // 0x0444(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnitPrice;                                         // 0x0448(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVisibleUpArrow;                                 // 0x044C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVisibleDownArrow;                               // 0x044D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44E[0x12];                                     // 0x044E(0x0012)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 ChangePage(bool IsRight);
	void DispItemListImpl(int32 InPage);
	int32 GetCurrentPage();
	int32 GetDispEndIndex();
	int32 GetDispTopIndex();
	int32 GetItemsPerPage();
	int32 GetMaxPage();
	void InitZukanWindow(class UCanvasPanel* ItemListCanvas, class UJackUMGPageController* InPageController, int32 InZOrder);
	void SetupPageController(int32 InInitDataIndex, int32 InInitPage, int32 InItemsPerPage, const TArray<class UJackUMGItemData*>& InItemDataList);

	int32 GetInputValue() const;
	int32 GetTotalPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGZukanWindow">();
	}
	static class UJackUMGZukanWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGZukanWindow>();
	}
};
static_assert(alignof(UJackUMGZukanWindow) == 0x000008, "Wrong alignment on UJackUMGZukanWindow");
static_assert(sizeof(UJackUMGZukanWindow) == 0x000460, "Wrong size on UJackUMGZukanWindow");
static_assert(offsetof(UJackUMGZukanWindow, ValueController) == 0x000400, "Member 'UJackUMGZukanWindow::ValueController' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, IsComma) == 0x000408, "Member 'UJackUMGZukanWindow::IsComma' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, IsZenkaku) == 0x000409, "Member 'UJackUMGZukanWindow::IsZenkaku' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, ItemDataList) == 0x000410, "Member 'UJackUMGZukanWindow::ItemDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, PageController) == 0x000420, "Member 'UJackUMGZukanWindow::PageController' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, TotalText) == 0x000428, "Member 'UJackUMGZukanWindow::TotalText' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, TotalPrice) == 0x000440, "Member 'UJackUMGZukanWindow::TotalPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, InputValue) == 0x000444, "Member 'UJackUMGZukanWindow::InputValue' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, UnitPrice) == 0x000448, "Member 'UJackUMGZukanWindow::UnitPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, bIsVisibleUpArrow) == 0x00044C, "Member 'UJackUMGZukanWindow::bIsVisibleUpArrow' has a wrong offset!");
static_assert(offsetof(UJackUMGZukanWindow, bIsVisibleDownArrow) == 0x00044D, "Member 'UJackUMGZukanWindow::bIsVisibleDownArrow' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepSoundTable
// 0x0008 (0x0080 - 0x0078)
class UJackAnimNotify_FootstepSoundTable : public UJackAnimNotify_FootstepSoundBase
{
public:
	TSubclassOf<class UJackCollideSoundTable>     FootstepSound;                                     // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundTable">();
	}
	static class UJackAnimNotify_FootstepSoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundTable>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundTable) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundTable");
static_assert(sizeof(UJackAnimNotify_FootstepSoundTable) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundTable");
static_assert(offsetof(UJackAnimNotify_FootstepSoundTable, FootstepSound) == 0x000078, "Member 'UJackAnimNotify_FootstepSoundTable::FootstepSound' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepSoundTableLeft
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotify_FootstepSoundTableLeft final : public UJackAnimNotify_FootstepSoundTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundTableLeft">();
	}
	static class UJackAnimNotify_FootstepSoundTableLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundTableLeft>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundTableLeft) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundTableLeft");
static_assert(sizeof(UJackAnimNotify_FootstepSoundTableLeft) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundTableLeft");

// Class JackGame.JackUmaRaceCameraResult
// 0x0038 (0x03D0 - 0x0398)
class AJackUmaRaceCameraResult final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAnimInst*                        CameraAnimInst;                                    // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJackUmaRaceCameraAnimData>     CameraAnimCuts;                                    // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x10];                                     // 0x03B8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  OwnerPawn;                                         // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceCameraResult">();
	}
	static class AJackUmaRaceCameraResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceCameraResult>();
	}
};
static_assert(alignof(AJackUmaRaceCameraResult) == 0x000008, "Wrong alignment on AJackUmaRaceCameraResult");
static_assert(sizeof(AJackUmaRaceCameraResult) == 0x0003D0, "Wrong size on AJackUmaRaceCameraResult");
static_assert(offsetof(AJackUmaRaceCameraResult, SceneComponent) == 0x000398, "Member 'AJackUmaRaceCameraResult::SceneComponent' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceCameraResult, CameraAnimInst) == 0x0003A0, "Member 'AJackUmaRaceCameraResult::CameraAnimInst' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceCameraResult, CameraAnimCuts) == 0x0003A8, "Member 'AJackUmaRaceCameraResult::CameraAnimCuts' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceCameraResult, OwnerPawn) == 0x0003C8, "Member 'AJackUmaRaceCameraResult::OwnerPawn' has a wrong offset!");

// Class JackGame.JackGameplayStatics
// 0x0000 (0x0038 - 0x0038)
class UJackGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddAcquiredActiveJumon(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InJumon);
	static void AddAcquiredActiveTokugi(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InTokugi);
	static void AddBlendable_CameraPostProcessSettings(class UCameraComponent* CameraComputer, TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	static class UJackPlayerCameraComponent* AddBlendable_PlayerCameraPostProcessSettings(class UObject* WorldContextObject, TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	static void AddBlendable_PostProcess(class APostProcessVolume* ProcessVolume, TScriptInterface<class IBlendableInterface> InBlendableObject, float InWeight);
	static void AddCategoryHiddenExclusionTag(class UObject* WorldContextObject, class FName InTag);
	static class UJackDebugMenuVariableBool* AddDebugMenuBool(class UObject* WorldContextObject, const class FString& Name_0, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableByte* AddDebugMenuByte(class UObject* WorldContextObject, const class FString& Name_0, uint8 Step, uint8 Min, uint8 Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableCommand* AddDebugMenuCommand(class UObject* WorldContextObject, const class FString& Command, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableFloat* AddDebugMenuFloat(class UObject* WorldContextObject, const class FString& Name_0, float Step, float Min, float Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableInt* AddDebugMenuInt(class UObject* WorldContextObject, const class FString& Name_0, int32 Step, int32 Min, int32 Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableMenu* AddDebugMenuItem(class UObject* WorldContextObject, const class FString& MenuName, EJackDebugMenuCategory DebugMenuCategory, const class FString& MenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableLinearColor* AddDebugMenuLinearColor(class UObject* WorldContextObject, const class FString& Name_0, float Step, float Min, float Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableRotator* AddDebugMenuRotator(class UObject* WorldContextObject, const class FString& Name_0, float Step, float Min, float Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class UJackDebugMenuVariableVector* AddDebugMenuVector(class UObject* WorldContextObject, const class FString& Name_0, float Step, float Min, float Max, const class FString& MenuTooltip, const class FString& SubMenuName, const class FString& SubMenuTooltip, class UJackDebugMenuVariableMenu* ParentMenu);
	static class ULevelStreamingKismet* AddDynamicLevelToWorld(class UObject* WorldContextObject, const class FString& PackageNameToLoad, bool bShouldBeLoaded, bool bShouldBeVisible, bool bShouldBlockOnLoad);
	static class UJackUMGWidgetBase* AddUMGMenuWidget(class UObject* WorldContextObject, TSubclassOf<class UJackUMGWidgetBase> WidgetType, bool IsNewPage, bool IsFocus);
	static class UJackUMGWidgetBase* AddUMGRootWidget(class UObject* WorldContextObject, TSubclassOf<class UJackUMGWidgetBase> WidgetType, const struct FJackUMGAnimSet& AnimSet, bool ToVisible);
	static void AdjustNavigation(class UObject* Object, const struct FLatentActionInfo& LatentInfo, const struct FVector& LocationStart, const struct FVector& LocationEnd);
	static void ApplyFriendCharacterPreset(class UObject* WorldContextObject, const struct FJackLDT_FriendCharacterPreset& Preset);
	static bool ApplySplashMonsterFromVehicle(class AJackMonsterCharacter* Monster, class AJackVehicleMonster* PlayerVehicle, class FName CollideEffectName, bool bIsAngry, bool bReserveBattle, float SplashWeight, bool bAnglyDamage, bool bIgnoreCheckFieldAttackSword);
	static void AsyncFixupAllCharactersLooks(class UObject* WorldContextObject);
	static void AsyncFixupCharacterLooks(class UObject* WorldContextObject, EJackCharacter CharacterType, bool bBattleCharacterOnly);
	static void AsyncLoadCharacterCoordinate(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EJackCharacter InCharacterType);
	static void AsyncLoadPartyMenmberResources(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void AsyncUMGMenuWidget(class UObject* WorldContextObject, TSoftClassPtr<class UClass> WidgetType, const struct FLatentActionInfo& LatentInfo, bool IsNewPage, bool IsFocus);
	static void AttachPropTo(class AActor* Actor, class FName PropName);
	static bool BGMChangeDisableBeginOverlap(class UObject* WorldContextObject, const class FName InVolumeID);
	static void BGMChangeDisableClearOverlap(class UObject* WorldContextObject);
	static bool BGMChangeDisableEndOverlap(class UObject* WorldContextObject, const class FName InVolumeID);
	static EJackBGMVolumeResult BGMVolumeBeginOverlap(class UObject* WorldContextObject, const class FName VolumeID);
	static void BGMVolumeClearOverlap(class UObject* WorldContextObject);
	static EJackBGMVolumeResult BGMVolumeEndOverlap(class UObject* WorldContextObject, const class FName VolumeID);
	static int32 BitShiftLeft(int32 Bit, int32 Shift);
	static int32 BitShiftRight(int32 Bit, int32 Shift);
	static bool CallFunction(class UObject* TargetObject, class FName FunctionName);
	static bool CanPossessPlayerControl(class UObject* WorldContextObject, EJackPlayerControlPossessor Possessor);
	static void CategoryHidden(class UObject* WorldContextObject, EJackCategoryHiddenType InType, EJackCategoryHiddenLayer Layer, bool bInHidden);
	static bool Change2DMode(class UObject* WorldContextObject, const class FName& InModeChangeType);
	static void ChangeCharacterItem(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void ChangeVisibleLevelsForEditor(class UObject* WorldContextObject, const TArray<class FString>& VisibleLevels);
	static void CheckToDisplayTabiNoKokoroe(class UObject* WorldContextObject, const struct FJackLDT_UITabiNoKokoroe& Key, bool bOnlyFlagSet, bool* bOutIsDisplayed, class UJackUMGAccessorCommon** OutAccessor);
	static void ClearAllRegistLoadFlagStore(class UObject* WorldContextObject);
	static void ClearFontCache(class UObject* WorldContextObject);
	static void ClearPreloadMap(class UObject* WorldContextObject);
	static void ClearRegistLoadFlagStore(class UObject* WorldContextObject, EJackGameFlagCategory Category);
	static class UJackUMGSerifuWindowController* CloseBattleMessageWindow(const class UObject* WorldContextObject);
	static class UJackUMGSerifuWindowController* CloseFieldMessageWindow(const class UObject* WorldContextObject);
	static void CloseFukidasi(class UObject* WorldContextObject, class AJackCharacter* Target);
	static class UJackUMGSerifuWindowController* CloseMovieMessageWindow(const class UObject* WorldContextObject);
	static class UJackUMGSerifuWindowController* CloseSerifuWindow(const class UObject* WorldContextObject);
	static void ComponentOverlapActorsByChannel(TArray<class AActor*>* OutOverlaps, const class UPrimitiveComponent* PrimComp, const TArray<ECollisionChannel>& TraceChannel, TSubclassOf<class AActor> ClassFilter);
	static TArray<class FString> ConvertNameArrayToStringArray(const TArray<class FName>& NameArray);
	static TArray<class FName> ConvertStringArrayToNameArray(const TArray<class FString>& StringArray);
	static int32 ConvertTextureGroupArrayToTextureGroupValue(const TArray<ETextureGroup>& TextureGroupArray);
	static int32 ConvertTextureGroupToTextureGroupValue(const ETextureGroup& TextureGroup);
	static TArray<ETextureGroup> ConvertTextureGroupValueToTextureGroupArray(int32 TextureGroups);
	static void CopyBrushComponent(class UBrushComponent* BrushComponent0, class UBrushComponent* BrushComponent1);
	static class AJackCharacterCaptureCamera* CreateCharacterCaptureCamera(class UObject* WorldContextObject);
	static class AJackCharacterCaptureCamera* CreateCharacterCaptureCameraWith(class UObject* WorldContextObject, TSubclassOf<class AJackCharacterCaptureCamera> CharacterCaptureCameraClass);
	static void DebugSpawnAllPartyCharacters(class UObject* WorldContextObject);
	static void DestroyAllVehicle(class UObject* WorldContextObject, bool bIgnoreNowRiding);
	static void DestroyCharacterCaptureCamera(class UObject* WorldContextObject);
	static void DetachPropFrom(class AActor* Actor, class FName PropName);
	static class UJackUMGSerifuWindowController* DisplayBattleMessageAtTextID(const class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	static class UJackUMGSerifuWindowController* DisplayFieldMessageAtTextID(const class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& Args);
	static class UJackUMGSerifuWindowController* DisplayMovieMessageByTextID(const class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& Args);
	static class UJackUMGSerifuWindowController* DisplaySerifuWindowAtFixedMessage(const class UObject* WorldContextObject, const class FString& Message, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	static class UJackUMGSerifuWindowController* DisplaySerifuWindowAtTextID(const class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	static class UJackUMGAccessorCommon* DisplayTabiNoKokoroe(class UObject* WorldContextObject, const struct FJackLDT_UITabiNoKokoroe& Key);
	static void DumpStatUnit(class UObject* WorldContextObject);
	static void EditorNotification(class UObject* WorldContextObject, const class FText& Message, float ExpireDuration);
	static void EffectFieldBaseSuperTickNative(float DeltaTime, class UJackOverlappedActorComponent* InOverlappedActorComponent, TSubclassOf<class UJackCollideEffect> InEffect, class UParticleSystem* ParticleSystem, float InCallTimer, const struct FVector& InOffsetLocation, float SpawnEffectVelocity);
	static void EnhancingTokugi(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InTokugi, class FName InEnhancedTokugi);
	static void EnhancingTokugiForAllPartyMember(class UObject* WorldContextObject, class FName InTokugi, class FName InEnhancedTokugi);
	static TArray<class UJackGameCharacter*> FindAllBattleMonsterGameCharacters(class UObject* WorldContextObject, class FName MonsterID, bool bOnlyOperational, bool bOnlyMovementEnabled);
	static class UJackDebugLoggerComponent* FindOrAddDebugLoggerComponents(class AActor* InOwner);
	static float FindParameterFloat(const class UObject* WorldContextObject, class FName InName);
	static float FindParameterFloatChecked(const class UObject* WorldContextObject, class FName InName);
	static int32 FindParameterInt(const class UObject* WorldContextObject, class FName InName);
	static int32 FindParameterIntChecked(const class UObject* WorldContextObject, class FName InName);
	static class FName FindParameterText(const class UObject* WorldContextObject, class FName InName);
	static class FName FindParameterTextChecked(const class UObject* WorldContextObject, class FName InName);
	static struct FVector FindParameterVector(const class UObject* WorldContextObject, class FName InName);
	static struct FVector FindParameterVectorChecked(const class UObject* WorldContextObject, class FName InName);
	static void FixupAllCharactersLooks(class UObject* WorldContextObject);
	static void FixupCharacterLooks(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void ForceGottenFromGettableObject(class UObject* WorldContextObject, class FName GetFlag);
	static void ForceMultiSetActorCinematicMipLevel(class AActor* Actor, const TArray<ETextureGroup>& CinematicTextureGroups, bool bForceCinematicMipLevelsToBeResident);
	static void ForceMultiSetMaterialCinematicMipLevel(class UMaterialInterface* Material, const TArray<ETextureGroup>& CinematicTextureGroups, bool bForceCinematicMipLevelsToBeResident);
	static void ForceMultiSetTextureCinematicMipLevel(class UTexture* Texture, const TArray<ETextureGroup>& CinematicTextureGroups, bool bForceCinematicMipLevelsToBeResident);
	static void ForceSetActorCinematicMipLevel(class AActor* Actor, ETextureGroup CinematicTextureGroup, bool bForceCinematicMipLevelsToBeResident);
	static void ForceSetMaterialCinematicMipLevel(class UMaterialInterface* Material, ETextureGroup CinematicTextureGroup, bool bForceCinematicMipLevelsToBeResident);
	static void ForceSetTextureCinematicMipLevel(class UTexture* Texture, ETextureGroup CinematicTextureGroup, bool bForceCinematicMipLevelsToBeResident);
	static void FriendJoin(class UObject* WorldContextObject, EJackCharacter InType);
	static void FriendLeave(class UObject* WorldContextObject, EJackCharacter InType, bool bKeepItems);
	static class FString Get2ByteDecText(int32 Val, int32 Digit, bool bZeroAlign, bool bInsertComma);
	static class UJackAchievementManager* GetAchievementManager(class UObject* WorldContextObject);
	static class UJackActionDatabase* GetActionDatabase(class UObject* WorldContextObject);
	static class AJackActionManager* GetActionManager(class UObject* WorldContextObject);
	static void GetActorEyesViewPoint(const class AActor* Actor, struct FVector* OutLocation, struct FRotator* OutRotation);
	static class ULevel* GetActorLevel(class AActor* Actor);
	static TArray<class AActor*> GetActorsByTag(class UObject* WorldContextObject, class FName TargetTag, bool* bSuccess);
	static TArray<class AActor*> GetActorsByTags(class UObject* WorldContextObject, const TArray<class FName>& TargetTags, bool* bSuccess);
	static int32 GetAllTextureGroups();
	static struct FVector GetAlongFloor(class UPrimitiveComponent* PrimCompo, const struct FVector& ArrangeCenter, float ArrangeHalfLength, bool bSweepOnlyUnder, bool bIgnoreCheckToNormal);
	static struct FVector GetAlongFloorCharacter(class AJackCharacter* Character, const struct FVector& ArrangeCenter, float ArrangeHalfLength, bool bSweepOnlyUnder, bool bIgnoreCheckToNormal);
	static TArray<class UAnimMontage*> GetAnimMontageArratsHasNames(class AJackCharacter* Character, const TArray<class UAnimMontage*>& InMontageArray, const TArray<class FName>& MontageNameArray, bool bIsEmptyCheckInMontageArray);
	static class UAnimMontage* GetAnimMontageHasName(class AJackCharacter* Character, class UAnimMontage* InMontage, class FName MontageName, bool bIsNullCheckInMontage);
	static float GetAnimSequenceLength(class UAnimSequenceBase* InAnimSequenceBase);
	static class FString GetAsciiDecText(int32 Val, int32 Digit, bool bZeroAlign, bool bInsertComma);
	static class FName GetAssetFName(const TSoftObjectPtr<class UObject>& AssetID);
	static TSoftObjectPtr<class UObject> GetAssetIDFromFName(const class FName AssetName);
	static TSoftObjectPtr<class UObject> GetAssetIDFromName(const class FString& AssetName);
	static TSoftObjectPtr<class UObject> GetAssetIDFromObject(const class UObject* Object);
	static class FString GetAssetName(const TSoftObjectPtr<class UObject>& AssetID);
	static class UJackBattleCharacterManager* GetBattleCharacterManager(class UObject* WorldContextObject);
	static class AJackBattlePlayerController* GetBattleController(class UObject* WorldContextObject);
	static class AJackBattleManager* GetBattleManager(class UObject* WorldContextObject);
	static TSoftObjectPtr<class USoundBase> GetBGMAssetNameFromBGMID(const class FName BGMID, bool bNightTime, bool IsOrchestra, bool IsDQ8);
	static bool GetBGMFromBGMID(class FName BGMID, bool bNightTime, TSoftObjectPtr<class USoundBase>* OutAsset, EJackBGMControl* OutBGMControl);
	static class FName GetBGMIDFromCSID(class FName CSID);
	static class FName GetBGMIDFromMapID(class FName MapId);
	static class FName GetBlueprintName(class UObject* WorldContextObject);
	static struct FBoneReference GetBoneReference(int32 BoneIndex);
	static struct FBoneReference GetBoneReferenceByName(class FName BoneName, class UAnimInstance* AnimInstance);
	static bool GetCameraFadeInfo(class UObject* WorldContextObject, EJackCameraFadeCategory Category, EJackCameraFadeZLayer* OutFadeLayer, struct FLinearColor* OutFadeColor, float* OutFadeAlpha);
	static class AJackCharacterCaptureCamera* GetCharacterCaptureCamera(class UObject* WorldContextObject);
	static TArray<class AJackCharacter*> GetCharacters(class UObject* WorldContextObject);
	static int32 GetCharacterTextureGroups();
	static class UStaticMeshComponent* GetCharacterWeaponAccessaryMeshComponent(class UObject* WorldContextObject, class AActor* Character, EJackEquippedHand Type);
	static class UStaticMeshComponent* GetCharacterWeaponMeshComponent(class UObject* WorldContextObject, class AActor* Character, EJackEquippedHand Type);
	static int32 GetCinematicTextureGroups();
	static TSoftClassPtr<class UClass> GetClassAssetIDFromClass(const class UClass* Class_0);
	static TSoftClassPtr<class UClass> GetClassAssetIDFromFName(const class FName ClassName);
	static TSoftClassPtr<class UClass> GetClassAssetIDFromName(const class FString& ClassName);
	static class FName GetClassFName(const TSoftClassPtr<class UClass>& ClassAssetID);
	static class FString GetClassName(const TSoftClassPtr<class UClass>& ClassAssetID);
	static class AJackCharacter* GetClosestMonsterToCharacter(float* OutDistance, const class AJackCharacter* Character, bool bDropZ, bool bIgnoreDeath);
	static struct FVector GetClosestSplinePoint(class USplineComponent* InSplineComponent, const struct FVector& InWorldLocation, float* OutClosestTime);
	static class UJackCoinManager* GetCoinManager(class UObject* WorldContextObject);
	static class UJackCommandDispatcher* GetCommandDispatcher(class UObject* WorldContextObject);
	static EJackCharacter GetControlledCharacterType(const class UObject* WorldContextObject);
	static class FName GetCorrectedTokugiID(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InTokugi);
	static class USoundBase* GetCurrentBGMAsset(class UObject* WorldContextObject);
	static class AJackCutSceneController* GetCutSceneController(class UObject* WorldContextObject);
	static bool GetDebugMenuBool(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static uint8 GetDebugMenuByte(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static class FString GetDebugMenuCursorLocation(class UObject* WorldContextObject);
	static float GetDebugMenuFloat(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static int32 GetDebugMenuInt(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static class UJackDebugMenuVariableMenu* GetDebugMenuItemByPath(class UObject* WorldContextObject, const class FString& MenuPath);
	static struct FLinearColor GetDebugMenuLinearColor(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static struct FRotator GetDebugMenuRotator(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static struct FVector GetDebugMenuVector(class UObject* WorldContextObject, const class FString& Name_0, const class FString& SubMenuName);
	static float GetDefaultDeltaTime();
	static float GetDefaultFPS();
	static class UObject* GetDefaultObject(TSubclassOf<class UObject> ObjectClass);
	static class UJackDispersionManager* GetDispersionManager(class UObject* WorldContextObject);
	static EJackEdition GetEditionType();
	static class AJackEffectManager* GetEffectManager(class UObject* WorldContextObject);
	static int32 GetEffectTextureGroups();
	static int32 GetEnvironmentTextureGroups();
	static class AJackEventBattleManager* GetEventBattleManager(class UObject* WorldContextObject);
	static class FString GetEventBattleMonsterDisplayName(class UObject* WorldContextObject, class FName EventBattleID, int32 MonsterIndex);
	static class FName GetEventBattleMonsterId(class UObject* WorldContextObject, class FName EventBattleID, int32 MonsterIndex);
	static class UJackFacilityManager* GetFacilityManager(class UObject* WorldContextObject);
	static struct FLinearColor GetFadeColor(class UObject* WorldContextObject, EJackFadeColor FadeColorType);
	static float GetFadeTime(class UObject* WorldContextObject, EJackFadeTime FadeTimeType);
	static class FName GetFieldActionMessageTextId(const class UObject* WorldContextObject, class FName ActionID, EJackActionFieldTextType Timing);
	static EJackPlayerControlCharacter GetFieldPlayerCharacterType(const class UObject* WorldContextObject);
	static class UJackInteractiveActorComponent* GetFocusedInteractiveActorComponent(const class UObject* WorldContextObject);
	static TArray<class AJackCharacter*> GetFollowingCharacters(class UObject* WorldContextObject);
	static TArray<class AJackCharacter*> GetFollowingFriendCharacters(class UObject* WorldContextObject);
	static class UJackFukkatunojumonManager* GetFukkatunojumonManager(class UObject* WorldContextObject);
	static class UJackGameCharacter* GetGameCharacter(class UObject* WorldContextObject, EJackCharacter Character);
	static class UJackGameFlag* GetGameFlag(class UObject* WorldContextObject);
	static bool GetGameFlagBool(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static float GetGameFlagFloat(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static int32 GetGameFlagInt(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static class FString GetGameFlagString(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static class APostProcessVolume* GetGlobalPostProcessVolume(class UObject* WorldContextObject);
	static struct FVector GetGroundLocation(class UObject* WorldContextObject, const struct FVector& InLocation, bool bDownOnly, float SphereRadius, float SweepDistance);
	static struct FVector GetGroundLocationWithBool(class UObject* WorldContextObject, bool* OutOnGround, const struct FVector& InLocation, bool bDownOnly, float SphereRadius, float SweepDistance);
	static class UJackGuestNpcGameCharacter* GetGuestNPCCharacter(class UObject* WorldContextObject, EJackCharacter InType);
	static TArray<class AJackCharacter*> GetGuestNPCCharacters(class UObject* WorldContextObject);
	static TArray<class UJackGuestNpcGameCharacter*> GetGuestNpcGameCharacters(class UObject* WorldContextObject);
	static EJackHeroCharacterForm GetHeroCharacterForm(const class UObject* WorldContextObject);
	static class UJackImeManager* GetImeManager(class UObject* WorldContextObject);
	static struct FRotator GetInverseRotator(const struct FRotator& Rotation);
	static class UJackItemManager* GetItemManager(class UObject* WorldContextObject);
	static class UJackItemPresentManager* GetItemPresentManager(class UObject* WorldContextObject);
	static class UJackCharacterSystem* GetJackCharacterSystem(class UObject* WorldContextObject);
	static class UJackGameInstance* GetJackGameInstance(class UObject* WorldContextObject);
	static class AJackGameMode* GetJackGameMode(class UObject* WorldContextObject);
	static class AJackGameModeBase* GetJackGameModeBase(class UObject* WorldContextObject);
	static class UJackGamePlayer* GetJackGamePlayer(class UObject* WorldContextObject);
	static class AJackPlayerCameraManager* GetJackPlayerCameraManager(class UObject* WorldContextObject);
	static class AJackCharacter* GetJackPlayerCharacter(class UObject* WorldContextObject, bool bIgnoreVehicle);
	static class AJackPlayerController* GetJackPlayerController(const class UObject* WorldContextObject);
	static class UJackKiraManager* GetKiraManager(class UObject* WorldContextObject);
	static EJackLanguage GetLanguageType();
	static TArray<class AActor*> GetLevelActorsByName(class UObject* WorldContextObject, class FName LevelName);
	static TArray<class FString> GetLevelNames(class UObject* WorldContextObject);
	static TArray<class FString> GetLevelPackageNames(class UObject* WorldContextObject, bool bRemovePIEPrefix);
	static TArray<class UWorld*> GetLevelWorlds(class UObject* WorldContextObject);
	static class ULevel* GetLoadedLevelByLevelPackageName(class UObject* WorldContextObject, class FName LevelName);
	static class ULevel* GetLoadedLevelByName(class UObject* WorldContextObject, class FName LevelName);
	static TArray<class ULevel*> GetLoadedLevels(class UObject* WorldContextObject);
	static TArray<class ULevel*> GetLoadedLevelsByLevelPackageName(class UObject* WorldContextObject, const TArray<class FName>& LevelNames);
	static TArray<class ULevel*> GetLoadedLevelsByName(class UObject* WorldContextObject, const TArray<class FName>& LevelNames);
	static class UJackLocalizationManager* GetLocalizationManager(class UObject* WorldContextObject);
	static int32 GetMapStartCameraNo(class UObject* WorldContextObject, const class FName MapStartName);
	static TArray<class FName> GetMapVolumeIDFromGettable_Common(class UObject* WorldContextObject, const class UDataTable* CommonTable, EJackGettableCommonPurpose Purpose, EJackGettableCommonPurpose ExclusivePurpose);
	static class UJackMedalManager* GetMedalManager(class UObject* WorldContextObject);
	static class UJackMiniGameManager* GetMiniGameManager(class UObject* WorldContextObject);
	static class UJackModeChangeManager* GetModeChangeManager(class UObject* WorldContextObject);
	static TArray<class AJackMonsterCharacter*> GetMonsterCharacters(class UObject* WorldContextObject);
	static class UJackMonsterDatabase* GetMonsterDatabase(class UObject* WorldContextObject);
	static class UJackMusicManager* GetMusicManager(class UObject* WorldContextObject);
	static int32 GetNowWorldTime(class UObject* WorldContextObject);
	static TArray<class AJackNPC*> GetNPCCharacters(class UObject* WorldContextObject);
	static EJackNPCImportance GetNPCImportanceFromScenarioText(class UObject* WorldContextObject, const struct FJackSerifuAutomationFlags& SerifuAutomationFlags, class FName TextID);
	static int32 GetNPCScheduleControlCounter(class UObject* WorldContextObject, int32 Index_0);
	static class UJackOddEffectDatabase* GetOddEffectDatabase(class UObject* WorldContextObject);
	static class UJackOddEffectManager* GetOddEffectManager(class UObject* WorldContextObject);
	static class UJackPairingManager* GetPairingManager(class UObject* WorldContextObject);
	static struct FVector GetPartyCharacterHomeLocation(int32 Index_0, const struct FTransform& LeaderTransform);
	static TArray<class AJackCharacter*> GetPartyCharacters(class UObject* WorldContextObject, bool bIgnoreVehicle);
	static class FString GetPersistentLevelName(class UObject* WorldContextObject);
	static class FString GetPersistentLevelPackageName(class UObject* WorldContextObject, bool bRemovePIEPrefix);
	static class FName GetPlayBGMIDFromMapID(const class UObject* WorldContextObject, const class FName& InMapId);
	static float GetPlayerCameraFov(const class UObject* WorldContextObject);
	static struct FVector GetPlayerCameraLocation(const class UObject* WorldContextObject);
	static class APlayerCameraManager* GetPlayerCameraManager(class UObject* WorldContextObject, EJackPlayerController ControllerType);
	static struct FRotator GetPlayerCameraRotation(const class UObject* WorldContextObject);
	static class ACharacter* GetPlayerCharacter(class UObject* WorldContextObject, EJackPlayerController ControllerType);
	static class APlayerController* GetPlayerController(class UObject* WorldContextObject, EJackPlayerController ControllerType);
	static EJackPlayerControlPossessor GetPlayerControlPossessor(const class UObject* WorldContextObject);
	static class UJackGameCharacter* GetPlayerGameCharacter(class UObject* WorldContextObject);
	static class FString GetPlayerGameCharacterName(class UObject* WorldContextObject);
	static class APawn* GetPlayerPawn(class UObject* WorldContextObject, EJackPlayerController ControllerType);
	static EJackVehicleModelId GetPlayerRidingVehicleModelId(const class UObject* WorldContextObject);
	static EJackVehicle GetPlayerRidingVehicleType(const class UObject* WorldContextObject);
	static class UJackWeatherAffectComponent* GetPlayerWeatherAffectComponent(class UObject* WorldContextObject);
	static class UJackRecipeBookManager* GetRecipeBookManager(class UObject* WorldContextObject);
	static EJackRegion GetRegionType();
	static class AJackRenkeiManager* GetRenkeiManager(class UObject* WorldContextObject);
	static void GetRidableVehicleArray(class UObject* WorldContextObject, TArray<class AJackVehicle*>* OutVehicleArray);
	static EJackRuraFail GetRuraAreaFailType(class UObject* WorldContextObject, const struct FVector& Location, float SphereRadius);
	static class AJackSafeAreaManager* GetSafeAreaManager(class UObject* WorldContextObject);
	static class UJackSaveData* GetSaveData(class UObject* WorldContextObject);
	static class FName GetScenarioBGMIDFromMapID(const class UObject* WorldContextObject, const class FName& InMapId);
	static void GetScenarioInfo(const class UObject* WorldContextObject, EJackScenarioPlaythrough Playthrough, class FName ScenarioFlag, EJackScenarioID* ScenarioID, int32* ScenarioFlagIndex);
	static void GetScreenDebugMessageFontSize(class UObject* WorldContextObject, float* CharSizeHalfWidthX, float* CharSizeFullWidthX, float* CharSizeY);
	static int32 GetSelectedIndexBySerifuExecution(class UObject* WorldContextObject);
	static EJackSenaHairStyle GetSenaHairStyle(const class UObject* WorldContextObject);
	static class UJackSibariManager* GetSibariManager(class UObject* WorldContextObject);
	static TArray<class FName> GetSkeletalMeshClothingAssetNames(class USkeletalMesh* SkeletalMesh);
	static float GetSkeletalMeshClothingAssetsBendResistance(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static int32 GetSkeletalMeshClothingAssetsCount(class USkeletalMesh* SkeletalMesh);
	static float GetSkeletalMeshClothingAssetsDamping(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsDrag(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsFriction(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsGravityScale(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsInertiaBlend(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsSelfCollisionThickness(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsShearResistance(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static float GetSkeletalMeshClothingAssetsStretchLimit(class USkeletalMesh* SkeletalMesh, int32 Index_0);
	static bool GetSkeletalMeshRefPoseBoneTransform(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, struct FTransform* OutTransform);
	static class UJackSoundManager* GetSoundManager(class UObject* WorldContextObject);
	static class UJackSQEXNGWordManager* GetSQEXNGWordManager(class UObject* WorldContextObject);
	static class UJackStoreManager* GetStoreManager(class UObject* WorldContextObject);
	static TArray<class ULevelStreaming*> GetStreamLevels(class UObject* WorldContextObject);
	static class UJackSystemData* GetSystemData(class UObject* WorldContextObject);
	static class AJackCharacter* GetTalkingNPC(class UObject* WorldContextObject);
	static class FName GetTalkingNPCUniqueID(class UObject* WorldContextObject);
	static class FString GetText(class UObject* WorldContextObject, class FName TextID);
	static class FString GetTextForName(class UObject* WorldContextObject, const class FName& TextID);
	static class UJackTextMacroReplaceManager* GetTextMacroReplaceManager(class UObject* WorldContextObject);
	static class UJackTextManager* GetTextManager(class UObject* WorldContextObject);
	static struct FLinearColor GetTimeColorNative(const TArray<struct FLinearColor>& ColorTable, int32 Time);
	static float GetTimeFloatNative(const TArray<float>& FloatTable, int32 Time);
	static class UJackTokugiManager* GetTokugiManager(class UObject* WorldContextObject);
	static class UJackUIMapManager* GetUIMapManager(class UObject* WorldContextObject);
	static EJackUIPlatformType GetUIPlatformType(class UObject* WorldContextObject);
	static bool GetUmayobiNoBeruFailCondition(class UObject* WorldContextObject);
	static bool GetUmayobiNoBeruFailConditionWithPurpose(class UObject* WorldContextObject, EJackUmayobiNoBeruFailPurpose FailPurpose);
	static class UJackUMGManager* GetUMGManager(class UObject* WorldContextObject);
	static int32 GetUnacquiredCountFromGettable_Common(class UObject* WorldContextObject, const class UDataTable* CommonTable, class FName MapVolumeID, EJackGettableCommonPurpose Purpose, EJackGettableCommonPurpose ExclusivePurpose);
	static int32 GetUnacquiredCountFromGettable_TreasureBox(class UObject* WorldContextObject, const class UDataTable* TreasureBoxTable, class FName MapVolumeID);
	static class FString GetVehicleDisplayName(class UObject* WorldContextObject, EJackVehicleModelId ID);
	static class UJackWeatherAffectComponent* GetWeatherAffectComponent(class UObject* WorldContextObject);
	static EJackWhaleCharacterForm GetWhaleCharacterForm(const class UObject* WorldContextObject);
	static TArray<struct FJackWorldParticleContainer> GetWorldParticles(class UObject* WorldContextObject);
	static class UJackWorldTime* GetWorldTime(class UObject* WorldContextObject);
	static class UJackWorldWeather* GetWorldWeather(class UObject* WorldContextObject);
	static float GetYawLocationToLocation(const struct FVector& FromLocation, const struct FVector& ToLocation);
	static void GuestNpcJoin(class UObject* WorldContextObject, EJackCharacter InType, const struct FVector& Location, const struct FRotator& Rotation);
	static void GuestNpcLeave(class UObject* WorldContextObject, EJackCharacter InType);
	static void GuestNpcLeaveAll(class UObject* WorldContextObject);
	static bool HasLazyMessage(class UObject* WorldContextObject);
	static bool InteractToActor(class AActor* InteractorActor, class AActor* InteractiveActor);
	static bool InteractToComponent(class AActor* InteractorActor, class UJackInteractiveActorComponent* InteractiveActorComponent);
	static bool IsAcquiredActiveTokugiInPartyMember(class UObject* WorldContextObject);
	static bool IsAcquiredJumonInPartyMember(class UObject* WorldContextObject);
	static bool IsActorControlledByPlayer(class AActor* Actor);
	static bool IsActorPlayerMarker(class AActor* Actor);
	static bool IsAttachedPropTo(class AActor* Actor, class FName PropName);
	static bool IsBattleSimpleCameraMode(class UObject* WorldContextObject);
	static bool IsCameraAndPlayerMarkerCollisionIgnored(class UObject* WorldContextObject);
	static bool IsCaravan();
	static bool IsCategoryHidden(class UObject* WorldContextObject, EJackCategoryHiddenType InType);
	static bool IsDisableChangePlayBGM(class UObject* WorldContextObject);
	static bool IsEnabledLevelDebugDisplay();
	static bool IsEnabledLevelDebugFeature();
	static bool IsEnabledLevelStreamingUpdate(class UObject* WorldContextObject);
	static bool IsEnabledSleep(class UObject* WorldContextObject);
	static bool IsEnableFading(class UObject* WorldContextObject);
	static bool IsExchangeEnterButton();
	static bool IsExistsGameFlag(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static bool IsFadeAnimationRunning(class UObject* WorldContextObject);
	static bool IsGamePlayerCondition(class UObject* WorldContextObject, EJackGamePlayerCondition InCondition);
	static bool IsGameWorld(class UObject* WorldContextObject);
	static bool IsGottenFromGettableObject(class UObject* WorldContextObject, class FName GetFlag);
	static bool IsInputActionKeyDown(class AJackPlayerController* Controller, class FName ActionName);
	static bool IsLevelLoading(class UObject* WorldContextObject, const class FName LevelName);
	static bool IsMainGameMode(class UObject* WorldContextObject);
	static bool IsMatineeControlled(class AActor* InActor);
	static bool IsNavSystemBusy(class UObject* WorldContextObject);
	static bool IsOnAsyncFixupAnyCharacterLooks(class UObject* WorldContextObject);
	static bool IsOnAsyncFixupCharacterLooks(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static bool IsOpenedDressupCoordinate(class UObject* WorldContextObject, const struct FJackLDT_EquipmentCoordinate& Coordinate);
	static bool IsOpenSerifuWindow(class UObject* WorldContextObject);
	static bool IsPartyMember(class UObject* WorldContextObject, EJackCharacter InCharacterType);
	static bool IsPIE(class UObject* WorldContextObject);
	static bool IsPossessedPlayerControl(const class UObject* WorldContextObject);
	static bool IsPreloading(class UObject* WorldContextObject);
	static bool IsPreloadVehicleClassComplete(class UObject* WorldContextObject, EJackVehicleModelId ModelId);
	static bool IsResidentDataLoadCompleted(class UObject* WorldContextObject);
	static bool IsScenarioFlagBetween(class UObject* WorldContextObject, class FName Lower, bool bLowerEquals, class FName Value, bool bEqualsUpper, class FName Upper);
	static bool IsScenarioFlagGreaterThan(class UObject* WorldContextObject, class FName Lhs, bool bEquals, class FName Rhs);
	static bool IsScenarioFlagLessThan(class UObject* WorldContextObject, class FName Lhs, bool bEquals, class FName Rhs);
	static bool IsSenaShortHairCoordinate(const class UObject* WorldContextObject);
	static bool IsShowingLoadingScreen(class UObject* WorldContextObject);
	static bool IsSkipNPCTickAtLoadReductionEnabled(class UObject* WorldContextObject);
	static bool IsTaughtTabiNoKokoroe(class UObject* WorldContextObject, const struct FJackLDT_UITabiNoKokoroe& Key);
	static bool IsTravelMapGame(class UObject* WorldContextObject);
	static bool IsTrial();
	static bool IsTripleRunning(class UObject* WorldContextObject);
	static bool IsValidUMGManager(class UObject* WorldContextObject);
	static void LatentPossessPlayerControl(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EJackPlayerControlPossessor Possessor);
	static float Limits_Float_Max();
	static float Limits_Float_Min();
	static int32 Limits_Int32_Max();
	static int32 Limits_Int32_Min();
	static int32 Limits_Int8_Max();
	static int32 Limits_Int8_Min();
	static bool LineTraceSingleByCharacterCollisionChannel(const class AJackCharacter* JackCharacter, const struct FVector& Start, const struct FVector& End, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static bool LineTraceSingleByCollisionChannel(class UObject* WorldContextObject, ECollisionChannel CollisionChannel, const struct FVector& Start, const struct FVector& End, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, EDrawDebugTrace DrawDebugType, struct FHitResult* OutHit, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, float DrawTime);
	static void LoadStreamLevels(class UObject* WorldContextObject, const TArray<class FName>& LevelNames, bool bMakeVisibleAfterLoad, bool bShouldBlockOnLoad, const struct FLatentActionInfo& LatentInfo);
	static void LockDressupCoordinate(class UObject* WorldContextObject, EJackCharacter CharacterType, EJackDressupCoordinateLockReason Reason);
	static void LogLevelStreamingStatus(class UObject* WorldContextObject, const class FName NewMapStart);
	static struct FJackMessageArgumentData MakeJackMessageArgumentDataAtFloatValue(const class FString& ArgumentName, float ArgumentValue);
	static struct FJackMessageArgumentData MakeJackMessageArgumentDataAtGameCharacter(const class FString& ArgumentName, const class UJackGameCharacter* GameCharacter);
	static struct FJackMessageArgumentData MakeJackMessageArgumentDataAtGameCharacterType(const class UObject* WorldContextObject, const class FString& ArgumentName, const EJackCharacter CharacterType);
	static struct FJackMessageArgumentData MakeJackMessageArgumentDataAtIntValue(const class FString& ArgumentName, int32 ArgumentValue);
	static struct FRotator MakeRotation(const struct FVector& Direction);
	static void MapJumpBySavedGame(class UObject* WorldContextObject);
	static void Matinee_AddAcquiredJumon(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InJumon);
	static void Matinee_AddAcquiredTokugi(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InTokugi);
	static void Matinee_EquipItemOnlyLooks(class AActor* InActor, EJackEquipmentRegion InRegion, class FName ItemID);
	static void Matinee_RestoreEquipmentItem(class AActor* InActor);
	static void Matinee_UnEquipItemOnlyLooks(class AActor* InActor, EJackEquipmentRegion InRegion);
	static struct FVector2D MeasureText(const class UObject* WorldContextObject, const class FString& Text, const struct FSlateFontInfo& FontInfo);
	static void MergeCharacterBagToCommonBag(class UObject* WorldContextObject, EJackCharacter InType);
	static void MergeCharacterItem(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void MultiResetActorCinematicMipLevel(class AActor* Actor, const TArray<ETextureGroup>& CinematicTextureGroups);
	static void MultiResetMaterialCinematicMipLevel(class UMaterialInterface* Material, const TArray<ETextureGroup>& CinematicTextureGroups);
	static void MultiSetActorCinematicMipLevel(class AActor* Actor, const TArray<ETextureGroup>& CinematicTextureGroups, float CinematicMipLevelsDuration);
	static void MultiSetIgnoreTextureGroupLODBias(const TArray<ETextureGroup>& TargetTextureGroups, bool bIgnore);
	static void MultiSetMaterialCinematicMipLevel(class UMaterialInterface* Material, const TArray<ETextureGroup>& CinematicTextureGroups, float CinematicMipLevelsDuration);
	static void MultiSetTextureCinematicMipLevel(class UTexture* Texture, const TArray<ETextureGroup>& CinematicTextureGroups, float CinematicMipLevelsDuration);
	static void OpenFukidasi(class UObject* WorldContextObject, class AJackCharacter* Target, const class FString& FukidasiID, bool bCheckPlayerDistance);
	static void OutputLogMessage(class UObject* WorldContextObject, const class FString& Message);
	static void ParameterSettingPowerAwakening(class UObject* WorldContextObject);
	static void ParameterSettingWhenBackToThePast(class UObject* WorldContextObject);
	static void PartyRecovery(class UObject* WorldContextObject, EJackCharacterRecover Type);
	static void PartyResurrection(class UObject* WorldContextObject, bool bSetHP1, EJackCharacter CharacterType);
	static bool PlayBGM(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, TSoftObjectPtr<class USoundBase> Asset, EJackBGMControl Control, float FadeOutTime, float FadeInTime, float StartTime, bool bPushMusic);
	static bool PlayBGMFromAsset(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Asset, EJackBGMControl Control, float FadeOutTime, float FadeInTime, float StartTime);
	static bool PlayBGMFromAssetRef(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const struct FSoftObjectPath& MusicAssetRef, float FadeOutTime, bool bForceNewPlay, bool bPushMusic);
	static bool PlayBGMFromBGMID(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName BGMID, bool bNightTime, float FadeOutTime, float FadeInTime, float PregapTime, bool bPushMusic);
	static bool PlayBGMFromCSID(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName CSID, bool bNightTime, float FadeOutTime, float FadeInTime, float StartTime, bool bPushMusic);
	static bool PlayBGMFromMapID(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName MapId, bool bNightTime, float FadeOutTime, float FadeInTime, float StartTime, bool bPushMusic);
	static class UJackMaterialUpdaterCurve* PlayDamageMaterialAnimation(class AActor* Actor, const struct FJackLDT_DamageMaterialAnimation& AnimationName);
	static bool PlayEnvSoundFromAsset(class UObject* WorldContextObject, class USoundBase* Asset, float InDuration);
	static bool PlayEnvSoundFromMapID(class UObject* WorldContextObject, const class FName InMapId, bool bNightTime, EJackWorldWeather InWeatherType, EJackWorldWindLevel InWindLevelType, float InDuration);
	static bool PlayMEFromMEID(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName MeId, float FadeOutTime, float FadeInTime, bool bDontResumeBGM);
	static bool PlayMEFromMEIDByMEType(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName MeId, EJackMEType InMEType, float FadeOutTime, float FadeInTime, bool bDontResumeBGM);
	static bool PlayMinigameMEFromMEID(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName MeId, float FadeOutTime, float FadeInTime, bool bDontResumeBGM);
	static void PlayPartyTalkVoiceDirect(class AJackCharacter* InPlayVoice, class FName InVoiceID, bool bRandomLip);
	static void PlayPresetShake(class UObject* WorldContextObject, const struct FJackLDT_PresetCameraShake& PresetCameraShake, const struct FJackLDT_PresetForceFeedback& PresetForceFeedback, TSubclassOf<class UCameraShake> OverrideCameraShakeClass, class UForceFeedbackEffect* OverrideForceFeedback);
	static bool PlaySound2D_PlaybackComplete(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Sound, float VolumeMultiplier, float PitchMultiplier, float StartTime);
	static bool PlaySoundAtLocation_PlaybackComplete(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USoundBase* Sound, const struct FVector& Location, const struct FRotator& Rotation, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
	static bool PlaySoundAttached_PlaybackComplete(class UObject* WorldContextObject, class USoundBase* Sound, class USceneComponent* AttachToComponent, const struct FLatentActionInfo& LatentInfo, class FName AttachPointName, const struct FVector& Location, EAttachLocation LocationType, bool bStopWhenAttachedToDestroyed, float VolumeMultiplier, float PitchMultiplier, float StartTime, class USoundAttenuation* AttenuationSettings);
	static void PossessPlayerControl(class UObject* WorldContextObject, EJackPlayerControlPossessor Possessor);
	static void PostQuestComplete(class UObject* WorldContextObject, const class FName QuestFlagName);
	static class FName PreloadGetName(class UObject* WorldContextObject);
	static void PreloadMap(class UObject* WorldContextObject, const class FName MapStartName);
	static void PreloadMemoryOutPut(class UObject* WorldContextObject);
	static void PreloadStopWatchStart(class UObject* WorldContextObject, class FName KeyName);
	static void PreloadStopWatchStop(class UObject* WorldContextObject, class FName KeyName);
	static void PreloadVehicleClass(class UObject* WorldContextObject, EJackVehicleModelId ModelId);
	static bool RandomBoolFraction(int32 Denominator, int32 Numerator);
	static bool RandomBoolPercent(int32 Percent);
	static bool RandomBoolPercentFloat(float Percent);
	static bool RandomBoolRate(float Rate);
	static int32 RandomProbabilityTable(const TArray<int32>& ProbabilityTbl);
	static TArray<int32> RandomProbabilityTableArray(const TArray<int32>& ProbabilityTbl);
	static void ReapplyGameCharacterExp(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void RebuildAutoSave(class UObject* WorldContextObject);
	static void RefreshItemGettableObject(class UObject* WorldContextObject);
	static bool RemoteEvent(class UObject* WorldContextObject, class FName EventName, bool bLevelBlueprint, bool bActorBlueprint, class AActor* IgnoreActor);
	static bool RemoteEventWithIgnoreActor(class UObject* WorldContextObject, class FName EventName, bool bLevelBlueprint, bool bActorBlueprint, const TArray<class AActor*>& IgnoreActors);
	static void RemoveAcquiredActiveTokugi(class UObject* WorldContextObject, EJackCharacter InCharacterType, class FName InTokugi);
	static void RemoveBlendable_PlayerCameraPostProcessSettings(class UCameraComponent* CameraComputer, TScriptInterface<class IBlendableInterface> InBlendableObject);
	static void RemoveBlendable_PostProcess(class APostProcessVolume* ProcessVolume, TScriptInterface<class IBlendableInterface> InBlendableObject);
	static void RemoveCategoryHiddenExclusionTag(class UObject* WorldContextObject, class FName InTag);
	static void RemoveUMGWidget(class UObject* WorldContextObject, class UJackUMGWidgetBase* Widget);
	static TArray<class FString> ReplaceArrayMessageTag(class UObject* WorldContextObject, const TArray<class FString>& InTextArray, const TArray<struct FJackMessageArgumentData>& Args);
	static class FString ReplaceMessageTag(class UObject* WorldContextObject, const class FString& InText, const TArray<struct FJackMessageArgumentData>& Args);
	static class FString ReplacePlatformSpecificTextTags(const class FString& InString);
	static void RequestAutoSave(class UObject* WorldContextObject);
	static void RequestGC(class UObject* WorldContextObject);
	static void RequestPrepareMapChange(class UObject* WorldContextObject, const class FName NextMapStart, const class FName NextMapID, const struct FJackTravelMapInfo& TravelMapInfo);
	static void ReservePlayerControl(TDelegate<void(class AActor* PlayerActor, class AActor* ControlActor)> Delegate, class AActor* OtherActor, class AActor* ControlActor, EJackPlayerControlPossessor Possessor, int32 MinorPriority, class UPrimitiveComponent* OverlappingIgnoreComponent);
	static void ReservePlayerControlWithFailedEvent(TDelegate<void(class AActor* PlayerActor, class AActor* ControlActor)> Delegate, class AActor* OtherActor, class AActor* ControlActor, EJackPlayerControlPossessor Possessor, int32 MinorPriority, class UPrimitiveComponent* OverlappingIgnoreComponent, TDelegate<void()> FailedDelegate);
	static void ResetActorCinematicMipLevel(class AActor* Actor, ETextureGroup CinematicTextureGroup);
	static void ResetAllGameFlags(class UObject* WorldContextObject);
	static void ResetDressupCoordinate(class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void ResetFixedPartyMembers(const class UObject* WorldContextObject);
	static void ResetGameFlag(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static void ResetMaterialCinematicMipLevel(class UMaterialInterface* Material, ETextureGroup CinematicTextureGroup);
	static void RestoreVehicleRideStatus(class UObject* WorldContextObject);
	static bool ResumeBGM(class UObject* WorldContextObject, float FadeInTime, bool bIgnoreResumeDelay);
	static void Sample_ArgumentTest(class UObject* WorldContextObject, const struct FVector& Vector1, const struct FVector& Vector2, const struct FVector& Vector3, struct FVector& Vector4);
	static void Sample_CommentTest1(class UObject* WorldContextObject, int32 Test);
	static void Sample_CommentTest2(class UObject* WorldContextObject, int32 Test);
	static void Sample_CommentTest3(class UObject* WorldContextObject, int32 Test);
	static void Sample_CommentTest4(class UObject* WorldContextObject, int32 Test);
	static bool Sample_GetAny(class UObject* WorldContextObject);
	static void Sample_SetAny(class UObject* WorldContextObject, bool Boolean);
	static void SavingBackToThePastInfo(class UObject* WorldContextObject);
	static void ScreenDebugMessage(class UObject* WorldContextObject, const class FString& Message, float ScreenPositionX, float ScreenPositionY, float LifeTime, bool bDrawTile, bool bUniqMessageColor, const struct FColor& MessageColor);
	static void SEAD_AutoSeCtrl_SetEnable(bool bEnable);
	static void SEAD_CategoryCtrl_Resume(EJackSEADCategory Category, float FadeInTime);
	static void SEAD_CategoryCtrl_ResumeAll(float FadeInTime);
	static void SEAD_CategoryCtrl_SetLayerVolume(EJackSEADCategory Category, EJackSEADCategoryLayer Layer, float Volume, float FadeTime);
	static void SEAD_CategoryCtrl_SetMusicOptionVolume(float Volume, float FadeTime);
	static void SEAD_CategoryCtrl_SetSEOptionVolume(float Volume, float FadeTime);
	static void SEAD_CategoryCtrl_SetVoiceOptionVolume(float InVolume, float FadeTime, bool bEnableP001Voice);
	static void SEAD_CategoryCtrl_SetVolume(EJackSEADCategory Category, float Volume, float FadeTime);
	static void SEAD_CategoryCtrl_SetVolumeAll(float Volume, float FadeTime);
	static void SEAD_CategoryCtrl_Stop(EJackSEADCategory Category, float FadeOutTime);
	static void SEAD_CategoryCtrl_StopAll(float FadeOutTime);
	static void SEAD_CategoryCtrl_Suspend(EJackSEADCategory Category, float FadeOutTime);
	static void SEAD_CategoryCtrl_SuspendAll(float FadeOutTime);
	static class FName SEAD_GetCategoryName(EJackSEADCategory Category);
	static void SEAD_ZeroOneCtrl_SetValue(class UAudioComponent* AudioComponent, int32 Slot, float Value);
	static class AJackScheduledNPC* SearchNearestNPC(class AActor* BaseActor, float Distance, float Angle);
	static void SerifuExecution(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName TextID, const TArray<struct FJackMessageArgumentData>& TagValueList, const struct FJackSerifuAutomationFlags& AutomationFlags, bool bForceMessageEnd);
	static void SerifuExecutionStandby(class UObject* WorldContextObject);
	static void SetActorCinematicMipLevel(class AActor* Actor, ETextureGroup CinematicTextureGroup, float CinematicMipLevelsDuration);
	static void SetActorCoordinate(class AActor* Actor, const class FName CoordinateName);
	static void SetActorInputPriority(class AActor* Actor, EJackInputPriority InputPriority);
	static void SetActorLightingChannels(class AActor* Actor, const struct FLightingChannels& NewLightingChannels);
	static void SetBehaviorDirectBranch(class UObject* WorldContextObject, class FName InBranch);
	static void SetBehaviorDirectBranches(class UObject* WorldContextObject, const TArray<class FName>& InBranches);
	static void SetCameraAndPlayerMarkerCollisionIgnored(class UObject* WorldContextObject, bool bIgnored);
	static void SetCameraFade(class UObject* WorldContextObject, EJackCameraFadeCategory Layer, EJackCameraFadeZLayer ZLayer, float FadeAlpha, float FadeTime, const struct FLinearColor& FadeColor, bool bFadeAudio, bool bHoldWhenFinished);
	static void SetCameraResetRuraMove(class UObject* WorldContextObject, float InterpSec, bool bKeepYaw);
	static bool SetComponentVisibility(class AActor* Actor, class FName ComponentName, bool bVisibility);
	static void SetContactShadowLength(class ULightComponent* Component, float Length);
	static void SetControlledCharacterType(const class UObject* WorldContextObject, EJackCharacter CharacterType);
	static void SetCpuBoostMode(bool bEnable);
	static void SetDebugMenuBool(class UObject* WorldContextObject, const class FString& Name_0, bool Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDebugMenuByte(class UObject* WorldContextObject, const class FString& Name_0, uint8 Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static bool SetDebugMenuCursorLocation(class UObject* WorldContextObject, const class FString& CursorLocation);
	static void SetDebugMenuFloat(class UObject* WorldContextObject, const class FString& Name_0, float Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDebugMenuInt(class UObject* WorldContextObject, const class FString& Name_0, int32 Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDebugMenuLinearColor(class UObject* WorldContextObject, const class FString& Name_0, const struct FLinearColor& Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDebugMenuRotator(class UObject* WorldContextObject, const class FString& Name_0, const struct FRotator& Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDebugMenuVector(class UObject* WorldContextObject, const class FString& Name_0, const struct FVector& Value, const class FString& MenuTooltip, const class FString& SubMenuName);
	static void SetDefaultNearClippingPlane(class UObject* WorldContextObject);
	static void SetDepthPriorityGroup(class UPrimitiveComponent* PrimitiveComponent, ESceneDepthPriorityGroup NewDepthPriorityGroup);
	static void SetDisableJackGameViewportClientRendering(const class UObject* WorldContextObject, EJackGameViewportClientControlCategory Category, bool bDisable);
	static void SetDisableJackGameViewportClientVolumetricLightmap(const class UObject* WorldContextObject, EJackGameViewportClientControlCategory Category, bool bDisable);
	static void SetDressupCoordinate(class UObject* WorldContextObject, EJackCharacter CharacterType, const struct FJackLDT_EquipmentCoordinate& Coordinate);
	static void SetEnabledLevelStreamingUpdate(class UObject* WorldContextObject, bool bEnabled);
	static void SetEnabledLiveStreaming(class UObject* WorldContextObject, bool bEnable, bool bForce);
	static void SetEnabledScreenShot(class UObject* WorldContextObject, bool bEnable, bool bForce);
	static void SetEnabledSharePlay(class UObject* WorldContextObject, bool bEnable, bool bForce);
	static void SetEnabledSleep(class UObject* WorldContextObject, bool bEnable);
	static void SetEnabledVideoRecording(class UObject* WorldContextObject, bool bEnable, bool bForce);
	static void SetEnlightenUpdateRateFixedFrame(class UObject* WorldContextObject, int32 UpdateFrame);
	static void SetFieldPlayerCharacterType(const class UObject* WorldContextObject, EJackPlayerControlCharacter InPlayerControlCharacter);
	static void SetFixedPartyMembers(const class UObject* WorldContextObject, const TArray<EJackCharacter>& CharacterTypes);
	static void SetFollowingFriendCharacterHiddenAll(class UObject* WorldContextObject, EJackGuestNpcHiddenPurpose InPurpose, bool bInHidden, bool bInFade, bool bInFixedPosi);
	static void SetFollowingFriendCharacterHiddenByCharacterType(class UObject* WorldContextObject, EJackCharacter InCharacterType, EJackGuestNpcHiddenPurpose InPurpose, bool bInHidden, bool bInFade, bool bInFixedPosi);
	static void SetFootIKDisable(class UObject* WorldContextObject, class AJackCharacter* InCharacter, bool bInDisable, EJackFootIKControlPurpose InPurpose);
	static void SetFriendGuestBehaviorBranch(class UObject* WorldContextObject, EJackCharacter InType, int32 InNo);
	static void SetGameFlagBool(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0, bool Value);
	static void SetGameFlagFloat(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0, float Value);
	static void SetGameFlagInt(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0, int32 Value);
	static void SetGameFlagString(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0, const class FString& Value);
	static void SetGamePlayerCondition(class UObject* WorldContextObject, EJackGamePlayerCondition InCondition, EJackGamePlayerConditionControlPurpose InPurpose, bool bTrue);
	static void SetGuestNpcHiddenAll(class UObject* WorldContextObject, EJackGuestNpcHiddenPurpose InPurpose, bool bInHidden, bool bInFade, bool bInFixedPosi);
	static void SetGuestNpcHiddenByCharacterType(class UObject* WorldContextObject, EJackCharacter InCharacterType, EJackGuestNpcHiddenPurpose InPurpose, bool bInHidden, bool bInFade, bool bInFixedPosi);
	static void SetGuestNpcPosition(class UObject* WorldContextObject, EJackCharacter InType, const struct FVector& Location, const struct FRotator& Rotation);
	static void SetHeroCharacterForm(const class UObject* WorldContextObject, EJackHeroCharacterForm InHeroCharacterForm);
	static void SetIgnoreCheatSlomoCommand(class UObject* WorldContextObject, bool bIgnore);
	static void SetIgnoreTextureGroupLODBias(ETextureGroup TargetTextureGroup, bool bIgnore);
	static void SetLazyPartyConditionOffMessage(class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	static void SetLazyQuestMessage(class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	static void SetLazyTabiNoKokoroe(class UObject* WorldContextObject, const struct FJackLDT_UITabiNoKokoroe& Key);
	static void SetLazyTabiNoKokoroeWithFName(class UObject* WorldContextObject, class FName KeyRowName);
	static void SetLazyTokugiOkMessage(class UObject* WorldContextObject, class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	static void SetLevelStreamingVisible(class UObject* WorldContextObject, class ULevelStreaming* LevelStreaming, bool bShouldBeVisible);
	static void SetLightingChannels(class UPrimitiveComponent* PrimitiveComponent, const struct FLightingChannels& NewLightingChannels);
	static void SetLightIntensityAndColor(class ALight* Light, float IntensityBase, int32 Time, float CurveRate, class UCurveFloat* CurveIntensity, class UCurveLinearColor* CurveColor);
	static void SetLoadingScreenType(class UObject* WorldContextObject, EJackLoadingScreen InLoadingScreenType, EJackLoadingScreenTips InLoadingScreenTips, const class FName InTispId, bool bSetCsFlag);
	static void SetMaterialCinematicMipLevel(class UMaterialInterface* Material, ETextureGroup CinematicTextureGroup, float CinematicMipLevelsDuration);
	static void SetNearClippingPlane(class UObject* WorldContextObject, float NearClippingPlane);
	static void SetNPCReactionExternalTrigger(class UObject* WorldContextObject, EJackNPCReactionExternalTrigger Trigger);
	static void SetNPCScheduleControlCounter(class UObject* WorldContextObject, int32 Index_0, int32 Counter);
	static void SetOddEffectInotinoIsiIfHas(class UJackGameCharacter* InFriendGameCharacter);
	static void SetOddEffectInotinoIsiIfHasSelectBag(class UObject* WorldContextObject, EJackItem_Bag BagType);
	static void SetParticleSystemComponentAutoDestroy(const class UParticleSystemComponent* ParticleSystemComponent, bool bAutoDestroy);
	static void SetPlayerMarkerInTheRoom(class UObject* WorldContextObject, bool bInTheRoom);
	static void SetPropHiddenInGame(class AActor* Actor, class FName PropName, bool bHidden);
	static void SetPS4CheckerboardHistoryBlendWeight(float HistoryBlendWeight);
	static void SetRenkeiDisplayRefresh(class UObject* WorldContextObject);
	static void SetReserveFirstParadeAnimation(const class UObject* WorldContextObject, bool bReserve);
	static void SetRiremitoJumpTag(class UObject* WorldContextObject, const class FName JumpTag);
	static void SetRuraForceFailCondition(class UObject* WorldContextObject, EJackRuraFail FailType, EJackRuraFailPurpose FailPurpose);
	static void SetSenaHairStyle(const class UObject* WorldContextObject, EJackSenaHairStyle NewHairStyle);
	static void SetSkeletalMeshBoneTransformInComponentSpace(class USkeletalMeshComponent* SkeletalMeshComponent, class FName BoneName, const struct FTransform& TransformInComponentSpace);
	static void SetSkeletalMeshClothingAssetsBendResistance(class USkeletalMesh* SkeletalMesh, int32 Index_0, float BendResistance);
	static void SetSkeletalMeshClothingAssetsDamping(class USkeletalMesh* SkeletalMesh, int32 Index_0, float Damping);
	static void SetSkeletalMeshClothingAssetsDrag(class USkeletalMesh* SkeletalMesh, int32 Index_0, float Drag);
	static void SetSkeletalMeshClothingAssetsFriction(class USkeletalMesh* SkeletalMesh, int32 Index_0, float Friction);
	static void SetSkeletalMeshClothingAssetsGravityScale(class USkeletalMesh* SkeletalMesh, int32 Index_0, float GravityScale);
	static void SetSkeletalMeshClothingAssetsInertiaBlend(class USkeletalMesh* SkeletalMesh, int32 Index_0, float InertiaBlend);
	static void SetSkeletalMeshClothingAssetsSelfCollisionThickness(class USkeletalMesh* SkeletalMesh, int32 Index_0, float SelfCollisionThickness);
	static void SetSkeletalMeshClothingAssetsShearResistance(class USkeletalMesh* SkeletalMesh, int32 Index_0, float ShearResistance);
	static void SetSkeletalMeshClothingAssetsStretchLimit(class USkeletalMesh* SkeletalMesh, int32 Index_0, float StretchLimit);
	static void SetSkipNPCTickAtLoadReductionEnabled(class UObject* WorldContextObject, bool bFlag);
	static void SetTalkingNPC(class UObject* WorldContextObject, class AJackCharacter* NPC);
	static void SetTextureCinematicMipLevel(class UTexture* Texture, ETextureGroup CinematicTextureGroup, float CinematicMipLevelsDuration);
	static void SetUmayobiNoBeruFailCondition(class UObject* WorldContextObject, EJackUmayobiNoBeruFailPurpose FailPurpose, bool bFail);
	static void SetVehicleSpawnPoint(class UObject* WorldContextObject, const struct FVector& SpawnLocation, const struct FRotator& SpawnRotator);
	static void SetViewOwnerDepthPriorityGroup(class UPrimitiveComponent* PrimitiveComponent, bool bNewUseViewOwnerDepthPriorityGroup, ESceneDepthPriorityGroup NewViewOwnerDepthPriorityGroup);
	static void SetVisibilityLevelBrushModel(class UObject* WorldContextObject, class ULevel* Level, bool Visibility);
	static void SetWhaleCharacterForm(const class UObject* WorldContextObject, EJackWhaleCharacterForm InWhaleCharacterForm);
	static void ShowItemGetIconAtPlayerPos(const class UObject* WorldContextObject, EJackItemGetIcon IconType, class FName ItemID);
	static void SlomoCharacters(const class UObject* WorldContextObject, EJackCharacterScope Scope, EJackTimeDilationPurpose Purpose, float TimeDilation);
	static void SlomoWorld(const class UObject* WorldContextObject, EJackWorldTimeDilation Type, float TimeDilation);
	static bool SoundPlaybackComplete(class UObject* WorldContextObject, class UAudioComponent* AudioComponent, const struct FLatentActionInfo& LatentInfo);
	static bool SoundWaitFadeOut(class UObject* WorldContextObject, class UAudioComponent* AudioComponent, const struct FLatentActionInfo& LatentInfo);
	static void SpawnAndMountVehicle(class UObject* WorldContextObject, const struct FVector& InLocation, const struct FRotator& InRotation, EJackVehicleModelId ModelId);
	static void SpawnAndRideImmidiateIfNeed(class UObject* WorldContextObject);
	static void SpawnCollideEffect(class UObject* WorldContextObject, TSubclassOf<class UJackCollideEffect> Effect, const struct FHitResult& HitResult, const struct FVector& EffectLocation, const struct FRotator& EffectRotation, const struct FVector& DecalLocation, const struct FRotator& DecalRotation, float DecalAddSize, bool bOverrideAttachInfo, bool bOverrideAttached, class FName OverrideSocketName, EAttachLocation InOverrideAttachLocationType, const struct FVector& InOverrideOffsetLocation, const struct FRotator& InOverrideOffsetRotation, float InOverrideEffectLifeSpan);
	static void SpawnCollideEffectAtLocation(class UObject* WorldContextObject, TSubclassOf<class UJackCollideEffect> Effect, const struct FHitResult& HitResult, const struct FVector& HitLocation, const struct FRotator& HitRotation, const struct FVector& HitNormal, float EffectBumpOffset, float DecalAddSize, bool bOverrideAttachInfo, bool bOverrideAttached, class FName OverrideSocketName, EAttachLocation InOverrideAttachLocationType, const struct FVector& InOverrideOffsetLocation, const struct FRotator& InOverrideOffsetRotation, float InOverrideEffectLifeSpan);
	static void SpawnCollideEffectFromHitResult(class UObject* WorldContextObject, TSubclassOf<class UJackCollideEffect> Effect, const struct FHitResult& HitResult, float EffectBumpOffset, float DecalAddSize, bool bOverrideAttachInfo, bool bOverrideAttached, class FName OverrideSocketName, EAttachLocation InOverrideAttachLocationType, const struct FVector& InOverrideOffsetLocation, const struct FRotator& InOverrideOffsetRotation, float InOverrideEffectLifeSpan);
	static class AJackVehicle* SpawnVehicle(class UObject* WorldContextObject, EJackVehicleModelId ID);
	static class AJackWeaponBase* SpawnWeaponBody(class AActor* OwnerActor, class FName ItemID, EJackEquippedHand Hand);
	static class AJackWeaponBase* SpawnWeaponCase(class AActor* OwnerActor, class FName ItemID, EJackEquippedHand Hand);
	static bool SpecificLevelRemoteEvent(class UObject* WorldContextObject, class FName EventName, const TArray<class FName>& TargetLevelNames, bool bLevelBlueprint, bool bActorBlueprint, class AActor* IgnoreActor);
	static bool SpecificLevelRemoteEventWithIgnoreActor(class UObject* WorldContextObject, class FName EventName, const TArray<class FName>& TargetLevelNames, bool bLevelBlueprint, bool bActorBlueprint, const TArray<class AActor*>& IgnoreActors);
	static void SpecificTriggerMapChange(class UObject* WorldContextObject, const class FName NextMapStart, EJackFadeColor FadeColor, EJackFadeTime FadeTime, EJackBGMControl BGMControl, EJackFadeTime BGMFadeTime, bool bPlayMapChangeAnimation, bool bUnmountVehicle, EJackMapChangeSound PlayMapChangeSound);
	static class UJackMaterialUpdaterDT* StartActorMaterialCharacterUpdate(class UObject* WorldContextObject, class AActor* Actor, const struct FJackLDT_CharacterMaterialUpdater& AnimationName);
	static class UJackMaterialUpdaterCurve* StartActorMaterialCurveAlphaUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterCurve* StartActorMaterialCurveUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterHandle* StartActorMaterialLoopedCurveUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName, const class UCurveBase* StartCurve, const class UCurveBase* LoopCurve, float ValueScale, class UJackMaterialUpdaterHandle* Handle);
	static class UJackMaterialUpdaterScalar* StartActorMaterialScalarUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName, float DesiredValue, float Duration);
	static class UJackMaterialUpdaterVector* StartActorMaterialVectorUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName, const struct FLinearColor& DesiredValue, float Duration);
	static class UJackMaterialUpdaterCurve* StartComponentMaterialCurveAlphaUpdate(class UObject* WorldContextObject, class UPrimitiveComponent* Component, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterCurve* StartComponentMaterialCurveUpdate(class UObject* WorldContextObject, class UPrimitiveComponent* Component, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterScalar* StartComponentMaterialScalarUpdate(class UObject* WorldContextObject, class UPrimitiveComponent* Component, class FName ParameterName, float DesiredValue, float Duration);
	static class UJackMaterialUpdaterVector* StartComponentMaterialVectorUpdate(class UObject* WorldContextObject, class UPrimitiveComponent* Component, class FName ParameterName, const struct FLinearColor& DesiredValue, float Duration);
	static class UMaterialInstanceDynamic* StartCrossFade(class UObject* WorldContextObject, class APostProcessVolume* PostProcessVolume);
	static void StartLoadingScreen(class UObject* WorldContextObject, bool bAutoCompleteWhenLoadingCompletes);
	static class UJackMaterialUpdaterCurve* StartMaterialCurveAlphaUpdate(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterCurve* StartMaterialCurveUpdate(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterCurve* StartMaterialParameterCollectionCurveAlphaUpdate(class UObject* WorldContextObject, class UMaterialParameterCollection* MPC, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterCurve* StartMaterialParameterCollectionCurveUpdate(class UObject* WorldContextObject, class UMaterialParameterCollection* MPC, class FName ParameterName, class UCurveBase* Curve, float Duration);
	static class UJackMaterialUpdaterScalar* StartMaterialParameterCollectionScalarUpdate(class UObject* WorldContextObject, class UMaterialParameterCollection* MPC, class FName ParameterName, float DesiredValue, float Duration);
	static class UJackMaterialUpdaterVector* StartMaterialParameterCollectionVectorUpdate(class UObject* WorldContextObject, class UMaterialParameterCollection* MPC, class FName ParameterName, const struct FLinearColor& DesiredValue, float Duration);
	static class UJackMaterialUpdaterScalar* StartMaterialScalarUpdate(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParameterName, float DesiredValue, float Duration);
	static class UJackMaterialUpdaterVector* StartMaterialVectorUpdate(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParameterName, const struct FLinearColor& DesiredValue, float Duration);
	static void StartPostProcessAutoExposureBias(class UObject* WorldContextObject, class UCurveFloat* Curve);
	static void StartPostProcessAutoExposureBiasFromCharacter(class AJackCharacter* Character, class FName CurveName);
	static bool StopActorMaterialCharacterUpdate(class UObject* WorldContextObject, class AActor* Actor, const struct FJackLDT_CharacterMaterialUpdater& AnimationName);
	static bool StopActorMaterialUpdate(class UObject* WorldContextObject, class AActor* Actor, class FName ParameterName);
	static bool StopAllBGM(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float FadeOutTime);
	static bool StopBGM(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, float FadeOutTime, bool bDontResumeOldBGM);
	static bool StopComponentMaterialUpdate(class UObject* WorldContextObject, class UPrimitiveComponent* Component, class FName ParameterName);
	static void StopCrossFade(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class APostProcessVolume* PostProcessVolume);
	static bool StopCSBGM(class UObject* WorldContextObject, float InFadeOutTime, bool bDontResumeOldBGM);
	static void StopEnvSound(class UObject* WorldContextObject, float InDuration);
	static void StopLoadingScreen(class UObject* WorldContextObject, bool bSkipFlushStreaming);
	static bool StopMaterialParameterCollectionUpdate(class UObject* WorldContextObject, class UMaterialParameterCollection* MPC, class FName ParameterName);
	static bool StopMaterialUpdate(class UObject* WorldContextObject, class UMaterialInstanceDynamic* Mid, class FName ParameterName);
	static bool StopMaterialUpdaterHandle(class UObject* WorldContextObject, class UJackMaterialUpdaterHandle* Handle, float FadeOutTime);
	static bool StopMEForEmergency(const class UObject* WorldContextObject, float FOTime);
	static void StopPartyTalkVoiceDirect(class AJackCharacter* InPlayVoice);
	static bool SuspendBGM(class UObject* WorldContextObject, float FadeOutTime);
	static bool TakeFieldDamage(class UObject* WorldContextObject, EJackCharacter InType, int32 Damage, int32 MaxLow);
	static void TextHyphenation(const class UObject* WorldContextObject, const class FString& Text, const struct FSlateFontInfo& FontInfo, float ContentSize, int32 MaxLines, TArray<class FString>* OutLineTextArray);
	static void TextHyphenationForTextBlock(const class UObject* WorldContextObject, const class FString& Text, class UTextBlock* TextBlock, TArray<class FString>* OutLineTextArray);
	static bool TickGridPlaceLookAt(class UObject* WorldContextObject, const TArray<class USceneComponent*>& InAgentArray, class AActor* LookAtObj, float OrientOffset);
	static void TickGridPlaceOptimize(class UObject* WorldContextObject, const TArray<class USkeletalMeshComponent*>& InAgentArray);
	static bool TimeChangePostNative(const TArray<class APostProcessVolume*>& PostProcessVolume, int32 PostTime, const TArray<float>& BroomIntensity, bool bOverrideBloomIntensity, const TArray<float>& BloomThreshold, bool bOverrideBloomThreshold, const TArray<float>& BroomDirtMaskIntensity, bool bOverrideDirtMaskIntensity, const TArray<struct FLinearColor>& BloomDirtMaskTint, bool bOverrideDirtMaskTint, const TArray<float>& AutoExposeMinBrightness, bool bOverrideAutoExposeMinBrightness, const TArray<float>& AutoExposeMaxBrightness, bool bOverrideAutoExposeMaxBrightness, const TArray<float>& AmbientOcclusionIntensity, bool bOverrideAmbientOcclusionIntensity, const TArray<float>& AmbientOcclusionRadius, bool bOverrideAmbientOcclusionRadius, const TArray<float>& AmbientOcclusionPower, bool bOverrideAmbientOcclusionPower, const TArray<struct FLinearColor>& SceneColorSceneColorTint, bool bOverrideSceneColorSceneColorTint, const TArray<struct FLinearColor>& AmbientCubemapTint, bool bOverrideAmbientCubemapTint, const TArray<float>& AmbientCubemapIntensity, bool bOverrideAmbientCubemapIntensity, const TArray<float>& IndirectLightingIntensity, bool bOverrideIndirectLightingIntensity, const TArray<struct FLinearColor>& IndirectLightingColor, bool bOverrideIndirectLightingColor, const TArray<struct FLinearColor>& LinearColor_ColorGradingGlobalGain, bool bOverrideColorGradingGlobalGain);
	static bool ToggleGameFlagBool(class UObject* WorldContextObject, EJackGameFlagCategory Category, class FName Name_0);
	static void TransferPlayerControl(class UObject* WorldContextObject, EJackPlayerControlPossessor NewPossessor);
	static void TravelMap(class UObject* WorldContextObject, const class FName NextMapStart, const class FName NextMapID, const class FName TravelMapName);
	static void TriggerMapChange(class UObject* WorldContextObject, const class FName NextMapStart, const struct FJackMapJumpVolumeInfo& MapJumpVolumeInfo);
	static void UnloadAllFriendGameCharacters(class UObject* WorldContextObject);
	static void UnloadStreamLevels(class UObject* WorldContextObject, const TArray<class FName>& LevelNames, const struct FLatentActionInfo& LatentInfo);
	static void UnlockDressupCoordinate(class UObject* WorldContextObject, EJackCharacter CharacterType, EJackDressupCoordinateLockReason Reason);
	static void UnmountVehicleAndStoreVehicleRideStatus(class UObject* WorldContextObject, bool bAutoHidden, class AJackVehicle** OutVehicle);
	static void UnpossessPlayerControl(class UObject* WorldContextObject, EJackPlayerControlPossessor Possessor);
	static void UpdateAchievedSibariPlayFlag(class UObject* WorldContextObject);
	static void UpdateFollowingFriendCharacters(class UObject* WorldContextObject, bool bRelocation);
	static void UpdateFriendGuestBehaviorState(class UObject* WorldContextObject);
	static void UpdateLevelStreamingStatus(class UObject* WorldContextObject, const class FName CurrentMapStart, const struct FJackTravelMapInfo& TravelMapInfo);
	static void UpdateNavOctreeAfterMove(class USceneComponent* Comp);
	static void UpdateNavOctreeAll(class AActor* Actor, bool bUpdateAttachedActors);
	static void UpdateNavOctreeByActor(class AActor* Actor);
	static void UpdateNavOctreeByComponent(class UActorComponent* Comp);
	static void WaitCameraFade(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitCompleteChangeSchedulePatternAllScheduledNPC(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitCompleteChangeSchedulePatternScheduledNPC(class UObject* WorldContextObject, class AJackScheduledNPC* NPC, class FName EventName, const struct FLatentActionInfo& LatentInfo);
	static void WaitInitializingAllScheduledNPCForMatinee(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitLoadingAllCharactersCoordinate(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitLoadingCharacterCoordinate(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AJackCharacter* InJackCharacter);
	static void WaitMonsterGeneratorStable(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	static void WaitSaveLoad(class UObject* WorldContextObject);
	static bool WorldToScreen(class ULocalPlayer* InLocalPlayer, const struct FVector& InWorldLocation, struct FVector2D* OutScreenLocation);

	void FadeOutAllSounds(class UObject* WorldContextObject, float FadeOutTime, bool bIgnoreBGM);
	const struct FLightingChannels GetLightingChannelsDefaultValue(bool bEnableDefaultLighting, bool bEnableCharacterLighting, bool bEnableOffscreenRenderingLighting);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameplayStatics">();
	}
	static class UJackGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameplayStatics>();
	}
};
static_assert(alignof(UJackGameplayStatics) == 0x000008, "Wrong alignment on UJackGameplayStatics");
static_assert(sizeof(UJackGameplayStatics) == 0x000038, "Wrong size on UJackGameplayStatics");

// Class JackGame.JackUpdateWhenNotRenderedForTagTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackUpdateWhenNotRenderedForTagTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUpdateWhenNotRenderedForTagTrackInst">();
	}
	static class UJackUpdateWhenNotRenderedForTagTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUpdateWhenNotRenderedForTagTrackInst>();
	}
};
static_assert(alignof(UJackUpdateWhenNotRenderedForTagTrackInst) == 0x000008, "Wrong alignment on UJackUpdateWhenNotRenderedForTagTrackInst");
static_assert(sizeof(UJackUpdateWhenNotRenderedForTagTrackInst) == 0x000050, "Wrong size on UJackUpdateWhenNotRenderedForTagTrackInst");

// Class JackGame.JackAnimNotify_FootstepSoundTableRight
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotify_FootstepSoundTableRight final : public UJackAnimNotify_FootstepSoundTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundTableRight">();
	}
	static class UJackAnimNotify_FootstepSoundTableRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundTableRight>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundTableRight) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundTableRight");
static_assert(sizeof(UJackAnimNotify_FootstepSoundTableRight) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundTableRight");

// Class JackGame.JackAnimNotify_FootstepSoundType
// 0x0008 (0x0080 - 0x0078)
class UJackAnimNotify_FootstepSoundType : public UJackAnimNotify_FootstepSoundBase
{
public:
	EJackCharacterFootstepType                    FootstepType;                                      // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundType">();
	}
	static class UJackAnimNotify_FootstepSoundType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundType>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundType) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundType");
static_assert(sizeof(UJackAnimNotify_FootstepSoundType) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundType");
static_assert(offsetof(UJackAnimNotify_FootstepSoundType, FootstepType) == 0x000078, "Member 'UJackAnimNotify_FootstepSoundType::FootstepType' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepSoundTypeLeft
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotify_FootstepSoundTypeLeft final : public UJackAnimNotify_FootstepSoundType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundTypeLeft">();
	}
	static class UJackAnimNotify_FootstepSoundTypeLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundTypeLeft>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundTypeLeft) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundTypeLeft");
static_assert(sizeof(UJackAnimNotify_FootstepSoundTypeLeft) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundTypeLeft");

// Class JackGame.JackAnimNotify_FootstepSoundTypeRight
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotify_FootstepSoundTypeRight final : public UJackAnimNotify_FootstepSoundType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepSoundTypeRight">();
	}
	static class UJackAnimNotify_FootstepSoundTypeRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepSoundTypeRight>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepSoundTypeRight) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepSoundTypeRight");
static_assert(sizeof(UJackAnimNotify_FootstepSoundTypeRight) == 0x000080, "Wrong size on UJackAnimNotify_FootstepSoundTypeRight");

// Class JackGame.JackUmaRaceManager
// 0x00E8 (0x0480 - 0x0398)
class AJackUmaRaceManager final : public AActor
{
public:
	TSubclassOf<class AJackUmaRaceHud>            HUDClass;                                          // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackFieldPlayerUmaRaceController> PlayerControllerClass;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AJackVehicleUmaRace>        FarisPlayerVehicleClass;                           // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUmaRaceHorseType                         FarisPlayerVehicleType;                            // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x3];                                      // 0x03B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceRetireTime;                                   // 0x03B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x48];                                     // 0x03B8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     EntryDataTable;                                    // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UDataTable*>                     TimeScheduleDataTableArray;                        // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x60];                                     // 0x0420(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddSplinePathArray(const TArray<class AJackUmaRaceSplinePath*>& InComponents);
	void AddUnit(class AJackUmaRaceUnit* Unit);
	void ApplyClearEventItemGet(const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	void ApplyResult();
	float CalcPlayerToDistance(class AJackUmaRaceUnit* Unit);
	void ChangeCameraMode();
	void DebugLog();
	void DisableInputUnits();
	void EnableInputUnits();
	void EndRace();
	void Finalize();
	void ForceDashEnd();
	class FName GetClearEventItemGetName(const struct FJackDataTableUmaRaceMapData& InData, int32 InGoalRank);
	class FName GetClearItem(const struct FJackDataTableUmaRaceMapData& InData);
	TArray<EJackUmaRaceHorseType> GetHorseTypes();
	class AJackUmaRaceHud* GetHUD();
	int32 GetLapCountNum();
	int32 GetPlayerGoalRank();
	int32 GetPlayerRankFromLapTime();
	TArray<struct FJackUmaRaceResultParameter> GetResult();
	TArray<struct FJackUmaRaceResultParameter> GetResultFromTime();
	class USplineComponent* GetSplinePath(int32 No);
	class AJackFieldPlayerUmaRaceController* GetUmaRacePlayerController();
	class AJackUmaRaceUnit* GetUnit(int32 Index_0);
	int32 GetUnitNum();
	TArray<float> GetUnitRatioArray();
	TArray<class AJackUmaRaceUnit*> GetUnits();
	bool IsCheckGoal();
	bool IsClearBestTime();
	bool IsGiveUp();
	bool IsMountOK();
	bool IsStateIdle();
	bool IsTimeUp();
	void Mount(int32 Index_0, class AJackCharacter* PlayerCharacter);
	void MountAll();
	void OnForceRetireBp();
	void OnGiveUp();
	void PossessController(class AJackCharacter* Character);
	void QuantizeRaceTime();
	void RandomEntrySetting();
	void RegistEntryDataTable(const class UDataTable* Data);
	void ResetGame();
	void SaveLapTimes();
	void SetCourseJudgePath(class USplineComponent* InSplineComponent);
	void SetLapCountNum(int32 InLapCountNum);
	void SetShowDebugInfo(bool bIsEnable);
	class AJackUmaRaceHud* SpawnHud();
	void StartRace();
	bool Unmount();
	void UnPossessController();

	float CalcPlayerRatio() const;
	float GetRaceTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceManager">();
	}
	static class AJackUmaRaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceManager>();
	}
};
static_assert(alignof(AJackUmaRaceManager) == 0x000008, "Wrong alignment on AJackUmaRaceManager");
static_assert(sizeof(AJackUmaRaceManager) == 0x000480, "Wrong size on AJackUmaRaceManager");
static_assert(offsetof(AJackUmaRaceManager, HUDClass) == 0x000398, "Member 'AJackUmaRaceManager::HUDClass' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, PlayerControllerClass) == 0x0003A0, "Member 'AJackUmaRaceManager::PlayerControllerClass' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, FarisPlayerVehicleClass) == 0x0003A8, "Member 'AJackUmaRaceManager::FarisPlayerVehicleClass' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, FarisPlayerVehicleType) == 0x0003B0, "Member 'AJackUmaRaceManager::FarisPlayerVehicleType' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, ForceRetireTime) == 0x0003B4, "Member 'AJackUmaRaceManager::ForceRetireTime' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, EntryDataTable) == 0x000400, "Member 'AJackUmaRaceManager::EntryDataTable' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceManager, TimeScheduleDataTableArray) == 0x000410, "Member 'AJackUmaRaceManager::TimeScheduleDataTableArray' has a wrong offset!");

// Class JackGame.JackUMGMedalStampWindow
// 0x0030 (0x0430 - 0x0400)
class UJackUMGMedalStampWindow final : public UJackUMGWindowBase
{
public:
	float                                         AnimMarginOfFirstStamp;                            // 0x0400(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfShowStamp;                           // 0x0404(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfShowLargeStamp;                      // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfShowStampAndShowTreasureBox;         // 0x040C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfShowTreasureBoxAndShowItemGetMessage; // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimTimeOfHideTreasureBox;                         // 0x0414(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimTimeOfHideBottomInfo;                          // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfCompleteMessageAndShowCompleteStamp; // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimMarginOfShowCompleteStamp;                     // 0x0420(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimIntervalOfHidePageAndShowPage;                 // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimTimeOfShowNextPage;                            // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AnimMarginOfFinishOfStamp;                         // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	TArray<struct FJackUMGMedalStampAnimData> ExecuteMedalStamp(EJackMedal_Shop ShopType);
	class UTexture2D* GetItemIconTexture(class FName ItemID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMedalStampWindow">();
	}
	static class UJackUMGMedalStampWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMedalStampWindow>();
	}
};
static_assert(alignof(UJackUMGMedalStampWindow) == 0x000008, "Wrong alignment on UJackUMGMedalStampWindow");
static_assert(sizeof(UJackUMGMedalStampWindow) == 0x000430, "Wrong size on UJackUMGMedalStampWindow");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimMarginOfFirstStamp) == 0x000400, "Member 'UJackUMGMedalStampWindow::AnimMarginOfFirstStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfShowStamp) == 0x000404, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfShowStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfShowLargeStamp) == 0x000408, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfShowLargeStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfShowStampAndShowTreasureBox) == 0x00040C, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfShowStampAndShowTreasureBox' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfShowTreasureBoxAndShowItemGetMessage) == 0x000410, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfShowTreasureBoxAndShowItemGetMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimTimeOfHideTreasureBox) == 0x000414, "Member 'UJackUMGMedalStampWindow::AnimTimeOfHideTreasureBox' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimTimeOfHideBottomInfo) == 0x000418, "Member 'UJackUMGMedalStampWindow::AnimTimeOfHideBottomInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfCompleteMessageAndShowCompleteStamp) == 0x00041C, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfCompleteMessageAndShowCompleteStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimMarginOfShowCompleteStamp) == 0x000420, "Member 'UJackUMGMedalStampWindow::AnimMarginOfShowCompleteStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimIntervalOfHidePageAndShowPage) == 0x000424, "Member 'UJackUMGMedalStampWindow::AnimIntervalOfHidePageAndShowPage' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimTimeOfShowNextPage) == 0x000428, "Member 'UJackUMGMedalStampWindow::AnimTimeOfShowNextPage' has a wrong offset!");
static_assert(offsetof(UJackUMGMedalStampWindow, AnimMarginOfFinishOfStamp) == 0x00042C, "Member 'UJackUMGMedalStampWindow::AnimMarginOfFinishOfStamp' has a wrong offset!");

// Class JackGame.JackGameState
// 0x0000 (0x03F8 - 0x03F8)
class AJackGameState final : public AGameState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameState">();
	}
	static class AJackGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackGameState>();
	}
};
static_assert(alignof(AJackGameState) == 0x000008, "Wrong alignment on AJackGameState");
static_assert(sizeof(AJackGameState) == 0x0003F8, "Wrong size on AJackGameState");

// Class JackGame.JackAnimNotify_FootstepTable
// 0x0008 (0x0070 - 0x0068)
class UJackAnimNotify_FootstepTable : public UJackAnimNotify_FootstepBase
{
public:
	TSubclassOf<class UJackCollideEffectTable>    FootstepEffect;                                    // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepTable">();
	}
	static class UJackAnimNotify_FootstepTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepTable>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepTable) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepTable");
static_assert(sizeof(UJackAnimNotify_FootstepTable) == 0x000070, "Wrong size on UJackAnimNotify_FootstepTable");
static_assert(offsetof(UJackAnimNotify_FootstepTable, FootstepEffect) == 0x000068, "Member 'UJackAnimNotify_FootstepTable::FootstepEffect' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepTableLeft
// 0x0000 (0x0070 - 0x0070)
class UJackAnimNotify_FootstepTableLeft final : public UJackAnimNotify_FootstepTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepTableLeft">();
	}
	static class UJackAnimNotify_FootstepTableLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepTableLeft>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepTableLeft) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepTableLeft");
static_assert(sizeof(UJackAnimNotify_FootstepTableLeft) == 0x000070, "Wrong size on UJackAnimNotify_FootstepTableLeft");

// Class JackGame.JackFriendGameCharacter
// 0x0080 (0x06D0 - 0x0650)
class UJackFriendGameCharacter : public UJackGameCharacter
{
public:
	EJackItem_Bag                                 Bag;                                               // 0x0650(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFriend;                                           // 0x0651(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bGuest;                                            // 0x0652(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsLeaving;                                        // 0x0653(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSubjectOfAttack;                                // 0x0654(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsGetExp;                                         // 0x0655(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMenuDisp;                                       // 0x0656(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsPartyTalk;                                      // 0x0657(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReturnToBag;                                    // 0x0658(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsReturnToBagExceptEquip;                         // 0x0659(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsNotGuestDisp;                                   // 0x065A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_65B[0x5];                                      // 0x065B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BattleAI_ID;                                       // 0x0660(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         GambitRate;                                        // 0x0668(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BaseParameterID;                                   // 0x0670(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TalkSituation;                                     // 0x0678(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FieldDokuDamage;                                   // 0x067C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DokuLeftSec;                                       // 0x0680(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_684[0x4];                                      // 0x0684(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FieldExp;                                          // 0x0688(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68C[0x14];                                     // 0x068C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               CharacterAssetHolder;                              // 0x06A0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackStreamObjectsHolder*               CoordinateAssetHolder;                             // 0x06A8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6B0[0x20];                                     // 0x06B0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackCharacterResourcesLoadedSignature__DelegateSignature(class UJackFriendGameCharacter* FriendGameCharacter);
	void SetBag(EJackItem_Bag InBag);
	void SetBaseParameterID(class FName InBaseParameterID);
	void SetBattleAI_ID(class FName InBattleAI_ID);
	void SetDokuLeftSec(float DokuSec);
	void SetDokuLeftSecByTurn(int32 TurnNum);
	void SetExtraEquipmentsCoordinateID(class FName InCoordinateID);
	void SetFriend(bool bInFriend);
	void SetGambitRate(int32 InGambitRate);
	void SetGetExp(bool bInGetExp);
	void SetGuest(bool bInGuest);
	void SetLeaving(bool bInLeaving);
	void SetMenuDisp(bool bInMenuDisp);
	void SetNotGuestDisp(bool bInNotGuestDisp);
	void SetPartyTalk(bool bInPartyTalk);
	void SetReturnToBag(bool bInReturnToBag);
	void SetReturnToBagExceptEquip(bool bInReturnToBagExceptEquip);
	void SetSubjectOfAttack(bool bInSubjectOfAttack);
	void SetTalkSituation(int32 InTalkSituation);
	bool UpdateDokuLeftSec(float DeltaSec, float PoisonDamageInterval);

	EJackItem_Bag GetBag() const;
	class FName GetBaseParameterID() const;
	class FName GetBattleAI_ID() const;
	float GetDokuLeftSec() const;
	int32 GetDokuTurn() const;
	int32 GetFieldDokuDamage() const;
	bool IsFieldDoku() const;
	bool IsFriend() const;
	bool IsGetExp() const;
	bool IsGuest() const;
	bool IsLeaving() const;
	bool IsMenuDisp() const;
	bool IsNotGuestDisp() const;
	bool IsPartyTalk() const;
	bool IsReturnToBag() const;
	bool IsReturnToBagExceptEquip() const;
	bool IsSubjectOfAttack() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendGameCharacter">();
	}
	static class UJackFriendGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFriendGameCharacter>();
	}
};
static_assert(alignof(UJackFriendGameCharacter) == 0x000008, "Wrong alignment on UJackFriendGameCharacter");
static_assert(sizeof(UJackFriendGameCharacter) == 0x0006D0, "Wrong size on UJackFriendGameCharacter");
static_assert(offsetof(UJackFriendGameCharacter, Bag) == 0x000650, "Member 'UJackFriendGameCharacter::Bag' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bFriend) == 0x000651, "Member 'UJackFriendGameCharacter::bFriend' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bGuest) == 0x000652, "Member 'UJackFriendGameCharacter::bGuest' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsLeaving) == 0x000653, "Member 'UJackFriendGameCharacter::bIsLeaving' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsSubjectOfAttack) == 0x000654, "Member 'UJackFriendGameCharacter::bIsSubjectOfAttack' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsGetExp) == 0x000655, "Member 'UJackFriendGameCharacter::bIsGetExp' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsMenuDisp) == 0x000656, "Member 'UJackFriendGameCharacter::bIsMenuDisp' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsPartyTalk) == 0x000657, "Member 'UJackFriendGameCharacter::bIsPartyTalk' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsReturnToBag) == 0x000658, "Member 'UJackFriendGameCharacter::bIsReturnToBag' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsReturnToBagExceptEquip) == 0x000659, "Member 'UJackFriendGameCharacter::bIsReturnToBagExceptEquip' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, bIsNotGuestDisp) == 0x00065A, "Member 'UJackFriendGameCharacter::bIsNotGuestDisp' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, BattleAI_ID) == 0x000660, "Member 'UJackFriendGameCharacter::BattleAI_ID' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, GambitRate) == 0x000668, "Member 'UJackFriendGameCharacter::GambitRate' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, BaseParameterID) == 0x000670, "Member 'UJackFriendGameCharacter::BaseParameterID' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, TalkSituation) == 0x000678, "Member 'UJackFriendGameCharacter::TalkSituation' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, FieldDokuDamage) == 0x00067C, "Member 'UJackFriendGameCharacter::FieldDokuDamage' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, DokuLeftSec) == 0x000680, "Member 'UJackFriendGameCharacter::DokuLeftSec' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, FieldExp) == 0x000688, "Member 'UJackFriendGameCharacter::FieldExp' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, CharacterAssetHolder) == 0x0006A0, "Member 'UJackFriendGameCharacter::CharacterAssetHolder' has a wrong offset!");
static_assert(offsetof(UJackFriendGameCharacter, CoordinateAssetHolder) == 0x0006A8, "Member 'UJackFriendGameCharacter::CoordinateAssetHolder' has a wrong offset!");

// Class JackGame.JackGuestNpcGameCharacter
// 0x0020 (0x06F0 - 0x06D0)
class UJackGuestNpcGameCharacter final : public UJackFriendGameCharacter
{
public:
	uint8                                         Pad_6D0[0x20];                                     // 0x06D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGuestNpcGameCharacter">();
	}
	static class UJackGuestNpcGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGuestNpcGameCharacter>();
	}
};
static_assert(alignof(UJackGuestNpcGameCharacter) == 0x000008, "Wrong alignment on UJackGuestNpcGameCharacter");
static_assert(sizeof(UJackGuestNpcGameCharacter) == 0x0006F0, "Wrong size on UJackGuestNpcGameCharacter");

// Class JackGame.JackAnimNotify_FootstepTableRight
// 0x0000 (0x0070 - 0x0070)
class UJackAnimNotify_FootstepTableRight final : public UJackAnimNotify_FootstepTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepTableRight">();
	}
	static class UJackAnimNotify_FootstepTableRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepTableRight>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepTableRight) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepTableRight");
static_assert(sizeof(UJackAnimNotify_FootstepTableRight) == 0x000070, "Wrong size on UJackAnimNotify_FootstepTableRight");

// Class JackGame.JackAnimNotify_FootstepType
// 0x0008 (0x0070 - 0x0068)
class UJackAnimNotify_FootstepType : public UJackAnimNotify_FootstepBase
{
public:
	EJackCharacterFootstepType                    FootstepType;                                      // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepType">();
	}
	static class UJackAnimNotify_FootstepType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepType>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepType) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepType");
static_assert(sizeof(UJackAnimNotify_FootstepType) == 0x000070, "Wrong size on UJackAnimNotify_FootstepType");
static_assert(offsetof(UJackAnimNotify_FootstepType, FootstepType) == 0x000068, "Member 'UJackAnimNotify_FootstepType::FootstepType' has a wrong offset!");

// Class JackGame.JackUMGStateDispController
// 0x0018 (0x0050 - 0x0038)
class UJackUMGStateDispController final : public UObject
{
public:
	int32                                         NumDisp;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGCharStateType*>          StateList;                                         // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGStateDispController">();
	}
	static class UJackUMGStateDispController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGStateDispController>();
	}
};
static_assert(alignof(UJackUMGStateDispController) == 0x000008, "Wrong alignment on UJackUMGStateDispController");
static_assert(sizeof(UJackUMGStateDispController) == 0x000050, "Wrong size on UJackUMGStateDispController");
static_assert(offsetof(UJackUMGStateDispController, NumDisp) == 0x000038, "Member 'UJackUMGStateDispController::NumDisp' has a wrong offset!");
static_assert(offsetof(UJackUMGStateDispController, StateList) == 0x000040, "Member 'UJackUMGStateDispController::StateList' has a wrong offset!");

// Class JackGame.JackAnimNotify_FootstepTypeLeft
// 0x0000 (0x0070 - 0x0070)
class UJackAnimNotify_FootstepTypeLeft final : public UJackAnimNotify_FootstepType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepTypeLeft">();
	}
	static class UJackAnimNotify_FootstepTypeLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepTypeLeft>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepTypeLeft) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepTypeLeft");
static_assert(sizeof(UJackAnimNotify_FootstepTypeLeft) == 0x000070, "Wrong size on UJackAnimNotify_FootstepTypeLeft");

// Class JackGame.JackAnimNotify_FootstepTypeRight
// 0x0000 (0x0070 - 0x0070)
class UJackAnimNotify_FootstepTypeRight final : public UJackAnimNotify_FootstepType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_FootstepTypeRight">();
	}
	static class UJackAnimNotify_FootstepTypeRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_FootstepTypeRight>();
	}
};
static_assert(alignof(UJackAnimNotify_FootstepTypeRight) == 0x000008, "Wrong alignment on UJackAnimNotify_FootstepTypeRight");
static_assert(sizeof(UJackAnimNotify_FootstepTypeRight) == 0x000070, "Wrong size on UJackAnimNotify_FootstepTypeRight");

// Class JackGame.JackAnimNotify_HidePropActor
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotify_HidePropActor final : public UJackAnimNotify
{
public:
	class FName                                   PropName;                                          // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHidden;                                           // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_HidePropActor">();
	}
	static class UJackAnimNotify_HidePropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_HidePropActor>();
	}
};
static_assert(alignof(UJackAnimNotify_HidePropActor) == 0x000008, "Wrong alignment on UJackAnimNotify_HidePropActor");
static_assert(sizeof(UJackAnimNotify_HidePropActor) == 0x000058, "Wrong size on UJackAnimNotify_HidePropActor");
static_assert(offsetof(UJackAnimNotify_HidePropActor, PropName) == 0x000048, "Member 'UJackAnimNotify_HidePropActor::PropName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HidePropActor, bHidden) == 0x000050, "Member 'UJackAnimNotify_HidePropActor::bHidden' has a wrong offset!");

// Class JackGame.JackAnimNotify_HitByChannelsBase
// 0x0028 (0x0070 - 0x0048)
class UJackAnimNotify_HitByChannelsBase : public UJackAnimNotify
{
public:
	TArray<ECollisionChannel>                     CheckChannels;                                     // 0x0048(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   Socket;                                            // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckOffsetUpper;                                  // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CheckOffsetUnder;                                  // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepSphereRadius;                                 // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_HitByChannelsBase">();
	}
	static class UJackAnimNotify_HitByChannelsBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_HitByChannelsBase>();
	}
};
static_assert(alignof(UJackAnimNotify_HitByChannelsBase) == 0x000008, "Wrong alignment on UJackAnimNotify_HitByChannelsBase");
static_assert(sizeof(UJackAnimNotify_HitByChannelsBase) == 0x000070, "Wrong size on UJackAnimNotify_HitByChannelsBase");
static_assert(offsetof(UJackAnimNotify_HitByChannelsBase, CheckChannels) == 0x000048, "Member 'UJackAnimNotify_HitByChannelsBase::CheckChannels' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HitByChannelsBase, Socket) == 0x000058, "Member 'UJackAnimNotify_HitByChannelsBase::Socket' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HitByChannelsBase, CheckOffsetUpper) == 0x000060, "Member 'UJackAnimNotify_HitByChannelsBase::CheckOffsetUpper' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HitByChannelsBase, CheckOffsetUnder) == 0x000064, "Member 'UJackAnimNotify_HitByChannelsBase::CheckOffsetUnder' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HitByChannelsBase, SweepSphereRadius) == 0x000068, "Member 'UJackAnimNotify_HitByChannelsBase::SweepSphereRadius' has a wrong offset!");

// Class JackGame.JackUMGFukidasiWindowController
// 0x0420 (0x0458 - 0x0038)
class UJackUMGFukidasiWindowController : public UObject
{
public:
	TSubclassOf<class UUserWidget>                RootPanelWidgetClass;                              // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          ActionCursorWidgetPresetData;                      // 0x0040(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          BattleCursorWidgetPresetData;                      // 0x0070(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          ActionGuideWidgetPresetData;                       // 0x00A0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          FukidasiIconWidgetPresetData;                      // 0x00D0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          FukidasiWidgetPresetData;                          // 0x0100(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          NamePlateWidgetPresetData;                         // 0x0130(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          ItemGetIconWidgetPresetData;                       // 0x0160(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          MonsterExclamationWidgetPresetData;                // 0x0190(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          MonsterEmotionLoopIconWidgetPresetData;            // 0x01C0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          FusigiKaziMaterialWidgetPresetData;                // 0x01F0(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          FusigiKaziFailedWidgetPresetData;                  // 0x0220(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackUMGCharacterUIPresetData          FusigiKaziSuccessWidgetPresetData;                 // 0x0250(0x0030)(Edit, DisableEditOnInstance, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         OpenFukidasiAnimTime;                              // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           OpenFukidasiScaleAnimCurve;                        // 0x0288(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenFukidasiScaleAnimTime;                         // 0x0290(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_294[0x4];                                      // 0x0294(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            OpenFukidasiAlphaAnimCurve;                        // 0x0298(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenFukidasiAlphaAnimTime;                         // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A4[0x4];                                      // 0x02A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           OpenFukidasiFaceIconScaleAnimCurve;                // 0x02A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         OpenFukidasiFaceIconScaleAnimTime;                 // 0x02B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2B4[0x4];                                      // 0x02B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSlateFontInfo                         NamePlateFontInfo;                                 // 0x02B8(0x0058)(Edit, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbbreviationLengthBorder;                          // 0x0310(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         AbbreviatedNameLength;                             // 0x0314(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableOfNamePlateOverlapCheck;                    // 0x0318(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_319[0x3];                                      // 0x0319(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpSpeedOfNamePlateOverlapCheck;                // 0x031C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDontInterpAtInitializeOfNamePlateOverlapCheck;    // 0x0320(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayBattleCursorInForeground;                  // 0x0321(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_322[0x16];                                     // 0x0322(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGManager*                        UMGManager;                                        // 0x0338(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackHUD*                               HUD;                                               // 0x0340(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UUserWidget*                            RootWidget;                                        // 0x0348(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           RootPanelWidget;                                   // 0x0350(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGActionCursorData*               ActionCursorData;                                  // 0x0358(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGActionCursorBaseData*           ActionCursorIconData;                              // 0x0360(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMG3DWidgetData*                   BattleCursorData;                                  // 0x0368(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJackUMG3DWidgetData*>           ActionGuideDataList;                               // 0x0370(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGFukidasiIconData*>       FukidasiIconDataList;                              // 0x0380(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGFukidasiData*>           FukidasiDataList;                                  // 0x0390(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMonsterNamePlateData*>   NamePlateDataList;                                 // 0x03A0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UJackUMGItemGetIconData*                ItemGetIconData;                                   // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMonsterEmotionIconData*> MonsterEmotionIconDataList;                        // 0x03B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMonsterEmotionLoopIconData*> MonsterEmotionLoopIconDataList;                    // 0x03C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UJackUMGFusigiKaziEffectData*           FusigiKaziMaterialData;                            // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGFusigiKaziEffectData*           FusigiKaziFailedData;                              // 0x03E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGFusigiKaziEffectData*           FusigiKaziSuccessData;                             // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, class UTexture2D*>          PreloadedTextureMap;                               // 0x03F0(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x8];                                      // 0x0440(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackFukidasiLateTickActor> LateTickActor;                                     // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisplayUIFukidasiIconInfo;                        // 0x0450(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearPreloadedTexture();
	void CloseAllMonsterNamePlate();
	void CloseMonsterNamePlate(const class AJackCharacter* Target);
	void CloseNPCFukidasi(const class AJackCharacter* Target);
	void DrawUpdate3dWidget();
	void HideActionCursor(const class AActor* Target, const class UJackInteractiveActorComponent* TargetComponent);
	void HideActionCursorIcon(const class AActor* Target);
	void HideActionCursorWidget(const class UJackUMG3DWidgetData* Data);
	void HideActionGuide(const class AActor* Target, const class UJackInteractiveActorComponent* TargetComponent);
	void HideBattleCursor();
	void HideBattleCursorWidget(const class UJackUMG3DWidgetData* Data);
	void HideFukidasiIcon(const class AJackCharacter* Target);
	void HideFusigiKaziFailed();
	void HideFusigiKaziFailedWidget(const class UJackUMG3DWidgetData* Data);
	void HideFusigiKaziMaterial();
	void HideFusigiKaziMaterialWidget(const class UJackUMG3DWidgetData* Data);
	void HideFusigiKaziSuccess();
	void HideFusigiKaziSuccessWidget(const class UJackUMG3DWidgetData* Data);
	void HideItemGetIcon();
	void HideMonsterEmotionIcon(const class UJackUMG3DWidgetData* Data);
	void HideMonsterEmotionLoopIcon(const class AJackCharacter* Target, EJackMonsterEmotionIcon IconType);
	void HideMonsterEmotionLoopIconWidget(const class UJackUMG3DWidgetData* Data);
	void HideNamePlateWidget(const class UJackUMG3DWidgetData* Data);
	void InitActionGuideWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitBattleCursorWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitFukidasiIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitFukidasiWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitFusigiKaziFailedWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitFusigiKaziMaterialWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitFusigiKaziSuccessWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitItemGetIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitMonsterEmotionIcon(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitMonsterEmotionLoopIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void InitNamePlateWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	bool IsActionCursorVisible(const class AActor* Target, const class UJackInteractiveActorComponent* TargetComponent);
	void OpenActorFukidasi(class AActor* Target, const class FString& InMessage, float DisplaySeconds);
	void OpenActorNamePlate(const class AActor* Target, const class FString& Message);
	void OpenMonsterNamePlate(const class AJackCharacter* Target, const class FString& Message, const class FString& MonsterRawName);
	void OpenNPCFukidasi(class AJackCharacter* Target, const class FString& InMessage, float DisplaySeconds);
	void PreloadTextureByItemIdList(const TArray<class FName>& ItemIDList);
	void Set3dWidgetCaptureScreenPosition(const struct FVector2D& InScale, const struct FVector2D& InOffset);
	void ShowActionCursor(const class AActor* Target, const class UJackInteractiveActorComponent* TargetComponent);
	void ShowActionCursorIcon(const class AActor* Target, EJackActionCursor ActionCursorType, EJackNPCImportance Importance);
	void ShowActionGuide(const class AActor* Target, const class UJackInteractiveActorComponent* TargetComponent);
	void ShowBattleCursor(const class AActor* Target);
	void ShowFukidasiIcon(class AJackCharacter* Target);
	void ShowFusigiKaziFailed(const class AActor* Target, const TArray<class FName>& ItemIDList, class USceneCaptureComponent2D* SceneCaptureComponent2D);
	void ShowFusigiKaziMaterial(const class AActor* Target, const TArray<class FName>& ItemIDList, class USceneCaptureComponent2D* SceneCaptureComponent2D);
	void ShowFusigiKaziSuccess(const class AActor* Target, const TArray<class FName>& ItemIDList, class USceneCaptureComponent2D* SceneCaptureComponent2D);
	void ShowItemGetIcon(const class AJackCharacter* Target, EJackItemGetIcon IconType, const class FName& ItemID);
	void ShowMonsterEmotionIcon(const class AJackCharacter* Target, EJackMonsterEmotionIcon IconType);
	void ShowMonsterEmotionLoopIcon(const class AJackCharacter* Target, EJackMonsterEmotionIcon IconType);
	class AActor* SpawnActionCursor3dActor(TSubclassOf<class AActor> ActionCursor3dActorClass, const struct FTransform& Transform);
	void TextureLoadComplete(class FName ItemID, class UObject* LoadedObject);
	void UpdateActionCursorIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateActionCursorWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateBattleCursorWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateFukidasiIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateFukidasiWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateFusigiKaziFailedWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateFusigiKaziMaterialWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateFusigiKaziSuccessWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateMonsterEmotionIcon(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateMonsterEmotionLoopIconWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);
	void UpdateNamePlateWidget(class UUserWidget* Widget, const class UJackUMG3DWidgetData* Data);

	bool ExistsNPCFukidasi(const class AJackCharacter* Target) const;
	class UTexture2D* GetPreloadedTextureByItemId(class FName ItemID) const;
	bool IsCompletedPreloadTexture() const;
	bool IsNPCFukidasiOpened(const class AJackCharacter* Target) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFukidasiWindowController">();
	}
	static class UJackUMGFukidasiWindowController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFukidasiWindowController>();
	}
};
static_assert(alignof(UJackUMGFukidasiWindowController) == 0x000008, "Wrong alignment on UJackUMGFukidasiWindowController");
static_assert(sizeof(UJackUMGFukidasiWindowController) == 0x000458, "Wrong size on UJackUMGFukidasiWindowController");
static_assert(offsetof(UJackUMGFukidasiWindowController, RootPanelWidgetClass) == 0x000038, "Member 'UJackUMGFukidasiWindowController::RootPanelWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ActionCursorWidgetPresetData) == 0x000040, "Member 'UJackUMGFukidasiWindowController::ActionCursorWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, BattleCursorWidgetPresetData) == 0x000070, "Member 'UJackUMGFukidasiWindowController::BattleCursorWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ActionGuideWidgetPresetData) == 0x0000A0, "Member 'UJackUMGFukidasiWindowController::ActionGuideWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FukidasiIconWidgetPresetData) == 0x0000D0, "Member 'UJackUMGFukidasiWindowController::FukidasiIconWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FukidasiWidgetPresetData) == 0x000100, "Member 'UJackUMGFukidasiWindowController::FukidasiWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, NamePlateWidgetPresetData) == 0x000130, "Member 'UJackUMGFukidasiWindowController::NamePlateWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ItemGetIconWidgetPresetData) == 0x000160, "Member 'UJackUMGFukidasiWindowController::ItemGetIconWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, MonsterExclamationWidgetPresetData) == 0x000190, "Member 'UJackUMGFukidasiWindowController::MonsterExclamationWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, MonsterEmotionLoopIconWidgetPresetData) == 0x0001C0, "Member 'UJackUMGFukidasiWindowController::MonsterEmotionLoopIconWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziMaterialWidgetPresetData) == 0x0001F0, "Member 'UJackUMGFukidasiWindowController::FusigiKaziMaterialWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziFailedWidgetPresetData) == 0x000220, "Member 'UJackUMGFukidasiWindowController::FusigiKaziFailedWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziSuccessWidgetPresetData) == 0x000250, "Member 'UJackUMGFukidasiWindowController::FusigiKaziSuccessWidgetPresetData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiAnimTime) == 0x000280, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiAnimTime' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiScaleAnimCurve) == 0x000288, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiScaleAnimCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiScaleAnimTime) == 0x000290, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiScaleAnimTime' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiAlphaAnimCurve) == 0x000298, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiAlphaAnimCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiAlphaAnimTime) == 0x0002A0, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiAlphaAnimTime' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiFaceIconScaleAnimCurve) == 0x0002A8, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiFaceIconScaleAnimCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, OpenFukidasiFaceIconScaleAnimTime) == 0x0002B0, "Member 'UJackUMGFukidasiWindowController::OpenFukidasiFaceIconScaleAnimTime' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, NamePlateFontInfo) == 0x0002B8, "Member 'UJackUMGFukidasiWindowController::NamePlateFontInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, AbbreviationLengthBorder) == 0x000310, "Member 'UJackUMGFukidasiWindowController::AbbreviationLengthBorder' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, AbbreviatedNameLength) == 0x000314, "Member 'UJackUMGFukidasiWindowController::AbbreviatedNameLength' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, bEnableOfNamePlateOverlapCheck) == 0x000318, "Member 'UJackUMGFukidasiWindowController::bEnableOfNamePlateOverlapCheck' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, InterpSpeedOfNamePlateOverlapCheck) == 0x00031C, "Member 'UJackUMGFukidasiWindowController::InterpSpeedOfNamePlateOverlapCheck' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, bDontInterpAtInitializeOfNamePlateOverlapCheck) == 0x000320, "Member 'UJackUMGFukidasiWindowController::bDontInterpAtInitializeOfNamePlateOverlapCheck' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, bDisplayBattleCursorInForeground) == 0x000321, "Member 'UJackUMGFukidasiWindowController::bDisplayBattleCursorInForeground' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, UMGManager) == 0x000338, "Member 'UJackUMGFukidasiWindowController::UMGManager' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, HUD) == 0x000340, "Member 'UJackUMGFukidasiWindowController::HUD' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, RootWidget) == 0x000348, "Member 'UJackUMGFukidasiWindowController::RootWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, RootPanelWidget) == 0x000350, "Member 'UJackUMGFukidasiWindowController::RootPanelWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ActionCursorData) == 0x000358, "Member 'UJackUMGFukidasiWindowController::ActionCursorData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ActionCursorIconData) == 0x000360, "Member 'UJackUMGFukidasiWindowController::ActionCursorIconData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, BattleCursorData) == 0x000368, "Member 'UJackUMGFukidasiWindowController::BattleCursorData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ActionGuideDataList) == 0x000370, "Member 'UJackUMGFukidasiWindowController::ActionGuideDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FukidasiIconDataList) == 0x000380, "Member 'UJackUMGFukidasiWindowController::FukidasiIconDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FukidasiDataList) == 0x000390, "Member 'UJackUMGFukidasiWindowController::FukidasiDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, NamePlateDataList) == 0x0003A0, "Member 'UJackUMGFukidasiWindowController::NamePlateDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, ItemGetIconData) == 0x0003B0, "Member 'UJackUMGFukidasiWindowController::ItemGetIconData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, MonsterEmotionIconDataList) == 0x0003B8, "Member 'UJackUMGFukidasiWindowController::MonsterEmotionIconDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, MonsterEmotionLoopIconDataList) == 0x0003C8, "Member 'UJackUMGFukidasiWindowController::MonsterEmotionLoopIconDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziMaterialData) == 0x0003D8, "Member 'UJackUMGFukidasiWindowController::FusigiKaziMaterialData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziFailedData) == 0x0003E0, "Member 'UJackUMGFukidasiWindowController::FusigiKaziFailedData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, FusigiKaziSuccessData) == 0x0003E8, "Member 'UJackUMGFukidasiWindowController::FusigiKaziSuccessData' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, PreloadedTextureMap) == 0x0003F0, "Member 'UJackUMGFukidasiWindowController::PreloadedTextureMap' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, LateTickActor) == 0x000448, "Member 'UJackUMGFukidasiWindowController::LateTickActor' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiWindowController, bDisplayUIFukidasiIconInfo) == 0x000450, "Member 'UJackUMGFukidasiWindowController::bDisplayUIFukidasiIconInfo' has a wrong offset!");

// Class JackGame.JackUMGNeighborMapInfo
// 0x0020 (0x00A8 - 0x0088)
class UJackUMGNeighborMapInfo final : public UJackUMGItemData
{
public:
	bool                                          bEnabled;                                          // 0x0088(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapVolumeID;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DisplayLocationName;                               // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGNeighborMapInfo">();
	}
	static class UJackUMGNeighborMapInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGNeighborMapInfo>();
	}
};
static_assert(alignof(UJackUMGNeighborMapInfo) == 0x000008, "Wrong alignment on UJackUMGNeighborMapInfo");
static_assert(sizeof(UJackUMGNeighborMapInfo) == 0x0000A8, "Wrong size on UJackUMGNeighborMapInfo");
static_assert(offsetof(UJackUMGNeighborMapInfo, bEnabled) == 0x000088, "Member 'UJackUMGNeighborMapInfo::bEnabled' has a wrong offset!");
static_assert(offsetof(UJackUMGNeighborMapInfo, MapVolumeID) == 0x000090, "Member 'UJackUMGNeighborMapInfo::MapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGNeighborMapInfo, DisplayLocationName) == 0x000098, "Member 'UJackUMGNeighborMapInfo::DisplayLocationName' has a wrong offset!");

// Class JackGame.JackLocator
// 0x0008 (0x03A0 - 0x0398)
class AJackLocator : public AActor
{
public:
	int32                                         LocatorSortPriority;                               // 0x0398(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLocator">();
	}
	static class AJackLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackLocator>();
	}
};
static_assert(alignof(AJackLocator) == 0x000008, "Wrong alignment on AJackLocator");
static_assert(sizeof(AJackLocator) == 0x0003A0, "Wrong size on AJackLocator");
static_assert(offsetof(AJackLocator, LocatorSortPriority) == 0x000398, "Member 'AJackLocator::LocatorSortPriority' has a wrong offset!");

// Class JackGame.JackGoalMarker
// 0x0008 (0x03A8 - 0x03A0)
class AJackGoalMarker : public AJackLocator
{
public:
	uint8                                         Pad_3A0[0x4];                                      // 0x03A0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	float GetRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGoalMarker">();
	}
	static class AJackGoalMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackGoalMarker>();
	}
};
static_assert(alignof(AJackGoalMarker) == 0x000008, "Wrong alignment on AJackGoalMarker");
static_assert(sizeof(AJackGoalMarker) == 0x0003A8, "Wrong size on AJackGoalMarker");
static_assert(offsetof(AJackGoalMarker, Radius) == 0x0003A4, "Member 'AJackGoalMarker::Radius' has a wrong offset!");

// Class JackGame.JackAnimNotify_HitEffectByChannels
// 0x00A0 (0x0110 - 0x0070)
class UJackAnimNotify_HitEffectByChannels final : public UJackAnimNotify_HitByChannelsBase
{
public:
	TMap<EPhysicalSurface, class UParticleSystem*> HitEffect;                                         // 0x0070(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TMap<EPhysicalSurface, class USoundBase*>     HitSound;                                          // 0x00C0(0x0050)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_HitEffectByChannels">();
	}
	static class UJackAnimNotify_HitEffectByChannels* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_HitEffectByChannels>();
	}
};
static_assert(alignof(UJackAnimNotify_HitEffectByChannels) == 0x000008, "Wrong alignment on UJackAnimNotify_HitEffectByChannels");
static_assert(sizeof(UJackAnimNotify_HitEffectByChannels) == 0x000110, "Wrong size on UJackAnimNotify_HitEffectByChannels");
static_assert(offsetof(UJackAnimNotify_HitEffectByChannels, HitEffect) == 0x000070, "Member 'UJackAnimNotify_HitEffectByChannels::HitEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_HitEffectByChannels, HitSound) == 0x0000C0, "Member 'UJackAnimNotify_HitEffectByChannels::HitSound' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayBattleFukidasi
// 0x0000 (0x0048 - 0x0048)
class UJackAnimNotify_PlayBattleFukidasi final : public UJackAnimNotify
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayBattleFukidasi">();
	}
	static class UJackAnimNotify_PlayBattleFukidasi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayBattleFukidasi>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayBattleFukidasi) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayBattleFukidasi");
static_assert(sizeof(UJackAnimNotify_PlayBattleFukidasi) == 0x000048, "Wrong size on UJackAnimNotify_PlayBattleFukidasi");

// Class JackGame.JackPlayableAnimInstance
// 0x0100 (0x0CE0 - 0x0BE0)
#pragma pack(push, 0x1)
class alignas(0x10) UJackPlayableAnimInstance : public UJackAnimInstance
{
public:
	uint8                                         Pad_BD8[0x4];                                      // 0x0BD8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRate;                                      // 0x0BDC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementYaw;                                       // 0x0BE0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementAnimationPlayRate;                         // 0x0BE4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsInTheAir;                                       // 0x0BE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE9[0x3];                                      // 0x0BE9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageAnimationApplyRate;                          // 0x0BEC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpUpperBodyAnimationWeight;                      // 0x0BF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpLowerBodyAnimationWeight;                      // 0x0BF4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bJumpEndEnabled;                                   // 0x0BF8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF9[0x3];                                      // 0x0BF9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MovementRateInterpSpeed;                           // 0x0BFC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpEndAnimationLength;                            // 0x0C00(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpUpperMovementRateScale;                     // 0x0C04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpLinearUpperMovementRateScale;                  // 0x0C08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpUpperExp;                                   // 0x0C0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpLowerMovementRateScale;                     // 0x0C10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpLinearLowerMovementRateScale;                  // 0x0C14(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpLowerOffset;                                // 0x0C18(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpLowerScale;                                 // 0x0C1C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         JumpExpLowerExp;                                   // 0x0C20(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bHasTorch;                                         // 0x0C24(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C25[0x3];                                      // 0x0C25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpTimer;                                         // 0x0C28(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpAddMotionblendWeight;                          // 0x0C2C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementAnimationTranslationMultiplier;            // 0x0C30(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C34[0x7C];                                     // 0x0C34(0x007C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveMotionRateWalkSpeed;                           // 0x0CB0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RootMotionMultiChangeSpeed;                        // 0x0CB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RootMotionMultiLimitMin;                           // 0x0CB8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RootMotionMultiThreshold;                          // 0x0CBC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         WaitColliderMultiplier;                            // 0x0CC0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CC4[0x14];                                     // 0x0CC4(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetJumpTimer();
	void SetMovementRateDirectly(float InMovementRate);

	bool IsSkipAnimOpenWeapon() const;
	bool IsWeaponStyleChanging() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableAnimInstance">();
	}
	static class UJackPlayableAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackPlayableAnimInstance) == 0x000010, "Wrong alignment on UJackPlayableAnimInstance");
static_assert(sizeof(UJackPlayableAnimInstance) == 0x000CE0, "Wrong size on UJackPlayableAnimInstance");
static_assert(offsetof(UJackPlayableAnimInstance, MovementRate) == 0x000BDC, "Member 'UJackPlayableAnimInstance::MovementRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, MovementYaw) == 0x000BE0, "Member 'UJackPlayableAnimInstance::MovementYaw' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, MovementAnimationPlayRate) == 0x000BE4, "Member 'UJackPlayableAnimInstance::MovementAnimationPlayRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, bIsInTheAir) == 0x000BE8, "Member 'UJackPlayableAnimInstance::bIsInTheAir' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, DamageAnimationApplyRate) == 0x000BEC, "Member 'UJackPlayableAnimInstance::DamageAnimationApplyRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpUpperBodyAnimationWeight) == 0x000BF0, "Member 'UJackPlayableAnimInstance::JumpUpperBodyAnimationWeight' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpLowerBodyAnimationWeight) == 0x000BF4, "Member 'UJackPlayableAnimInstance::JumpLowerBodyAnimationWeight' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, bJumpEndEnabled) == 0x000BF8, "Member 'UJackPlayableAnimInstance::bJumpEndEnabled' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, MovementRateInterpSpeed) == 0x000BFC, "Member 'UJackPlayableAnimInstance::MovementRateInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpEndAnimationLength) == 0x000C00, "Member 'UJackPlayableAnimInstance::JumpEndAnimationLength' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpUpperMovementRateScale) == 0x000C04, "Member 'UJackPlayableAnimInstance::JumpExpUpperMovementRateScale' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpLinearUpperMovementRateScale) == 0x000C08, "Member 'UJackPlayableAnimInstance::JumpLinearUpperMovementRateScale' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpUpperExp) == 0x000C0C, "Member 'UJackPlayableAnimInstance::JumpExpUpperExp' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpLowerMovementRateScale) == 0x000C10, "Member 'UJackPlayableAnimInstance::JumpExpLowerMovementRateScale' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpLinearLowerMovementRateScale) == 0x000C14, "Member 'UJackPlayableAnimInstance::JumpLinearLowerMovementRateScale' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpLowerOffset) == 0x000C18, "Member 'UJackPlayableAnimInstance::JumpExpLowerOffset' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpLowerScale) == 0x000C1C, "Member 'UJackPlayableAnimInstance::JumpExpLowerScale' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpExpLowerExp) == 0x000C20, "Member 'UJackPlayableAnimInstance::JumpExpLowerExp' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, bHasTorch) == 0x000C24, "Member 'UJackPlayableAnimInstance::bHasTorch' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpTimer) == 0x000C28, "Member 'UJackPlayableAnimInstance::JumpTimer' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, JumpAddMotionblendWeight) == 0x000C2C, "Member 'UJackPlayableAnimInstance::JumpAddMotionblendWeight' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, MovementAnimationTranslationMultiplier) == 0x000C30, "Member 'UJackPlayableAnimInstance::MovementAnimationTranslationMultiplier' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, MoveMotionRateWalkSpeed) == 0x000CB0, "Member 'UJackPlayableAnimInstance::MoveMotionRateWalkSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, RootMotionMultiChangeSpeed) == 0x000CB4, "Member 'UJackPlayableAnimInstance::RootMotionMultiChangeSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, RootMotionMultiLimitMin) == 0x000CB8, "Member 'UJackPlayableAnimInstance::RootMotionMultiLimitMin' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, RootMotionMultiThreshold) == 0x000CBC, "Member 'UJackPlayableAnimInstance::RootMotionMultiThreshold' has a wrong offset!");
static_assert(offsetof(UJackPlayableAnimInstance, WaitColliderMultiplier) == 0x000CC0, "Member 'UJackPlayableAnimInstance::WaitColliderMultiplier' has a wrong offset!");

// Class JackGame.JackFriendAnimInstance
// 0x0010 (0x0CF0 - 0x0CE0)
class UJackFriendAnimInstance final : public UJackPlayableAnimInstance
{
public:
	float                                         WalkAnimationSpeed;                                // 0x0CD8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WalkAnimationRateInBlend;                          // 0x0CDC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAnimationSpeed;                                 // 0x0CE0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RunAnimationRateInBlend;                           // 0x0CE4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFriendAnimation                          FriendAnimationType;                               // 0x0CE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CE9[0x7];                                      // 0x0CE9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJackArmIKResult GetLeftArmIKReslt() const;
	EJackPlayableMovement GetPlayableMovementType() const;
	struct FJackArmIKResult GetRightArmIKReslt() const;
	bool IsSlippingOff() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendAnimInstance">();
	}
	static class UJackFriendAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFriendAnimInstance>();
	}
};
static_assert(alignof(UJackFriendAnimInstance) == 0x000010, "Wrong alignment on UJackFriendAnimInstance");
static_assert(sizeof(UJackFriendAnimInstance) == 0x000CF0, "Wrong size on UJackFriendAnimInstance");
static_assert(offsetof(UJackFriendAnimInstance, WalkAnimationSpeed) == 0x000CD8, "Member 'UJackFriendAnimInstance::WalkAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimInstance, WalkAnimationRateInBlend) == 0x000CDC, "Member 'UJackFriendAnimInstance::WalkAnimationRateInBlend' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimInstance, RunAnimationSpeed) == 0x000CE0, "Member 'UJackFriendAnimInstance::RunAnimationSpeed' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimInstance, RunAnimationRateInBlend) == 0x000CE4, "Member 'UJackFriendAnimInstance::RunAnimationRateInBlend' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimInstance, FriendAnimationType) == 0x000CE8, "Member 'UJackFriendAnimInstance::FriendAnimationType' has a wrong offset!");

// Class JackGame.JackVehicleFakeForceTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackVehicleFakeForceTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleFakeForceTrack">();
	}
	static class UJackVehicleFakeForceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleFakeForceTrack>();
	}
};
static_assert(alignof(UJackVehicleFakeForceTrack) == 0x000008, "Wrong alignment on UJackVehicleFakeForceTrack");
static_assert(sizeof(UJackVehicleFakeForceTrack) == 0x0000A8, "Wrong size on UJackVehicleFakeForceTrack");

// Class JackGame.JackAnimNotify_PlayCameraAnim
// 0x0038 (0x0080 - 0x0048)
class UJackAnimNotify_PlayCameraAnim final : public UJackAnimNotify
{
public:
	EJackPlayerController                         PlayerController;                                  // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraAnim*                            Anim;                                              // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomStartTime;                                  // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x2];                                       // 0x006A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRot;                                  // 0x0074(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCameraAnim">();
	}
	static class UJackAnimNotify_PlayCameraAnim* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCameraAnim>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCameraAnim) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCameraAnim");
static_assert(sizeof(UJackAnimNotify_PlayCameraAnim) == 0x000080, "Wrong size on UJackAnimNotify_PlayCameraAnim");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, PlayerController) == 0x000048, "Member 'UJackAnimNotify_PlayCameraAnim::PlayerController' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, Anim) == 0x000050, "Member 'UJackAnimNotify_PlayCameraAnim::Anim' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, Rate) == 0x000058, "Member 'UJackAnimNotify_PlayCameraAnim::Rate' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, Scale) == 0x00005C, "Member 'UJackAnimNotify_PlayCameraAnim::Scale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, BlendInTime) == 0x000060, "Member 'UJackAnimNotify_PlayCameraAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, BlendOutTime) == 0x000064, "Member 'UJackAnimNotify_PlayCameraAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, bLoop) == 0x000068, "Member 'UJackAnimNotify_PlayCameraAnim::bLoop' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, bRandomStartTime) == 0x000069, "Member 'UJackAnimNotify_PlayCameraAnim::bRandomStartTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, Duration) == 0x00006C, "Member 'UJackAnimNotify_PlayCameraAnim::Duration' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, PlaySpace) == 0x000070, "Member 'UJackAnimNotify_PlayCameraAnim::PlaySpace' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraAnim, UserPlaySpaceRot) == 0x000074, "Member 'UJackAnimNotify_PlayCameraAnim::UserPlaySpaceRot' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayCameraLensEffect
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotify_PlayCameraLensEffect final : public UJackAnimNotify
{
public:
	TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass;                            // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LifeSpan;                                          // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCameraLensEffect">();
	}
	static class UJackAnimNotify_PlayCameraLensEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCameraLensEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCameraLensEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCameraLensEffect");
static_assert(sizeof(UJackAnimNotify_PlayCameraLensEffect) == 0x000058, "Wrong size on UJackAnimNotify_PlayCameraLensEffect");
static_assert(offsetof(UJackAnimNotify_PlayCameraLensEffect, LensEffectEmitterClass) == 0x000048, "Member 'UJackAnimNotify_PlayCameraLensEffect::LensEffectEmitterClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraLensEffect, LifeSpan) == 0x000050, "Member 'UJackAnimNotify_PlayCameraLensEffect::LifeSpan' has a wrong offset!");

// Class JackGame.JackUMG3DWidgetData
// 0x0060 (0x0098 - 0x0038)
class UJackUMG3DWidgetData : public UObject
{
public:
	class AActor*                                 TargetActor;                                       // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x4];                                       // 0x0040(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0044(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bProjected;                                        // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TargetWidget;                                      // 0x0060(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TargetWidget3d;                                    // 0x0068(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackInteractiveActorComponent*         TargetInteractiveActorComponent;                   // 0x0070(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x4];                                       // 0x0078(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OffsetLength;                                      // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_80[0x18];                                      // 0x0080(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMG3DWidgetData">();
	}
	static class UJackUMG3DWidgetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMG3DWidgetData>();
	}
};
static_assert(alignof(UJackUMG3DWidgetData) == 0x000008, "Wrong alignment on UJackUMG3DWidgetData");
static_assert(sizeof(UJackUMG3DWidgetData) == 0x000098, "Wrong size on UJackUMG3DWidgetData");
static_assert(offsetof(UJackUMG3DWidgetData, TargetActor) == 0x000038, "Member 'UJackUMG3DWidgetData::TargetActor' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, Location) == 0x000044, "Member 'UJackUMG3DWidgetData::Location' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, bProjected) == 0x000050, "Member 'UJackUMG3DWidgetData::bProjected' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, TargetWidget) == 0x000060, "Member 'UJackUMG3DWidgetData::TargetWidget' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, TargetWidget3d) == 0x000068, "Member 'UJackUMG3DWidgetData::TargetWidget3d' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, TargetInteractiveActorComponent) == 0x000070, "Member 'UJackUMG3DWidgetData::TargetInteractiveActorComponent' has a wrong offset!");
static_assert(offsetof(UJackUMG3DWidgetData, OffsetLength) == 0x00007C, "Member 'UJackUMG3DWidgetData::OffsetLength' has a wrong offset!");

// Class JackGame.JackUMGActionCursorBaseData
// 0x0018 (0x00B0 - 0x0098)
class UJackUMGActionCursorBaseData : public UJackUMG3DWidgetData
{
public:
	EJackActionCursor                             ActionCursorType;                                  // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackNPCImportance                            Importance;                                        // 0x0099(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x2];                                       // 0x009A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ScaleAnimTimer;                                    // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x00A0(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGActionCursorBaseData">();
	}
	static class UJackUMGActionCursorBaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGActionCursorBaseData>();
	}
};
static_assert(alignof(UJackUMGActionCursorBaseData) == 0x000008, "Wrong alignment on UJackUMGActionCursorBaseData");
static_assert(sizeof(UJackUMGActionCursorBaseData) == 0x0000B0, "Wrong size on UJackUMGActionCursorBaseData");
static_assert(offsetof(UJackUMGActionCursorBaseData, ActionCursorType) == 0x000098, "Member 'UJackUMGActionCursorBaseData::ActionCursorType' has a wrong offset!");
static_assert(offsetof(UJackUMGActionCursorBaseData, Importance) == 0x000099, "Member 'UJackUMGActionCursorBaseData::Importance' has a wrong offset!");
static_assert(offsetof(UJackUMGActionCursorBaseData, ScaleAnimTimer) == 0x00009C, "Member 'UJackUMGActionCursorBaseData::ScaleAnimTimer' has a wrong offset!");
static_assert(offsetof(UJackUMGActionCursorBaseData, Scale) == 0x0000A0, "Member 'UJackUMGActionCursorBaseData::Scale' has a wrong offset!");

// Class JackGame.JackUMGActionCursorData
// 0x0010 (0x00C0 - 0x00B0)
class UJackUMGActionCursorData final : public UJackUMGActionCursorBaseData
{
public:
	class AJackScheduledNPC*                      TargetNPC;                                         // 0x00B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B8[0x3];                                       // 0x00B8(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAnimInit;                                         // 0x00BB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGActionCursorData">();
	}
	static class UJackUMGActionCursorData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGActionCursorData>();
	}
};
static_assert(alignof(UJackUMGActionCursorData) == 0x000008, "Wrong alignment on UJackUMGActionCursorData");
static_assert(sizeof(UJackUMGActionCursorData) == 0x0000C0, "Wrong size on UJackUMGActionCursorData");
static_assert(offsetof(UJackUMGActionCursorData, TargetNPC) == 0x0000B0, "Member 'UJackUMGActionCursorData::TargetNPC' has a wrong offset!");
static_assert(offsetof(UJackUMGActionCursorData, bAnimInit) == 0x0000BB, "Member 'UJackUMGActionCursorData::bAnimInit' has a wrong offset!");

// Class JackGame.JackForceUpdateAnimationInMatineeTrackInst
// 0x0008 (0x0048 - 0x0040)
class UJackForceUpdateAnimationInMatineeTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForceUpdateAnimationInMatineeTrackInst">();
	}
	static class UJackForceUpdateAnimationInMatineeTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForceUpdateAnimationInMatineeTrackInst>();
	}
};
static_assert(alignof(UJackForceUpdateAnimationInMatineeTrackInst) == 0x000008, "Wrong alignment on UJackForceUpdateAnimationInMatineeTrackInst");
static_assert(sizeof(UJackForceUpdateAnimationInMatineeTrackInst) == 0x000048, "Wrong size on UJackForceUpdateAnimationInMatineeTrackInst");

// Class JackGame.JackCharacterMovementComponent
// 0x05A0 (0x0D10 - 0x0770)
class UJackCharacterMovementComponent : public UCharacterMovementComponent
{
public:
	uint8                                         Pad_768[0x18];                                     // 0x0768(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMoveSpeed;                                      // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreRotationYaw;                                // 0x0784(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotationPitch;                              // 0x0785(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreRotationRoll;                               // 0x0786(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSafeNavConstrainedDuringMove;                     // 0x0787(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleMaxTurnSpeed;                                // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78C[0x4];                                      // 0x078C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     NavigationQueryFilter;                             // 0x0790(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_798[0x98];                                     // 0x0798(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsIgnoreMovementDisabledCheckCollision;           // 0x0830(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_831[0x3BF];                                    // 0x0831(0x03BF)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bOrientRotationToBattleMovement;                   // 0x0BF0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BF1[0x11F];                                    // 0x0BF1(0x011F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlapControllPrimitive(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlapControllPrimitive(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void SetAutonomicMovementDisabled(bool bDisabled, EJackCharacterControlChannel InChannel);
	void SetConstrainedOnNavMesh(EJackCharacterConstrainedOnNavMeshPurpose Purpose, bool bConstrainedOnNavMesh);
	void SetIgnoreMovementDisabledCheckCollision(bool bDisabled);
	void SetJumpDisabled(bool bDisabled, EJackCharacterControlChannel InChannel);
	void SetMovementEnabled(bool bEnabled, EJackCharacterControlChannel InChannel);
	void SetMovementMaxSpeedType(EJackCharacterMovementMaxSpeedPurpose Purpose, EJackCharacterMovementMaxSpeed MaxSpeedType);
	void SetReservedMovementLocation(const struct FVector& InLocation, bool bAdditive, bool bConsumeAll);
	void SetReservedMovementRotation(const struct FRotator& InRotation, bool bAdditive, bool bConsumeAll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterMovementComponent">();
	}
	static class UJackCharacterMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterMovementComponent>();
	}
};
static_assert(alignof(UJackCharacterMovementComponent) == 0x000010, "Wrong alignment on UJackCharacterMovementComponent");
static_assert(sizeof(UJackCharacterMovementComponent) == 0x000D10, "Wrong size on UJackCharacterMovementComponent");
static_assert(offsetof(UJackCharacterMovementComponent, MaxMoveSpeed) == 0x000780, "Member 'UJackCharacterMovementComponent::MaxMoveSpeed' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bIgnoreRotationYaw) == 0x000784, "Member 'UJackCharacterMovementComponent::bIgnoreRotationYaw' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bIgnoreRotationPitch) == 0x000785, "Member 'UJackCharacterMovementComponent::bIgnoreRotationPitch' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bIgnoreRotationRoll) == 0x000786, "Member 'UJackCharacterMovementComponent::bIgnoreRotationRoll' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bSafeNavConstrainedDuringMove) == 0x000787, "Member 'UJackCharacterMovementComponent::bSafeNavConstrainedDuringMove' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, BattleMaxTurnSpeed) == 0x000788, "Member 'UJackCharacterMovementComponent::BattleMaxTurnSpeed' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, NavigationQueryFilter) == 0x000790, "Member 'UJackCharacterMovementComponent::NavigationQueryFilter' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bIsIgnoreMovementDisabledCheckCollision) == 0x000830, "Member 'UJackCharacterMovementComponent::bIsIgnoreMovementDisabledCheckCollision' has a wrong offset!");
static_assert(offsetof(UJackCharacterMovementComponent, bOrientRotationToBattleMovement) == 0x000BF0, "Member 'UJackCharacterMovementComponent::bOrientRotationToBattleMovement' has a wrong offset!");

// Class JackGame.JackPlayableMovementComponent
// 0x0140 (0x0E50 - 0x0D10)
class UJackPlayableMovementComponent : public UJackCharacterMovementComponent
{
public:
	bool                                          bSlipEnable;                                       // 0x0D10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSlip;                                             // 0x0D11(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D12[0x2];                                      // 0x0D12(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlipDumpRate;                                      // 0x0D14(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipVelocityRate;                                  // 0x0D18(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipMaxSpeed;                                      // 0x0D1C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipSlopeStartAngle;                               // 0x0D20(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipSlopeSpeedRate;                                // 0x0D24(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SlipFallingSec;                                    // 0x0D28(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoFloorSlipDisable;                               // 0x0D2C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D2D[0x3];                                      // 0x0D2D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NoFloorSlipCheckOffset;                            // 0x0D30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipCheckRadius;                            // 0x0D34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipCheckWaitSec;                           // 0x0D38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipSpeedRate;                              // 0x0D3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipDownRate;                               // 0x0D40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipDumpRate;                               // 0x0D44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipMaxSpeed;                               // 0x0D48(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NoFloorSlipSlopeSpeedRate;                         // 0x0D4C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoFloorSlipCheckVelocityZero;                     // 0x0D50(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D51[0x3F];                                     // 0x0D51(0x003F)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackPlayableMovementMode*              PlayableMovementMode;                              // 0x0D90(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinMovementSpeedRate;                              // 0x0D98(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D9C[0x18];                                     // 0x0D9C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SecondsUntilNextJump;                              // 0x0DB4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DB8[0x4];                                      // 0x0DB8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDontApplyAvoidanceVelocity;                       // 0x0DBC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableSuppressionOfJumpingDueToSmallSteps;        // 0x0DBD(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_DBE[0x92];                                     // 0x0DBE(0x0092)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnMovementDisabled(bool bDisabled);
	void PopPlayableMovementDefaultType();
	void PushPlayableMovementDefaultType(EJackPlayableMovementDefault Mode, bool bForceNoneSet);
	void ResetPlayableMovementDefaultType();
	void ResetPlayableMovementMode();
	void SetPlayableMovementDefaultType(EJackPlayableMovementDefault Mode);
	void SetPlayableMovementDefaultTypeOverride(EJackPlayableMovementDefault OverrideMode);
	class UJackPlayableMovementMode* SetPlayableMovementMode(TSubclassOf<class UJackPlayableMovementMode> PlayableMovementModeClass);
	void SetSlip(bool bOn);
	void SetSlipParam(float InSlipDumpRate, float InSlipVelocityRate, float InSlipMaxSpeed, float InSlipSlopeStartAngle, float InSlipSlopeSpeedRate);

	EJackPlayableMovementDefault GetPlayableMovementDefaultType() const;
	class UJackPlayableMovementMode* GetPlayableMovementMode() const;
	EJackPlayableMovement GetPlayableMovementType() const;
	bool IsPlayableMovementDefaultOverride() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableMovementComponent">();
	}
	static class UJackPlayableMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableMovementComponent>();
	}
};
static_assert(alignof(UJackPlayableMovementComponent) == 0x000010, "Wrong alignment on UJackPlayableMovementComponent");
static_assert(sizeof(UJackPlayableMovementComponent) == 0x000E50, "Wrong size on UJackPlayableMovementComponent");
static_assert(offsetof(UJackPlayableMovementComponent, bSlipEnable) == 0x000D10, "Member 'UJackPlayableMovementComponent::bSlipEnable' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, bSlip) == 0x000D11, "Member 'UJackPlayableMovementComponent::bSlip' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipDumpRate) == 0x000D14, "Member 'UJackPlayableMovementComponent::SlipDumpRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipVelocityRate) == 0x000D18, "Member 'UJackPlayableMovementComponent::SlipVelocityRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipMaxSpeed) == 0x000D1C, "Member 'UJackPlayableMovementComponent::SlipMaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipSlopeStartAngle) == 0x000D20, "Member 'UJackPlayableMovementComponent::SlipSlopeStartAngle' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipSlopeSpeedRate) == 0x000D24, "Member 'UJackPlayableMovementComponent::SlipSlopeSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SlipFallingSec) == 0x000D28, "Member 'UJackPlayableMovementComponent::SlipFallingSec' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, bNoFloorSlipDisable) == 0x000D2C, "Member 'UJackPlayableMovementComponent::bNoFloorSlipDisable' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipCheckOffset) == 0x000D30, "Member 'UJackPlayableMovementComponent::NoFloorSlipCheckOffset' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipCheckRadius) == 0x000D34, "Member 'UJackPlayableMovementComponent::NoFloorSlipCheckRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipCheckWaitSec) == 0x000D38, "Member 'UJackPlayableMovementComponent::NoFloorSlipCheckWaitSec' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipSpeedRate) == 0x000D3C, "Member 'UJackPlayableMovementComponent::NoFloorSlipSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipDownRate) == 0x000D40, "Member 'UJackPlayableMovementComponent::NoFloorSlipDownRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipDumpRate) == 0x000D44, "Member 'UJackPlayableMovementComponent::NoFloorSlipDumpRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipMaxSpeed) == 0x000D48, "Member 'UJackPlayableMovementComponent::NoFloorSlipMaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, NoFloorSlipSlopeSpeedRate) == 0x000D4C, "Member 'UJackPlayableMovementComponent::NoFloorSlipSlopeSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, bNoFloorSlipCheckVelocityZero) == 0x000D50, "Member 'UJackPlayableMovementComponent::bNoFloorSlipCheckVelocityZero' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, PlayableMovementMode) == 0x000D90, "Member 'UJackPlayableMovementComponent::PlayableMovementMode' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, MinMovementSpeedRate) == 0x000D98, "Member 'UJackPlayableMovementComponent::MinMovementSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, SecondsUntilNextJump) == 0x000DB4, "Member 'UJackPlayableMovementComponent::SecondsUntilNextJump' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, bDontApplyAvoidanceVelocity) == 0x000DBC, "Member 'UJackPlayableMovementComponent::bDontApplyAvoidanceVelocity' has a wrong offset!");
static_assert(offsetof(UJackPlayableMovementComponent, bEnableSuppressionOfJumpingDueToSmallSteps) == 0x000DBD, "Member 'UJackPlayableMovementComponent::bEnableSuppressionOfJumpingDueToSmallSteps' has a wrong offset!");

// Class JackGame.JackVehicleMovementComponent
// 0x00D0 (0x0F20 - 0x0E50)
class UJackVehicleMovementComponent : public UJackPlayableMovementComponent
{
public:
	uint8                                         Pad_E50[0x60];                                     // 0x0E50(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bExternCollideUseMoveComponent;                    // 0x0EB0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExternCollideFirstPenetration;                    // 0x0EB1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUseExternCollide;                            // 0x0EB2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EB3[0x1];                                      // 0x0EB3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ExternSweepRate;                                   // 0x0EB4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ExternCollideTagName;                              // 0x0EC0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ExternCollideDumpVelocityRate;                     // 0x0EC8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPrevVelocityApplyedIfZero;                      // 0x0ECC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugStrictRotateMoveDelta;                       // 0x0ECD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ECE[0x2];                                      // 0x0ECE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PenetrationAddLength;                              // 0x0ED0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugAddIgnoreHitArrayNonFirstOnly;               // 0x0ED4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCorrectToFirstWalkingVelocity;                    // 0x0ED5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_ED6[0x2];                                      // 0x0ED6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CorrectToFirstWalkingVelocityClipAddStartVelocity; // 0x0ED8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EDC[0x2C];                                     // 0x0EDC(0x002C)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UShapeComponent>> ExternCollideArray;                                // 0x0F08(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_F18[0x8];                                      // 0x0F18(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CheckShapeComponentNuke(class UShapeComponent* Shape);

	void ClearVelocity();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleMovementComponent">();
	}
	static class UJackVehicleMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleMovementComponent>();
	}
};
static_assert(alignof(UJackVehicleMovementComponent) == 0x000010, "Wrong alignment on UJackVehicleMovementComponent");
static_assert(sizeof(UJackVehicleMovementComponent) == 0x000F20, "Wrong size on UJackVehicleMovementComponent");
static_assert(offsetof(UJackVehicleMovementComponent, bExternCollideUseMoveComponent) == 0x000EB0, "Member 'UJackVehicleMovementComponent::bExternCollideUseMoveComponent' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bExternCollideFirstPenetration) == 0x000EB1, "Member 'UJackVehicleMovementComponent::bExternCollideFirstPenetration' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bForceUseExternCollide) == 0x000EB2, "Member 'UJackVehicleMovementComponent::bForceUseExternCollide' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, ExternSweepRate) == 0x000EB4, "Member 'UJackVehicleMovementComponent::ExternSweepRate' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, ExternCollideTagName) == 0x000EC0, "Member 'UJackVehicleMovementComponent::ExternCollideTagName' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, ExternCollideDumpVelocityRate) == 0x000EC8, "Member 'UJackVehicleMovementComponent::ExternCollideDumpVelocityRate' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bIsPrevVelocityApplyedIfZero) == 0x000ECC, "Member 'UJackVehicleMovementComponent::bIsPrevVelocityApplyedIfZero' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bDebugStrictRotateMoveDelta) == 0x000ECD, "Member 'UJackVehicleMovementComponent::bDebugStrictRotateMoveDelta' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, PenetrationAddLength) == 0x000ED0, "Member 'UJackVehicleMovementComponent::PenetrationAddLength' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bDebugAddIgnoreHitArrayNonFirstOnly) == 0x000ED4, "Member 'UJackVehicleMovementComponent::bDebugAddIgnoreHitArrayNonFirstOnly' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, bCorrectToFirstWalkingVelocity) == 0x000ED5, "Member 'UJackVehicleMovementComponent::bCorrectToFirstWalkingVelocity' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, CorrectToFirstWalkingVelocityClipAddStartVelocity) == 0x000ED8, "Member 'UJackVehicleMovementComponent::CorrectToFirstWalkingVelocityClipAddStartVelocity' has a wrong offset!");
static_assert(offsetof(UJackVehicleMovementComponent, ExternCollideArray) == 0x000F08, "Member 'UJackVehicleMovementComponent::ExternCollideArray' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayCameraParticleEffect
// 0x0038 (0x0080 - 0x0048)
class UJackAnimNotify_PlayCameraParticleEffect final : public UJackAnimNotify
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LocationOffset;                                    // 0x0050(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x005C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteLocation;                                 // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteRotation;                                 // 0x0069(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteScale;                                    // 0x006A(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6B[0x5];                                       // 0x006B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundVolume;                                       // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCameraParticleEffect">();
	}
	static class UJackAnimNotify_PlayCameraParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCameraParticleEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCameraParticleEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCameraParticleEffect");
static_assert(sizeof(UJackAnimNotify_PlayCameraParticleEffect) == 0x000080, "Wrong size on UJackAnimNotify_PlayCameraParticleEffect");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, PSTemplate) == 0x000048, "Member 'UJackAnimNotify_PlayCameraParticleEffect::PSTemplate' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, LocationOffset) == 0x000050, "Member 'UJackAnimNotify_PlayCameraParticleEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, RotationOffset) == 0x00005C, "Member 'UJackAnimNotify_PlayCameraParticleEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, bAbsoluteLocation) == 0x000068, "Member 'UJackAnimNotify_PlayCameraParticleEffect::bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, bAbsoluteRotation) == 0x000069, "Member 'UJackAnimNotify_PlayCameraParticleEffect::bAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, bAbsoluteScale) == 0x00006A, "Member 'UJackAnimNotify_PlayCameraParticleEffect::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, Sound) == 0x000070, "Member 'UJackAnimNotify_PlayCameraParticleEffect::Sound' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCameraParticleEffect, SoundVolume) == 0x000078, "Member 'UJackAnimNotify_PlayCameraParticleEffect::SoundVolume' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayCollideEffect
// 0x0050 (0x0098 - 0x0048)
class UJackAnimNotify_PlayCollideEffect final : public UJackAnimNotify
{
public:
	TSubclassOf<class UJackCollideEffect>         CollideEffectClass;                                // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttachInfo;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttached;                                 // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideSocketName;                                // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               OverrideAttachLocationType;                        // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideOffsetLocation;                            // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OverrideOffsetRotation;                            // 0x0070(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceEnabled;                                     // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x007D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceEndSocketName;                                // 0x0090(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCollideEffect">();
	}
	static class UJackAnimNotify_PlayCollideEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCollideEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCollideEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCollideEffect");
static_assert(sizeof(UJackAnimNotify_PlayCollideEffect) == 0x000098, "Wrong size on UJackAnimNotify_PlayCollideEffect");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, CollideEffectClass) == 0x000048, "Member 'UJackAnimNotify_PlayCollideEffect::CollideEffectClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, bOverrideAttachInfo) == 0x000050, "Member 'UJackAnimNotify_PlayCollideEffect::bOverrideAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, bOverrideAttached) == 0x000051, "Member 'UJackAnimNotify_PlayCollideEffect::bOverrideAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, OverrideSocketName) == 0x000058, "Member 'UJackAnimNotify_PlayCollideEffect::OverrideSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, OverrideAttachLocationType) == 0x000060, "Member 'UJackAnimNotify_PlayCollideEffect::OverrideAttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, OverrideOffsetLocation) == 0x000064, "Member 'UJackAnimNotify_PlayCollideEffect::OverrideOffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, OverrideOffsetRotation) == 0x000070, "Member 'UJackAnimNotify_PlayCollideEffect::OverrideOffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, bTraceEnabled) == 0x00007C, "Member 'UJackAnimNotify_PlayCollideEffect::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, TraceChannel) == 0x00007D, "Member 'UJackAnimNotify_PlayCollideEffect::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, TraceSphereRadius) == 0x000080, "Member 'UJackAnimNotify_PlayCollideEffect::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, TraceStartSocketName) == 0x000088, "Member 'UJackAnimNotify_PlayCollideEffect::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffect, TraceEndSocketName) == 0x000090, "Member 'UJackAnimNotify_PlayCollideEffect::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackVehicleV012
// 0x0020 (0x1B50 - 0x1B30)
class AJackVehicleV012 final : public AJackVehicleMonster
{
public:
	TWeakObjectPtr<class AActor>                  StaticMeshActor;                                   // 0x1B30(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B38[0x18];                                    // 0x1B38(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetUnmountGauge(bool bOn);

	float GetMovementSpeedRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV012">();
	}
	static class AJackVehicleV012* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV012>();
	}
};
static_assert(alignof(AJackVehicleV012) == 0x000010, "Wrong alignment on AJackVehicleV012");
static_assert(sizeof(AJackVehicleV012) == 0x001B50, "Wrong size on AJackVehicleV012");
static_assert(offsetof(AJackVehicleV012, StaticMeshActor) == 0x001B30, "Member 'AJackVehicleV012::StaticMeshActor' has a wrong offset!");

// Class JackGame.JackGarbageCollectionManager
// 0x0038 (0x0070 - 0x0038)
class UJackGarbageCollectionManager final : public UObject
{
public:
	uint8                                         Pad_38[0x38];                                      // 0x0038(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGarbageCollectionManager">();
	}
	static class UJackGarbageCollectionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGarbageCollectionManager>();
	}
};
static_assert(alignof(UJackGarbageCollectionManager) == 0x000008, "Wrong alignment on UJackGarbageCollectionManager");
static_assert(sizeof(UJackGarbageCollectionManager) == 0x000070, "Wrong size on UJackGarbageCollectionManager");

// Class JackGame.JackAnimNotify_PlayCollideEffectTable
// 0x0050 (0x0098 - 0x0048)
class UJackAnimNotify_PlayCollideEffectTable final : public UJackAnimNotify
{
public:
	TSubclassOf<class UJackCollideEffectTable>    CollideEffectClass;                                // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttachInfo;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttached;                                 // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideSocketName;                                // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               OverrideAttachLocationType;                        // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideOffsetLocation;                            // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OverrideOffsetRotation;                            // 0x0070(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bTraceEnabled;                                     // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x007D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceEndSocketName;                                // 0x0090(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCollideEffectTable">();
	}
	static class UJackAnimNotify_PlayCollideEffectTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCollideEffectTable>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCollideEffectTable) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCollideEffectTable");
static_assert(sizeof(UJackAnimNotify_PlayCollideEffectTable) == 0x000098, "Wrong size on UJackAnimNotify_PlayCollideEffectTable");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, CollideEffectClass) == 0x000048, "Member 'UJackAnimNotify_PlayCollideEffectTable::CollideEffectClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, bOverrideAttachInfo) == 0x000050, "Member 'UJackAnimNotify_PlayCollideEffectTable::bOverrideAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, bOverrideAttached) == 0x000051, "Member 'UJackAnimNotify_PlayCollideEffectTable::bOverrideAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, OverrideSocketName) == 0x000058, "Member 'UJackAnimNotify_PlayCollideEffectTable::OverrideSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, OverrideAttachLocationType) == 0x000060, "Member 'UJackAnimNotify_PlayCollideEffectTable::OverrideAttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, OverrideOffsetLocation) == 0x000064, "Member 'UJackAnimNotify_PlayCollideEffectTable::OverrideOffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, OverrideOffsetRotation) == 0x000070, "Member 'UJackAnimNotify_PlayCollideEffectTable::OverrideOffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, bTraceEnabled) == 0x00007C, "Member 'UJackAnimNotify_PlayCollideEffectTable::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, TraceChannel) == 0x00007D, "Member 'UJackAnimNotify_PlayCollideEffectTable::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, TraceSphereRadius) == 0x000080, "Member 'UJackAnimNotify_PlayCollideEffectTable::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, TraceStartSocketName) == 0x000088, "Member 'UJackAnimNotify_PlayCollideEffectTable::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideEffectTable, TraceEndSocketName) == 0x000090, "Member 'UJackAnimNotify_PlayCollideEffectTable::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayCollideSoundTable
// 0x0050 (0x0098 - 0x0048)
class UJackAnimNotify_PlayCollideSoundTable final : public UJackAnimNotify
{
public:
	TSubclassOf<class UJackCollideSoundTable>     CollideSoundClass;                                 // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAttached;                                         // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachLocationType;                                // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetLocation;                                    // 0x0064(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OffsetRotation;                                    // 0x0070(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTraceEnabled;                                     // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x007D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0088(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TraceEndSocketName;                                // 0x0090(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayCollideSoundTable">();
	}
	static class UJackAnimNotify_PlayCollideSoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayCollideSoundTable>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayCollideSoundTable) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayCollideSoundTable");
static_assert(sizeof(UJackAnimNotify_PlayCollideSoundTable) == 0x000098, "Wrong size on UJackAnimNotify_PlayCollideSoundTable");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, CollideSoundClass) == 0x000048, "Member 'UJackAnimNotify_PlayCollideSoundTable::CollideSoundClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, bAttached) == 0x000050, "Member 'UJackAnimNotify_PlayCollideSoundTable::bAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, SocketName) == 0x000058, "Member 'UJackAnimNotify_PlayCollideSoundTable::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, AttachLocationType) == 0x000060, "Member 'UJackAnimNotify_PlayCollideSoundTable::AttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, OffsetLocation) == 0x000064, "Member 'UJackAnimNotify_PlayCollideSoundTable::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, OffsetRotation) == 0x000070, "Member 'UJackAnimNotify_PlayCollideSoundTable::OffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, bTraceEnabled) == 0x00007C, "Member 'UJackAnimNotify_PlayCollideSoundTable::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, TraceChannel) == 0x00007D, "Member 'UJackAnimNotify_PlayCollideSoundTable::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, TraceSphereRadius) == 0x000080, "Member 'UJackAnimNotify_PlayCollideSoundTable::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, TraceStartSocketName) == 0x000088, "Member 'UJackAnimNotify_PlayCollideSoundTable::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayCollideSoundTable, TraceEndSocketName) == 0x000090, "Member 'UJackAnimNotify_PlayCollideSoundTable::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackUMGMonsterNamePlateData
// 0x0068 (0x0100 - 0x0098)
class UJackUMGMonsterNamePlateData final : public UJackUMG3DWidgetData
{
public:
	class UJackGameCharacter*                     TargetGameCaracter;                                // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Message;                                           // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateShowingOddEffect;                           // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OddEffectIdList;                                   // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<int32>                                 OddEffectSlideRankList;                            // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ShowingOddEffectIndex;                             // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGTextColorSet                          TextColor;                                         // 0x00DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DD[0x23];                                      // 0x00DD(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMonsterNamePlateData">();
	}
	static class UJackUMGMonsterNamePlateData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMonsterNamePlateData>();
	}
};
static_assert(alignof(UJackUMGMonsterNamePlateData) == 0x000008, "Wrong alignment on UJackUMGMonsterNamePlateData");
static_assert(sizeof(UJackUMGMonsterNamePlateData) == 0x000100, "Wrong size on UJackUMGMonsterNamePlateData");
static_assert(offsetof(UJackUMGMonsterNamePlateData, TargetGameCaracter) == 0x000098, "Member 'UJackUMGMonsterNamePlateData::TargetGameCaracter' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, Message) == 0x0000A0, "Member 'UJackUMGMonsterNamePlateData::Message' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, bUpdateShowingOddEffect) == 0x0000B0, "Member 'UJackUMGMonsterNamePlateData::bUpdateShowingOddEffect' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, OddEffectIdList) == 0x0000B8, "Member 'UJackUMGMonsterNamePlateData::OddEffectIdList' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, OddEffectSlideRankList) == 0x0000C8, "Member 'UJackUMGMonsterNamePlateData::OddEffectSlideRankList' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, ShowingOddEffectIndex) == 0x0000D8, "Member 'UJackUMGMonsterNamePlateData::ShowingOddEffectIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterNamePlateData, TextColor) == 0x0000DC, "Member 'UJackUMGMonsterNamePlateData::TextColor' has a wrong offset!");

// Class JackGame.JackFriendAnimationStateMachine
// 0x00A8 (0x00E0 - 0x0038)
class UJackFriendAnimationStateMachine : public UObject
{
public:
	class FName                                   DefaultState;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DamageState;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageBlendRate;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDead;                                             // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDamaging;                                         // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialMove;                                      // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MontagePlayCount;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlendRateCount;                                    // 0x0054(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OddEffectMotionID;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x80];                                      // 0x0060(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendAnimationStateMachine">();
	}
	static class UJackFriendAnimationStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFriendAnimationStateMachine>();
	}
};
static_assert(alignof(UJackFriendAnimationStateMachine) == 0x000008, "Wrong alignment on UJackFriendAnimationStateMachine");
static_assert(sizeof(UJackFriendAnimationStateMachine) == 0x0000E0, "Wrong size on UJackFriendAnimationStateMachine");
static_assert(offsetof(UJackFriendAnimationStateMachine, DefaultState) == 0x000038, "Member 'UJackFriendAnimationStateMachine::DefaultState' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, DamageState) == 0x000040, "Member 'UJackFriendAnimationStateMachine::DamageState' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, DamageBlendRate) == 0x000048, "Member 'UJackFriendAnimationStateMachine::DamageBlendRate' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, bDead) == 0x00004C, "Member 'UJackFriendAnimationStateMachine::bDead' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, bDamaging) == 0x00004D, "Member 'UJackFriendAnimationStateMachine::bDamaging' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, bSpecialMove) == 0x00004E, "Member 'UJackFriendAnimationStateMachine::bSpecialMove' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, MontagePlayCount) == 0x000050, "Member 'UJackFriendAnimationStateMachine::MontagePlayCount' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, BlendRateCount) == 0x000054, "Member 'UJackFriendAnimationStateMachine::BlendRateCount' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationStateMachine, OddEffectMotionID) == 0x000058, "Member 'UJackFriendAnimationStateMachine::OddEffectMotionID' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayMaterialAnimation
// 0x0018 (0x0060 - 0x0048)
class UJackAnimNotify_PlayMaterialAnimation final : public UJackAnimNotify
{
public:
	struct FJackLDT_CharacterMaterialUpdater      CharacterMaterialUpdater;                          // 0x0048(0x0010)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackAnimNotify_PlayMaterialAnimation_ApplyParts ApplyParts;                                        // 0x0058(0x0005)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayMaterialAnimation">();
	}
	static class UJackAnimNotify_PlayMaterialAnimation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayMaterialAnimation>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayMaterialAnimation) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayMaterialAnimation");
static_assert(sizeof(UJackAnimNotify_PlayMaterialAnimation) == 0x000060, "Wrong size on UJackAnimNotify_PlayMaterialAnimation");
static_assert(offsetof(UJackAnimNotify_PlayMaterialAnimation, CharacterMaterialUpdater) == 0x000048, "Member 'UJackAnimNotify_PlayMaterialAnimation::CharacterMaterialUpdater' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayMaterialAnimation, ApplyParts) == 0x000058, "Member 'UJackAnimNotify_PlayMaterialAnimation::ApplyParts' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayParticleEffect
// 0x0048 (0x0090 - 0x0048)
class UJackAnimNotify_PlayParticleEffect : public UJackAnimNotify
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttached;                                         // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBeAffectedByMaterialAnimation;                    // 0x0059(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x2];                                       // 0x005A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                LocationOffset;                                    // 0x005C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationOffset;                                    // 0x0068(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteLocation;                                 // 0x0074(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteRotation;                                 // 0x0075(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAbsoluteScale;                                    // 0x0076(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_77[0x1];                                       // 0x0077(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundVolume;                                       // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UParticleSystemComponent> ParticleSystemComponent;                           // 0x0084(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AutoPopulateInstanceProperties() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayParticleEffect">();
	}
	static class UJackAnimNotify_PlayParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayParticleEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayParticleEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayParticleEffect");
static_assert(sizeof(UJackAnimNotify_PlayParticleEffect) == 0x000090, "Wrong size on UJackAnimNotify_PlayParticleEffect");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, PSTemplate) == 0x000048, "Member 'UJackAnimNotify_PlayParticleEffect::PSTemplate' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, SocketName) == 0x000050, "Member 'UJackAnimNotify_PlayParticleEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, bAttached) == 0x000058, "Member 'UJackAnimNotify_PlayParticleEffect::bAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, bBeAffectedByMaterialAnimation) == 0x000059, "Member 'UJackAnimNotify_PlayParticleEffect::bBeAffectedByMaterialAnimation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, LocationOffset) == 0x00005C, "Member 'UJackAnimNotify_PlayParticleEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, RotationOffset) == 0x000068, "Member 'UJackAnimNotify_PlayParticleEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, bAbsoluteLocation) == 0x000074, "Member 'UJackAnimNotify_PlayParticleEffect::bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, bAbsoluteRotation) == 0x000075, "Member 'UJackAnimNotify_PlayParticleEffect::bAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, bAbsoluteScale) == 0x000076, "Member 'UJackAnimNotify_PlayParticleEffect::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, Sound) == 0x000078, "Member 'UJackAnimNotify_PlayParticleEffect::Sound' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, SoundVolume) == 0x000080, "Member 'UJackAnimNotify_PlayParticleEffect::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayParticleEffect, ParticleSystemComponent) == 0x000084, "Member 'UJackAnimNotify_PlayParticleEffect::ParticleSystemComponent' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayParticleSlotEffect
// 0x0008 (0x0098 - 0x0090)
class UJackAnimNotify_PlayParticleSlotEffect final : public UJackAnimNotify_PlayParticleEffect
{
public:
	int32                                         SlotNo;                                            // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayParticleSlotEffect">();
	}
	static class UJackAnimNotify_PlayParticleSlotEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayParticleSlotEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayParticleSlotEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayParticleSlotEffect");
static_assert(sizeof(UJackAnimNotify_PlayParticleSlotEffect) == 0x000098, "Wrong size on UJackAnimNotify_PlayParticleSlotEffect");
static_assert(offsetof(UJackAnimNotify_PlayParticleSlotEffect, SlotNo) == 0x000090, "Member 'UJackAnimNotify_PlayParticleSlotEffect::SlotNo' has a wrong offset!");

// Class JackGame.JackPostProcessVolume
// 0x0000 (0x08F0 - 0x08F0)
class AJackPostProcessVolume : public APostProcessVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPostProcessVolume">();
	}
	static class AJackPostProcessVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPostProcessVolume>();
	}
};
static_assert(alignof(AJackPostProcessVolume) == 0x000010, "Wrong alignment on AJackPostProcessVolume");
static_assert(sizeof(AJackPostProcessVolume) == 0x0008F0, "Wrong size on AJackPostProcessVolume");

// Class JackGame.JackAnimNotify_PlayPostProcessEffect
// 0x0050 (0x0098 - 0x0048)
class UJackAnimNotify_PlayPostProcessEffect final : public UJackAnimNotify
{
public:
	bool                                          bRefActionEffect;                                  // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackActionEffectCategory                     EffectCategory;                                    // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackPostProcessEffect                 PostProcessEffect;                                 // 0x0060(0x0020)(Edit, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBlendablePostProcessSettingsData> PostBlendableData;                                 // 0x0088(0x0010)(BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayPostProcessEffect">();
	}
	static class UJackAnimNotify_PlayPostProcessEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayPostProcessEffect>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayPostProcessEffect) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayPostProcessEffect");
static_assert(sizeof(UJackAnimNotify_PlayPostProcessEffect) == 0x000098, "Wrong size on UJackAnimNotify_PlayPostProcessEffect");
static_assert(offsetof(UJackAnimNotify_PlayPostProcessEffect, bRefActionEffect) == 0x000048, "Member 'UJackAnimNotify_PlayPostProcessEffect::bRefActionEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPostProcessEffect, SocketName) == 0x000050, "Member 'UJackAnimNotify_PlayPostProcessEffect::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPostProcessEffect, EffectCategory) == 0x000058, "Member 'UJackAnimNotify_PlayPostProcessEffect::EffectCategory' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPostProcessEffect, PostProcessEffect) == 0x000060, "Member 'UJackAnimNotify_PlayPostProcessEffect::PostProcessEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPostProcessEffect, PostBlendableData) == 0x000088, "Member 'UJackAnimNotify_PlayPostProcessEffect::PostBlendableData' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayPresetShake
// 0x0030 (0x0078 - 0x0048)
class UJackAnimNotify_PlayPresetShake final : public UJackAnimNotify
{
public:
	struct FJackLDT_PresetCameraShake             PresetCameraShake;                                 // 0x0048(0x0010)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FJackLDT_PresetForceFeedback           PresetForceFeedback;                               // 0x0058(0x0010)(Edit, BlueprintReadOnly, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UCameraShake>               OverrideCameraShakeClass;                          // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UForceFeedbackEffect*                   OverrideForceFeedback;                             // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayPresetShake">();
	}
	static class UJackAnimNotify_PlayPresetShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayPresetShake>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayPresetShake) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayPresetShake");
static_assert(sizeof(UJackAnimNotify_PlayPresetShake) == 0x000078, "Wrong size on UJackAnimNotify_PlayPresetShake");
static_assert(offsetof(UJackAnimNotify_PlayPresetShake, PresetCameraShake) == 0x000048, "Member 'UJackAnimNotify_PlayPresetShake::PresetCameraShake' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPresetShake, PresetForceFeedback) == 0x000058, "Member 'UJackAnimNotify_PlayPresetShake::PresetForceFeedback' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPresetShake, OverrideCameraShakeClass) == 0x000068, "Member 'UJackAnimNotify_PlayPresetShake::OverrideCameraShakeClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayPresetShake, OverrideForceFeedback) == 0x000070, "Member 'UJackAnimNotify_PlayPresetShake::OverrideForceFeedback' has a wrong offset!");

// Class JackGame.JackBattleParameter
// 0x0678 (0x06B0 - 0x0038)
class UJackBattleParameter : public UObject
{
public:
	float                                         FastMode_TimeDilation;                             // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastMode_TimeDilationByVeryFast;                   // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastMode_IncludingMonsterAppear;                  // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastMode_IncludingResult;                         // 0x0041(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastMode_IncludingMatineeRenkei;                  // 0x0042(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFastMode_VoiceEnable;                             // 0x0043(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastMode_CameraRotationSpeed;                      // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FastMode_CameraRotationSpeedByVeryFast;            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fade_EndFadeOutDefaultTimeByWin;                   // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fade_EndFadeOutDefaultTimeByOther;                 // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foliage_DitherRanges[0x3];                         // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Foliage_BattleFieldDitherLowerLimitRadius;         // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBattleFieldFoliageDitherInfo> Foliage_BattleFieldFoliageDitherInfos;             // 0x0068(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Chara_InjuryRateInterpTime;                        // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackKougekiInfo>               PlayerKougekiInfos;                                // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bPlayerMove_TurnToEnable;                          // 0x0090(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayerMove_SpeedInterpIn;                          // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMove_SpeedInterpOut;                         // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMove_SpeedInterpAdjustP0;                    // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMove_SpeedInterpAdjustP1;                    // 0x00A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMove_SpeedInterpAdjustP2;                    // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMove_SpeedInterpAdjustP3;                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleFieldDirectionForcedAngle;                   // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleFieldDirectionForcedAdjustment;              // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleStartMenu_MenuOpenWaitTime;                  // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackPreparationViewData>       PreparationViewData;                               // 0x00B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         ActionAssistMove_Timeout;                          // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionAssistMove_RotationSpeed;                    // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionAssistMove_RotationDurationTime;             // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_BackJump;                          // 0x00D4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_IgnoreMeireisasero;                // 0x00D5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D6[0x2];                                       // 0x00D6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionBackMove_BackJumpThresholdLength;            // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ActionBackMove_BackJumpLimitLength;                // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_BackJumpForceByAutoCamera;         // 0x00E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionBackMove_BackJumpForceThresholdLength;       // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_ActionCompleteWaitIfBackJumpPlayingByAutoCamera; // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_ActionPlayWaitIfAnyBackJumpPlayingByAutoCamera; // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActionBackMove_InvalidRelocateIfBackJumpPlayingByAutoCamera; // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHiddenFriends;                                    // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCamera_GroupMoveDisable;                    // 0x00EC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCamera_TeleportToHomePositionEnable;        // 0x00ED(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCamera_RenzokuKoudouTeleportDisable;        // 0x00EE(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCamera_RenzokuKoudouTeleportDisableByBattleCommand; // 0x00EF(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSimpleCamera_LookAtDisable;                       // 0x00F0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PrgCamera_ScorePenalty_Overlap;                    // 0x00F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_80;                         // 0x00F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_50;                         // 0x00FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenaltyTurnChara_50;                // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_MarginSizeAll;              // 0x0104(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_MarginSizeH;                // 0x0108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_MarginSizeUnder;            // 0x010C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_MarginBalanceH;             // 0x0110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_MarginBalanceW;             // 0x0114(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_TurnCharaDist;              // 0x0118(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_PreCamera;                  // 0x011C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_FrontDiffDist;              // 0x0120(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_BirdDiffDist;               // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ScorePenalty_DiagonalDiffDist;           // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Front_FixDist;                           // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Front_DistOfs;                           // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Front_YawAdd;                            // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Front_PitchAdd;                          // 0x0138(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Front_GroundMargin;                      // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Bird_LotPar;                             // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Bird_FixDist;                            // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Bird_YawVariation;                       // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Diagonal_LotFrontPar;                    // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Diagonal_LotTrackingPar;                 // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_NoTrackingDist;                 // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   PrgCamera_Diagonal_CurveFunc;                      // 0x0158(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x3];                                      // 0x0159(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PrgCamera_Diagonal_LotBestMax;                     // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Diagonal_PitchVariation;                 // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_DistOffsetMax;                  // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_YawMin;                         // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_MinZ;                           // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_TrackingMinZ;                   // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_NoLowMinZ;                      // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_TrackingNoLowMinZ;              // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Diagonal_YawAdd;                         // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PrgCamera_Socket_OffsetPos;                        // 0x0180(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PrgCamera_Socket_LotPar;                           // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Anim_MaxTime;                            // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Anim_YawAdd;                             // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_Anim_DistAdd;                            // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_GroundMargin;                            // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_CollisionSphereRadius;                   // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_PushOutMargin;                           // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PrgCamera_ShrinkLotPar;                            // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackAutoCameraScoreRect>       PrgCamera_PCCameraScoreRects;                      // 0x01B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrgCamera_Diagonal_MainViewMonsters;               // 0x01C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrgCamera_Diagonal_HorizontalViewMonsters;         // 0x01D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrgCamera_BirdMonsters;                            // 0x01E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           PrgCamera_CameraBlockMonsters;                     // 0x01F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Nigeru_BaseSuccessPer;                             // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nigeru_KiyousaHosei;                               // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Nigeru_CertainKouSyuThreshold;                     // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20C[0x4];                                      // 0x020C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 Nigeru_SaiteiHosyouSuccessPerArray;                // 0x0210(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         Action_NifuramuDitherTime;                         // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_InoriNoYubiwaBreakProb;                     // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_BunnyNoMamoriActionHitDelayTime;            // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_BunnyNoMamoriActionFadeAlpha;               // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_BunnyNoMamoriActionFadeOutTime;             // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_BunnyNoMamoriActionFadeInTime;              // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action_TateGuardSEID_Player;                       // 0x0238(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Action_TateGuardSEID_Monster;                      // 0x0240(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_FailShotMotionLoopTime;                     // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_FailMessageDelayTime_Default;               // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_FailMessageDelayTime_DefaultByItem;         // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Action_FailMessageDelayTime_Exclusive;             // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NakamaYobi_CheckCapsuleRadius;                     // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25C[0x4];                                      // 0x025C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           Renkei_MemorizeRenkeiIDs;                          // 0x0260(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         TurnOrder_SubayasaHoseiMin_Player;                 // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOrder_SubayasaHoseiMax_Player;                 // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOrder_SubayasaHoseiMin_Monster;                // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnOrder_SubayasaHoseiMax_Monster;                // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnStartOddEffect_WaitSecondMin;                  // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TurnStartOddEffect_ActionCameraID_Player;          // 0x0288(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TurnStartOddEffect_ActionCameraID_Monster;         // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mitoreru_HanteiOddEffectID;                        // 0x0298(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Mitoreru_OddEffectID;                              // 0x02A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mitoreru_CalcBaseParameter1;                       // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mitoreru_CalcBaseParameter2;                       // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mitoreru_CalcBaseClampMin;                         // 0x02B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mitoreru_CalcBaseClampMax;                         // 0x02B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HazukasiiNoroi_OddEffectIDs[0xA];                  // 0x02B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hazukasiinoroi_MiryouMukou;                        // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hazukasiinoroi_KonranMukou;                        // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Hazukasiinoroi_NemuriMukou;                        // 0x0310(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_314[0x4];                                      // 0x0314(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackHazukasiiNoroiMessageInfo> Hazukasiinoroi_RandomTexts;                        // 0x0318(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         OddEffect_Konran_MeityuuHoseiPer;                  // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OddEffect_Miryou_KougekiBairituHoseiPer;           // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<float>                                 OddEffect_NakamaTurnSkip_KoudouPerArray;           // 0x0330(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJackHitStopPresetInfo                 HitStop_PresetInfos[0x17];                         // 0x0340(0x0002)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackHitCameraShakePresetInfo          HitCameraShake_PresetInfos[0x17];                  // 0x0370(0x0010)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<float>                                 Hate_Ranks;                                        // 0x04E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         AI_CalcActionStrideTableCountMax;                  // 0x04F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_CalcScoreTimeMax;                               // 0x04F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckZoneCoefficient;                      // 0x04F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckNemuriCoefficient;                    // 0x04FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckNemuriCorrectCoefficient;             // 0x0500(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckMetalCoefficient;                     // 0x0504(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AI_ScoreCheckMetalExpCoefficient;                  // 0x0508(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckContinuedDamageCoefficient;           // 0x050C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAttackUpEnableCoefficient;            // 0x0510(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckDazzleCureEnableCoefficient;          // 0x0514(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckDazzleCorrectCoefficient;             // 0x0518(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_Zaoriku;               // 0x051C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_Zaoraru;               // 0x0520(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_FukkatuNoTue;          // 0x0524(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_SeijaNoUta;            // 0x0528(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_Megazaru;              // 0x052C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckCRACoefficient_Etc;                   // 0x0530(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_Zaoriku;               // 0x0534(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_Zaoraru;               // 0x0538(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_FukkatuNoTue;          // 0x053C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_SeijaNoUta;            // 0x0540(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_Megazaru;              // 0x0544(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckTRACoefficient_Etc;                   // 0x0548(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_Rihoimi;               // 0x054C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_Ribehoimi;             // 0x0550(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_Ribehoimu;             // 0x0554(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_IyasiNoAme;            // 0x0558(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_RamudaNoInori;         // 0x055C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAHHCoefficient_RamudaNoInori_Otona;   // 0x0560(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckAtkStrRankCoefficient[0x4];           // 0x0564(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckDefStrRankCoefficient[0x4];           // 0x0574(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckDefStrSlideChangeCoefficient[0x5];    // 0x0584(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AI_ScoreCheckUseMpImpactCoefficient[0x5];          // 0x0598(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Coffin_RotationYawRandomWidth;                     // 0x05AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_YarukiVoiceID;                            // 0x05B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_TyuuikankiVoiceID;                        // 0x05B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_ReiseiVoiceID;                            // 0x05C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_AseriVoiceID;                             // 0x05C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_IkariVoiceID;                             // 0x05D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_KansyaVoiceID;                            // 0x05D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_YorokobiVoiceID;                          // 0x05E0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Fukidasi_KonranVoiceID;                            // 0x05E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fukidasi_PerTimming;                               // 0x05F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fukidasi_PerTwoCharacter;                          // 0x05F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Fukidasi_DerayTime;                                // 0x05F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5FC[0x4];                                      // 0x05FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackActionCompactMessageInfo>  ActionCompactMessages;                             // 0x0600(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackDamageCompactMessageInfo>  DamageCompactMessages;                             // 0x0610(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackOddEffectCompactMessageInfo> OddEffectCompactMessages;                          // 0x0620(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackPafuPafuMessageInfo>       PafuPafuMukouMessages;                             // 0x0630(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bHansyaValidity_Mahosute;                          // 0x0640(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHansyaValidity_BukiTateGuard;                     // 0x0641(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHansyaValidity_DamageKanzenGuard;                 // 0x0642(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHansyaValidity_KaisinKanzenGuard;                 // 0x0643(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_Counter;                        // 0x0644(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_Mikawasi;                       // 0x0645(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_BukiTateGuard;                  // 0x0646(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_DamageKanzenGuard;              // 0x0647(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_ButuriKanzenGuard;              // 0x0648(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUkenagasiValidity_KaisinKanzenGuard;              // 0x0649(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleMonsterCollisionVisible;                    // 0x064A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64B[0x5];                                      // 0x064B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackActionBalloonDelayInfo>    BalloonDelayInfos;                                 // 0x0650(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         KnockBack_SmallRate;                               // 0x0660(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBack_NormalRate;                              // 0x0664(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockBack_PlayerDamageSS_BlendRate;                // 0x0668(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_66C[0x4];                                      // 0x066C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           RotationToAttackerLocationMonsterIDs;              // 0x0670(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Class_NigeruEffectClass;                           // 0x0680(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Class_ResultZenmetuClass;                          // 0x0698(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	int32 GetAICalcActionStrideTableCountMax() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleParameter">();
	}
	static class UJackBattleParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleParameter>();
	}
};
static_assert(alignof(UJackBattleParameter) == 0x000008, "Wrong alignment on UJackBattleParameter");
static_assert(sizeof(UJackBattleParameter) == 0x0006B0, "Wrong size on UJackBattleParameter");
static_assert(offsetof(UJackBattleParameter, FastMode_TimeDilation) == 0x000038, "Member 'UJackBattleParameter::FastMode_TimeDilation' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, FastMode_TimeDilationByVeryFast) == 0x00003C, "Member 'UJackBattleParameter::FastMode_TimeDilationByVeryFast' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bFastMode_IncludingMonsterAppear) == 0x000040, "Member 'UJackBattleParameter::bFastMode_IncludingMonsterAppear' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bFastMode_IncludingResult) == 0x000041, "Member 'UJackBattleParameter::bFastMode_IncludingResult' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bFastMode_IncludingMatineeRenkei) == 0x000042, "Member 'UJackBattleParameter::bFastMode_IncludingMatineeRenkei' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bFastMode_VoiceEnable) == 0x000043, "Member 'UJackBattleParameter::bFastMode_VoiceEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, FastMode_CameraRotationSpeed) == 0x000044, "Member 'UJackBattleParameter::FastMode_CameraRotationSpeed' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, FastMode_CameraRotationSpeedByVeryFast) == 0x000048, "Member 'UJackBattleParameter::FastMode_CameraRotationSpeedByVeryFast' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fade_EndFadeOutDefaultTimeByWin) == 0x00004C, "Member 'UJackBattleParameter::Fade_EndFadeOutDefaultTimeByWin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fade_EndFadeOutDefaultTimeByOther) == 0x000050, "Member 'UJackBattleParameter::Fade_EndFadeOutDefaultTimeByOther' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Foliage_DitherRanges) == 0x000054, "Member 'UJackBattleParameter::Foliage_DitherRanges' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Foliage_BattleFieldDitherLowerLimitRadius) == 0x000060, "Member 'UJackBattleParameter::Foliage_BattleFieldDitherLowerLimitRadius' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Foliage_BattleFieldFoliageDitherInfos) == 0x000068, "Member 'UJackBattleParameter::Foliage_BattleFieldFoliageDitherInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Chara_InjuryRateInterpTime) == 0x000078, "Member 'UJackBattleParameter::Chara_InjuryRateInterpTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerKougekiInfos) == 0x000080, "Member 'UJackBattleParameter::PlayerKougekiInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bPlayerMove_TurnToEnable) == 0x000090, "Member 'UJackBattleParameter::bPlayerMove_TurnToEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpIn) == 0x000094, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpIn' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpOut) == 0x000098, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpOut' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpAdjustP0) == 0x00009C, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpAdjustP0' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpAdjustP1) == 0x0000A0, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpAdjustP1' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpAdjustP2) == 0x0000A4, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpAdjustP2' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PlayerMove_SpeedInterpAdjustP3) == 0x0000A8, "Member 'UJackBattleParameter::PlayerMove_SpeedInterpAdjustP3' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, BattleFieldDirectionForcedAngle) == 0x0000AC, "Member 'UJackBattleParameter::BattleFieldDirectionForcedAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, BattleFieldDirectionForcedAdjustment) == 0x0000B0, "Member 'UJackBattleParameter::BattleFieldDirectionForcedAdjustment' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, BattleStartMenu_MenuOpenWaitTime) == 0x0000B4, "Member 'UJackBattleParameter::BattleStartMenu_MenuOpenWaitTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PreparationViewData) == 0x0000B8, "Member 'UJackBattleParameter::PreparationViewData' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionAssistMove_Timeout) == 0x0000C8, "Member 'UJackBattleParameter::ActionAssistMove_Timeout' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionAssistMove_RotationSpeed) == 0x0000CC, "Member 'UJackBattleParameter::ActionAssistMove_RotationSpeed' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionAssistMove_RotationDurationTime) == 0x0000D0, "Member 'UJackBattleParameter::ActionAssistMove_RotationDurationTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_BackJump) == 0x0000D4, "Member 'UJackBattleParameter::bActionBackMove_BackJump' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_IgnoreMeireisasero) == 0x0000D5, "Member 'UJackBattleParameter::bActionBackMove_IgnoreMeireisasero' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionBackMove_BackJumpThresholdLength) == 0x0000D8, "Member 'UJackBattleParameter::ActionBackMove_BackJumpThresholdLength' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionBackMove_BackJumpLimitLength) == 0x0000DC, "Member 'UJackBattleParameter::ActionBackMove_BackJumpLimitLength' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_BackJumpForceByAutoCamera) == 0x0000E0, "Member 'UJackBattleParameter::bActionBackMove_BackJumpForceByAutoCamera' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionBackMove_BackJumpForceThresholdLength) == 0x0000E4, "Member 'UJackBattleParameter::ActionBackMove_BackJumpForceThresholdLength' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_ActionCompleteWaitIfBackJumpPlayingByAutoCamera) == 0x0000E8, "Member 'UJackBattleParameter::bActionBackMove_ActionCompleteWaitIfBackJumpPlayingByAutoCamera' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_ActionPlayWaitIfAnyBackJumpPlayingByAutoCamera) == 0x0000E9, "Member 'UJackBattleParameter::bActionBackMove_ActionPlayWaitIfAnyBackJumpPlayingByAutoCamera' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bActionBackMove_InvalidRelocateIfBackJumpPlayingByAutoCamera) == 0x0000EA, "Member 'UJackBattleParameter::bActionBackMove_InvalidRelocateIfBackJumpPlayingByAutoCamera' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bHiddenFriends) == 0x0000EB, "Member 'UJackBattleParameter::bHiddenFriends' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bSimpleCamera_GroupMoveDisable) == 0x0000EC, "Member 'UJackBattleParameter::bSimpleCamera_GroupMoveDisable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bSimpleCamera_TeleportToHomePositionEnable) == 0x0000ED, "Member 'UJackBattleParameter::bSimpleCamera_TeleportToHomePositionEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bSimpleCamera_RenzokuKoudouTeleportDisable) == 0x0000EE, "Member 'UJackBattleParameter::bSimpleCamera_RenzokuKoudouTeleportDisable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bSimpleCamera_RenzokuKoudouTeleportDisableByBattleCommand) == 0x0000EF, "Member 'UJackBattleParameter::bSimpleCamera_RenzokuKoudouTeleportDisableByBattleCommand' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bSimpleCamera_LookAtDisable) == 0x0000F0, "Member 'UJackBattleParameter::bSimpleCamera_LookAtDisable' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_Overlap) == 0x0000F4, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_Overlap' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_80) == 0x0000F8, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_80' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_50) == 0x0000FC, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_50' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenaltyTurnChara_50) == 0x000100, "Member 'UJackBattleParameter::PrgCamera_ScorePenaltyTurnChara_50' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_MarginSizeAll) == 0x000104, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_MarginSizeAll' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_MarginSizeH) == 0x000108, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_MarginSizeH' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_MarginSizeUnder) == 0x00010C, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_MarginSizeUnder' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_MarginBalanceH) == 0x000110, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_MarginBalanceH' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_MarginBalanceW) == 0x000114, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_MarginBalanceW' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_TurnCharaDist) == 0x000118, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_TurnCharaDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_PreCamera) == 0x00011C, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_PreCamera' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_FrontDiffDist) == 0x000120, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_FrontDiffDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_BirdDiffDist) == 0x000124, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_BirdDiffDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ScorePenalty_DiagonalDiffDist) == 0x000128, "Member 'UJackBattleParameter::PrgCamera_ScorePenalty_DiagonalDiffDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Front_FixDist) == 0x00012C, "Member 'UJackBattleParameter::PrgCamera_Front_FixDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Front_DistOfs) == 0x000130, "Member 'UJackBattleParameter::PrgCamera_Front_DistOfs' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Front_YawAdd) == 0x000134, "Member 'UJackBattleParameter::PrgCamera_Front_YawAdd' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Front_PitchAdd) == 0x000138, "Member 'UJackBattleParameter::PrgCamera_Front_PitchAdd' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Front_GroundMargin) == 0x00013C, "Member 'UJackBattleParameter::PrgCamera_Front_GroundMargin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Bird_LotPar) == 0x000140, "Member 'UJackBattleParameter::PrgCamera_Bird_LotPar' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Bird_FixDist) == 0x000144, "Member 'UJackBattleParameter::PrgCamera_Bird_FixDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Bird_YawVariation) == 0x000148, "Member 'UJackBattleParameter::PrgCamera_Bird_YawVariation' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_LotFrontPar) == 0x00014C, "Member 'UJackBattleParameter::PrgCamera_Diagonal_LotFrontPar' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_LotTrackingPar) == 0x000150, "Member 'UJackBattleParameter::PrgCamera_Diagonal_LotTrackingPar' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_NoTrackingDist) == 0x000154, "Member 'UJackBattleParameter::PrgCamera_Diagonal_NoTrackingDist' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_CurveFunc) == 0x000158, "Member 'UJackBattleParameter::PrgCamera_Diagonal_CurveFunc' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_LotBestMax) == 0x00015C, "Member 'UJackBattleParameter::PrgCamera_Diagonal_LotBestMax' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_PitchVariation) == 0x000160, "Member 'UJackBattleParameter::PrgCamera_Diagonal_PitchVariation' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_DistOffsetMax) == 0x000164, "Member 'UJackBattleParameter::PrgCamera_Diagonal_DistOffsetMax' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_YawMin) == 0x000168, "Member 'UJackBattleParameter::PrgCamera_Diagonal_YawMin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_MinZ) == 0x00016C, "Member 'UJackBattleParameter::PrgCamera_Diagonal_MinZ' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_TrackingMinZ) == 0x000170, "Member 'UJackBattleParameter::PrgCamera_Diagonal_TrackingMinZ' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_NoLowMinZ) == 0x000174, "Member 'UJackBattleParameter::PrgCamera_Diagonal_NoLowMinZ' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_TrackingNoLowMinZ) == 0x000178, "Member 'UJackBattleParameter::PrgCamera_Diagonal_TrackingNoLowMinZ' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_YawAdd) == 0x00017C, "Member 'UJackBattleParameter::PrgCamera_Diagonal_YawAdd' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Socket_OffsetPos) == 0x000180, "Member 'UJackBattleParameter::PrgCamera_Socket_OffsetPos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Socket_LotPar) == 0x00018C, "Member 'UJackBattleParameter::PrgCamera_Socket_LotPar' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Anim_MaxTime) == 0x000190, "Member 'UJackBattleParameter::PrgCamera_Anim_MaxTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Anim_YawAdd) == 0x000194, "Member 'UJackBattleParameter::PrgCamera_Anim_YawAdd' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Anim_DistAdd) == 0x000198, "Member 'UJackBattleParameter::PrgCamera_Anim_DistAdd' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_GroundMargin) == 0x00019C, "Member 'UJackBattleParameter::PrgCamera_GroundMargin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_CollisionSphereRadius) == 0x0001A0, "Member 'UJackBattleParameter::PrgCamera_CollisionSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_PushOutMargin) == 0x0001A4, "Member 'UJackBattleParameter::PrgCamera_PushOutMargin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_ShrinkLotPar) == 0x0001A8, "Member 'UJackBattleParameter::PrgCamera_ShrinkLotPar' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_PCCameraScoreRects) == 0x0001B0, "Member 'UJackBattleParameter::PrgCamera_PCCameraScoreRects' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_MainViewMonsters) == 0x0001C0, "Member 'UJackBattleParameter::PrgCamera_Diagonal_MainViewMonsters' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_Diagonal_HorizontalViewMonsters) == 0x0001D0, "Member 'UJackBattleParameter::PrgCamera_Diagonal_HorizontalViewMonsters' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_BirdMonsters) == 0x0001E0, "Member 'UJackBattleParameter::PrgCamera_BirdMonsters' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PrgCamera_CameraBlockMonsters) == 0x0001F0, "Member 'UJackBattleParameter::PrgCamera_CameraBlockMonsters' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Nigeru_BaseSuccessPer) == 0x000200, "Member 'UJackBattleParameter::Nigeru_BaseSuccessPer' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Nigeru_KiyousaHosei) == 0x000204, "Member 'UJackBattleParameter::Nigeru_KiyousaHosei' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Nigeru_CertainKouSyuThreshold) == 0x000208, "Member 'UJackBattleParameter::Nigeru_CertainKouSyuThreshold' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Nigeru_SaiteiHosyouSuccessPerArray) == 0x000210, "Member 'UJackBattleParameter::Nigeru_SaiteiHosyouSuccessPerArray' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_NifuramuDitherTime) == 0x000220, "Member 'UJackBattleParameter::Action_NifuramuDitherTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_InoriNoYubiwaBreakProb) == 0x000224, "Member 'UJackBattleParameter::Action_InoriNoYubiwaBreakProb' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_BunnyNoMamoriActionHitDelayTime) == 0x000228, "Member 'UJackBattleParameter::Action_BunnyNoMamoriActionHitDelayTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_BunnyNoMamoriActionFadeAlpha) == 0x00022C, "Member 'UJackBattleParameter::Action_BunnyNoMamoriActionFadeAlpha' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_BunnyNoMamoriActionFadeOutTime) == 0x000230, "Member 'UJackBattleParameter::Action_BunnyNoMamoriActionFadeOutTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_BunnyNoMamoriActionFadeInTime) == 0x000234, "Member 'UJackBattleParameter::Action_BunnyNoMamoriActionFadeInTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_TateGuardSEID_Player) == 0x000238, "Member 'UJackBattleParameter::Action_TateGuardSEID_Player' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_TateGuardSEID_Monster) == 0x000240, "Member 'UJackBattleParameter::Action_TateGuardSEID_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_FailShotMotionLoopTime) == 0x000248, "Member 'UJackBattleParameter::Action_FailShotMotionLoopTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_FailMessageDelayTime_Default) == 0x00024C, "Member 'UJackBattleParameter::Action_FailMessageDelayTime_Default' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_FailMessageDelayTime_DefaultByItem) == 0x000250, "Member 'UJackBattleParameter::Action_FailMessageDelayTime_DefaultByItem' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Action_FailMessageDelayTime_Exclusive) == 0x000254, "Member 'UJackBattleParameter::Action_FailMessageDelayTime_Exclusive' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, NakamaYobi_CheckCapsuleRadius) == 0x000258, "Member 'UJackBattleParameter::NakamaYobi_CheckCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Renkei_MemorizeRenkeiIDs) == 0x000260, "Member 'UJackBattleParameter::Renkei_MemorizeRenkeiIDs' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnOrder_SubayasaHoseiMin_Player) == 0x000270, "Member 'UJackBattleParameter::TurnOrder_SubayasaHoseiMin_Player' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnOrder_SubayasaHoseiMax_Player) == 0x000274, "Member 'UJackBattleParameter::TurnOrder_SubayasaHoseiMax_Player' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnOrder_SubayasaHoseiMin_Monster) == 0x000278, "Member 'UJackBattleParameter::TurnOrder_SubayasaHoseiMin_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnOrder_SubayasaHoseiMax_Monster) == 0x00027C, "Member 'UJackBattleParameter::TurnOrder_SubayasaHoseiMax_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnStartOddEffect_WaitSecondMin) == 0x000280, "Member 'UJackBattleParameter::TurnStartOddEffect_WaitSecondMin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnStartOddEffect_ActionCameraID_Player) == 0x000288, "Member 'UJackBattleParameter::TurnStartOddEffect_ActionCameraID_Player' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, TurnStartOddEffect_ActionCameraID_Monster) == 0x000290, "Member 'UJackBattleParameter::TurnStartOddEffect_ActionCameraID_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_HanteiOddEffectID) == 0x000298, "Member 'UJackBattleParameter::Mitoreru_HanteiOddEffectID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_OddEffectID) == 0x0002A0, "Member 'UJackBattleParameter::Mitoreru_OddEffectID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_CalcBaseParameter1) == 0x0002A8, "Member 'UJackBattleParameter::Mitoreru_CalcBaseParameter1' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_CalcBaseParameter2) == 0x0002AC, "Member 'UJackBattleParameter::Mitoreru_CalcBaseParameter2' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_CalcBaseClampMin) == 0x0002B0, "Member 'UJackBattleParameter::Mitoreru_CalcBaseClampMin' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Mitoreru_CalcBaseClampMax) == 0x0002B4, "Member 'UJackBattleParameter::Mitoreru_CalcBaseClampMax' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, HazukasiiNoroi_OddEffectIDs) == 0x0002B8, "Member 'UJackBattleParameter::HazukasiiNoroi_OddEffectIDs' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Hazukasiinoroi_MiryouMukou) == 0x000308, "Member 'UJackBattleParameter::Hazukasiinoroi_MiryouMukou' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Hazukasiinoroi_KonranMukou) == 0x00030C, "Member 'UJackBattleParameter::Hazukasiinoroi_KonranMukou' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Hazukasiinoroi_NemuriMukou) == 0x000310, "Member 'UJackBattleParameter::Hazukasiinoroi_NemuriMukou' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Hazukasiinoroi_RandomTexts) == 0x000318, "Member 'UJackBattleParameter::Hazukasiinoroi_RandomTexts' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, OddEffect_Konran_MeityuuHoseiPer) == 0x000328, "Member 'UJackBattleParameter::OddEffect_Konran_MeityuuHoseiPer' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, OddEffect_Miryou_KougekiBairituHoseiPer) == 0x00032C, "Member 'UJackBattleParameter::OddEffect_Miryou_KougekiBairituHoseiPer' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, OddEffect_NakamaTurnSkip_KoudouPerArray) == 0x000330, "Member 'UJackBattleParameter::OddEffect_NakamaTurnSkip_KoudouPerArray' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, HitStop_PresetInfos) == 0x000340, "Member 'UJackBattleParameter::HitStop_PresetInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, HitCameraShake_PresetInfos) == 0x000370, "Member 'UJackBattleParameter::HitCameraShake_PresetInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Hate_Ranks) == 0x0004E0, "Member 'UJackBattleParameter::Hate_Ranks' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_CalcActionStrideTableCountMax) == 0x0004F0, "Member 'UJackBattleParameter::AI_CalcActionStrideTableCountMax' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_CalcScoreTimeMax) == 0x0004F4, "Member 'UJackBattleParameter::AI_CalcScoreTimeMax' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckZoneCoefficient) == 0x0004F8, "Member 'UJackBattleParameter::AI_ScoreCheckZoneCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckNemuriCoefficient) == 0x0004FC, "Member 'UJackBattleParameter::AI_ScoreCheckNemuriCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckNemuriCorrectCoefficient) == 0x000500, "Member 'UJackBattleParameter::AI_ScoreCheckNemuriCorrectCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckMetalCoefficient) == 0x000504, "Member 'UJackBattleParameter::AI_ScoreCheckMetalCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckMetalExpCoefficient) == 0x000508, "Member 'UJackBattleParameter::AI_ScoreCheckMetalExpCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckContinuedDamageCoefficient) == 0x00050C, "Member 'UJackBattleParameter::AI_ScoreCheckContinuedDamageCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAttackUpEnableCoefficient) == 0x000510, "Member 'UJackBattleParameter::AI_ScoreCheckAttackUpEnableCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckDazzleCureEnableCoefficient) == 0x000514, "Member 'UJackBattleParameter::AI_ScoreCheckDazzleCureEnableCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckDazzleCorrectCoefficient) == 0x000518, "Member 'UJackBattleParameter::AI_ScoreCheckDazzleCorrectCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_Zaoriku) == 0x00051C, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_Zaoriku' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_Zaoraru) == 0x000520, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_Zaoraru' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_FukkatuNoTue) == 0x000524, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_FukkatuNoTue' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_SeijaNoUta) == 0x000528, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_SeijaNoUta' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_Megazaru) == 0x00052C, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_Megazaru' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckCRACoefficient_Etc) == 0x000530, "Member 'UJackBattleParameter::AI_ScoreCheckCRACoefficient_Etc' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_Zaoriku) == 0x000534, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_Zaoriku' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_Zaoraru) == 0x000538, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_Zaoraru' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_FukkatuNoTue) == 0x00053C, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_FukkatuNoTue' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_SeijaNoUta) == 0x000540, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_SeijaNoUta' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_Megazaru) == 0x000544, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_Megazaru' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckTRACoefficient_Etc) == 0x000548, "Member 'UJackBattleParameter::AI_ScoreCheckTRACoefficient_Etc' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_Rihoimi) == 0x00054C, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_Rihoimi' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_Ribehoimi) == 0x000550, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_Ribehoimi' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_Ribehoimu) == 0x000554, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_Ribehoimu' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_IyasiNoAme) == 0x000558, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_IyasiNoAme' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_RamudaNoInori) == 0x00055C, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_RamudaNoInori' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAHHCoefficient_RamudaNoInori_Otona) == 0x000560, "Member 'UJackBattleParameter::AI_ScoreCheckAHHCoefficient_RamudaNoInori_Otona' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckAtkStrRankCoefficient) == 0x000564, "Member 'UJackBattleParameter::AI_ScoreCheckAtkStrRankCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckDefStrRankCoefficient) == 0x000574, "Member 'UJackBattleParameter::AI_ScoreCheckDefStrRankCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckDefStrSlideChangeCoefficient) == 0x000584, "Member 'UJackBattleParameter::AI_ScoreCheckDefStrSlideChangeCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, AI_ScoreCheckUseMpImpactCoefficient) == 0x000598, "Member 'UJackBattleParameter::AI_ScoreCheckUseMpImpactCoefficient' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Coffin_RotationYawRandomWidth) == 0x0005AC, "Member 'UJackBattleParameter::Coffin_RotationYawRandomWidth' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_YarukiVoiceID) == 0x0005B0, "Member 'UJackBattleParameter::Fukidasi_YarukiVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_TyuuikankiVoiceID) == 0x0005B8, "Member 'UJackBattleParameter::Fukidasi_TyuuikankiVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_ReiseiVoiceID) == 0x0005C0, "Member 'UJackBattleParameter::Fukidasi_ReiseiVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_AseriVoiceID) == 0x0005C8, "Member 'UJackBattleParameter::Fukidasi_AseriVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_IkariVoiceID) == 0x0005D0, "Member 'UJackBattleParameter::Fukidasi_IkariVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_KansyaVoiceID) == 0x0005D8, "Member 'UJackBattleParameter::Fukidasi_KansyaVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_YorokobiVoiceID) == 0x0005E0, "Member 'UJackBattleParameter::Fukidasi_YorokobiVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_KonranVoiceID) == 0x0005E8, "Member 'UJackBattleParameter::Fukidasi_KonranVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_PerTimming) == 0x0005F0, "Member 'UJackBattleParameter::Fukidasi_PerTimming' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_PerTwoCharacter) == 0x0005F4, "Member 'UJackBattleParameter::Fukidasi_PerTwoCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Fukidasi_DerayTime) == 0x0005F8, "Member 'UJackBattleParameter::Fukidasi_DerayTime' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, ActionCompactMessages) == 0x000600, "Member 'UJackBattleParameter::ActionCompactMessages' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, DamageCompactMessages) == 0x000610, "Member 'UJackBattleParameter::DamageCompactMessages' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, OddEffectCompactMessages) == 0x000620, "Member 'UJackBattleParameter::OddEffectCompactMessages' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, PafuPafuMukouMessages) == 0x000630, "Member 'UJackBattleParameter::PafuPafuMukouMessages' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bHansyaValidity_Mahosute) == 0x000640, "Member 'UJackBattleParameter::bHansyaValidity_Mahosute' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bHansyaValidity_BukiTateGuard) == 0x000641, "Member 'UJackBattleParameter::bHansyaValidity_BukiTateGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bHansyaValidity_DamageKanzenGuard) == 0x000642, "Member 'UJackBattleParameter::bHansyaValidity_DamageKanzenGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bHansyaValidity_KaisinKanzenGuard) == 0x000643, "Member 'UJackBattleParameter::bHansyaValidity_KaisinKanzenGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_Counter) == 0x000644, "Member 'UJackBattleParameter::bUkenagasiValidity_Counter' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_Mikawasi) == 0x000645, "Member 'UJackBattleParameter::bUkenagasiValidity_Mikawasi' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_BukiTateGuard) == 0x000646, "Member 'UJackBattleParameter::bUkenagasiValidity_BukiTateGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_DamageKanzenGuard) == 0x000647, "Member 'UJackBattleParameter::bUkenagasiValidity_DamageKanzenGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_ButuriKanzenGuard) == 0x000648, "Member 'UJackBattleParameter::bUkenagasiValidity_ButuriKanzenGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bUkenagasiValidity_KaisinKanzenGuard) == 0x000649, "Member 'UJackBattleParameter::bUkenagasiValidity_KaisinKanzenGuard' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, bBattleMonsterCollisionVisible) == 0x00064A, "Member 'UJackBattleParameter::bBattleMonsterCollisionVisible' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, BalloonDelayInfos) == 0x000650, "Member 'UJackBattleParameter::BalloonDelayInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, KnockBack_SmallRate) == 0x000660, "Member 'UJackBattleParameter::KnockBack_SmallRate' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, KnockBack_NormalRate) == 0x000664, "Member 'UJackBattleParameter::KnockBack_NormalRate' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, KnockBack_PlayerDamageSS_BlendRate) == 0x000668, "Member 'UJackBattleParameter::KnockBack_PlayerDamageSS_BlendRate' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, RotationToAttackerLocationMonsterIDs) == 0x000670, "Member 'UJackBattleParameter::RotationToAttackerLocationMonsterIDs' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Class_NigeruEffectClass) == 0x000680, "Member 'UJackBattleParameter::Class_NigeruEffectClass' has a wrong offset!");
static_assert(offsetof(UJackBattleParameter, Class_ResultZenmetuClass) == 0x000698, "Member 'UJackBattleParameter::Class_ResultZenmetuClass' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayVoice
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotify_PlayVoice final : public UJackAnimNotify
{
public:
	class FName                                   VoiceID;                                           // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayVoice">();
	}
	static class UJackAnimNotify_PlayVoice* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayVoice>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayVoice) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayVoice");
static_assert(sizeof(UJackAnimNotify_PlayVoice) == 0x000050, "Wrong size on UJackAnimNotify_PlayVoice");
static_assert(offsetof(UJackAnimNotify_PlayVoice, VoiceID) == 0x000048, "Member 'UJackAnimNotify_PlayVoice::VoiceID' has a wrong offset!");

// Class JackGame.JackAnimNotify_PlayWaterSurfaceSound
// 0x0010 (0x0078 - 0x0068)
class UJackAnimNotify_PlayWaterSurfaceSound final : public UAnimNotify_PlaySound
{
public:
	float                                         TraceUpperDistance;                                // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceLowerDistance;                                // 0x006C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepSphereRadius;                                 // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_PlayWaterSurfaceSound">();
	}
	static class UJackAnimNotify_PlayWaterSurfaceSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_PlayWaterSurfaceSound>();
	}
};
static_assert(alignof(UJackAnimNotify_PlayWaterSurfaceSound) == 0x000008, "Wrong alignment on UJackAnimNotify_PlayWaterSurfaceSound");
static_assert(sizeof(UJackAnimNotify_PlayWaterSurfaceSound) == 0x000078, "Wrong size on UJackAnimNotify_PlayWaterSurfaceSound");
static_assert(offsetof(UJackAnimNotify_PlayWaterSurfaceSound, TraceUpperDistance) == 0x000068, "Member 'UJackAnimNotify_PlayWaterSurfaceSound::TraceUpperDistance' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayWaterSurfaceSound, TraceLowerDistance) == 0x00006C, "Member 'UJackAnimNotify_PlayWaterSurfaceSound::TraceLowerDistance' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_PlayWaterSurfaceSound, SweepSphereRadius) == 0x000070, "Member 'UJackAnimNotify_PlayWaterSurfaceSound::SweepSphereRadius' has a wrong offset!");

// Class JackGame.JackAnimNotify_SpawnAirBubble
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotify_SpawnAirBubble final : public UJackAnimNotify
{
public:
	EJackAirBubble                                AirBubbleType;                                     // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SpawnRate;                                         // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_SpawnAirBubble">();
	}
	static class UJackAnimNotify_SpawnAirBubble* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_SpawnAirBubble>();
	}
};
static_assert(alignof(UJackAnimNotify_SpawnAirBubble) == 0x000008, "Wrong alignment on UJackAnimNotify_SpawnAirBubble");
static_assert(sizeof(UJackAnimNotify_SpawnAirBubble) == 0x000050, "Wrong size on UJackAnimNotify_SpawnAirBubble");
static_assert(offsetof(UJackAnimNotify_SpawnAirBubble, AirBubbleType) == 0x000048, "Member 'UJackAnimNotify_SpawnAirBubble::AirBubbleType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnAirBubble, SpawnRate) == 0x00004C, "Member 'UJackAnimNotify_SpawnAirBubble::SpawnRate' has a wrong offset!");

// Class JackGame.JackAnimNotify_SpawnDecalActor
// 0x0088 (0x00D0 - 0x0048)
class UJackAnimNotify_SpawnDecalActor final : public UJackAnimNotify
{
public:
	class UMaterialInterface*                     DecalMaterialInterface;                            // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FTransform                             OffsetSpawnTransform;                              // 0x0050(0x0030)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         ActorLifeSpan;                                     // 0x0080(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RandomRotationRange;                               // 0x0084(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bApplyPostRandomRotation;                          // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveLinearColor*                      ColorCurve;                                        // 0x0098(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   MaterialParameterNameToModifyColorCurve;           // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bApplyCurveAlphaOnly;                              // 0x00A8(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStaticMeshDecal;                                  // 0x00A9(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AA[0x2];                                       // 0x00AA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZFadeRange;                                        // 0x00AC(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseRaycastHitLocation;                            // 0x00B0(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B1[0x3];                                       // 0x00B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RaycastOffsetStart;                                // 0x00B4(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RaycastOffsetEnd;                                  // 0x00C0(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAlignRaycastHitNormal;                            // 0x00CC(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         AxisToAlignRaycastHitNormal;                       // 0x00CD(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMinusAxisToAlignRaycastHitNormal;                 // 0x00CE(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CF[0x1];                                       // 0x00CF(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_SpawnDecalActor">();
	}
	static class UJackAnimNotify_SpawnDecalActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_SpawnDecalActor>();
	}
};
static_assert(alignof(UJackAnimNotify_SpawnDecalActor) == 0x000010, "Wrong alignment on UJackAnimNotify_SpawnDecalActor");
static_assert(sizeof(UJackAnimNotify_SpawnDecalActor) == 0x0000D0, "Wrong size on UJackAnimNotify_SpawnDecalActor");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, DecalMaterialInterface) == 0x000048, "Member 'UJackAnimNotify_SpawnDecalActor::DecalMaterialInterface' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, OffsetSpawnTransform) == 0x000050, "Member 'UJackAnimNotify_SpawnDecalActor::OffsetSpawnTransform' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, ActorLifeSpan) == 0x000080, "Member 'UJackAnimNotify_SpawnDecalActor::ActorLifeSpan' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, RandomRotationRange) == 0x000084, "Member 'UJackAnimNotify_SpawnDecalActor::RandomRotationRange' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bApplyPostRandomRotation) == 0x000090, "Member 'UJackAnimNotify_SpawnDecalActor::bApplyPostRandomRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, ColorCurve) == 0x000098, "Member 'UJackAnimNotify_SpawnDecalActor::ColorCurve' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, MaterialParameterNameToModifyColorCurve) == 0x0000A0, "Member 'UJackAnimNotify_SpawnDecalActor::MaterialParameterNameToModifyColorCurve' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bApplyCurveAlphaOnly) == 0x0000A8, "Member 'UJackAnimNotify_SpawnDecalActor::bApplyCurveAlphaOnly' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bStaticMeshDecal) == 0x0000A9, "Member 'UJackAnimNotify_SpawnDecalActor::bStaticMeshDecal' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, ZFadeRange) == 0x0000AC, "Member 'UJackAnimNotify_SpawnDecalActor::ZFadeRange' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bUseRaycastHitLocation) == 0x0000B0, "Member 'UJackAnimNotify_SpawnDecalActor::bUseRaycastHitLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, RaycastOffsetStart) == 0x0000B4, "Member 'UJackAnimNotify_SpawnDecalActor::RaycastOffsetStart' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, RaycastOffsetEnd) == 0x0000C0, "Member 'UJackAnimNotify_SpawnDecalActor::RaycastOffsetEnd' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bAlignRaycastHitNormal) == 0x0000CC, "Member 'UJackAnimNotify_SpawnDecalActor::bAlignRaycastHitNormal' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, AxisToAlignRaycastHitNormal) == 0x0000CD, "Member 'UJackAnimNotify_SpawnDecalActor::AxisToAlignRaycastHitNormal' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_SpawnDecalActor, bMinusAxisToAlignRaycastHitNormal) == 0x0000CE, "Member 'UJackAnimNotify_SpawnDecalActor::bMinusAxisToAlignRaycastHitNormal' has a wrong offset!");

// Class JackGame.JackAnimNotify_StabilizeAnimDynamics
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotify_StabilizeAnimDynamics final : public UJackAnimNotify
{
public:
	bool                                          bRequireResetAnimDynamics;                         // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AnimDynamicsIdlingCount;                           // 0x004C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUPPER_BODY;                                       // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLOWER_BODY;                                       // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBODY_EXTRA;                                       // 0x0052(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHair;                                             // 0x0053(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHAIR_EXTRA;                                       // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMantle;                                           // 0x0055(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOther;                                            // 0x0056(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_StabilizeAnimDynamics">();
	}
	static class UJackAnimNotify_StabilizeAnimDynamics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_StabilizeAnimDynamics>();
	}
};
static_assert(alignof(UJackAnimNotify_StabilizeAnimDynamics) == 0x000008, "Wrong alignment on UJackAnimNotify_StabilizeAnimDynamics");
static_assert(sizeof(UJackAnimNotify_StabilizeAnimDynamics) == 0x000058, "Wrong size on UJackAnimNotify_StabilizeAnimDynamics");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bRequireResetAnimDynamics) == 0x000048, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bRequireResetAnimDynamics' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, AnimDynamicsIdlingCount) == 0x00004C, "Member 'UJackAnimNotify_StabilizeAnimDynamics::AnimDynamicsIdlingCount' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bUPPER_BODY) == 0x000050, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bUPPER_BODY' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bLOWER_BODY) == 0x000051, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bLOWER_BODY' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bBODY_EXTRA) == 0x000052, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bBODY_EXTRA' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bHair) == 0x000053, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bHair' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bHAIR_EXTRA) == 0x000054, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bHAIR_EXTRA' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bMantle) == 0x000055, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bMantle' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StabilizeAnimDynamics, bOther) == 0x000056, "Member 'UJackAnimNotify_StabilizeAnimDynamics::bOther' has a wrong offset!");

// Class JackGame.JackBattleNigeruComponent
// 0x0008 (0x0130 - 0x0128)
class UJackBattleNigeruComponent : public UActorComponent
{
public:
	bool                                          bNigeruConfirmWindowComplete;                      // 0x0128(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NigeruConfirmWindowExecCount;                      // 0x012C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void NigeruConfirmWindow_OnComplete();
	void NigeruConfirmWindow_OnSelectComplete(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, int32 SelectDialogIndex);
	void SetRecast();

	bool CheckInputRequest(float AllowRadius, float AllowPower) const;
	bool IsInNigeruRequestArea() const;
	bool IsNigeruRequest() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleNigeruComponent">();
	}
	static class UJackBattleNigeruComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleNigeruComponent>();
	}
};
static_assert(alignof(UJackBattleNigeruComponent) == 0x000008, "Wrong alignment on UJackBattleNigeruComponent");
static_assert(sizeof(UJackBattleNigeruComponent) == 0x000130, "Wrong size on UJackBattleNigeruComponent");
static_assert(offsetof(UJackBattleNigeruComponent, bNigeruConfirmWindowComplete) == 0x000128, "Member 'UJackBattleNigeruComponent::bNigeruConfirmWindowComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleNigeruComponent, NigeruConfirmWindowExecCount) == 0x00012C, "Member 'UJackBattleNigeruComponent::NigeruConfirmWindowExecCount' has a wrong offset!");

// Class JackGame.JackAnimNotify_StartComponentMaterialCurveUpdate
// 0x0018 (0x0060 - 0x0048)
class UJackAnimNotify_StartComponentMaterialCurveUpdate final : public UJackAnimNotify
{
public:
	class FName                                   ParameterName;                                     // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveBase*                             Curve;                                             // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         Duration;                                          // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyAlpha;                                        // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOnlyComponent;                                    // 0x005D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5E[0x2];                                       // 0x005E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_StartComponentMaterialCurveUpdate">();
	}
	static class UJackAnimNotify_StartComponentMaterialCurveUpdate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_StartComponentMaterialCurveUpdate>();
	}
};
static_assert(alignof(UJackAnimNotify_StartComponentMaterialCurveUpdate) == 0x000008, "Wrong alignment on UJackAnimNotify_StartComponentMaterialCurveUpdate");
static_assert(sizeof(UJackAnimNotify_StartComponentMaterialCurveUpdate) == 0x000060, "Wrong size on UJackAnimNotify_StartComponentMaterialCurveUpdate");
static_assert(offsetof(UJackAnimNotify_StartComponentMaterialCurveUpdate, ParameterName) == 0x000048, "Member 'UJackAnimNotify_StartComponentMaterialCurveUpdate::ParameterName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StartComponentMaterialCurveUpdate, Curve) == 0x000050, "Member 'UJackAnimNotify_StartComponentMaterialCurveUpdate::Curve' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StartComponentMaterialCurveUpdate, Duration) == 0x000058, "Member 'UJackAnimNotify_StartComponentMaterialCurveUpdate::Duration' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StartComponentMaterialCurveUpdate, bOnlyAlpha) == 0x00005C, "Member 'UJackAnimNotify_StartComponentMaterialCurveUpdate::bOnlyAlpha' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_StartComponentMaterialCurveUpdate, bOnlyComponent) == 0x00005D, "Member 'UJackAnimNotify_StartComponentMaterialCurveUpdate::bOnlyComponent' has a wrong offset!");

// Class JackGame.JackAnimNotify_WaterSurfaceEffectBase
// 0x0020 (0x0068 - 0x0048)
class UJackAnimNotify_WaterSurfaceEffectBase : public UJackAnimNotify
{
public:
	TSubclassOf<class UJackCollideEffectTable>    WaterSurfaceEffect;                                // 0x0048(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EffectScale;                                       // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceSocketName;                                   // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bExecuteTrace;                                     // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceMargin;                                       // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_WaterSurfaceEffectBase">();
	}
	static class UJackAnimNotify_WaterSurfaceEffectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_WaterSurfaceEffectBase>();
	}
};
static_assert(alignof(UJackAnimNotify_WaterSurfaceEffectBase) == 0x000008, "Wrong alignment on UJackAnimNotify_WaterSurfaceEffectBase");
static_assert(sizeof(UJackAnimNotify_WaterSurfaceEffectBase) == 0x000068, "Wrong size on UJackAnimNotify_WaterSurfaceEffectBase");
static_assert(offsetof(UJackAnimNotify_WaterSurfaceEffectBase, WaterSurfaceEffect) == 0x000048, "Member 'UJackAnimNotify_WaterSurfaceEffectBase::WaterSurfaceEffect' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_WaterSurfaceEffectBase, EffectScale) == 0x000050, "Member 'UJackAnimNotify_WaterSurfaceEffectBase::EffectScale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_WaterSurfaceEffectBase, TraceSocketName) == 0x000058, "Member 'UJackAnimNotify_WaterSurfaceEffectBase::TraceSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_WaterSurfaceEffectBase, bExecuteTrace) == 0x000060, "Member 'UJackAnimNotify_WaterSurfaceEffectBase::bExecuteTrace' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_WaterSurfaceEffectBase, TraceMargin) == 0x000064, "Member 'UJackAnimNotify_WaterSurfaceEffectBase::TraceMargin' has a wrong offset!");

// Class JackGame.JackBattleResultZenmetu
// 0x0008 (0x03A0 - 0x0398)
class AJackBattleResultZenmetu final : public AActor
{
public:
	bool                                          bPlaying;                                          // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRequestEnd;                                       // 0x0399(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39A[0x2];                                      // 0x039A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Scene;                                             // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void ExecEvent(EJackBattleResultZenmetuEventType EventType, class FName Param);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleResultZenmetu">();
	}
	static class AJackBattleResultZenmetu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleResultZenmetu>();
	}
};
static_assert(alignof(AJackBattleResultZenmetu) == 0x000008, "Wrong alignment on AJackBattleResultZenmetu");
static_assert(sizeof(AJackBattleResultZenmetu) == 0x0003A0, "Wrong size on AJackBattleResultZenmetu");
static_assert(offsetof(AJackBattleResultZenmetu, bPlaying) == 0x000398, "Member 'AJackBattleResultZenmetu::bPlaying' has a wrong offset!");
static_assert(offsetof(AJackBattleResultZenmetu, bRequestEnd) == 0x000399, "Member 'AJackBattleResultZenmetu::bRequestEnd' has a wrong offset!");
static_assert(offsetof(AJackBattleResultZenmetu, Scene) == 0x00039C, "Member 'AJackBattleResultZenmetu::Scene' has a wrong offset!");

// Class JackGame.JackAnimNotify_WeaponAction
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotify_WeaponAction final : public UJackAnimNotify
{
public:
	EJackEquippedHand                             EquippedHand;                                      // 0x0048(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotify_WeaponAction">();
	}
	static class UJackAnimNotify_WeaponAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotify_WeaponAction>();
	}
};
static_assert(alignof(UJackAnimNotify_WeaponAction) == 0x000008, "Wrong alignment on UJackAnimNotify_WeaponAction");
static_assert(sizeof(UJackAnimNotify_WeaponAction) == 0x000058, "Wrong size on UJackAnimNotify_WeaponAction");
static_assert(offsetof(UJackAnimNotify_WeaponAction, EquippedHand) == 0x000048, "Member 'UJackAnimNotify_WeaponAction::EquippedHand' has a wrong offset!");
static_assert(offsetof(UJackAnimNotify_WeaponAction, ActionName) == 0x000050, "Member 'UJackAnimNotify_WeaponAction::ActionName' has a wrong offset!");

// Class JackGame.JackAnimNotifyComponent
// 0x0050 (0x0178 - 0x0128)
class UJackAnimNotifyComponent final : public UActorComponent
{
public:
	TMap<class FName, class UJackAnimNotifyData*> AnimNotifyDatas;                                   // 0x0128(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyComponent">();
	}
	static class UJackAnimNotifyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyComponent>();
	}
};
static_assert(alignof(UJackAnimNotifyComponent) == 0x000008, "Wrong alignment on UJackAnimNotifyComponent");
static_assert(sizeof(UJackAnimNotifyComponent) == 0x000178, "Wrong size on UJackAnimNotifyComponent");
static_assert(offsetof(UJackAnimNotifyComponent, AnimNotifyDatas) == 0x000128, "Member 'UJackAnimNotifyComponent::AnimNotifyDatas' has a wrong offset!");

// Class JackGame.JackScheduledAIController
// 0x05D0 (0x0B50 - 0x0580)
class AJackScheduledAIController : public AJackAIController
{
public:
	uint8                                         Pad_580[0x54C];                                    // 0x0580(0x054C)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimMontage>            SuspendAnimation[0x2];                             // 0x0ACC(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_ADC[0x74];                                     // 0x0ADC(0x0074)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackScheduledAIController">();
	}
	static class AJackScheduledAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackScheduledAIController>();
	}
};
static_assert(alignof(AJackScheduledAIController) == 0x000008, "Wrong alignment on AJackScheduledAIController");
static_assert(sizeof(AJackScheduledAIController) == 0x000B50, "Wrong size on AJackScheduledAIController");
static_assert(offsetof(AJackScheduledAIController, SuspendAnimation) == 0x000ACC, "Member 'AJackScheduledAIController::SuspendAnimation' has a wrong offset!");

// Class JackGame.JackAnimNotifyData
// 0x0010 (0x0048 - 0x0038)
class UJackAnimNotifyData : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData">();
	}
	static class UJackAnimNotifyData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData>();
	}
};
static_assert(alignof(UJackAnimNotifyData) == 0x000008, "Wrong alignment on UJackAnimNotifyData");
static_assert(sizeof(UJackAnimNotifyData) == 0x000048, "Wrong size on UJackAnimNotifyData");

// Class JackGame.JackAnimNotifyData_ArmIKBase
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotifyData_ArmIKBase final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_ArmIKBase">();
	}
	static class UJackAnimNotifyData_ArmIKBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_ArmIKBase>();
	}
};
static_assert(alignof(UJackAnimNotifyData_ArmIKBase) == 0x000008, "Wrong alignment on UJackAnimNotifyData_ArmIKBase");
static_assert(sizeof(UJackAnimNotifyData_ArmIKBase) == 0x000050, "Wrong size on UJackAnimNotifyData_ArmIKBase");

// Class JackGame.JackBattleMemberChange
// 0x0128 (0x04C0 - 0x0398)
class AJackBattleMemberChange : public AActor
{
public:
	uint8                                         Pad_398[0xF0];                                     // 0x0398(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBattleMemberChangeCharaInfo> MemberChangeCharaInfos;                            // 0x0488(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	class UJackTaskHolder*                        TaskHolder;                                        // 0x0498(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleMemberChangeType                   MemberChangeType;                                  // 0x04A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4A1[0x3];                                      // 0x04A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CharaOutDitherTime;                                // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharaIntervalTimeMin;                              // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharaIntervalTimeMax;                              // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CharaDitherTime;                                   // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B4[0xC];                                      // 0x04B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleMemberChange">();
	}
	static class AJackBattleMemberChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleMemberChange>();
	}
};
static_assert(alignof(AJackBattleMemberChange) == 0x000008, "Wrong alignment on AJackBattleMemberChange");
static_assert(sizeof(AJackBattleMemberChange) == 0x0004C0, "Wrong size on AJackBattleMemberChange");
static_assert(offsetof(AJackBattleMemberChange, MemberChangeCharaInfos) == 0x000488, "Member 'AJackBattleMemberChange::MemberChangeCharaInfos' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, TaskHolder) == 0x000498, "Member 'AJackBattleMemberChange::TaskHolder' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, MemberChangeType) == 0x0004A0, "Member 'AJackBattleMemberChange::MemberChangeType' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, CharaOutDitherTime) == 0x0004A4, "Member 'AJackBattleMemberChange::CharaOutDitherTime' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, CharaIntervalTimeMin) == 0x0004A8, "Member 'AJackBattleMemberChange::CharaIntervalTimeMin' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, CharaIntervalTimeMax) == 0x0004AC, "Member 'AJackBattleMemberChange::CharaIntervalTimeMax' has a wrong offset!");
static_assert(offsetof(AJackBattleMemberChange, CharaDitherTime) == 0x0004B0, "Member 'AJackBattleMemberChange::CharaDitherTime' has a wrong offset!");

// Class JackGame.JackAnimNotifyData_AttackBase
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotifyData_AttackBase : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_AttackBase">();
	}
	static class UJackAnimNotifyData_AttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_AttackBase>();
	}
};
static_assert(alignof(UJackAnimNotifyData_AttackBase) == 0x000008, "Wrong alignment on UJackAnimNotifyData_AttackBase");
static_assert(sizeof(UJackAnimNotifyData_AttackBase) == 0x000058, "Wrong size on UJackAnimNotifyData_AttackBase");

// Class JackGame.JackAnimNotifyData_AttackBurstSphere
// 0x0010 (0x0068 - 0x0058)
class UJackAnimNotifyData_AttackBurstSphere final : public UJackAnimNotifyData_AttackBase
{
public:
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_AttackBurstSphere">();
	}
	static class UJackAnimNotifyData_AttackBurstSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_AttackBurstSphere>();
	}
};
static_assert(alignof(UJackAnimNotifyData_AttackBurstSphere) == 0x000008, "Wrong alignment on UJackAnimNotifyData_AttackBurstSphere");
static_assert(sizeof(UJackAnimNotifyData_AttackBurstSphere) == 0x000068, "Wrong size on UJackAnimNotifyData_AttackBurstSphere");

// Class JackGame.JackSpotLightInnerConeAngleTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackSpotLightInnerConeAngleTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSpotLightInnerConeAngleTrackInst">();
	}
	static class UJackSpotLightInnerConeAngleTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSpotLightInnerConeAngleTrackInst>();
	}
};
static_assert(alignof(UJackSpotLightInnerConeAngleTrackInst) == 0x000008, "Wrong alignment on UJackSpotLightInnerConeAngleTrackInst");
static_assert(sizeof(UJackSpotLightInnerConeAngleTrackInst) == 0x000040, "Wrong size on UJackSpotLightInnerConeAngleTrackInst");

// Class JackGame.JackBattleResultParameter
// 0x0038 (0x0070 - 0x0038)
class UJackBattleResultParameter : public UObject
{
public:
	float                                         LevelUpCamera_InterpSeconds;                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBattleResultFormations>    PlayerFormation;                                   // 0x0040(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackBattleResultFormations>    GuestFormation;                                    // 0x0050(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FormationRandom;                                   // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DropItemDelayTime;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLevelUpRecover;                                   // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleResultParameter">();
	}
	static class UJackBattleResultParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleResultParameter>();
	}
};
static_assert(alignof(UJackBattleResultParameter) == 0x000008, "Wrong alignment on UJackBattleResultParameter");
static_assert(sizeof(UJackBattleResultParameter) == 0x000070, "Wrong size on UJackBattleResultParameter");
static_assert(offsetof(UJackBattleResultParameter, LevelUpCamera_InterpSeconds) == 0x000038, "Member 'UJackBattleResultParameter::LevelUpCamera_InterpSeconds' has a wrong offset!");
static_assert(offsetof(UJackBattleResultParameter, PlayerFormation) == 0x000040, "Member 'UJackBattleResultParameter::PlayerFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleResultParameter, GuestFormation) == 0x000050, "Member 'UJackBattleResultParameter::GuestFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleResultParameter, FormationRandom) == 0x000060, "Member 'UJackBattleResultParameter::FormationRandom' has a wrong offset!");
static_assert(offsetof(UJackBattleResultParameter, DropItemDelayTime) == 0x000064, "Member 'UJackBattleResultParameter::DropItemDelayTime' has a wrong offset!");
static_assert(offsetof(UJackBattleResultParameter, bLevelUpRecover) == 0x000068, "Member 'UJackBattleResultParameter::bLevelUpRecover' has a wrong offset!");

// Class JackGame.JackAnimNotifyData_AttackRay
// 0x0020 (0x0078 - 0x0058)
class UJackAnimNotifyData_AttackRay final : public UJackAnimNotifyData_AttackBase
{
public:
	uint8                                         Pad_58[0x20];                                      // 0x0058(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_AttackRay">();
	}
	static class UJackAnimNotifyData_AttackRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_AttackRay>();
	}
};
static_assert(alignof(UJackAnimNotifyData_AttackRay) == 0x000008, "Wrong alignment on UJackAnimNotifyData_AttackRay");
static_assert(sizeof(UJackAnimNotifyData_AttackRay) == 0x000078, "Wrong size on UJackAnimNotifyData_AttackRay");

// Class JackGame.JackAnimNotifyData_AttackSweptSphere
// 0x0018 (0x0070 - 0x0058)
class UJackAnimNotifyData_AttackSweptSphere final : public UJackAnimNotifyData_AttackBase
{
public:
	uint8                                         Pad_58[0x18];                                      // 0x0058(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_AttackSweptSphere">();
	}
	static class UJackAnimNotifyData_AttackSweptSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_AttackSweptSphere>();
	}
};
static_assert(alignof(UJackAnimNotifyData_AttackSweptSphere) == 0x000008, "Wrong alignment on UJackAnimNotifyData_AttackSweptSphere");
static_assert(sizeof(UJackAnimNotifyData_AttackSweptSphere) == 0x000070, "Wrong size on UJackAnimNotifyData_AttackSweptSphere");

// Class JackGame.JackMoveTrack
// 0x0008 (0x00F0 - 0x00E8)
class UJackMoveTrack : public UInterpTrackMove
{
public:
	bool                                          bDisableMovementAssist;                            // 0x00E8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustTransformForJackCharacter;                  // 0x00E9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRotateToAdjustCharacter;                     // 0x00EA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyScaleToAdjustCharacter;                      // 0x00EB(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EC[0x4];                                       // 0x00EC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMoveTrack">();
	}
	static class UJackMoveTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMoveTrack>();
	}
};
static_assert(alignof(UJackMoveTrack) == 0x000008, "Wrong alignment on UJackMoveTrack");
static_assert(sizeof(UJackMoveTrack) == 0x0000F0, "Wrong size on UJackMoveTrack");
static_assert(offsetof(UJackMoveTrack, bDisableMovementAssist) == 0x0000E8, "Member 'UJackMoveTrack::bDisableMovementAssist' has a wrong offset!");
static_assert(offsetof(UJackMoveTrack, bAdjustTransformForJackCharacter) == 0x0000E9, "Member 'UJackMoveTrack::bAdjustTransformForJackCharacter' has a wrong offset!");
static_assert(offsetof(UJackMoveTrack, bApplyRotateToAdjustCharacter) == 0x0000EA, "Member 'UJackMoveTrack::bApplyRotateToAdjustCharacter' has a wrong offset!");
static_assert(offsetof(UJackMoveTrack, bApplyScaleToAdjustCharacter) == 0x0000EB, "Member 'UJackMoveTrack::bApplyScaleToAdjustCharacter' has a wrong offset!");

// Class JackGame.JackWindControlTrack
// 0x0010 (0x0100 - 0x00F0)
class UJackWindControlTrack final : public UJackMoveTrack
{
public:
	TArray<struct FJackWindControlInfo>           WindInfos;                                         // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWindControlTrack">();
	}
	static class UJackWindControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWindControlTrack>();
	}
};
static_assert(alignof(UJackWindControlTrack) == 0x000008, "Wrong alignment on UJackWindControlTrack");
static_assert(sizeof(UJackWindControlTrack) == 0x000100, "Wrong size on UJackWindControlTrack");
static_assert(offsetof(UJackWindControlTrack, WindInfos) == 0x0000F0, "Member 'UJackWindControlTrack::WindInfos' has a wrong offset!");

// Class JackGame.JackBattleTypes
// 0x0000 (0x0038 - 0x0038)
class UJackBattleTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleTypes">();
	}
	static class UJackBattleTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleTypes>();
	}
};
static_assert(alignof(UJackBattleTypes) == 0x000008, "Wrong alignment on UJackBattleTypes");
static_assert(sizeof(UJackBattleTypes) == 0x000038, "Wrong size on UJackBattleTypes");

// Class JackGame.JackAnimNotifyData_MoveToReservedLocation
// 0x0028 (0x0070 - 0x0048)
class UJackAnimNotifyData_MoveToReservedLocation final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_MoveToReservedLocation">();
	}
	static class UJackAnimNotifyData_MoveToReservedLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_MoveToReservedLocation>();
	}
};
static_assert(alignof(UJackAnimNotifyData_MoveToReservedLocation) == 0x000008, "Wrong alignment on UJackAnimNotifyData_MoveToReservedLocation");
static_assert(sizeof(UJackAnimNotifyData_MoveToReservedLocation) == 0x000070, "Wrong size on UJackAnimNotifyData_MoveToReservedLocation");

// Class JackGame.JackAnimNotifyData_MoveToReservedRotation
// 0x0028 (0x0070 - 0x0048)
class UJackAnimNotifyData_MoveToReservedRotation final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x28];                                      // 0x0048(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_MoveToReservedRotation">();
	}
	static class UJackAnimNotifyData_MoveToReservedRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_MoveToReservedRotation>();
	}
};
static_assert(alignof(UJackAnimNotifyData_MoveToReservedRotation) == 0x000008, "Wrong alignment on UJackAnimNotifyData_MoveToReservedRotation");
static_assert(sizeof(UJackAnimNotifyData_MoveToReservedRotation) == 0x000070, "Wrong size on UJackAnimNotifyData_MoveToReservedRotation");

// Class JackGame.JackBattleSnowman
// 0x0010 (0x1100 - 0x10F0)
class AJackBattleSnowman final : public AJackCharacter
{
public:
	uint8                                         Pad_10F0[0x10];                                    // 0x10F0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleSnowman">();
	}
	static class AJackBattleSnowman* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleSnowman>();
	}
};
static_assert(alignof(AJackBattleSnowman) == 0x000010, "Wrong alignment on AJackBattleSnowman");
static_assert(sizeof(AJackBattleSnowman) == 0x001100, "Wrong size on AJackBattleSnowman");

// Class JackGame.JackAnimNotifyData_OverrideMovementMode
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotifyData_OverrideMovementMode final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_OverrideMovementMode">();
	}
	static class UJackAnimNotifyData_OverrideMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_OverrideMovementMode>();
	}
};
static_assert(alignof(UJackAnimNotifyData_OverrideMovementMode) == 0x000008, "Wrong alignment on UJackAnimNotifyData_OverrideMovementMode");
static_assert(sizeof(UJackAnimNotifyData_OverrideMovementMode) == 0x000050, "Wrong size on UJackAnimNotifyData_OverrideMovementMode");

// Class JackGame.JackAnimNotifyData_OverrideWeaponAttachment
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotifyData_OverrideWeaponAttachment final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_OverrideWeaponAttachment">();
	}
	static class UJackAnimNotifyData_OverrideWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_OverrideWeaponAttachment>();
	}
};
static_assert(alignof(UJackAnimNotifyData_OverrideWeaponAttachment) == 0x000008, "Wrong alignment on UJackAnimNotifyData_OverrideWeaponAttachment");
static_assert(sizeof(UJackAnimNotifyData_OverrideWeaponAttachment) == 0x000050, "Wrong size on UJackAnimNotifyData_OverrideWeaponAttachment");

// Class JackGame.JackFieldPlayerController
// 0x01F8 (0x0B28 - 0x0930)
#pragma pack(push, 0x1)
class alignas(0x08) AJackFieldPlayerController : public AJackPlayerController
{
public:
	uint8                                         Pad_930[0x10];                                     // 0x0930(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialParameterCollection*           MPC_GroundAffect;                                  // 0x0940(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectPlayerMarker;                               // 0x0948(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAffectPossessedConditionInTheAir;                 // 0x0949(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHandleControlGuideVisibility;                     // 0x094A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94B[0x15];                                     // 0x094B(0x0015)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCanEnterPhotoMode;                                // 0x0960(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_961[0x3];                                      // 0x0961(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActionGuideVisibleRate;                            // 0x0964(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_968[0x28];                                     // 0x0968(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackVehicleControllerComponent*        VehicleControllerComponent;                        // 0x0990(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackVehicleRiderControllerComponent*   VehicleRiderControllerComponent;                   // 0x0998(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackVehicle*                           StoredVehicle;                                     // 0x09A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_9A8[0x180];                                    // 0x09A8(0x0180)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void NakamaKaiwa();
	void OnAutoRunDiableChanged(bool bDisable);
	void OnCloseActionGuideHelp();
	void OnDisplayActionGuide();
	void OnHideControlGuideUIChanged(bool bHide);
	void OnOpenActionGuideHelp();
	void OnPawnTeleportSucceeded();
	void OnPlayerMovementModeChanged(class ACharacter* InCharacter, EMovementMode PrevMovementMode, uint8 PreviousCustomMode);
	void PhotoMode();
	void Taimatu();
	void Yubibue();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFieldPlayerController">();
	}
	static class AJackFieldPlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFieldPlayerController>();
	}
};
#pragma pack(pop)
static_assert(alignof(AJackFieldPlayerController) == 0x000008, "Wrong alignment on AJackFieldPlayerController");
static_assert(sizeof(AJackFieldPlayerController) == 0x000B28, "Wrong size on AJackFieldPlayerController");
static_assert(offsetof(AJackFieldPlayerController, MPC_GroundAffect) == 0x000940, "Member 'AJackFieldPlayerController::MPC_GroundAffect' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, bAffectPlayerMarker) == 0x000948, "Member 'AJackFieldPlayerController::bAffectPlayerMarker' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, bAffectPossessedConditionInTheAir) == 0x000949, "Member 'AJackFieldPlayerController::bAffectPossessedConditionInTheAir' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, bHandleControlGuideVisibility) == 0x00094A, "Member 'AJackFieldPlayerController::bHandleControlGuideVisibility' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, bCanEnterPhotoMode) == 0x000960, "Member 'AJackFieldPlayerController::bCanEnterPhotoMode' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, ActionGuideVisibleRate) == 0x000964, "Member 'AJackFieldPlayerController::ActionGuideVisibleRate' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, VehicleControllerComponent) == 0x000990, "Member 'AJackFieldPlayerController::VehicleControllerComponent' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, VehicleRiderControllerComponent) == 0x000998, "Member 'AJackFieldPlayerController::VehicleRiderControllerComponent' has a wrong offset!");
static_assert(offsetof(AJackFieldPlayerController, StoredVehicle) == 0x0009A0, "Member 'AJackFieldPlayerController::StoredVehicle' has a wrong offset!");

// Class JackGame.JackBattlePlayerController
// 0x01A8 (0x0CD0 - 0x0B28)
class AJackBattlePlayerController : public AJackFieldPlayerController
{
public:
	TWeakObjectPtr<class AJackFieldPlayerController> OriginalPlayerController;                          // 0x0B28(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackPlayableCharacter>  FieldPlayableCharacter;                            // 0x0B30(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B38[0x80];                                     // 0x0B38(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDrawEnabled;                                 // 0x0BB8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB9[0x7];                                      // 0x0BB9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackActionCameraParameter*             JackActionCameraParameter;                         // 0x0BC0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC8[0x108];                                    // 0x0BC8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsEncountable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattlePlayerController">();
	}
	static class AJackBattlePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattlePlayerController>();
	}
};
static_assert(alignof(AJackBattlePlayerController) == 0x000008, "Wrong alignment on AJackBattlePlayerController");
static_assert(sizeof(AJackBattlePlayerController) == 0x000CD0, "Wrong size on AJackBattlePlayerController");
static_assert(offsetof(AJackBattlePlayerController, OriginalPlayerController) == 0x000B28, "Member 'AJackBattlePlayerController::OriginalPlayerController' has a wrong offset!");
static_assert(offsetof(AJackBattlePlayerController, FieldPlayableCharacter) == 0x000B30, "Member 'AJackBattlePlayerController::FieldPlayableCharacter' has a wrong offset!");
static_assert(offsetof(AJackBattlePlayerController, bDebugDrawEnabled) == 0x000BB8, "Member 'AJackBattlePlayerController::bDebugDrawEnabled' has a wrong offset!");
static_assert(offsetof(AJackBattlePlayerController, JackActionCameraParameter) == 0x000BC0, "Member 'AJackBattlePlayerController::JackActionCameraParameter' has a wrong offset!");

// Class JackGame.JackAnimNotifyData_PlayCollideEffect
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotifyData_PlayCollideEffect final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_PlayCollideEffect">();
	}
	static class UJackAnimNotifyData_PlayCollideEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_PlayCollideEffect>();
	}
};
static_assert(alignof(UJackAnimNotifyData_PlayCollideEffect) == 0x000008, "Wrong alignment on UJackAnimNotifyData_PlayCollideEffect");
static_assert(sizeof(UJackAnimNotifyData_PlayCollideEffect) == 0x000050, "Wrong size on UJackAnimNotifyData_PlayCollideEffect");

// Class JackGame.JackAnimNotifyData_PlaySound
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotifyData_PlaySound final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_PlaySound">();
	}
	static class UJackAnimNotifyData_PlaySound* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_PlaySound>();
	}
};
static_assert(alignof(UJackAnimNotifyData_PlaySound) == 0x000008, "Wrong alignment on UJackAnimNotifyData_PlaySound");
static_assert(sizeof(UJackAnimNotifyData_PlaySound) == 0x000058, "Wrong size on UJackAnimNotifyData_PlaySound");

// Class JackGame.JackStreamableManager
// 0x0100 (0x0138 - 0x0038)
class UJackStreamableManager final : public UObject
{
public:
	uint8                                         Pad_38[0xF0];                                      // 0x0038(0x00F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackStreamObjectsReceiver*>     StreamObjectsReceivers;                            // 0x0128(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackStreamableManager">();
	}
	static class UJackStreamableManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackStreamableManager>();
	}
};
static_assert(alignof(UJackStreamableManager) == 0x000008, "Wrong alignment on UJackStreamableManager");
static_assert(sizeof(UJackStreamableManager) == 0x000138, "Wrong size on UJackStreamableManager");
static_assert(offsetof(UJackStreamableManager, StreamObjectsReceivers) == 0x000128, "Member 'UJackStreamableManager::StreamObjectsReceivers' has a wrong offset!");

// Class JackGame.JackTaskHolder
// 0x0010 (0x0060 - 0x0050)
class UJackTaskHolder final : public UJackTickableGameObject
{
public:
	TArray<class UJackTask*>                      Tasks;                                             // 0x0050(0x0010)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTaskHolder">();
	}
	static class UJackTaskHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTaskHolder>();
	}
};
static_assert(alignof(UJackTaskHolder) == 0x000008, "Wrong alignment on UJackTaskHolder");
static_assert(sizeof(UJackTaskHolder) == 0x000060, "Wrong size on UJackTaskHolder");
static_assert(offsetof(UJackTaskHolder, Tasks) == 0x000050, "Member 'UJackTaskHolder::Tasks' has a wrong offset!");

// Class JackGame.JackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve
// 0x0010 (0x0058 - 0x0048)
class UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve">();
	}
	static class UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve>();
	}
};
static_assert(alignof(UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve) == 0x000008, "Wrong alignment on UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve");
static_assert(sizeof(UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve) == 0x000058, "Wrong size on UJackAnimNotifyData_StartActorMaterialUpdaterLoopedCurve");

// Class JackGame.JackAnimNotifyData_TiltAlongGround
// 0x0008 (0x0050 - 0x0048)
class UJackAnimNotifyData_TiltAlongGround final : public UJackAnimNotifyData
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyData_TiltAlongGround">();
	}
	static class UJackAnimNotifyData_TiltAlongGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyData_TiltAlongGround>();
	}
};
static_assert(alignof(UJackAnimNotifyData_TiltAlongGround) == 0x000008, "Wrong alignment on UJackAnimNotifyData_TiltAlongGround");
static_assert(sizeof(UJackAnimNotifyData_TiltAlongGround) == 0x000050, "Wrong size on UJackAnimNotifyData_TiltAlongGround");

// Class JackGame.JackAnimNotifyState
// 0x0010 (0x0050 - 0x0040)
class UJackAnimNotifyState : public UAnimNotifyState
{
public:
	float                                         TickStartTime;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickEndTime;                                       // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TickDuration;                                      // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState">();
	}
	static class UJackAnimNotifyState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState>();
	}
};
static_assert(alignof(UJackAnimNotifyState) == 0x000008, "Wrong alignment on UJackAnimNotifyState");
static_assert(sizeof(UJackAnimNotifyState) == 0x000050, "Wrong size on UJackAnimNotifyState");
static_assert(offsetof(UJackAnimNotifyState, TickStartTime) == 0x000040, "Member 'UJackAnimNotifyState::TickStartTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState, TickEndTime) == 0x000044, "Member 'UJackAnimNotifyState::TickEndTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState, TickDuration) == 0x000048, "Member 'UJackAnimNotifyState::TickDuration' has a wrong offset!");

// Class JackGame.JackSynchroCaptionTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackSynchroCaptionTrackInst final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSynchroCaptionTrackInst">();
	}
	static class UJackSynchroCaptionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSynchroCaptionTrackInst>();
	}
};
static_assert(alignof(UJackSynchroCaptionTrackInst) == 0x000008, "Wrong alignment on UJackSynchroCaptionTrackInst");
static_assert(sizeof(UJackSynchroCaptionTrackInst) == 0x000040, "Wrong size on UJackSynchroCaptionTrackInst");
static_assert(offsetof(UJackSynchroCaptionTrackInst, LastUpdatePosition) == 0x000038, "Member 'UJackSynchroCaptionTrackInst::LastUpdatePosition' has a wrong offset!");

// Class JackGame.JackWeaponStructs
// 0x0000 (0x0038 - 0x0038)
class UJackWeaponStructs final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponStructs">();
	}
	static class UJackWeaponStructs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWeaponStructs>();
	}
};
static_assert(alignof(UJackWeaponStructs) == 0x000008, "Wrong alignment on UJackWeaponStructs");
static_assert(sizeof(UJackWeaponStructs) == 0x000038, "Wrong size on UJackWeaponStructs");

// Class JackGame.JackBattleVoiceResourceChanger
// 0x0070 (0x00C0 - 0x0050)
class UJackBattleVoiceResourceChanger final : public UJackTickableGameObject
{
public:
	uint8                                         Pad_50[0x50];                                      // 0x0050(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackFriendGameCharacter*>       ReloadFriendGameCharacters;                        // 0x00A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B0[0x10];                                      // 0x00B0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleVoiceResourceChanger">();
	}
	static class UJackBattleVoiceResourceChanger* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleVoiceResourceChanger>();
	}
};
static_assert(alignof(UJackBattleVoiceResourceChanger) == 0x000008, "Wrong alignment on UJackBattleVoiceResourceChanger");
static_assert(sizeof(UJackBattleVoiceResourceChanger) == 0x0000C0, "Wrong size on UJackBattleVoiceResourceChanger");
static_assert(offsetof(UJackBattleVoiceResourceChanger, ReloadFriendGameCharacters) == 0x0000A0, "Member 'UJackBattleVoiceResourceChanger::ReloadFriendGameCharacters' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_ArmIKBase
// 0x0080 (0x00D0 - 0x0050)
class UJackAnimNotifyState_ArmIKBase : public UJackAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendInEasingFunc;                                 // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInSeconds;                                    // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendOutEasingFunc;                                // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutSeconds;                                   // 0x0064(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AlphaMax;                                          // 0x0068(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EBoneControlSpace                             TraceStartOffsetLocationSpace;                     // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TraceStartOffsetLocation;                          // 0x007C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                MoveLocationScale;                                 // 0x0088(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x3C];                                      // 0x0094(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_ArmIKBase">();
	}
	static class UJackAnimNotifyState_ArmIKBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_ArmIKBase>();
	}
};
static_assert(alignof(UJackAnimNotifyState_ArmIKBase) == 0x000008, "Wrong alignment on UJackAnimNotifyState_ArmIKBase");
static_assert(sizeof(UJackAnimNotifyState_ArmIKBase) == 0x0000D0, "Wrong size on UJackAnimNotifyState_ArmIKBase");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, SocketName) == 0x000050, "Member 'UJackAnimNotifyState_ArmIKBase::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, BlendInEasingFunc) == 0x000058, "Member 'UJackAnimNotifyState_ArmIKBase::BlendInEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, BlendInSeconds) == 0x00005C, "Member 'UJackAnimNotifyState_ArmIKBase::BlendInSeconds' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, BlendOutEasingFunc) == 0x000060, "Member 'UJackAnimNotifyState_ArmIKBase::BlendOutEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, BlendOutSeconds) == 0x000064, "Member 'UJackAnimNotifyState_ArmIKBase::BlendOutSeconds' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, AlphaMax) == 0x000068, "Member 'UJackAnimNotifyState_ArmIKBase::AlphaMax' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, TraceStartSocketName) == 0x000070, "Member 'UJackAnimNotifyState_ArmIKBase::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, TraceStartOffsetLocationSpace) == 0x000078, "Member 'UJackAnimNotifyState_ArmIKBase::TraceStartOffsetLocationSpace' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, TraceStartOffsetLocation) == 0x00007C, "Member 'UJackAnimNotifyState_ArmIKBase::TraceStartOffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ArmIKBase, MoveLocationScale) == 0x000088, "Member 'UJackAnimNotifyState_ArmIKBase::MoveLocationScale' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_ArmIKLeft
// 0x0000 (0x00D0 - 0x00D0)
class UJackAnimNotifyState_ArmIKLeft final : public UJackAnimNotifyState_ArmIKBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_ArmIKLeft">();
	}
	static class UJackAnimNotifyState_ArmIKLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_ArmIKLeft>();
	}
};
static_assert(alignof(UJackAnimNotifyState_ArmIKLeft) == 0x000008, "Wrong alignment on UJackAnimNotifyState_ArmIKLeft");
static_assert(sizeof(UJackAnimNotifyState_ArmIKLeft) == 0x0000D0, "Wrong size on UJackAnimNotifyState_ArmIKLeft");

// Class JackGame.JackBattleToubatuEffect
// 0x00F8 (0x0490 - 0x0398)
class AJackBattleToubatuEffect : public AActor
{
public:
	uint8                                         Pad_398[0xE8];                                     // 0x0398(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bPlayCompleteRequest;                              // 0x0480(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_481[0xF];                                      // 0x0481(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayComplete();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleToubatuEffect">();
	}
	static class AJackBattleToubatuEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleToubatuEffect>();
	}
};
static_assert(alignof(AJackBattleToubatuEffect) == 0x000008, "Wrong alignment on AJackBattleToubatuEffect");
static_assert(sizeof(AJackBattleToubatuEffect) == 0x000490, "Wrong size on AJackBattleToubatuEffect");
static_assert(offsetof(AJackBattleToubatuEffect, bPlayCompleteRequest) == 0x000480, "Member 'AJackBattleToubatuEffect::bPlayCompleteRequest' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_ArmIKRight
// 0x0000 (0x00D0 - 0x00D0)
class UJackAnimNotifyState_ArmIKRight final : public UJackAnimNotifyState_ArmIKBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_ArmIKRight">();
	}
	static class UJackAnimNotifyState_ArmIKRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_ArmIKRight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_ArmIKRight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_ArmIKRight");
static_assert(sizeof(UJackAnimNotifyState_ArmIKRight) == 0x0000D0, "Wrong size on UJackAnimNotifyState_ArmIKRight");

// Class JackGame.JackAnimNotifyState_AttachedProps
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_AttachedProps final : public UJackAnimNotifyState
{
public:
	class FName                                   PropName;                                          // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttachedProps">();
	}
	static class UJackAnimNotifyState_AttachedProps* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttachedProps>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttachedProps) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttachedProps");
static_assert(sizeof(UJackAnimNotifyState_AttachedProps) == 0x000058, "Wrong size on UJackAnimNotifyState_AttachedProps");
static_assert(offsetof(UJackAnimNotifyState_AttachedProps, PropName) == 0x000050, "Member 'UJackAnimNotifyState_AttachedProps::PropName' has a wrong offset!");

// Class JackGame.JackTriggerVolume
// 0x0000 (0x03D0 - 0x03D0)
class AJackTriggerVolume : public ATriggerVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTriggerVolume">();
	}
	static class AJackTriggerVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTriggerVolume>();
	}
};
static_assert(alignof(AJackTriggerVolume) == 0x000008, "Wrong alignment on AJackTriggerVolume");
static_assert(sizeof(AJackTriggerVolume) == 0x0003D0, "Wrong size on AJackTriggerVolume");

// Class JackGame.JackRuraArea
// 0x0008 (0x03D8 - 0x03D0)
class AJackRuraArea final : public AJackTriggerVolume
{
public:
	EJackRuraFail                                 FailType;                                          // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x3];                                      // 0x03D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Level;                                             // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRuraArea">();
	}
	static class AJackRuraArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRuraArea>();
	}
};
static_assert(alignof(AJackRuraArea) == 0x000008, "Wrong alignment on AJackRuraArea");
static_assert(sizeof(AJackRuraArea) == 0x0003D8, "Wrong size on AJackRuraArea");
static_assert(offsetof(AJackRuraArea, FailType) == 0x0003D0, "Member 'AJackRuraArea::FailType' has a wrong offset!");
static_assert(offsetof(AJackRuraArea, Level) == 0x0003D4, "Member 'AJackRuraArea::Level' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_AttackBase
// 0x0020 (0x0070 - 0x0050)
class UJackAnimNotifyState_AttackBase : public UJackAnimNotifyState
{
public:
	EJackNumberOfAttacks                          NumberOfAttacks;                                   // 0x0050(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AttackPower;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         KnockbackPower;                                    // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitStopTime;                                       // 0x0068(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceHitToTarget;                                 // 0x006C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanFriendryFire;                                  // 0x006D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreview;                                          // 0x006E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6F[0x1];                                       // 0x006F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttackBase">();
	}
	static class UJackAnimNotifyState_AttackBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttackBase>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttackBase) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttackBase");
static_assert(sizeof(UJackAnimNotifyState_AttackBase) == 0x000070, "Wrong size on UJackAnimNotifyState_AttackBase");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, NumberOfAttacks) == 0x000050, "Member 'UJackAnimNotifyState_AttackBase::NumberOfAttacks' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, DamageType) == 0x000058, "Member 'UJackAnimNotifyState_AttackBase::DamageType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, AttackPower) == 0x000060, "Member 'UJackAnimNotifyState_AttackBase::AttackPower' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, KnockbackPower) == 0x000064, "Member 'UJackAnimNotifyState_AttackBase::KnockbackPower' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, HitStopTime) == 0x000068, "Member 'UJackAnimNotifyState_AttackBase::HitStopTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, bForceHitToTarget) == 0x00006C, "Member 'UJackAnimNotifyState_AttackBase::bForceHitToTarget' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, bCanFriendryFire) == 0x00006D, "Member 'UJackAnimNotifyState_AttackBase::bCanFriendryFire' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackBase, bPreview) == 0x00006E, "Member 'UJackAnimNotifyState_AttackBase::bPreview' has a wrong offset!");

// Class JackGame.JackUMGWidgetAnimPlayer
// 0x0028 (0x0060 - 0x0038)
class UJackUMGWidgetAnimPlayer final : public UObject
{
public:
	class UUserWidget*                            WidgetRef;                                         // 0x0038(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJackUMGWidgetAnimData                 Playing;                                           // 0x0040(0x0010)(NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FJackUMGWidgetAnimData>         AnimList;                                          // 0x0050(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	static class UJackUMGWidgetAnimPlayer* CreateUMGWidgetAnimPlayer(class UUserWidget* InWidget);

	bool FinishedToPlayNext();
	void PlayJoinLoop(class UWidgetAnimation* InStartAnimRef, class UWidgetAnimation* InLoopAnimRef, bool bIsAddQueue);
	void PlayOneShot(class UWidgetAnimation* InAnimRef, int32 InNumLoop, bool bIsAddQueue);
	void Stop(bool bIsAll);

	bool IsPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWidgetAnimPlayer">();
	}
	static class UJackUMGWidgetAnimPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWidgetAnimPlayer>();
	}
};
static_assert(alignof(UJackUMGWidgetAnimPlayer) == 0x000008, "Wrong alignment on UJackUMGWidgetAnimPlayer");
static_assert(sizeof(UJackUMGWidgetAnimPlayer) == 0x000060, "Wrong size on UJackUMGWidgetAnimPlayer");
static_assert(offsetof(UJackUMGWidgetAnimPlayer, WidgetRef) == 0x000038, "Member 'UJackUMGWidgetAnimPlayer::WidgetRef' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetAnimPlayer, Playing) == 0x000040, "Member 'UJackUMGWidgetAnimPlayer::Playing' has a wrong offset!");
static_assert(offsetof(UJackUMGWidgetAnimPlayer, AnimList) == 0x000050, "Member 'UJackUMGWidgetAnimPlayer::AnimList' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_AttackBurstSphere
// 0x0010 (0x0080 - 0x0070)
class UJackAnimNotifyState_AttackBurstSphere final : public UJackAnimNotifyState_AttackBase
{
public:
	TArray<struct FJackAttackBurstSphere>         AttackBurstSpheres;                                // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttackBurstSphere">();
	}
	static class UJackAnimNotifyState_AttackBurstSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttackBurstSphere>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttackBurstSphere) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttackBurstSphere");
static_assert(sizeof(UJackAnimNotifyState_AttackBurstSphere) == 0x000080, "Wrong size on UJackAnimNotifyState_AttackBurstSphere");
static_assert(offsetof(UJackAnimNotifyState_AttackBurstSphere, AttackBurstSpheres) == 0x000070, "Member 'UJackAnimNotifyState_AttackBurstSphere::AttackBurstSpheres' has a wrong offset!");

// Class JackGame.JackBunsinComponent
// 0x0010 (0x01B0 - 0x01A0)
class UJackBunsinComponent final : public UJackCharacterComponent
{
public:
	TArray<TWeakObjectPtr<class AJackCharacter>>  BunsinActors;                                      // 0x01A0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)

public:
	class AJackCharacter* SpawnBunsinActor(const struct FTransform& Transform);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBunsinComponent">();
	}
	static class UJackBunsinComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBunsinComponent>();
	}
};
static_assert(alignof(UJackBunsinComponent) == 0x000008, "Wrong alignment on UJackBunsinComponent");
static_assert(sizeof(UJackBunsinComponent) == 0x0001B0, "Wrong size on UJackBunsinComponent");
static_assert(offsetof(UJackBunsinComponent, BunsinActors) == 0x0001A0, "Member 'UJackBunsinComponent::BunsinActors' has a wrong offset!");

// Class JackGame.JackVehicleFlyMovementComponent
// 0x0030 (0x0F50 - 0x0F20)
class UJackVehicleFlyMovementComponent final : public UJackVehicleMovementComponent
{
public:
	float                                         JumpBoostTime;                                     // 0x0F20(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixJumpMode;                                      // 0x0F24(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F25[0x3];                                      // 0x0F25(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FixJumpAccelZ;                                     // 0x0F28(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                JumpBoostVelocity;                                 // 0x0F2C(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallFlyDumpRateXY;                                 // 0x0F38(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallFlyDumpRateZ;                                  // 0x0F3C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F40[0x10];                                     // 0x0F40(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleFlyMovementComponent">();
	}
	static class UJackVehicleFlyMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleFlyMovementComponent>();
	}
};
static_assert(alignof(UJackVehicleFlyMovementComponent) == 0x000010, "Wrong alignment on UJackVehicleFlyMovementComponent");
static_assert(sizeof(UJackVehicleFlyMovementComponent) == 0x000F50, "Wrong size on UJackVehicleFlyMovementComponent");
static_assert(offsetof(UJackVehicleFlyMovementComponent, JumpBoostTime) == 0x000F20, "Member 'UJackVehicleFlyMovementComponent::JumpBoostTime' has a wrong offset!");
static_assert(offsetof(UJackVehicleFlyMovementComponent, bFixJumpMode) == 0x000F24, "Member 'UJackVehicleFlyMovementComponent::bFixJumpMode' has a wrong offset!");
static_assert(offsetof(UJackVehicleFlyMovementComponent, FixJumpAccelZ) == 0x000F28, "Member 'UJackVehicleFlyMovementComponent::FixJumpAccelZ' has a wrong offset!");
static_assert(offsetof(UJackVehicleFlyMovementComponent, JumpBoostVelocity) == 0x000F2C, "Member 'UJackVehicleFlyMovementComponent::JumpBoostVelocity' has a wrong offset!");
static_assert(offsetof(UJackVehicleFlyMovementComponent, FallFlyDumpRateXY) == 0x000F38, "Member 'UJackVehicleFlyMovementComponent::FallFlyDumpRateXY' has a wrong offset!");
static_assert(offsetof(UJackVehicleFlyMovementComponent, FallFlyDumpRateZ) == 0x000F3C, "Member 'UJackVehicleFlyMovementComponent::FallFlyDumpRateZ' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_AttackPredictionSphere
// 0x0010 (0x0080 - 0x0070)
class UJackAnimNotifyState_AttackPredictionSphere final : public UJackAnimNotifyState_AttackBase
{
public:
	TArray<struct FJackAttackSphere>              AttackSpheres;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttackPredictionSphere">();
	}
	static class UJackAnimNotifyState_AttackPredictionSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttackPredictionSphere>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttackPredictionSphere) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttackPredictionSphere");
static_assert(sizeof(UJackAnimNotifyState_AttackPredictionSphere) == 0x000080, "Wrong size on UJackAnimNotifyState_AttackPredictionSphere");
static_assert(offsetof(UJackAnimNotifyState_AttackPredictionSphere, AttackSpheres) == 0x000070, "Member 'UJackAnimNotifyState_AttackPredictionSphere::AttackSpheres' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_AttackRay
// 0x0010 (0x0080 - 0x0070)
class UJackAnimNotifyState_AttackRay final : public UJackAnimNotifyState_AttackBase
{
public:
	TArray<struct FJackAttackRay>                 AttackRays;                                        // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttackRay">();
	}
	static class UJackAnimNotifyState_AttackRay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttackRay>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttackRay) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttackRay");
static_assert(sizeof(UJackAnimNotifyState_AttackRay) == 0x000080, "Wrong size on UJackAnimNotifyState_AttackRay");
static_assert(offsetof(UJackAnimNotifyState_AttackRay, AttackRays) == 0x000070, "Member 'UJackAnimNotifyState_AttackRay::AttackRays' has a wrong offset!");

// Class JackGame.JackSaveData
// 0xC008 (0xC040 - 0x0038)
class UJackSaveData : public UObject
{
public:
	uint8                                         Pad_38[0xC008];                                    // 0x0038(0xC008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDefeatMonsterCount(class FName MonsterID, int32 AddCount, bool bSkipAchievementCheck);
	void GetOpenedMonsterZukan(TArray<class FName>* OutZukanIDList);
	void IncrementBattleCountBySwordAttack();
	void IncrementBattleVictoryCount();
	void IncrementBlowAwayMonsterCount();
	void IncrementCampCount();
	void IncrementInnStayCount();
	void IncrementObjectDestructionCount();
	void IncrementQuestClearCount();
	void IncrementRenkeiUseCount(class FName RenkeiID);
	void IncrementUseTokugiCount(class FName ActionID);
	void RecordExecuteMonsterRenkei(class FName MonsterRenkeiID);
	void RecordRideMonsterVehicle(EJackVehicle VehicleID);
	void SetActiveMapID(class FName MapId);
	void SetKaziLastTimePlayerLv(int32 Lv);
	void SetMainSlotIndex(int32 SlotIndex);

	const class FName GetActiveMapID() const;
	class FName GetActiveScenarioFlag() const;
	EJackScenarioGroup GetActiveScenarioGroup() const;
	EJackScenarioID GetActiveScenarioID() const;
	int32 GetBattleCountBySwordAttack() const;
	int32 GetBattleVictoryCount() const;
	int32 GetBlowAwayMonsterCount() const;
	int32 GetCampCount() const;
	int32 GetDefeatMetalMonsterTotalCount() const;
	int32 GetDefeatMonsterCount(class FName MonsterID) const;
	int32 GetDefeatMonsterKind() const;
	int32 GetDefeatMonsterTotalCount() const;
	int32 GetInnStayCount() const;
	class FName GetLatestScenarioFlag(EJackScenarioID ScenarioID) const;
	const int32 GetMainSlotIndex() const;
	const struct FJackMiniGameData GetMiniGameData() const;
	int32 GetMonsterRenkeiExecuteKind() const;
	int32 GetMonsterVehicleRideKind() const;
	int32 GetObjectDestructionCount() const;
	int32 GetOpenedMonsterZukanCount() const;
	const struct FJackOptionData GetOptionData() const;
	int32 GetQuestClearCount() const;
	int32 GetRenkeiUseCount() const;
	int32 GetRenkeiUseKind() const;
	EJackScenarioPlaythrough GetScenarioPlaythrough() const;
	int32 GetUseTokugiCount(class FName ActionID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSaveData">();
	}
	static class UJackSaveData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSaveData>();
	}
};
static_assert(alignof(UJackSaveData) == 0x000008, "Wrong alignment on UJackSaveData");
static_assert(sizeof(UJackSaveData) == 0x00C040, "Wrong size on UJackSaveData");

// Class JackGame.JackAnimNotifyState_AttackSweptSphere
// 0x0018 (0x0088 - 0x0070)
class UJackAnimNotifyState_AttackSweptSphere final : public UJackAnimNotifyState_AttackBase
{
public:
	TArray<struct FJackAttackSphere>              AttackSpheres;                                     // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         UpdateFrequency;                                   // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AttackSweptSphere">();
	}
	static class UJackAnimNotifyState_AttackSweptSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AttackSweptSphere>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AttackSweptSphere) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AttackSweptSphere");
static_assert(sizeof(UJackAnimNotifyState_AttackSweptSphere) == 0x000088, "Wrong size on UJackAnimNotifyState_AttackSweptSphere");
static_assert(offsetof(UJackAnimNotifyState_AttackSweptSphere, AttackSpheres) == 0x000070, "Member 'UJackAnimNotifyState_AttackSweptSphere::AttackSpheres' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_AttackSweptSphere, UpdateFrequency) == 0x000080, "Member 'UJackAnimNotifyState_AttackSweptSphere::UpdateFrequency' has a wrong offset!");

// Class JackGame.JackUMGLoadBrushBase
// 0x0010 (0x0048 - 0x0038)
class UJackUMGLoadBrushBase : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGLoadBrushBase">();
	}
	static class UJackUMGLoadBrushBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGLoadBrushBase>();
	}
};
static_assert(alignof(UJackUMGLoadBrushBase) == 0x000008, "Wrong alignment on UJackUMGLoadBrushBase");
static_assert(sizeof(UJackUMGLoadBrushBase) == 0x000048, "Wrong size on UJackUMGLoadBrushBase");

// Class JackGame.JackAnimNotifyState_AutoLookAt
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_AutoLookAt final : public UJackAnimNotifyState
{
public:
	bool                                          bDisableAutoLookAt;                                // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AutoLookAt">();
	}
	static class UJackAnimNotifyState_AutoLookAt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AutoLookAt>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AutoLookAt) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AutoLookAt");
static_assert(sizeof(UJackAnimNotifyState_AutoLookAt) == 0x000058, "Wrong size on UJackAnimNotifyState_AutoLookAt");
static_assert(offsetof(UJackAnimNotifyState_AutoLookAt, bDisableAutoLookAt) == 0x000050, "Member 'UJackAnimNotifyState_AutoLookAt::bDisableAutoLookAt' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_AutoStabilizeAnimDynamics
// 0x0000 (0x0050 - 0x0050)
class UJackAnimNotifyState_AutoStabilizeAnimDynamics : public UJackAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_AutoStabilizeAnimDynamics">();
	}
	static class UJackAnimNotifyState_AutoStabilizeAnimDynamics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_AutoStabilizeAnimDynamics>();
	}
};
static_assert(alignof(UJackAnimNotifyState_AutoStabilizeAnimDynamics) == 0x000008, "Wrong alignment on UJackAnimNotifyState_AutoStabilizeAnimDynamics");
static_assert(sizeof(UJackAnimNotifyState_AutoStabilizeAnimDynamics) == 0x000050, "Wrong size on UJackAnimNotifyState_AutoStabilizeAnimDynamics");

// Class JackGame.JackAnimNotifyState_BlockMovement
// 0x0000 (0x0050 - 0x0050)
class UJackAnimNotifyState_BlockMovement final : public UJackAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_BlockMovement">();
	}
	static class UJackAnimNotifyState_BlockMovement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_BlockMovement>();
	}
};
static_assert(alignof(UJackAnimNotifyState_BlockMovement) == 0x000008, "Wrong alignment on UJackAnimNotifyState_BlockMovement");
static_assert(sizeof(UJackAnimNotifyState_BlockMovement) == 0x000050, "Wrong size on UJackAnimNotifyState_BlockMovement");

// Class JackGame.JackScheduledKira
// 0x0040 (0x03E0 - 0x03A0)
class AJackScheduledKira : public AJackLocator
{
public:
	uint8                                         Pad_3A0[0x28];                                     // 0x03A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DataTable;                                         // 0x03C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   KiraScheduleID;                                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x4];                                      // 0x03DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceSetReplacementSec(float Seconds);
	int32 GetAppearedKiraCount();
	bool IsAlreadyGotten();
	bool OnRequestDestroy(class AActor* Actor);
	class AActor* OnSpawnKira(const class FName& ItemID, int32 ItemNum, const struct FVector& Location, const class FName& RespawnSaveFlagName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackScheduledKira">();
	}
	static class AJackScheduledKira* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackScheduledKira>();
	}
};
static_assert(alignof(AJackScheduledKira) == 0x000008, "Wrong alignment on AJackScheduledKira");
static_assert(sizeof(AJackScheduledKira) == 0x0003E0, "Wrong size on AJackScheduledKira");
static_assert(offsetof(AJackScheduledKira, DataTable) == 0x0003C8, "Member 'AJackScheduledKira::DataTable' has a wrong offset!");
static_assert(offsetof(AJackScheduledKira, KiraScheduleID) == 0x0003D0, "Member 'AJackScheduledKira::KiraScheduleID' has a wrong offset!");
static_assert(offsetof(AJackScheduledKira, Radius) == 0x0003D8, "Member 'AJackScheduledKira::Radius' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_BoneHidden
// 0x0020 (0x0070 - 0x0050)
class UJackAnimNotifyState_BoneHidden final : public UJackAnimNotifyState
{
public:
	TArray<struct FJackBoneHiddenPresetNameList>  PresetNameList;                                    // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             HiddenBonesDefTable;                               // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHiddenBoneWhenAnimEnd;                         // 0x0068(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHiddenBoneWhenNotifyEnd;                       // 0x0069(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6A[0x6];                                       // 0x006A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBoneScaleParameters(const class FName InPresetName, const bool bInIsHidden, class USkeletalMeshComponent* InMeshComp) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_BoneHidden">();
	}
	static class UJackAnimNotifyState_BoneHidden* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_BoneHidden>();
	}
};
static_assert(alignof(UJackAnimNotifyState_BoneHidden) == 0x000008, "Wrong alignment on UJackAnimNotifyState_BoneHidden");
static_assert(sizeof(UJackAnimNotifyState_BoneHidden) == 0x000070, "Wrong size on UJackAnimNotifyState_BoneHidden");
static_assert(offsetof(UJackAnimNotifyState_BoneHidden, PresetNameList) == 0x000050, "Member 'UJackAnimNotifyState_BoneHidden::PresetNameList' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_BoneHidden, HiddenBonesDefTable) == 0x000060, "Member 'UJackAnimNotifyState_BoneHidden::HiddenBonesDefTable' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_BoneHidden, bUseHiddenBoneWhenAnimEnd) == 0x000068, "Member 'UJackAnimNotifyState_BoneHidden::bUseHiddenBoneWhenAnimEnd' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_BoneHidden, bUseHiddenBoneWhenNotifyEnd) == 0x000069, "Member 'UJackAnimNotifyState_BoneHidden::bUseHiddenBoneWhenNotifyEnd' has a wrong offset!");

// Class JackGame.JackUMGJukeboxItemData
// 0x0030 (0x00B8 - 0x0088)
class UJackUMGJukeboxItemData final : public UJackUMGItemData
{
public:
	EJackMusicBGMVolumeType                       VolumeType;                                        // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Number;                                            // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	float                                         GoldVolume;                                        // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OrcheVolume;                                       // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoOrhce;                                          // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddVolume(float InAddStep, bool bIsMinus, EJackMusicBGMVolumeType InVolumeType);
	const class FText GetCategoryText();
	void Play(float InFadeOutTime);
	void Set(const class UJackUMGJukeboxItemData* InItemData, EJackMusicBGMVolumeType InVolumeType);
	void SetBGMType(EJackMusicBGMVolumeType InVolumeType);
	bool SetVolume(float InVolume, EJackMusicBGMVolumeType InVolumeType);
	void Stop(float InFadeOutTime);

	const class FText GetVolumeText(bool bIsOrhce) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGJukeboxItemData">();
	}
	static class UJackUMGJukeboxItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGJukeboxItemData>();
	}
};
static_assert(alignof(UJackUMGJukeboxItemData) == 0x000008, "Wrong alignment on UJackUMGJukeboxItemData");
static_assert(sizeof(UJackUMGJukeboxItemData) == 0x0000B8, "Wrong size on UJackUMGJukeboxItemData");
static_assert(offsetof(UJackUMGJukeboxItemData, VolumeType) == 0x000088, "Member 'UJackUMGJukeboxItemData::VolumeType' has a wrong offset!");
static_assert(offsetof(UJackUMGJukeboxItemData, Number) == 0x00008C, "Member 'UJackUMGJukeboxItemData::Number' has a wrong offset!");
static_assert(offsetof(UJackUMGJukeboxItemData, Title) == 0x000090, "Member 'UJackUMGJukeboxItemData::Title' has a wrong offset!");
static_assert(offsetof(UJackUMGJukeboxItemData, GoldVolume) == 0x0000A8, "Member 'UJackUMGJukeboxItemData::GoldVolume' has a wrong offset!");
static_assert(offsetof(UJackUMGJukeboxItemData, OrcheVolume) == 0x0000AC, "Member 'UJackUMGJukeboxItemData::OrcheVolume' has a wrong offset!");
static_assert(offsetof(UJackUMGJukeboxItemData, bNoOrhce) == 0x0000B0, "Member 'UJackUMGJukeboxItemData::bNoOrhce' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_CancelFrame
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_CancelFrame final : public UJackAnimNotifyState
{
public:
	float                                         BlendOutTime;                                      // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_CancelFrame">();
	}
	static class UJackAnimNotifyState_CancelFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_CancelFrame>();
	}
};
static_assert(alignof(UJackAnimNotifyState_CancelFrame) == 0x000008, "Wrong alignment on UJackAnimNotifyState_CancelFrame");
static_assert(sizeof(UJackAnimNotifyState_CancelFrame) == 0x000058, "Wrong size on UJackAnimNotifyState_CancelFrame");
static_assert(offsetof(UJackAnimNotifyState_CancelFrame, BlendOutTime) == 0x000050, "Member 'UJackAnimNotifyState_CancelFrame::BlendOutTime' has a wrong offset!");

// Class JackGame.JackCameraLightEnableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackCameraLightEnableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraLightEnableTrackInst">();
	}
	static class UJackCameraLightEnableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCameraLightEnableTrackInst>();
	}
};
static_assert(alignof(UJackCameraLightEnableTrackInst) == 0x000008, "Wrong alignment on UJackCameraLightEnableTrackInst");
static_assert(sizeof(UJackCameraLightEnableTrackInst) == 0x000040, "Wrong size on UJackCameraLightEnableTrackInst");

// Class JackGame.JackVehicleUmaRaceMovementComponent
// 0x0000 (0x0F20 - 0x0F20)
class UJackVehicleUmaRaceMovementComponent final : public UJackVehicleMovementComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleUmaRaceMovementComponent">();
	}
	static class UJackVehicleUmaRaceMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleUmaRaceMovementComponent>();
	}
};
static_assert(alignof(UJackVehicleUmaRaceMovementComponent) == 0x000010, "Wrong alignment on UJackVehicleUmaRaceMovementComponent");
static_assert(sizeof(UJackVehicleUmaRaceMovementComponent) == 0x000F20, "Wrong size on UJackVehicleUmaRaceMovementComponent");

// Class JackGame.JackAnimNotifyState_ClothBlendWeight
// 0x0020 (0x0070 - 0x0050)
class UJackAnimNotifyState_ClothBlendWeight final : public UJackAnimNotifyState
{
public:
	float                                         BeginClothBlendWeight;                             // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndClothBlendWeight;                               // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBeginCurrentClothBlendWeight;                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SpecificComponentName;                             // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_ClothBlendWeight">();
	}
	static class UJackAnimNotifyState_ClothBlendWeight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_ClothBlendWeight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_ClothBlendWeight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_ClothBlendWeight");
static_assert(sizeof(UJackAnimNotifyState_ClothBlendWeight) == 0x000070, "Wrong size on UJackAnimNotifyState_ClothBlendWeight");
static_assert(offsetof(UJackAnimNotifyState_ClothBlendWeight, BeginClothBlendWeight) == 0x000050, "Member 'UJackAnimNotifyState_ClothBlendWeight::BeginClothBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ClothBlendWeight, EndClothBlendWeight) == 0x000054, "Member 'UJackAnimNotifyState_ClothBlendWeight::EndClothBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ClothBlendWeight, bBeginCurrentClothBlendWeight) == 0x000058, "Member 'UJackAnimNotifyState_ClothBlendWeight::bBeginCurrentClothBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ClothBlendWeight, SpecificComponentName) == 0x000060, "Member 'UJackAnimNotifyState_ClothBlendWeight::SpecificComponentName' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_ConstBoneHiddenForLOD1
// 0x0038 (0x0088 - 0x0050)
class UJackAnimNotifyState_ConstBoneHiddenForLOD1 final : public UJackAnimNotifyState
{
public:
	class UDataTable*                             HiddenBonesDefTable;                               // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           VisibleBonesPresetName;                            // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           HiddenBonesPresetName;                             // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             FacialPartsAnimDataTable;                          // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FacialPoseName;                                    // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_ConstBoneHiddenForLOD1">();
	}
	static class UJackAnimNotifyState_ConstBoneHiddenForLOD1* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_ConstBoneHiddenForLOD1>();
	}
};
static_assert(alignof(UJackAnimNotifyState_ConstBoneHiddenForLOD1) == 0x000008, "Wrong alignment on UJackAnimNotifyState_ConstBoneHiddenForLOD1");
static_assert(sizeof(UJackAnimNotifyState_ConstBoneHiddenForLOD1) == 0x000088, "Wrong size on UJackAnimNotifyState_ConstBoneHiddenForLOD1");
static_assert(offsetof(UJackAnimNotifyState_ConstBoneHiddenForLOD1, HiddenBonesDefTable) == 0x000050, "Member 'UJackAnimNotifyState_ConstBoneHiddenForLOD1::HiddenBonesDefTable' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ConstBoneHiddenForLOD1, VisibleBonesPresetName) == 0x000058, "Member 'UJackAnimNotifyState_ConstBoneHiddenForLOD1::VisibleBonesPresetName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ConstBoneHiddenForLOD1, HiddenBonesPresetName) == 0x000068, "Member 'UJackAnimNotifyState_ConstBoneHiddenForLOD1::HiddenBonesPresetName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ConstBoneHiddenForLOD1, FacialPartsAnimDataTable) == 0x000078, "Member 'UJackAnimNotifyState_ConstBoneHiddenForLOD1::FacialPartsAnimDataTable' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_ConstBoneHiddenForLOD1, FacialPoseName) == 0x000080, "Member 'UJackAnimNotifyState_ConstBoneHiddenForLOD1::FacialPoseName' has a wrong offset!");

// Class JackGame.JackSeparateTranslucencyTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSeparateTranslucencyTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSeparateTranslucencyTrackInst">();
	}
	static class UJackSeparateTranslucencyTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSeparateTranslucencyTrackInst>();
	}
};
static_assert(alignof(UJackSeparateTranslucencyTrackInst) == 0x000008, "Wrong alignment on UJackSeparateTranslucencyTrackInst");
static_assert(sizeof(UJackSeparateTranslucencyTrackInst) == 0x000040, "Wrong size on UJackSeparateTranslucencyTrackInst");

// Class JackGame.JackCollideEffect
// 0x01B0 (0x0200 - 0x0050)
class UJackCollideEffect : public UJackTickableGameObject
{
public:
	struct FJackCollideEffects                    DefaultEffects;                                    // 0x0050(0x0078)(Edit, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ModifyTexturePosition;                             // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ModifyTextureRotation;                             // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ModifyColor;                                       // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UParticleSystemComponent> Emitter;                                           // 0x00E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UAudioComponent>         Audio;                                             // 0x00E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UObject>                 EffectOwner;                                       // 0x00F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F8[0x108];                                     // 0x00F8(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCollideEffect">();
	}
	static class UJackCollideEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCollideEffect>();
	}
};
static_assert(alignof(UJackCollideEffect) == 0x000008, "Wrong alignment on UJackCollideEffect");
static_assert(sizeof(UJackCollideEffect) == 0x000200, "Wrong size on UJackCollideEffect");
static_assert(offsetof(UJackCollideEffect, DefaultEffects) == 0x000050, "Member 'UJackCollideEffect::DefaultEffects' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, ModifyTexturePosition) == 0x0000C8, "Member 'UJackCollideEffect::ModifyTexturePosition' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, ModifyTextureRotation) == 0x0000D0, "Member 'UJackCollideEffect::ModifyTextureRotation' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, ModifyColor) == 0x0000D8, "Member 'UJackCollideEffect::ModifyColor' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, Emitter) == 0x0000E0, "Member 'UJackCollideEffect::Emitter' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, Audio) == 0x0000E8, "Member 'UJackCollideEffect::Audio' has a wrong offset!");
static_assert(offsetof(UJackCollideEffect, EffectOwner) == 0x0000F0, "Member 'UJackCollideEffect::EffectOwner' has a wrong offset!");

// Class JackGame.JackBurstEffect
// 0x0048 (0x0248 - 0x0200)
class UJackBurstEffect final : public UJackCollideEffect
{
public:
	TSubclassOf<class UJackCollideEffect>         BurstHitEffect;                                    // 0x0200(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffectTable>    BurstAttackHitEffect;                              // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartSize;                                         // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndSize;                                           // 0x0214(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstDelayStartTime;                               // 0x0218(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstDulation;                                     // 0x021C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreOwner;                                      // 0x0220(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_221[0x3];                                      // 0x0221(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BurstSphereSize;                                   // 0x0224(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BurstTimer;                                        // 0x0228(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22C[0x4];                                      // 0x022C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          AttachedActors;                                    // 0x0230(0x0010)(ZeroConstructor, Transient, UObjectWrapper, NativeAccessSpecifierPublic)
	bool                                          bHitTimingCallbackCalled;                          // 0x0240(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_241[0x7];                                      // 0x0241(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBurstEffect">();
	}
	static class UJackBurstEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBurstEffect>();
	}
};
static_assert(alignof(UJackBurstEffect) == 0x000008, "Wrong alignment on UJackBurstEffect");
static_assert(sizeof(UJackBurstEffect) == 0x000248, "Wrong size on UJackBurstEffect");
static_assert(offsetof(UJackBurstEffect, BurstHitEffect) == 0x000200, "Member 'UJackBurstEffect::BurstHitEffect' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, BurstAttackHitEffect) == 0x000208, "Member 'UJackBurstEffect::BurstAttackHitEffect' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, StartSize) == 0x000210, "Member 'UJackBurstEffect::StartSize' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, EndSize) == 0x000214, "Member 'UJackBurstEffect::EndSize' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, BurstDelayStartTime) == 0x000218, "Member 'UJackBurstEffect::BurstDelayStartTime' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, BurstDulation) == 0x00021C, "Member 'UJackBurstEffect::BurstDulation' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, bIgnoreOwner) == 0x000220, "Member 'UJackBurstEffect::bIgnoreOwner' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, BurstSphereSize) == 0x000224, "Member 'UJackBurstEffect::BurstSphereSize' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, BurstTimer) == 0x000228, "Member 'UJackBurstEffect::BurstTimer' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, AttachedActors) == 0x000230, "Member 'UJackBurstEffect::AttachedActors' has a wrong offset!");
static_assert(offsetof(UJackBurstEffect, bHitTimingCallbackCalled) == 0x000240, "Member 'UJackBurstEffect::bHitTimingCallbackCalled' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_DeactivateWeaponEffects
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_DeactivateWeaponEffects final : public UJackAnimNotifyState
{
public:
	EJackEquippedHand                             ControlHand;                                       // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bImmediately;                                      // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_DeactivateWeaponEffects">();
	}
	static class UJackAnimNotifyState_DeactivateWeaponEffects* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_DeactivateWeaponEffects>();
	}
};
static_assert(alignof(UJackAnimNotifyState_DeactivateWeaponEffects) == 0x000008, "Wrong alignment on UJackAnimNotifyState_DeactivateWeaponEffects");
static_assert(sizeof(UJackAnimNotifyState_DeactivateWeaponEffects) == 0x000058, "Wrong size on UJackAnimNotifyState_DeactivateWeaponEffects");
static_assert(offsetof(UJackAnimNotifyState_DeactivateWeaponEffects, ControlHand) == 0x000050, "Member 'UJackAnimNotifyState_DeactivateWeaponEffects::ControlHand' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_DeactivateWeaponEffects, bImmediately) == 0x000051, "Member 'UJackAnimNotifyState_DeactivateWeaponEffects::bImmediately' has a wrong offset!");

// Class JackGame.JackUMGHorizontalSelect
// 0x0018 (0x0418 - 0x0400)
class UJackUMGHorizontalSelect : public UJackUMGWindowBase
{
public:
	uint8                                         Pad_400[0x18];                                     // 0x0400(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetFullScreenModeFadeInTime();
	float GetFullScreenModeFadeOutTime();
	int32 GetModeSelectCameraPlayWait();
	int32 GetModeSelectCameraWait();
	bool IsModeSelectCameraTestMovie();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHorizontalSelect">();
	}
	static class UJackUMGHorizontalSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHorizontalSelect>();
	}
};
static_assert(alignof(UJackUMGHorizontalSelect) == 0x000008, "Wrong alignment on UJackUMGHorizontalSelect");
static_assert(sizeof(UJackUMGHorizontalSelect) == 0x000418, "Wrong size on UJackUMGHorizontalSelect");

// Class JackGame.JackUMGCameraModeSelect
// 0x0068 (0x0480 - 0x0418)
class UJackUMGCameraModeSelect : public UJackUMGHorizontalSelect
{
public:
	class UManaComponent*                         ManaComponent;                                     // 0x0418(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UManaTexture*>                   ManaTexture;                                       // 0x0420(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UImage*>                         MovieImage;                                        // 0x0430(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         SelectedMovie;                                     // 0x0440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x3C];                                     // 0x0444(0x003C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ChangeMediaSource();
	void FinishManaComponent();
	void Init();
	void InitializeWidget(class UCanvasPanel* ImageList, class UCanvasPanel* ItemList);
	void PauseMovie();
	void SelectMovie();
	void SetMediaSource();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCameraModeSelect">();
	}
	static class UJackUMGCameraModeSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCameraModeSelect>();
	}
};
static_assert(alignof(UJackUMGCameraModeSelect) == 0x000008, "Wrong alignment on UJackUMGCameraModeSelect");
static_assert(sizeof(UJackUMGCameraModeSelect) == 0x000480, "Wrong size on UJackUMGCameraModeSelect");
static_assert(offsetof(UJackUMGCameraModeSelect, ManaComponent) == 0x000418, "Member 'UJackUMGCameraModeSelect::ManaComponent' has a wrong offset!");
static_assert(offsetof(UJackUMGCameraModeSelect, ManaTexture) == 0x000420, "Member 'UJackUMGCameraModeSelect::ManaTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGCameraModeSelect, MovieImage) == 0x000430, "Member 'UJackUMGCameraModeSelect::MovieImage' has a wrong offset!");
static_assert(offsetof(UJackUMGCameraModeSelect, SelectedMovie) == 0x000440, "Member 'UJackUMGCameraModeSelect::SelectedMovie' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_EnsureEvalAnimPerFrame
// 0x0000 (0x0050 - 0x0050)
class UJackAnimNotifyState_EnsureEvalAnimPerFrame final : public UJackAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_EnsureEvalAnimPerFrame">();
	}
	static class UJackAnimNotifyState_EnsureEvalAnimPerFrame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_EnsureEvalAnimPerFrame>();
	}
};
static_assert(alignof(UJackAnimNotifyState_EnsureEvalAnimPerFrame) == 0x000008, "Wrong alignment on UJackAnimNotifyState_EnsureEvalAnimPerFrame");
static_assert(sizeof(UJackAnimNotifyState_EnsureEvalAnimPerFrame) == 0x000050, "Wrong size on UJackAnimNotifyState_EnsureEvalAnimPerFrame");

// Class JackGame.JackBowgunTargetManager
// 0x0010 (0x03A8 - 0x0398)
class AJackBowgunTargetManager final : public AActor
{
public:
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBowgunTargetManager">();
	}
	static class AJackBowgunTargetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBowgunTargetManager>();
	}
};
static_assert(alignof(AJackBowgunTargetManager) == 0x000008, "Wrong alignment on AJackBowgunTargetManager");
static_assert(sizeof(AJackBowgunTargetManager) == 0x0003A8, "Wrong size on AJackBowgunTargetManager");

// Class JackGame.JackAnimNotifyState_FootIKDisable
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_FootIKDisable final : public UJackAnimNotifyState
{
public:
	bool                                          bDisableFootIK;                                    // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDisableAdjustMeshHeight;                          // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootIKDisable">();
	}
	static class UJackAnimNotifyState_FootIKDisable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootIKDisable>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootIKDisable) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootIKDisable");
static_assert(sizeof(UJackAnimNotifyState_FootIKDisable) == 0x000058, "Wrong size on UJackAnimNotifyState_FootIKDisable");
static_assert(offsetof(UJackAnimNotifyState_FootIKDisable, bDisableFootIK) == 0x000050, "Member 'UJackAnimNotifyState_FootIKDisable::bDisableFootIK' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootIKDisable, bDisableAdjustMeshHeight) == 0x000051, "Member 'UJackAnimNotifyState_FootIKDisable::bDisableAdjustMeshHeight' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepBase
// 0x0028 (0x0078 - 0x0050)
class UJackAnimNotifyState_FootstepBase : public UJackAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpNormalSize;                                    // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceFootstepMargin;                               // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceFootstepRadius;                               // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceSocketName;                                   // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDestroyEffectImmediately;                         // 0x0070(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoundFadeoutTime;                                  // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepBase">();
	}
	static class UJackAnimNotifyState_FootstepBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepBase>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepBase) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepBase");
static_assert(sizeof(UJackAnimNotifyState_FootstepBase) == 0x000078, "Wrong size on UJackAnimNotifyState_FootstepBase");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, SocketName) == 0x000050, "Member 'UJackAnimNotifyState_FootstepBase::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, BumpNormalSize) == 0x000058, "Member 'UJackAnimNotifyState_FootstepBase::BumpNormalSize' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, TraceFootstepMargin) == 0x00005C, "Member 'UJackAnimNotifyState_FootstepBase::TraceFootstepMargin' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, TraceFootstepRadius) == 0x000060, "Member 'UJackAnimNotifyState_FootstepBase::TraceFootstepRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, TraceSocketName) == 0x000068, "Member 'UJackAnimNotifyState_FootstepBase::TraceSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, bDestroyEffectImmediately) == 0x000070, "Member 'UJackAnimNotifyState_FootstepBase::bDestroyEffectImmediately' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepBase, SoundFadeoutTime) == 0x000074, "Member 'UJackAnimNotifyState_FootstepBase::SoundFadeoutTime' has a wrong offset!");

// Class JackGame.JackPlayerAnimationStateMachine
// 0x0000 (0x00E0 - 0x00E0)
class UJackPlayerAnimationStateMachine final : public UJackFriendAnimationStateMachine
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerAnimationStateMachine">();
	}
	static class UJackPlayerAnimationStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerAnimationStateMachine>();
	}
};
static_assert(alignof(UJackPlayerAnimationStateMachine) == 0x000008, "Wrong alignment on UJackPlayerAnimationStateMachine");
static_assert(sizeof(UJackPlayerAnimationStateMachine) == 0x0000E0, "Wrong size on UJackPlayerAnimationStateMachine");

// Class JackGame.JackCameraLightDisableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackCameraLightDisableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraLightDisableTrackInst">();
	}
	static class UJackCameraLightDisableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCameraLightDisableTrackInst>();
	}
};
static_assert(alignof(UJackCameraLightDisableTrackInst) == 0x000008, "Wrong alignment on UJackCameraLightDisableTrackInst");
static_assert(sizeof(UJackCameraLightDisableTrackInst) == 0x000040, "Wrong size on UJackCameraLightDisableTrackInst");

// Class JackGame.JackAnimNotifyState_FootstepSoundBase
// 0x0030 (0x0080 - 0x0050)
class UJackAnimNotifyState_FootstepSoundBase : public UJackAnimNotifyState
{
public:
	class FName                                   SocketName;                                        // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BumpNormalSize;                                    // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceFootstepMargin;                               // 0x005C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TraceFootstepRadius;                               // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceSocketName;                                   // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundFadeoutTime;                                  // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundPitch;                                        // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableInGame;                                // 0x007C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSoundEnableCutScene;                              // 0x007D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7E[0x2];                                       // 0x007E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundBase">();
	}
	static class UJackAnimNotifyState_FootstepSoundBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundBase>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundBase) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundBase");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundBase) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepSoundBase");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, SocketName) == 0x000050, "Member 'UJackAnimNotifyState_FootstepSoundBase::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, BumpNormalSize) == 0x000058, "Member 'UJackAnimNotifyState_FootstepSoundBase::BumpNormalSize' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, TraceFootstepMargin) == 0x00005C, "Member 'UJackAnimNotifyState_FootstepSoundBase::TraceFootstepMargin' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, TraceFootstepRadius) == 0x000060, "Member 'UJackAnimNotifyState_FootstepSoundBase::TraceFootstepRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, TraceSocketName) == 0x000068, "Member 'UJackAnimNotifyState_FootstepSoundBase::TraceSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, SoundFadeoutTime) == 0x000070, "Member 'UJackAnimNotifyState_FootstepSoundBase::SoundFadeoutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, SoundVolume) == 0x000074, "Member 'UJackAnimNotifyState_FootstepSoundBase::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, SoundPitch) == 0x000078, "Member 'UJackAnimNotifyState_FootstepSoundBase::SoundPitch' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, bSoundEnableInGame) == 0x00007C, "Member 'UJackAnimNotifyState_FootstepSoundBase::bSoundEnableInGame' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundBase, bSoundEnableCutScene) == 0x00007D, "Member 'UJackAnimNotifyState_FootstepSoundBase::bSoundEnableCutScene' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepSoundTable
// 0x0008 (0x0088 - 0x0080)
class UJackAnimNotifyState_FootstepSoundTable : public UJackAnimNotifyState_FootstepSoundBase
{
public:
	TSubclassOf<class UJackCollideSoundTable>     FootstepSound;                                     // 0x0080(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundTable">();
	}
	static class UJackAnimNotifyState_FootstepSoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundTable>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundTable) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundTable");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundTable) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundTable");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundTable, FootstepSound) == 0x000080, "Member 'UJackAnimNotifyState_FootstepSoundTable::FootstepSound' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepSoundTableLeft
// 0x0000 (0x0088 - 0x0088)
class UJackAnimNotifyState_FootstepSoundTableLeft final : public UJackAnimNotifyState_FootstepSoundTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundTableLeft">();
	}
	static class UJackAnimNotifyState_FootstepSoundTableLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundTableLeft>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundTableLeft) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundTableLeft");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundTableLeft) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundTableLeft");

// Class JackGame.JackAnimNotifyState_FootstepSoundTableRight
// 0x0000 (0x0088 - 0x0088)
class UJackAnimNotifyState_FootstepSoundTableRight final : public UJackAnimNotifyState_FootstepSoundTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundTableRight">();
	}
	static class UJackAnimNotifyState_FootstepSoundTableRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundTableRight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundTableRight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundTableRight");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundTableRight) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundTableRight");

// Class JackGame.JackPlayerCameraComponent
// 0x01D0 (0x0A30 - 0x0860)
class UJackPlayerCameraComponent final : public UCameraComponent
{
public:
	uint8                                         Pad_860[0x1C8];                                    // 0x0860(0x01C8)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackDofFocalDistanceOverrider*         DofFocalDistanceOverrider;                         // 0x0A28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerCameraComponent">();
	}
	static class UJackPlayerCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerCameraComponent>();
	}
};
static_assert(alignof(UJackPlayerCameraComponent) == 0x000010, "Wrong alignment on UJackPlayerCameraComponent");
static_assert(sizeof(UJackPlayerCameraComponent) == 0x000A30, "Wrong size on UJackPlayerCameraComponent");
static_assert(offsetof(UJackPlayerCameraComponent, DofFocalDistanceOverrider) == 0x000A28, "Member 'UJackPlayerCameraComponent::DofFocalDistanceOverrider' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepSoundType
// 0x0008 (0x0088 - 0x0080)
class UJackAnimNotifyState_FootstepSoundType : public UJackAnimNotifyState_FootstepSoundBase
{
public:
	EJackCharacterFootstepType                    FootstepType;                                      // 0x0080(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundType">();
	}
	static class UJackAnimNotifyState_FootstepSoundType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundType>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundType) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundType");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundType) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundType");
static_assert(offsetof(UJackAnimNotifyState_FootstepSoundType, FootstepType) == 0x000080, "Member 'UJackAnimNotifyState_FootstepSoundType::FootstepType' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepSoundTypeLeft
// 0x0000 (0x0088 - 0x0088)
class UJackAnimNotifyState_FootstepSoundTypeLeft final : public UJackAnimNotifyState_FootstepSoundType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundTypeLeft">();
	}
	static class UJackAnimNotifyState_FootstepSoundTypeLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundTypeLeft>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundTypeLeft) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundTypeLeft");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundTypeLeft) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundTypeLeft");

// Class JackGame.JackCameraData
// 0x0008 (0x0040 - 0x0038)
class UJackCameraData : public UObject
{
public:
	float                                         FieldOfView;                                       // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraData">();
	}
	static class UJackCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCameraData>();
	}
};
static_assert(alignof(UJackCameraData) == 0x000008, "Wrong alignment on UJackCameraData");
static_assert(sizeof(UJackCameraData) == 0x000040, "Wrong size on UJackCameraData");
static_assert(offsetof(UJackCameraData, FieldOfView) == 0x000038, "Member 'UJackCameraData::FieldOfView' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepSoundTypeRight
// 0x0000 (0x0088 - 0x0088)
class UJackAnimNotifyState_FootstepSoundTypeRight final : public UJackAnimNotifyState_FootstepSoundType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepSoundTypeRight">();
	}
	static class UJackAnimNotifyState_FootstepSoundTypeRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepSoundTypeRight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepSoundTypeRight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepSoundTypeRight");
static_assert(sizeof(UJackAnimNotifyState_FootstepSoundTypeRight) == 0x000088, "Wrong size on UJackAnimNotifyState_FootstepSoundTypeRight");

// Class JackGame.JackAnimNotifyState_FootstepTable
// 0x0008 (0x0080 - 0x0078)
class UJackAnimNotifyState_FootstepTable : public UJackAnimNotifyState_FootstepBase
{
public:
	TSubclassOf<class UJackCollideEffectTable>    FootstepEffect;                                    // 0x0078(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepTable">();
	}
	static class UJackAnimNotifyState_FootstepTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepTable>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepTable) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepTable");
static_assert(sizeof(UJackAnimNotifyState_FootstepTable) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepTable");
static_assert(offsetof(UJackAnimNotifyState_FootstepTable, FootstepEffect) == 0x000078, "Member 'UJackAnimNotifyState_FootstepTable::FootstepEffect' has a wrong offset!");

// Class JackGame.JackCaptionTrackExecutor
// 0x02C8 (0x0660 - 0x0398)
class AJackCaptionTrackExecutor final : public AActor
{
public:
	TArray<struct FJackCaptionTrackShowSerifuInfo> ShowRequestArray;                                  // 0x0398(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FJackCaptionTrackSynchroInfo>   SynchroRequestArray;                               // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0xD8];                                     // 0x03B8(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackCutSceneTextController*            TextController;                                    // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLipSyncController                 LipController;                                     // 0x04A0(0x0190)(ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_630[0x30];                                     // 0x0630(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCaptionTrackExecutor">();
	}
	static class AJackCaptionTrackExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCaptionTrackExecutor>();
	}
};
static_assert(alignof(AJackCaptionTrackExecutor) == 0x000008, "Wrong alignment on AJackCaptionTrackExecutor");
static_assert(sizeof(AJackCaptionTrackExecutor) == 0x000660, "Wrong size on AJackCaptionTrackExecutor");
static_assert(offsetof(AJackCaptionTrackExecutor, ShowRequestArray) == 0x000398, "Member 'AJackCaptionTrackExecutor::ShowRequestArray' has a wrong offset!");
static_assert(offsetof(AJackCaptionTrackExecutor, SynchroRequestArray) == 0x0003A8, "Member 'AJackCaptionTrackExecutor::SynchroRequestArray' has a wrong offset!");
static_assert(offsetof(AJackCaptionTrackExecutor, TextController) == 0x000490, "Member 'AJackCaptionTrackExecutor::TextController' has a wrong offset!");
static_assert(offsetof(AJackCaptionTrackExecutor, LipController) == 0x0004A0, "Member 'AJackCaptionTrackExecutor::LipController' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepTableLeft
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotifyState_FootstepTableLeft final : public UJackAnimNotifyState_FootstepTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepTableLeft">();
	}
	static class UJackAnimNotifyState_FootstepTableLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepTableLeft>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepTableLeft) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepTableLeft");
static_assert(sizeof(UJackAnimNotifyState_FootstepTableLeft) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepTableLeft");

// Class JackGame.JackAnimNotifyState_FootstepTableRight
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotifyState_FootstepTableRight final : public UJackAnimNotifyState_FootstepTable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepTableRight">();
	}
	static class UJackAnimNotifyState_FootstepTableRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepTableRight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepTableRight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepTableRight");
static_assert(sizeof(UJackAnimNotifyState_FootstepTableRight) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepTableRight");

// Class JackGame.JackCharacterCapsuleComponent
// 0x0260 (0x09C0 - 0x0760)
#pragma pack(push, 0x1)
class alignas(0x10) UJackCharacterCapsuleComponent : public UCapsuleComponent
{
public:
	uint8                                         Pad_760[0xA0];                                     // 0x0760(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bThinCapsuleRadiusEnable;                          // 0x0800(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreCollisionByPlayerPawnWhilePlayerFalling;    // 0x0801(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFallingHitToThin;                                 // 0x0802(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_803[0x1];                                      // 0x0803(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FallingHitToThinExecuteSec;                        // 0x0804(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_808[0x150];                                    // 0x0808(0x0150)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackExtraNPCCapsuleComponent*          ExtraNPCCapsuleComponent;                          // 0x0958(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_960[0x58];                                     // 0x0960(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);
	void OnPlayerMovementModeChanged(class AJackCharacter* JackCharacter, EMovementMode OldMovementMode, EMovementMode NewMovementMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterCapsuleComponent">();
	}
	static class UJackCharacterCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterCapsuleComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackCharacterCapsuleComponent) == 0x000010, "Wrong alignment on UJackCharacterCapsuleComponent");
static_assert(sizeof(UJackCharacterCapsuleComponent) == 0x0009C0, "Wrong size on UJackCharacterCapsuleComponent");
static_assert(offsetof(UJackCharacterCapsuleComponent, bThinCapsuleRadiusEnable) == 0x000800, "Member 'UJackCharacterCapsuleComponent::bThinCapsuleRadiusEnable' has a wrong offset!");
static_assert(offsetof(UJackCharacterCapsuleComponent, bIgnoreCollisionByPlayerPawnWhilePlayerFalling) == 0x000801, "Member 'UJackCharacterCapsuleComponent::bIgnoreCollisionByPlayerPawnWhilePlayerFalling' has a wrong offset!");
static_assert(offsetof(UJackCharacterCapsuleComponent, bFallingHitToThin) == 0x000802, "Member 'UJackCharacterCapsuleComponent::bFallingHitToThin' has a wrong offset!");
static_assert(offsetof(UJackCharacterCapsuleComponent, FallingHitToThinExecuteSec) == 0x000804, "Member 'UJackCharacterCapsuleComponent::FallingHitToThinExecuteSec' has a wrong offset!");
static_assert(offsetof(UJackCharacterCapsuleComponent, ExtraNPCCapsuleComponent) == 0x000958, "Member 'UJackCharacterCapsuleComponent::ExtraNPCCapsuleComponent' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepType
// 0x0008 (0x0080 - 0x0078)
class UJackAnimNotifyState_FootstepType : public UJackAnimNotifyState_FootstepBase
{
public:
	EJackCharacterFootstepType                    FootstepType;                                      // 0x0078(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepType">();
	}
	static class UJackAnimNotifyState_FootstepType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepType>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepType) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepType");
static_assert(sizeof(UJackAnimNotifyState_FootstepType) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepType");
static_assert(offsetof(UJackAnimNotifyState_FootstepType, FootstepType) == 0x000078, "Member 'UJackAnimNotifyState_FootstepType::FootstepType' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepTypeLeft
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotifyState_FootstepTypeLeft final : public UJackAnimNotifyState_FootstepType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepTypeLeft">();
	}
	static class UJackAnimNotifyState_FootstepTypeLeft* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepTypeLeft>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepTypeLeft) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepTypeLeft");
static_assert(sizeof(UJackAnimNotifyState_FootstepTypeLeft) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepTypeLeft");

// Class JackGame.JackColorFadeTrack
// 0x0008 (0x00D0 - 0x00C8)
class UJackColorFadeTrack : public UInterpTrackFade
{
public:
	EJackFadeColor                                FadeColorType;                                     // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCutSceneFadeLayer                        FadeLayer;                                         // 0x00C9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CA[0x6];                                       // 0x00CA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackColorFadeTrack">();
	}
	static class UJackColorFadeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackColorFadeTrack>();
	}
};
static_assert(alignof(UJackColorFadeTrack) == 0x000008, "Wrong alignment on UJackColorFadeTrack");
static_assert(sizeof(UJackColorFadeTrack) == 0x0000D0, "Wrong size on UJackColorFadeTrack");
static_assert(offsetof(UJackColorFadeTrack, FadeColorType) == 0x0000C8, "Member 'UJackColorFadeTrack::FadeColorType' has a wrong offset!");
static_assert(offsetof(UJackColorFadeTrack, FadeLayer) == 0x0000C9, "Member 'UJackColorFadeTrack::FadeLayer' has a wrong offset!");

// Class JackGame.JackCategoryFadeTrack
// 0x0010 (0x00E0 - 0x00D0)
class UJackCategoryFadeTrack final : public UJackColorFadeTrack
{
public:
	TArray<EJackFadeTime>                         FadeTimeCategorys;                                 // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCategoryFadeTrack">();
	}
	static class UJackCategoryFadeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCategoryFadeTrack>();
	}
};
static_assert(alignof(UJackCategoryFadeTrack) == 0x000008, "Wrong alignment on UJackCategoryFadeTrack");
static_assert(sizeof(UJackCategoryFadeTrack) == 0x0000E0, "Wrong size on UJackCategoryFadeTrack");
static_assert(offsetof(UJackCategoryFadeTrack, FadeTimeCategorys) == 0x0000D0, "Member 'UJackCategoryFadeTrack::FadeTimeCategorys' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_FootstepTypeRight
// 0x0000 (0x0080 - 0x0080)
class UJackAnimNotifyState_FootstepTypeRight final : public UJackAnimNotifyState_FootstepType
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_FootstepTypeRight">();
	}
	static class UJackAnimNotifyState_FootstepTypeRight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_FootstepTypeRight>();
	}
};
static_assert(alignof(UJackAnimNotifyState_FootstepTypeRight) == 0x000008, "Wrong alignment on UJackAnimNotifyState_FootstepTypeRight");
static_assert(sizeof(UJackAnimNotifyState_FootstepTypeRight) == 0x000080, "Wrong size on UJackAnimNotifyState_FootstepTypeRight");

// Class JackGame.JackAnimNotifyState_HidePropActor
// 0x0010 (0x0060 - 0x0050)
class UJackAnimNotifyState_HidePropActor final : public UJackAnimNotifyState
{
public:
	TArray<class FName>                           PropNames;                                         // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_HidePropActor">();
	}
	static class UJackAnimNotifyState_HidePropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_HidePropActor>();
	}
};
static_assert(alignof(UJackAnimNotifyState_HidePropActor) == 0x000008, "Wrong alignment on UJackAnimNotifyState_HidePropActor");
static_assert(sizeof(UJackAnimNotifyState_HidePropActor) == 0x000060, "Wrong size on UJackAnimNotifyState_HidePropActor");
static_assert(offsetof(UJackAnimNotifyState_HidePropActor, PropNames) == 0x000050, "Member 'UJackAnimNotifyState_HidePropActor::PropNames' has a wrong offset!");

// Class JackGame.JackCaptionBlendRateTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackCaptionBlendRateTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCaptionBlendRateTrackInst">();
	}
	static class UJackCaptionBlendRateTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCaptionBlendRateTrackInst>();
	}
};
static_assert(alignof(UJackCaptionBlendRateTrackInst) == 0x000008, "Wrong alignment on UJackCaptionBlendRateTrackInst");
static_assert(sizeof(UJackCaptionBlendRateTrackInst) == 0x000038, "Wrong size on UJackCaptionBlendRateTrackInst");

// Class JackGame.JackAnimNotifyState_LockEyeViewPoint
// 0x0010 (0x0060 - 0x0050)
class UJackAnimNotifyState_LockEyeViewPoint final : public UJackAnimNotifyState
{
public:
	float                                         LockBlendSeconds;                                  // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   LockBlendEasingFunc;                               // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnlockBlendSeconds;                                // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   UnlockBlendEasingFunc;                             // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_LockEyeViewPoint">();
	}
	static class UJackAnimNotifyState_LockEyeViewPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_LockEyeViewPoint>();
	}
};
static_assert(alignof(UJackAnimNotifyState_LockEyeViewPoint) == 0x000008, "Wrong alignment on UJackAnimNotifyState_LockEyeViewPoint");
static_assert(sizeof(UJackAnimNotifyState_LockEyeViewPoint) == 0x000060, "Wrong size on UJackAnimNotifyState_LockEyeViewPoint");
static_assert(offsetof(UJackAnimNotifyState_LockEyeViewPoint, LockBlendSeconds) == 0x000050, "Member 'UJackAnimNotifyState_LockEyeViewPoint::LockBlendSeconds' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_LockEyeViewPoint, LockBlendEasingFunc) == 0x000054, "Member 'UJackAnimNotifyState_LockEyeViewPoint::LockBlendEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_LockEyeViewPoint, UnlockBlendSeconds) == 0x000058, "Member 'UJackAnimNotifyState_LockEyeViewPoint::UnlockBlendSeconds' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_LockEyeViewPoint, UnlockBlendEasingFunc) == 0x00005C, "Member 'UJackAnimNotifyState_LockEyeViewPoint::UnlockBlendEasingFunc' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_MoveToReservedLocation
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_MoveToReservedLocation : public UJackAnimNotifyState
{
public:
	EEasingFunc                                   EasingFunc;                                        // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideEasingFuncZ;                              // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFuncZ;                                       // 0x0052(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0053(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreX;                                          // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreY;                                          // 0x0055(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZ;                                          // 0x0056(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_57[0x1];                                       // 0x0057(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_MoveToReservedLocation">();
	}
	static class UJackAnimNotifyState_MoveToReservedLocation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_MoveToReservedLocation>();
	}
};
static_assert(alignof(UJackAnimNotifyState_MoveToReservedLocation) == 0x000008, "Wrong alignment on UJackAnimNotifyState_MoveToReservedLocation");
static_assert(sizeof(UJackAnimNotifyState_MoveToReservedLocation) == 0x000058, "Wrong size on UJackAnimNotifyState_MoveToReservedLocation");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, EasingFunc) == 0x000050, "Member 'UJackAnimNotifyState_MoveToReservedLocation::EasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, bOverrideEasingFuncZ) == 0x000051, "Member 'UJackAnimNotifyState_MoveToReservedLocation::bOverrideEasingFuncZ' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, EasingFuncZ) == 0x000052, "Member 'UJackAnimNotifyState_MoveToReservedLocation::EasingFuncZ' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, bSweep) == 0x000053, "Member 'UJackAnimNotifyState_MoveToReservedLocation::bSweep' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, bIgnoreX) == 0x000054, "Member 'UJackAnimNotifyState_MoveToReservedLocation::bIgnoreX' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, bIgnoreY) == 0x000055, "Member 'UJackAnimNotifyState_MoveToReservedLocation::bIgnoreY' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedLocation, bIgnoreZ) == 0x000056, "Member 'UJackAnimNotifyState_MoveToReservedLocation::bIgnoreZ' has a wrong offset!");

// Class JackGame.JackSkipSuspendTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSkipSuspendTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipSuspendTrackInst">();
	}
	static class UJackSkipSuspendTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipSuspendTrackInst>();
	}
};
static_assert(alignof(UJackSkipSuspendTrackInst) == 0x000008, "Wrong alignment on UJackSkipSuspendTrackInst");
static_assert(sizeof(UJackSkipSuspendTrackInst) == 0x000040, "Wrong size on UJackSkipSuspendTrackInst");

// Class JackGame.JackDebugMenuVariable
// 0x0050 (0x0088 - 0x0038)
class UJackDebugMenuVariable : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x40];                                      // 0x0048(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTooltip(const class FString& Tooltip);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariable">();
	}
	static class UJackDebugMenuVariable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariable>();
	}
};
static_assert(alignof(UJackDebugMenuVariable) == 0x000008, "Wrong alignment on UJackDebugMenuVariable");
static_assert(sizeof(UJackDebugMenuVariable) == 0x000088, "Wrong size on UJackDebugMenuVariable");
static_assert(offsetof(UJackDebugMenuVariable, Name_0) == 0x000038, "Member 'UJackDebugMenuVariable::Name_0' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableVector
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableVector final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FVector GetVector();
	void SetVector(const struct FVector& NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableVector">();
	}
	static class UJackDebugMenuVariableVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableVector>();
	}
};
static_assert(alignof(UJackDebugMenuVariableVector) == 0x000008, "Wrong alignment on UJackDebugMenuVariableVector");
static_assert(sizeof(UJackDebugMenuVariableVector) == 0x000098, "Wrong size on UJackDebugMenuVariableVector");
static_assert(offsetof(UJackDebugMenuVariableVector, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableVector::ValueChanged' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_MoveToReservedLocationStockStart
// 0x0000 (0x0058 - 0x0058)
class UJackAnimNotifyState_MoveToReservedLocationStockStart final : public UJackAnimNotifyState_MoveToReservedLocation
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_MoveToReservedLocationStockStart">();
	}
	static class UJackAnimNotifyState_MoveToReservedLocationStockStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_MoveToReservedLocationStockStart>();
	}
};
static_assert(alignof(UJackAnimNotifyState_MoveToReservedLocationStockStart) == 0x000008, "Wrong alignment on UJackAnimNotifyState_MoveToReservedLocationStockStart");
static_assert(sizeof(UJackAnimNotifyState_MoveToReservedLocationStockStart) == 0x000058, "Wrong size on UJackAnimNotifyState_MoveToReservedLocationStockStart");

// Class JackGame.JackAnimNotifyState_MoveToReservedRotation
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_MoveToReservedRotation final : public UJackAnimNotifyState
{
public:
	EEasingFunc                                   EasingFunc;                                        // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_MoveToReservedRotation">();
	}
	static class UJackAnimNotifyState_MoveToReservedRotation* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_MoveToReservedRotation>();
	}
};
static_assert(alignof(UJackAnimNotifyState_MoveToReservedRotation) == 0x000008, "Wrong alignment on UJackAnimNotifyState_MoveToReservedRotation");
static_assert(sizeof(UJackAnimNotifyState_MoveToReservedRotation) == 0x000058, "Wrong size on UJackAnimNotifyState_MoveToReservedRotation");
static_assert(offsetof(UJackAnimNotifyState_MoveToReservedRotation, EasingFunc) == 0x000050, "Member 'UJackAnimNotifyState_MoveToReservedRotation::EasingFunc' has a wrong offset!");

// Class JackGame.JackCharacterMeshComponent
// 0x0160 (0x1200 - 0x10A0)
class UJackCharacterMeshComponent final : public USkeletalMeshComponent
{
public:
	uint8                                         Pad_10A0[0x10];                                    // 0x10A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackAttitudeControlComponent*          CachedAttitudeControlComponent;                    // 0x10B0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10B8[0x148];                                   // 0x10B8(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EvaluateLowerFacePose(const struct FJackEvaluateFacePose_Params& Params_0);
	void EvaluateUpperFacePose(const struct FJackEvaluateFacePose_Params& Params_0);
	bool SetFixedLODBounds(class FName LODBoundsName);
	void SetFixedLODBoundsEnable(bool bEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterMeshComponent">();
	}
	static class UJackCharacterMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterMeshComponent>();
	}
};
static_assert(alignof(UJackCharacterMeshComponent) == 0x000010, "Wrong alignment on UJackCharacterMeshComponent");
static_assert(sizeof(UJackCharacterMeshComponent) == 0x001200, "Wrong size on UJackCharacterMeshComponent");
static_assert(offsetof(UJackCharacterMeshComponent, CachedAttitudeControlComponent) == 0x0010B0, "Member 'UJackCharacterMeshComponent::CachedAttitudeControlComponent' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_OverrideFacialState
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_OverrideFacialState final : public UJackAnimNotifyState
{
public:
	bool                                          bControlUpper;                                     // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUpperFacialState                         UpperFacialState;                                  // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bControlLower;                                     // 0x0052(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackLowerFacialState                         LowerFacialState;                                  // 0x0053(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_OverrideFacialState">();
	}
	static class UJackAnimNotifyState_OverrideFacialState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_OverrideFacialState>();
	}
};
static_assert(alignof(UJackAnimNotifyState_OverrideFacialState) == 0x000008, "Wrong alignment on UJackAnimNotifyState_OverrideFacialState");
static_assert(sizeof(UJackAnimNotifyState_OverrideFacialState) == 0x000058, "Wrong size on UJackAnimNotifyState_OverrideFacialState");
static_assert(offsetof(UJackAnimNotifyState_OverrideFacialState, bControlUpper) == 0x000050, "Member 'UJackAnimNotifyState_OverrideFacialState::bControlUpper' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_OverrideFacialState, UpperFacialState) == 0x000051, "Member 'UJackAnimNotifyState_OverrideFacialState::UpperFacialState' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_OverrideFacialState, bControlLower) == 0x000052, "Member 'UJackAnimNotifyState_OverrideFacialState::bControlLower' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_OverrideFacialState, LowerFacialState) == 0x000053, "Member 'UJackAnimNotifyState_OverrideFacialState::LowerFacialState' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_OverrideMovementMode
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_OverrideMovementMode final : public UJackAnimNotifyState
{
public:
	EMovementMode                                 OverrideMovementMode;                              // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRestoreMovementMode;                              // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_OverrideMovementMode">();
	}
	static class UJackAnimNotifyState_OverrideMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_OverrideMovementMode>();
	}
};
static_assert(alignof(UJackAnimNotifyState_OverrideMovementMode) == 0x000008, "Wrong alignment on UJackAnimNotifyState_OverrideMovementMode");
static_assert(sizeof(UJackAnimNotifyState_OverrideMovementMode) == 0x000058, "Wrong size on UJackAnimNotifyState_OverrideMovementMode");
static_assert(offsetof(UJackAnimNotifyState_OverrideMovementMode, OverrideMovementMode) == 0x000050, "Member 'UJackAnimNotifyState_OverrideMovementMode::OverrideMovementMode' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_OverrideMovementMode, bRestoreMovementMode) == 0x000051, "Member 'UJackAnimNotifyState_OverrideMovementMode::bRestoreMovementMode' has a wrong offset!");

// Class JackGame.JackSnapToGroundTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSnapToGroundTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSnapToGroundTrack">();
	}
	static class UJackSnapToGroundTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSnapToGroundTrack>();
	}
};
static_assert(alignof(UJackSnapToGroundTrack) == 0x000008, "Wrong alignment on UJackSnapToGroundTrack");
static_assert(sizeof(UJackSnapToGroundTrack) == 0x0000A8, "Wrong size on UJackSnapToGroundTrack");

// Class JackGame.JackAnimNotifyState_OverrideWeaponAttachment
// 0x0010 (0x0060 - 0x0050)
class UJackAnimNotifyState_OverrideWeaponAttachment final : public UJackAnimNotifyState
{
public:
	EJackEquippedHand                             EquippedHand;                                      // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0058(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_OverrideWeaponAttachment">();
	}
	static class UJackAnimNotifyState_OverrideWeaponAttachment* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_OverrideWeaponAttachment>();
	}
};
static_assert(alignof(UJackAnimNotifyState_OverrideWeaponAttachment) == 0x000008, "Wrong alignment on UJackAnimNotifyState_OverrideWeaponAttachment");
static_assert(sizeof(UJackAnimNotifyState_OverrideWeaponAttachment) == 0x000060, "Wrong size on UJackAnimNotifyState_OverrideWeaponAttachment");
static_assert(offsetof(UJackAnimNotifyState_OverrideWeaponAttachment, EquippedHand) == 0x000050, "Member 'UJackAnimNotifyState_OverrideWeaponAttachment::EquippedHand' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_OverrideWeaponAttachment, SocketName) == 0x000058, "Member 'UJackAnimNotifyState_OverrideWeaponAttachment::SocketName' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_PlayCollideEffect
// 0x0058 (0x00A8 - 0x0050)
class UJackAnimNotifyState_PlayCollideEffect final : public UJackAnimNotifyState
{
public:
	TSubclassOf<class UJackCollideEffect>         CollideEffectClass;                                // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttachInfo;                               // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttached;                                 // 0x0059(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideSocketName;                                // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               OverrideAttachLocationType;                        // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideOffsetLocation;                            // 0x006C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OverrideOffsetRotation;                            // 0x0078(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestroyEffectImmediately;                         // 0x0084(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoundFadeoutTime;                                  // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceEnabled;                                     // 0x008C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x008D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0098(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceEndSocketName;                                // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_PlayCollideEffect">();
	}
	static class UJackAnimNotifyState_PlayCollideEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_PlayCollideEffect>();
	}
};
static_assert(alignof(UJackAnimNotifyState_PlayCollideEffect) == 0x000008, "Wrong alignment on UJackAnimNotifyState_PlayCollideEffect");
static_assert(sizeof(UJackAnimNotifyState_PlayCollideEffect) == 0x0000A8, "Wrong size on UJackAnimNotifyState_PlayCollideEffect");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, CollideEffectClass) == 0x000050, "Member 'UJackAnimNotifyState_PlayCollideEffect::CollideEffectClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, bOverrideAttachInfo) == 0x000058, "Member 'UJackAnimNotifyState_PlayCollideEffect::bOverrideAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, bOverrideAttached) == 0x000059, "Member 'UJackAnimNotifyState_PlayCollideEffect::bOverrideAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, OverrideSocketName) == 0x000060, "Member 'UJackAnimNotifyState_PlayCollideEffect::OverrideSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, OverrideAttachLocationType) == 0x000068, "Member 'UJackAnimNotifyState_PlayCollideEffect::OverrideAttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, OverrideOffsetLocation) == 0x00006C, "Member 'UJackAnimNotifyState_PlayCollideEffect::OverrideOffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, OverrideOffsetRotation) == 0x000078, "Member 'UJackAnimNotifyState_PlayCollideEffect::OverrideOffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, bDestroyEffectImmediately) == 0x000084, "Member 'UJackAnimNotifyState_PlayCollideEffect::bDestroyEffectImmediately' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, SoundFadeoutTime) == 0x000088, "Member 'UJackAnimNotifyState_PlayCollideEffect::SoundFadeoutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, bTraceEnabled) == 0x00008C, "Member 'UJackAnimNotifyState_PlayCollideEffect::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, TraceChannel) == 0x00008D, "Member 'UJackAnimNotifyState_PlayCollideEffect::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, TraceSphereRadius) == 0x000090, "Member 'UJackAnimNotifyState_PlayCollideEffect::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, TraceStartSocketName) == 0x000098, "Member 'UJackAnimNotifyState_PlayCollideEffect::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffect, TraceEndSocketName) == 0x0000A0, "Member 'UJackAnimNotifyState_PlayCollideEffect::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableMenu
// 0x0000 (0x0088 - 0x0088)
class UJackDebugMenuVariableMenu final : public UJackDebugMenuVariable
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableMenu">();
	}
	static class UJackDebugMenuVariableMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableMenu>();
	}
};
static_assert(alignof(UJackDebugMenuVariableMenu) == 0x000008, "Wrong alignment on UJackDebugMenuVariableMenu");
static_assert(sizeof(UJackDebugMenuVariableMenu) == 0x000088, "Wrong size on UJackDebugMenuVariableMenu");

// Class JackGame.JackAnimNotifyState_PlayCollideEffectTable
// 0x0058 (0x00A8 - 0x0050)
class UJackAnimNotifyState_PlayCollideEffectTable final : public UJackAnimNotifyState
{
public:
	TSubclassOf<class UJackCollideEffectTable>    CollideEffectClass;                                // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttachInfo;                               // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bOverrideAttached;                                 // 0x0059(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5A[0x6];                                       // 0x005A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideSocketName;                                // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               OverrideAttachLocationType;                        // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OverrideOffsetLocation;                            // 0x006C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OverrideOffsetRotation;                            // 0x0078(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bDestroyEffectImmediately;                         // 0x0084(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_85[0x3];                                       // 0x0085(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SoundFadeoutTime;                                  // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceEnabled;                                     // 0x008C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x008D(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E[0x2];                                       // 0x008E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceSphereRadius;                                 // 0x0090(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartSocketName;                              // 0x0098(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceEndSocketName;                                // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_PlayCollideEffectTable">();
	}
	static class UJackAnimNotifyState_PlayCollideEffectTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_PlayCollideEffectTable>();
	}
};
static_assert(alignof(UJackAnimNotifyState_PlayCollideEffectTable) == 0x000008, "Wrong alignment on UJackAnimNotifyState_PlayCollideEffectTable");
static_assert(sizeof(UJackAnimNotifyState_PlayCollideEffectTable) == 0x0000A8, "Wrong size on UJackAnimNotifyState_PlayCollideEffectTable");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, CollideEffectClass) == 0x000050, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::CollideEffectClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, bOverrideAttachInfo) == 0x000058, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::bOverrideAttachInfo' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, bOverrideAttached) == 0x000059, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::bOverrideAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, OverrideSocketName) == 0x000060, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::OverrideSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, OverrideAttachLocationType) == 0x000068, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::OverrideAttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, OverrideOffsetLocation) == 0x00006C, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::OverrideOffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, OverrideOffsetRotation) == 0x000078, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::OverrideOffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, bDestroyEffectImmediately) == 0x000084, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::bDestroyEffectImmediately' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, SoundFadeoutTime) == 0x000088, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::SoundFadeoutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, bTraceEnabled) == 0x00008C, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, TraceChannel) == 0x00008D, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, TraceSphereRadius) == 0x000090, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, TraceStartSocketName) == 0x000098, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideEffectTable, TraceEndSocketName) == 0x0000A0, "Member 'UJackAnimNotifyState_PlayCollideEffectTable::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_PlayCollideSoundTable
// 0x0058 (0x00A8 - 0x0050)
class UJackAnimNotifyState_PlayCollideSoundTable final : public UJackAnimNotifyState
{
public:
	TSubclassOf<class UJackCollideSoundTable>     CollideSoundClass;                                 // 0x0050(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAttached;                                         // 0x0058(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SocketName;                                        // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               AttachLocationType;                                // 0x0068(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                OffsetLocation;                                    // 0x006C(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               OffsetRotation;                                    // 0x0078(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         SoundFadeoutTime;                                  // 0x0084(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundVolume;                                       // 0x0088(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundPitch;                                        // 0x008C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoundEnableInGame;                                // 0x0090(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSoundEnableCutScene;                              // 0x0091(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTraceEnabled;                                     // 0x0092(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	ECollisionChannel                             TraceChannel;                                      // 0x0093(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceSphereRadius;                                 // 0x0094(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceStartSocketName;                              // 0x0098(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TraceEndSocketName;                                // 0x00A0(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_PlayCollideSoundTable">();
	}
	static class UJackAnimNotifyState_PlayCollideSoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_PlayCollideSoundTable>();
	}
};
static_assert(alignof(UJackAnimNotifyState_PlayCollideSoundTable) == 0x000008, "Wrong alignment on UJackAnimNotifyState_PlayCollideSoundTable");
static_assert(sizeof(UJackAnimNotifyState_PlayCollideSoundTable) == 0x0000A8, "Wrong size on UJackAnimNotifyState_PlayCollideSoundTable");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, CollideSoundClass) == 0x000050, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::CollideSoundClass' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, bAttached) == 0x000058, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::bAttached' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, SocketName) == 0x000060, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::SocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, AttachLocationType) == 0x000068, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::AttachLocationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, OffsetLocation) == 0x00006C, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::OffsetLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, OffsetRotation) == 0x000078, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::OffsetRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, SoundFadeoutTime) == 0x000084, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::SoundFadeoutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, SoundVolume) == 0x000088, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, SoundPitch) == 0x00008C, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::SoundPitch' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, bSoundEnableInGame) == 0x000090, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::bSoundEnableInGame' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, bSoundEnableCutScene) == 0x000091, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::bSoundEnableCutScene' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, bTraceEnabled) == 0x000092, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::bTraceEnabled' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, TraceChannel) == 0x000093, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::TraceChannel' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, TraceSphereRadius) == 0x000094, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, TraceStartSocketName) == 0x000098, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::TraceStartSocketName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_PlayCollideSoundTable, TraceEndSocketName) == 0x0000A0, "Member 'UJackAnimNotifyState_PlayCollideSoundTable::TraceEndSocketName' has a wrong offset!");

// Class JackGame.JackSoundEffectContext
// 0x0000 (0x0068 - 0x0068)
class UJackSoundEffectContext final : public UJackSoundContext
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoundEffectContext">();
	}
	static class UJackSoundEffectContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoundEffectContext>();
	}
};
static_assert(alignof(UJackSoundEffectContext) == 0x000008, "Wrong alignment on UJackSoundEffectContext");
static_assert(sizeof(UJackSoundEffectContext) == 0x000068, "Wrong size on UJackSoundEffectContext");

// Class JackGame.JackCharacterDebugComponent
// 0x0000 (0x01A0 - 0x01A0)
class UJackCharacterDebugComponent final : public UJackCharacterComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterDebugComponent">();
	}
	static class UJackCharacterDebugComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterDebugComponent>();
	}
};
static_assert(alignof(UJackCharacterDebugComponent) == 0x000008, "Wrong alignment on UJackCharacterDebugComponent");
static_assert(sizeof(UJackCharacterDebugComponent) == 0x0001A0, "Wrong size on UJackCharacterDebugComponent");

// Class JackGame.JackAnimNotifyState_RotateTo
// 0x0018 (0x0068 - 0x0050)
class UJackAnimNotifyState_RotateTo final : public UJackAnimNotifyState
{
public:
	EJackRotationProcessType                      RotationProcessType;                               // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationParameter1;                                // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RotationParameter2;                                // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EEasingFunc                                   RotationParameterEasing;                           // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RotationDurationTime;                              // 0x0060(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackRotationLayer                            RotationLayer;                                     // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_RotateTo">();
	}
	static class UJackAnimNotifyState_RotateTo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_RotateTo>();
	}
};
static_assert(alignof(UJackAnimNotifyState_RotateTo) == 0x000008, "Wrong alignment on UJackAnimNotifyState_RotateTo");
static_assert(sizeof(UJackAnimNotifyState_RotateTo) == 0x000068, "Wrong size on UJackAnimNotifyState_RotateTo");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationProcessType) == 0x000050, "Member 'UJackAnimNotifyState_RotateTo::RotationProcessType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationParameter1) == 0x000054, "Member 'UJackAnimNotifyState_RotateTo::RotationParameter1' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationParameter2) == 0x000058, "Member 'UJackAnimNotifyState_RotateTo::RotationParameter2' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationParameterEasing) == 0x00005C, "Member 'UJackAnimNotifyState_RotateTo::RotationParameterEasing' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationDurationTime) == 0x000060, "Member 'UJackAnimNotifyState_RotateTo::RotationDurationTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_RotateTo, RotationLayer) == 0x000064, "Member 'UJackAnimNotifyState_RotateTo::RotationLayer' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_Slomo
// 0x0008 (0x0058 - 0x0050)
class UJackAnimNotifyState_Slomo final : public UJackAnimNotifyState
{
public:
	bool                                          bApplyToOwner;                                     // 0x0050(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackWorldTimeDilation                        WorldTimeDilationType;                             // 0x0051(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackCharacterScope                           SlomoScope;                                        // 0x0052(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DesiredTimeDilation;                               // 0x0054(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_Slomo">();
	}
	static class UJackAnimNotifyState_Slomo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_Slomo>();
	}
};
static_assert(alignof(UJackAnimNotifyState_Slomo) == 0x000008, "Wrong alignment on UJackAnimNotifyState_Slomo");
static_assert(sizeof(UJackAnimNotifyState_Slomo) == 0x000058, "Wrong size on UJackAnimNotifyState_Slomo");
static_assert(offsetof(UJackAnimNotifyState_Slomo, bApplyToOwner) == 0x000050, "Member 'UJackAnimNotifyState_Slomo::bApplyToOwner' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_Slomo, WorldTimeDilationType) == 0x000051, "Member 'UJackAnimNotifyState_Slomo::WorldTimeDilationType' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_Slomo, SlomoScope) == 0x000052, "Member 'UJackAnimNotifyState_Slomo::SlomoScope' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_Slomo, DesiredTimeDilation) == 0x000054, "Member 'UJackAnimNotifyState_Slomo::DesiredTimeDilation' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve
// 0x0030 (0x0080 - 0x0050)
class UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve final : public UJackAnimNotifyState
{
public:
	TArray<class UMaterialInterface*>             ApplyMaterials;                                    // 0x0050(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class FName                                   ParameterName;                                     // 0x0060(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveBase*                             StartCurve;                                        // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveBase*                             LoopCurve;                                         // 0x0070(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FadeOutTime;                                       // 0x0078(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ValueScale;                                        // 0x007C(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve">();
	}
	static class UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve>();
	}
};
static_assert(alignof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve) == 0x000008, "Wrong alignment on UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve");
static_assert(sizeof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve) == 0x000080, "Wrong size on UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, ApplyMaterials) == 0x000050, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::ApplyMaterials' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, ParameterName) == 0x000060, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::ParameterName' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, StartCurve) == 0x000068, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::StartCurve' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, LoopCurve) == 0x000070, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::LoopCurve' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, FadeOutTime) == 0x000078, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::FadeOutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve, ValueScale) == 0x00007C, "Member 'UJackAnimNotifyState_StartActorMaterialUpdaterLoopedCurve::ValueScale' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_TiltAlongGround
// 0x0028 (0x0078 - 0x0050)
class UJackAnimNotifyState_TiltAlongGround final : public UJackAnimNotifyState
{
public:
	float                                         BlendInTime;                                       // 0x0050(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendInEasingFunc;                                 // 0x0054(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTime;                                      // 0x0058(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendOutEasingFunc;                                // 0x005C(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5D[0x3];                                       // 0x005D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           SocketNames;                                       // 0x0060(0x0010)(Edit, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         TiltAngleMax;                                      // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceSphereOffsetHeight;                           // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_TiltAlongGround">();
	}
	static class UJackAnimNotifyState_TiltAlongGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_TiltAlongGround>();
	}
};
static_assert(alignof(UJackAnimNotifyState_TiltAlongGround) == 0x000008, "Wrong alignment on UJackAnimNotifyState_TiltAlongGround");
static_assert(sizeof(UJackAnimNotifyState_TiltAlongGround) == 0x000078, "Wrong size on UJackAnimNotifyState_TiltAlongGround");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, BlendInTime) == 0x000050, "Member 'UJackAnimNotifyState_TiltAlongGround::BlendInTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, BlendInEasingFunc) == 0x000054, "Member 'UJackAnimNotifyState_TiltAlongGround::BlendInEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, BlendOutTime) == 0x000058, "Member 'UJackAnimNotifyState_TiltAlongGround::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, BlendOutEasingFunc) == 0x00005C, "Member 'UJackAnimNotifyState_TiltAlongGround::BlendOutEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, SocketNames) == 0x000060, "Member 'UJackAnimNotifyState_TiltAlongGround::SocketNames' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, TiltAngleMax) == 0x000070, "Member 'UJackAnimNotifyState_TiltAlongGround::TiltAngleMax' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TiltAlongGround, TraceSphereOffsetHeight) == 0x000074, "Member 'UJackAnimNotifyState_TiltAlongGround::TraceSphereOffsetHeight' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_TimedCameraLensEffect
// 0x0008 (0x0048 - 0x0040)
class UJackAnimNotifyState_TimedCameraLensEffect final : public UAnimNotifyState
{
public:
	TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass;                            // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_TimedCameraLensEffect">();
	}
	static class UJackAnimNotifyState_TimedCameraLensEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_TimedCameraLensEffect>();
	}
};
static_assert(alignof(UJackAnimNotifyState_TimedCameraLensEffect) == 0x000008, "Wrong alignment on UJackAnimNotifyState_TimedCameraLensEffect");
static_assert(sizeof(UJackAnimNotifyState_TimedCameraLensEffect) == 0x000048, "Wrong size on UJackAnimNotifyState_TimedCameraLensEffect");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraLensEffect, LensEffectEmitterClass) == 0x000040, "Member 'UJackAnimNotifyState_TimedCameraLensEffect::LensEffectEmitterClass' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_TimedCameraParticleEffect
// 0x0038 (0x0078 - 0x0040)
class UJackAnimNotifyState_TimedCameraParticleEffect final : public UAnimNotifyState
{
public:
	class UParticleSystem*                        PSTemplate;                                        // 0x0040(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocationOffset;                                    // 0x0048(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               RotationOffset;                                    // 0x0054(0x000C)(Edit, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bDestroyAtEnd;                                     // 0x0060(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepWorldLocation;                                // 0x0061(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteLocation;                                 // 0x0062(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteRotation;                                 // 0x0063(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x0064(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             Sound;                                             // 0x0068(0x0008)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundVolume;                                       // 0x0070(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SoundFadeoutTime;                                  // 0x0074(0x0004)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_TimedCameraParticleEffect">();
	}
	static class UJackAnimNotifyState_TimedCameraParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_TimedCameraParticleEffect>();
	}
};
static_assert(alignof(UJackAnimNotifyState_TimedCameraParticleEffect) == 0x000008, "Wrong alignment on UJackAnimNotifyState_TimedCameraParticleEffect");
static_assert(sizeof(UJackAnimNotifyState_TimedCameraParticleEffect) == 0x000078, "Wrong size on UJackAnimNotifyState_TimedCameraParticleEffect");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, PSTemplate) == 0x000040, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::PSTemplate' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, LocationOffset) == 0x000048, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::LocationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, RotationOffset) == 0x000054, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::RotationOffset' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, bDestroyAtEnd) == 0x000060, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::bDestroyAtEnd' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, bKeepWorldLocation) == 0x000061, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::bKeepWorldLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, bAbsoluteLocation) == 0x000062, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, bAbsoluteRotation) == 0x000063, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::bAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, bAbsoluteScale) == 0x000064, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::bAbsoluteScale' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, Sound) == 0x000068, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::Sound' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, SoundVolume) == 0x000070, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::SoundVolume' has a wrong offset!");
static_assert(offsetof(UJackAnimNotifyState_TimedCameraParticleEffect, SoundFadeoutTime) == 0x000074, "Member 'UJackAnimNotifyState_TimedCameraParticleEffect::SoundFadeoutTime' has a wrong offset!");

// Class JackGame.JackAnimNotifyState_TimedParticleEffect
// 0x0008 (0x0090 - 0x0088)
class UJackAnimNotifyState_TimedParticleEffect final : public UAnimNotifyState_TimedParticleEffect
{
public:
	bool                                          bBeAffectedByMaterialAnimation;                    // 0x0088(0x0001)(Edit, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_TimedParticleEffect">();
	}
	static class UJackAnimNotifyState_TimedParticleEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_TimedParticleEffect>();
	}
};
static_assert(alignof(UJackAnimNotifyState_TimedParticleEffect) == 0x000008, "Wrong alignment on UJackAnimNotifyState_TimedParticleEffect");
static_assert(sizeof(UJackAnimNotifyState_TimedParticleEffect) == 0x000090, "Wrong size on UJackAnimNotifyState_TimedParticleEffect");
static_assert(offsetof(UJackAnimNotifyState_TimedParticleEffect, bBeAffectedByMaterialAnimation) == 0x000088, "Member 'UJackAnimNotifyState_TimedParticleEffect::bBeAffectedByMaterialAnimation' has a wrong offset!");

// Class JackGame.JackUMG3DWindowBase
// 0x0000 (0x0400 - 0x0400)
class UJackUMG3DWindowBase final : public UJackUMGWindowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMG3DWindowBase">();
	}
	static class UJackUMG3DWindowBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMG3DWindowBase>();
	}
};
static_assert(alignof(UJackUMG3DWindowBase) == 0x000008, "Wrong alignment on UJackUMG3DWindowBase");
static_assert(sizeof(UJackUMG3DWindowBase) == 0x000400, "Wrong size on UJackUMG3DWindowBase");

// Class JackGame.JackAnimNotifyState_VehicleSplash
// 0x0000 (0x0050 - 0x0050)
class UJackAnimNotifyState_VehicleSplash final : public UJackAnimNotifyState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAnimNotifyState_VehicleSplash">();
	}
	static class UJackAnimNotifyState_VehicleSplash* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAnimNotifyState_VehicleSplash>();
	}
};
static_assert(alignof(UJackAnimNotifyState_VehicleSplash) == 0x000008, "Wrong alignment on UJackAnimNotifyState_VehicleSplash");
static_assert(sizeof(UJackAnimNotifyState_VehicleSplash) == 0x000050, "Wrong size on UJackAnimNotifyState_VehicleSplash");

// Class JackGame.JackArmIKComponent
// 0x0080 (0x0220 - 0x01A0)
class UJackArmIKComponent final : public UJackCharacterComponent
{
public:
	struct FTransform                             LeftArmFabrikEffectorTransform;                    // 0x01A0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         LeftArmFabrikAlpha;                                // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D4[0xC];                                      // 0x01D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RightArmFabrikEffectorTransform;                   // 0x01E0(0x0030)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         RightArmFabrikAlpha;                               // 0x0210(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0xC];                                      // 0x0214(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackArmIKComponent">();
	}
	static class UJackArmIKComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackArmIKComponent>();
	}
};
static_assert(alignof(UJackArmIKComponent) == 0x000010, "Wrong alignment on UJackArmIKComponent");
static_assert(sizeof(UJackArmIKComponent) == 0x000220, "Wrong size on UJackArmIKComponent");
static_assert(offsetof(UJackArmIKComponent, LeftArmFabrikEffectorTransform) == 0x0001A0, "Member 'UJackArmIKComponent::LeftArmFabrikEffectorTransform' has a wrong offset!");
static_assert(offsetof(UJackArmIKComponent, LeftArmFabrikAlpha) == 0x0001D0, "Member 'UJackArmIKComponent::LeftArmFabrikAlpha' has a wrong offset!");
static_assert(offsetof(UJackArmIKComponent, RightArmFabrikEffectorTransform) == 0x0001E0, "Member 'UJackArmIKComponent::RightArmFabrikEffectorTransform' has a wrong offset!");
static_assert(offsetof(UJackArmIKComponent, RightArmFabrikAlpha) == 0x000210, "Member 'UJackArmIKComponent::RightArmFabrikAlpha' has a wrong offset!");

// Class JackGame.JackLookAtActorCameraData
// 0x0028 (0x0068 - 0x0040)
class UJackLookAtActorCameraData final : public UJackCameraData
{
public:
	float                                         FOV;                                               // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotationMin;                                   // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotationMax;                                   // 0x0054(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         bTraceCollision : 1;                               // 0x0060(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLookAtActorCameraData">();
	}
	static class UJackLookAtActorCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLookAtActorCameraData>();
	}
};
static_assert(alignof(UJackLookAtActorCameraData) == 0x000008, "Wrong alignment on UJackLookAtActorCameraData");
static_assert(sizeof(UJackLookAtActorCameraData) == 0x000068, "Wrong size on UJackLookAtActorCameraData");
static_assert(offsetof(UJackLookAtActorCameraData, FOV) == 0x000040, "Member 'UJackLookAtActorCameraData::FOV' has a wrong offset!");
static_assert(offsetof(UJackLookAtActorCameraData, Distance) == 0x000044, "Member 'UJackLookAtActorCameraData::Distance' has a wrong offset!");
static_assert(offsetof(UJackLookAtActorCameraData, ViewRotationMin) == 0x000048, "Member 'UJackLookAtActorCameraData::ViewRotationMin' has a wrong offset!");
static_assert(offsetof(UJackLookAtActorCameraData, ViewRotationMax) == 0x000054, "Member 'UJackLookAtActorCameraData::ViewRotationMax' has a wrong offset!");

// Class JackGame.JackClothBlendRateTrack
// 0x0010 (0x00C0 - 0x00B0)
class UJackClothBlendRateTrack final : public UInterpTrackFloatBase
{
public:
	TArray<struct FJackLDT_Coordinate>            ApplyCoordinates;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackClothBlendRateTrack">();
	}
	static class UJackClothBlendRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackClothBlendRateTrack>();
	}
};
static_assert(alignof(UJackClothBlendRateTrack) == 0x000008, "Wrong alignment on UJackClothBlendRateTrack");
static_assert(sizeof(UJackClothBlendRateTrack) == 0x0000C0, "Wrong size on UJackClothBlendRateTrack");
static_assert(offsetof(UJackClothBlendRateTrack, ApplyCoordinates) == 0x0000B0, "Member 'UJackClothBlendRateTrack::ApplyCoordinates' has a wrong offset!");

// Class JackGame.JackArmIKTrackTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackArmIKTrackTrack final : public UInterpTrackFloatBase
{
public:
	EJackCSArmType                                TargetArtm;                                        // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackArmIKTrackTrack">();
	}
	static class UJackArmIKTrackTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackArmIKTrackTrack>();
	}
};
static_assert(alignof(UJackArmIKTrackTrack) == 0x000008, "Wrong alignment on UJackArmIKTrackTrack");
static_assert(sizeof(UJackArmIKTrackTrack) == 0x0000B8, "Wrong size on UJackArmIKTrackTrack");
static_assert(offsetof(UJackArmIKTrackTrack, TargetArtm) == 0x0000B0, "Member 'UJackArmIKTrackTrack::TargetArtm' has a wrong offset!");

// Class JackGame.JackArmIKTrackTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackArmIKTrackTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackArmIKTrackTrackInst">();
	}
	static class UJackArmIKTrackTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackArmIKTrackTrackInst>();
	}
};
static_assert(alignof(UJackArmIKTrackTrackInst) == 0x000008, "Wrong alignment on UJackArmIKTrackTrackInst");
static_assert(sizeof(UJackArmIKTrackTrackInst) == 0x000040, "Wrong size on UJackArmIKTrackTrackInst");

// Class JackGame.JackUMGBattleGroupInfo
// 0x0040 (0x00C8 - 0x0088)
class UJackUMGBattleGroupInfo final : public UJackUMGItemData
{
public:
	int32                                         Group;                                             // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Name_0;                                            // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackGameCharacter*>             List;                                              // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   Unit;                                              // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGBattleGroupInfo">();
	}
	static class UJackUMGBattleGroupInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGBattleGroupInfo>();
	}
};
static_assert(alignof(UJackUMGBattleGroupInfo) == 0x000008, "Wrong alignment on UJackUMGBattleGroupInfo");
static_assert(sizeof(UJackUMGBattleGroupInfo) == 0x0000C8, "Wrong size on UJackUMGBattleGroupInfo");
static_assert(offsetof(UJackUMGBattleGroupInfo, Group) == 0x000088, "Member 'UJackUMGBattleGroupInfo::Group' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleGroupInfo, Name_0) == 0x000090, "Member 'UJackUMGBattleGroupInfo::Name_0' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleGroupInfo, Count) == 0x0000A8, "Member 'UJackUMGBattleGroupInfo::Count' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleGroupInfo, List) == 0x0000B0, "Member 'UJackUMGBattleGroupInfo::List' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleGroupInfo, Unit) == 0x0000C0, "Member 'UJackUMGBattleGroupInfo::Unit' has a wrong offset!");

// Class JackGame.JackCharacterOneTokiNoKesin
// 0x0200 (0x12F0 - 0x10F0)
class AJackCharacterOneTokiNoKesin : public AJackCharacter
{
public:
	class UJackLookAtComponent*                   LookAtComponent;                                   // 0x10F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackOverlappedActorComponent*          OverlappedActorComponent;                          // 0x10F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                TargetPosition;                                    // 0x1100(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrivedLength;                                     // 0x110C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NormalMoveRotateSpeed;                             // 0x1110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1114[0xBC];                                    // 0x1114(0x00BC)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ActorHeight;                                       // 0x11D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedWalk;                                     // 0x11D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeedRun;                                      // 0x11D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotLerpRate;                                       // 0x11DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLerpRate;                                      // 0x11E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWallMove;                                       // 0x11E4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11E5[0x3];                                     // 0x11E5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveAnimationRate;                                 // 0x11E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveMotionBlendRate;                               // 0x11EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackTokiNoKesinMotionState                   MotionState;                                       // 0x11F0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11F1[0x3];                                     // 0x11F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxMoveMotionBlendRate;                            // 0x11F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleSecMin;                                     // 0x11F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleSecMax;                                     // 0x11FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnVisibleSecMin;                                   // 0x1200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnVisibleSecMax;                                   // 0x1204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VisibleFadeSec;                                    // 0x1208(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnVisibleFadeSec;                                  // 0x120C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceUnVisibleFadeSec;                             // 0x1210(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1214[0x4];                                     // 0x1214(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UAnimMontage*>                   SitWaiterAnimArray;                                // 0x1218(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   StandWaiterAnimArray;                              // 0x1228(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Sit2pInteractionAnim;                              // 0x1238(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           Stand2pInteractionAnim;                            // 0x1240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           InDestroyWaitAnim;                                 // 0x1248(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtYawAngle;                                    // 0x1250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtLength;                                      // 0x1254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Wait2pInteractionAnimResetLength;                  // 0x1258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeSec;                                           // 0x125C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOffBlink;                                         // 0x1260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1261[0x8F];                                    // 0x1261(0x008F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool CanTokinoKesinSpawn();
	static int32 GetTokinoKesinSpawnLimitNum();
	static void SetTokinoKesinSpawnLimitNum(int32 Num);
	static void SyncTokinoKesinSpawnLimitManager();

	void AddOverlappedComponent(class UPrimitiveComponent* OtherComp);
	void RegistSpawnActor();
	void RemoveOverlappedComponent(class UPrimitiveComponent* OtherComp);
	void SetReuseActor();
	void SyncParameter();

	bool IsDestroyOk() const;
	bool IsMove() const;
	bool IsSit() const;
	bool IsStand() const;
	bool IsWait() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterOneTokiNoKesin">();
	}
	static class AJackCharacterOneTokiNoKesin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCharacterOneTokiNoKesin>();
	}
};
static_assert(alignof(AJackCharacterOneTokiNoKesin) == 0x000010, "Wrong alignment on AJackCharacterOneTokiNoKesin");
static_assert(sizeof(AJackCharacterOneTokiNoKesin) == 0x0012F0, "Wrong size on AJackCharacterOneTokiNoKesin");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, LookAtComponent) == 0x0010F0, "Member 'AJackCharacterOneTokiNoKesin::LookAtComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, OverlappedActorComponent) == 0x0010F8, "Member 'AJackCharacterOneTokiNoKesin::OverlappedActorComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, TargetPosition) == 0x001100, "Member 'AJackCharacterOneTokiNoKesin::TargetPosition' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, ArrivedLength) == 0x00110C, "Member 'AJackCharacterOneTokiNoKesin::ArrivedLength' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, NormalMoveRotateSpeed) == 0x001110, "Member 'AJackCharacterOneTokiNoKesin::NormalMoveRotateSpeed' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, ActorHeight) == 0x0011D0, "Member 'AJackCharacterOneTokiNoKesin::ActorHeight' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MoveSpeedWalk) == 0x0011D4, "Member 'AJackCharacterOneTokiNoKesin::MoveSpeedWalk' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MoveSpeedRun) == 0x0011D8, "Member 'AJackCharacterOneTokiNoKesin::MoveSpeedRun' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, RotLerpRate) == 0x0011DC, "Member 'AJackCharacterOneTokiNoKesin::RotLerpRate' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MoveLerpRate) == 0x0011E0, "Member 'AJackCharacterOneTokiNoKesin::MoveLerpRate' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, bIsWallMove) == 0x0011E4, "Member 'AJackCharacterOneTokiNoKesin::bIsWallMove' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MoveAnimationRate) == 0x0011E8, "Member 'AJackCharacterOneTokiNoKesin::MoveAnimationRate' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MoveMotionBlendRate) == 0x0011EC, "Member 'AJackCharacterOneTokiNoKesin::MoveMotionBlendRate' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MotionState) == 0x0011F0, "Member 'AJackCharacterOneTokiNoKesin::MotionState' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, MaxMoveMotionBlendRate) == 0x0011F4, "Member 'AJackCharacterOneTokiNoKesin::MaxMoveMotionBlendRate' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, VisibleSecMin) == 0x0011F8, "Member 'AJackCharacterOneTokiNoKesin::VisibleSecMin' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, VisibleSecMax) == 0x0011FC, "Member 'AJackCharacterOneTokiNoKesin::VisibleSecMax' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, UnVisibleSecMin) == 0x001200, "Member 'AJackCharacterOneTokiNoKesin::UnVisibleSecMin' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, UnVisibleSecMax) == 0x001204, "Member 'AJackCharacterOneTokiNoKesin::UnVisibleSecMax' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, VisibleFadeSec) == 0x001208, "Member 'AJackCharacterOneTokiNoKesin::VisibleFadeSec' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, UnVisibleFadeSec) == 0x00120C, "Member 'AJackCharacterOneTokiNoKesin::UnVisibleFadeSec' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, ForceUnVisibleFadeSec) == 0x001210, "Member 'AJackCharacterOneTokiNoKesin::ForceUnVisibleFadeSec' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, SitWaiterAnimArray) == 0x001218, "Member 'AJackCharacterOneTokiNoKesin::SitWaiterAnimArray' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, StandWaiterAnimArray) == 0x001228, "Member 'AJackCharacterOneTokiNoKesin::StandWaiterAnimArray' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, Sit2pInteractionAnim) == 0x001238, "Member 'AJackCharacterOneTokiNoKesin::Sit2pInteractionAnim' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, Stand2pInteractionAnim) == 0x001240, "Member 'AJackCharacterOneTokiNoKesin::Stand2pInteractionAnim' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, InDestroyWaitAnim) == 0x001248, "Member 'AJackCharacterOneTokiNoKesin::InDestroyWaitAnim' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, LookAtYawAngle) == 0x001250, "Member 'AJackCharacterOneTokiNoKesin::LookAtYawAngle' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, LookAtLength) == 0x001254, "Member 'AJackCharacterOneTokiNoKesin::LookAtLength' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, Wait2pInteractionAnimResetLength) == 0x001258, "Member 'AJackCharacterOneTokiNoKesin::Wait2pInteractionAnimResetLength' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, LifeSec) == 0x00125C, "Member 'AJackCharacterOneTokiNoKesin::LifeSec' has a wrong offset!");
static_assert(offsetof(AJackCharacterOneTokiNoKesin, bOffBlink) == 0x001260, "Member 'AJackCharacterOneTokiNoKesin::bOffBlink' has a wrong offset!");

// Class JackGame.JackAttachTrack
// 0x0018 (0x00C0 - 0x00A8)
class UJackAttachTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   AttachGroupName;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachBoneName;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteLocation;                                 // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteRotation;                                 // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteScale;                                    // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAttachTrack">();
	}
	static class UJackAttachTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAttachTrack>();
	}
};
static_assert(alignof(UJackAttachTrack) == 0x000008, "Wrong alignment on UJackAttachTrack");
static_assert(sizeof(UJackAttachTrack) == 0x0000C0, "Wrong size on UJackAttachTrack");
static_assert(offsetof(UJackAttachTrack, AttachGroupName) == 0x0000A8, "Member 'UJackAttachTrack::AttachGroupName' has a wrong offset!");
static_assert(offsetof(UJackAttachTrack, AttachBoneName) == 0x0000B0, "Member 'UJackAttachTrack::AttachBoneName' has a wrong offset!");
static_assert(offsetof(UJackAttachTrack, bAbsoluteLocation) == 0x0000B8, "Member 'UJackAttachTrack::bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(UJackAttachTrack, bAbsoluteRotation) == 0x0000B9, "Member 'UJackAttachTrack::bAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(UJackAttachTrack, bAbsoluteScale) == 0x0000BA, "Member 'UJackAttachTrack::bAbsoluteScale' has a wrong offset!");

// Class JackGame.JackAttachTrackInst
// 0x0008 (0x0048 - 0x0040)
class UJackAttachTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAttachTrackInst">();
	}
	static class UJackAttachTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAttachTrackInst>();
	}
};
static_assert(alignof(UJackAttachTrackInst) == 0x000008, "Wrong alignment on UJackAttachTrackInst");
static_assert(sizeof(UJackAttachTrackInst) == 0x000048, "Wrong size on UJackAttachTrackInst");

// Class JackGame.JackAttackHitEffect
// 0x0018 (0x0050 - 0x0038)
class UJackAttackHitEffect final : public UObject
{
public:
	TSubclassOf<class UJackCollideEffect>         DefaultEffect;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         CriticalEffect;                                    // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         GuardEffect;                                       // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAttackHitEffect">();
	}
	static class UJackAttackHitEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAttackHitEffect>();
	}
};
static_assert(alignof(UJackAttackHitEffect) == 0x000008, "Wrong alignment on UJackAttackHitEffect");
static_assert(sizeof(UJackAttackHitEffect) == 0x000050, "Wrong size on UJackAttackHitEffect");
static_assert(offsetof(UJackAttackHitEffect, DefaultEffect) == 0x000038, "Member 'UJackAttackHitEffect::DefaultEffect' has a wrong offset!");
static_assert(offsetof(UJackAttackHitEffect, CriticalEffect) == 0x000040, "Member 'UJackAttackHitEffect::CriticalEffect' has a wrong offset!");
static_assert(offsetof(UJackAttackHitEffect, GuardEffect) == 0x000048, "Member 'UJackAttackHitEffect::GuardEffect' has a wrong offset!");

// Class JackGame.JackLocalizationManager
// 0x0068 (0x00A0 - 0x0038)
class UJackLocalizationManager : public UObject
{
public:
	TArray<struct FJackFontDict>                  FontList;                                          // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             LetterList;                                        // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             UserDefinedTagDataTable;                           // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableUserDefinedTagValidation;                   // 0x0058(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bConvertsToFullWidthCharacter;                     // 0x0059(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUsesNarrowSpaceInWordWrapping;                    // 0x005A(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 NarrawSpaceCodeList;                               // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bAdjustsWordWrappingWidth;                         // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WordWrappingWidthAdjustmentOffset;                 // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WordWrappingWidthAdjustmentMaxCount;               // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             OverrideTranslationTextDataTable;                  // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableOverrideTranslationText;                    // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VoiceTagValidRangeMin_Jp;                          // 0x008C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VoiceTagValidRangeMax_Jp;                          // 0x0090(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VoiceTagInvalidRangeMin_En;                        // 0x0094(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         VoiceTagInvalidRangeMax_En;                        // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString ReplaceToAlternativeCharacter(const class FString& String) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLocalizationManager">();
	}
	static class UJackLocalizationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLocalizationManager>();
	}
};
static_assert(alignof(UJackLocalizationManager) == 0x000008, "Wrong alignment on UJackLocalizationManager");
static_assert(sizeof(UJackLocalizationManager) == 0x0000A0, "Wrong size on UJackLocalizationManager");
static_assert(offsetof(UJackLocalizationManager, FontList) == 0x000038, "Member 'UJackLocalizationManager::FontList' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, LetterList) == 0x000048, "Member 'UJackLocalizationManager::LetterList' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, UserDefinedTagDataTable) == 0x000050, "Member 'UJackLocalizationManager::UserDefinedTagDataTable' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, bEnableUserDefinedTagValidation) == 0x000058, "Member 'UJackLocalizationManager::bEnableUserDefinedTagValidation' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, bConvertsToFullWidthCharacter) == 0x000059, "Member 'UJackLocalizationManager::bConvertsToFullWidthCharacter' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, bUsesNarrowSpaceInWordWrapping) == 0x00005A, "Member 'UJackLocalizationManager::bUsesNarrowSpaceInWordWrapping' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, NarrawSpaceCodeList) == 0x000060, "Member 'UJackLocalizationManager::NarrawSpaceCodeList' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, bAdjustsWordWrappingWidth) == 0x000070, "Member 'UJackLocalizationManager::bAdjustsWordWrappingWidth' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, WordWrappingWidthAdjustmentOffset) == 0x000074, "Member 'UJackLocalizationManager::WordWrappingWidthAdjustmentOffset' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, WordWrappingWidthAdjustmentMaxCount) == 0x000078, "Member 'UJackLocalizationManager::WordWrappingWidthAdjustmentMaxCount' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, OverrideTranslationTextDataTable) == 0x000080, "Member 'UJackLocalizationManager::OverrideTranslationTextDataTable' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, bEnableOverrideTranslationText) == 0x000088, "Member 'UJackLocalizationManager::bEnableOverrideTranslationText' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, VoiceTagValidRangeMin_Jp) == 0x00008C, "Member 'UJackLocalizationManager::VoiceTagValidRangeMin_Jp' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, VoiceTagValidRangeMax_Jp) == 0x000090, "Member 'UJackLocalizationManager::VoiceTagValidRangeMax_Jp' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, VoiceTagInvalidRangeMin_En) == 0x000094, "Member 'UJackLocalizationManager::VoiceTagInvalidRangeMin_En' has a wrong offset!");
static_assert(offsetof(UJackLocalizationManager, VoiceTagInvalidRangeMax_En) == 0x000098, "Member 'UJackLocalizationManager::VoiceTagInvalidRangeMax_En' has a wrong offset!");

// Class JackGame.JackAttitudeControlComponent
// 0x00B0 (0x0250 - 0x01A0)
class UJackAttitudeControlComponent final : public UJackCharacterComponent
{
public:
	bool                                          bControlPitch;                                     // 0x01A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bControlRoll;                                      // 0x01A1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1A2[0x2];                                      // 0x01A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ControlRotationMin;                                // 0x01A4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               ControlRotationMax;                                // 0x01B0(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bIgnoreFalling;                                    // 0x01BC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bControlHoisting;                                  // 0x01BD(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bFixTurnMode;                                      // 0x01BE(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDeferredUpdateOverlaps;                           // 0x01BF(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckFourCorners;                                 // 0x01C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckFourCornersUseObjType;                       // 0x01C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckFourCornersSkipJackCharacter;                // 0x01C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCheckFourCornersFixBug;                           // 0x01C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GroundCheckUpOffset;                               // 0x01C4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SweepGroundDistance;                               // 0x01C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceForPitchControl;                           // 0x01CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DistanceForRollControl;                            // 0x01D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               RotationSpeed;                                     // 0x01D4(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         HoistingSpeed;                                     // 0x01E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HoistingHeight;                                    // 0x01E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalPitch;                                   // 0x01E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalRoll;                                    // 0x01EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         HistoricalTargetRotatorLerpNum;                    // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDraw;                                        // 0x01F4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1F5[0x5B];                                     // 0x01F5(0x005B)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAttitudeToZero(bool bOn, bool bImmidiate);
	void SetControlled(bool bPitch, bool bRoll);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAttitudeControlComponent">();
	}
	static class UJackAttitudeControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAttitudeControlComponent>();
	}
};
static_assert(alignof(UJackAttitudeControlComponent) == 0x000008, "Wrong alignment on UJackAttitudeControlComponent");
static_assert(sizeof(UJackAttitudeControlComponent) == 0x000250, "Wrong size on UJackAttitudeControlComponent");
static_assert(offsetof(UJackAttitudeControlComponent, bControlPitch) == 0x0001A0, "Member 'UJackAttitudeControlComponent::bControlPitch' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bControlRoll) == 0x0001A1, "Member 'UJackAttitudeControlComponent::bControlRoll' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, ControlRotationMin) == 0x0001A4, "Member 'UJackAttitudeControlComponent::ControlRotationMin' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, ControlRotationMax) == 0x0001B0, "Member 'UJackAttitudeControlComponent::ControlRotationMax' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bIgnoreFalling) == 0x0001BC, "Member 'UJackAttitudeControlComponent::bIgnoreFalling' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bControlHoisting) == 0x0001BD, "Member 'UJackAttitudeControlComponent::bControlHoisting' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bFixTurnMode) == 0x0001BE, "Member 'UJackAttitudeControlComponent::bFixTurnMode' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bDeferredUpdateOverlaps) == 0x0001BF, "Member 'UJackAttitudeControlComponent::bDeferredUpdateOverlaps' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bCheckFourCorners) == 0x0001C0, "Member 'UJackAttitudeControlComponent::bCheckFourCorners' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bCheckFourCornersUseObjType) == 0x0001C1, "Member 'UJackAttitudeControlComponent::bCheckFourCornersUseObjType' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bCheckFourCornersSkipJackCharacter) == 0x0001C2, "Member 'UJackAttitudeControlComponent::bCheckFourCornersSkipJackCharacter' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bCheckFourCornersFixBug) == 0x0001C3, "Member 'UJackAttitudeControlComponent::bCheckFourCornersFixBug' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, GroundCheckUpOffset) == 0x0001C4, "Member 'UJackAttitudeControlComponent::GroundCheckUpOffset' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, SweepGroundDistance) == 0x0001C8, "Member 'UJackAttitudeControlComponent::SweepGroundDistance' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, DistanceForPitchControl) == 0x0001CC, "Member 'UJackAttitudeControlComponent::DistanceForPitchControl' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, DistanceForRollControl) == 0x0001D0, "Member 'UJackAttitudeControlComponent::DistanceForRollControl' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, RotationSpeed) == 0x0001D4, "Member 'UJackAttitudeControlComponent::RotationSpeed' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, HoistingSpeed) == 0x0001E0, "Member 'UJackAttitudeControlComponent::HoistingSpeed' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, HoistingHeight) == 0x0001E4, "Member 'UJackAttitudeControlComponent::HoistingHeight' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, AdditionalPitch) == 0x0001E8, "Member 'UJackAttitudeControlComponent::AdditionalPitch' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, AdditionalRoll) == 0x0001EC, "Member 'UJackAttitudeControlComponent::AdditionalRoll' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, HistoricalTargetRotatorLerpNum) == 0x0001F0, "Member 'UJackAttitudeControlComponent::HistoricalTargetRotatorLerpNum' has a wrong offset!");
static_assert(offsetof(UJackAttitudeControlComponent, bDebugDraw) == 0x0001F4, "Member 'UJackAttitudeControlComponent::bDebugDraw' has a wrong offset!");

// Class JackGame.JackUMGAccessorCoordinate
// 0x0088 (0x00C8 - 0x0040)
class UJackUMGAccessorCoordinate : public UJackUMGAccessorBase
{
public:
	class FName                                   SavedCoordinateNameId;                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedCoordinateNameId;                          // 0x0048(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MitameNasiTextId;                                  // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MitameChangeableTextId;                            // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MitameUnchangeableTextId;                          // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LockReasonLevelTextId;                             // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LockReasonNoroiTextId;                             // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LockReasonVehicleTextId;                           // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                EquippedMitameIcon;                                // 0x0080(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                NoEquipmentMitameIcon;                             // 0x0098(0x0018)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           CanChangeFlags;                                    // 0x00B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x8];                                       // 0x00C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void SetModrenSoubiWindowAdjustPanels(const struct FJackUMGSoubiWindowMitameAdjust& InAdjustData, class UWidget* InTitlePanel, class UWidget* InStatusPanel, class UWidget* InSetimeiPanel);

	void ClearNewMark(EJackCharacter InCharacterType);
	void CoordinateInfoUpdateByScene(class UJackUMGDressupCoordinateInfo* InCoordinateInfo, bool bIsKeepFirstOpen);
	bool DisplayFirstMessage(EJackCharacter InCharacterType);
	class UJackUMGDressupCoordinateInfo* GetDressupCoordinateInfoFromCharacter(EJackCharacter InCharacterType);
	class UJackUMGDressupCoordinateInfo* GetDressupCoordinateInfoFromNameId(EJackCharacter InCharacterType, const class FName& InCoordinateName, bool bIsSoubiList);
	bool SetDressupCoordinateNameId(EJackCharacter InCharacterType, const class FName InDressupCoordinateName, bool bInLastIgnoreEquipment);
	void SetMitameSoubiListToWindow(class UJackUMGBrowserBase* InBrowserBase, EJackCharacter InCharacterType);

	EJackDressupCoordinateLockReason GetEquipmentDressupCoordinate(EJackCharacter InCharacterType) const;
	class UTexture2D* GetMitameIcon(bool bIsEquipped, bool bIsList) const;
	const class FName GetMitameNasiTextId() const;
	bool IsEquipmentDressupCoordinate(EJackCharacter CharacterType, class FName* OutTextId) const;
	bool IsLastIgnoreEquipment() const;
	bool IsNewMark(EJackCharacter InCharacterType) const;
	bool IsOpendMitameSoubiAll(EJackCharacter InCharacterType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorCoordinate">();
	}
	static class UJackUMGAccessorCoordinate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorCoordinate>();
	}
};
static_assert(alignof(UJackUMGAccessorCoordinate) == 0x000008, "Wrong alignment on UJackUMGAccessorCoordinate");
static_assert(sizeof(UJackUMGAccessorCoordinate) == 0x0000C8, "Wrong size on UJackUMGAccessorCoordinate");
static_assert(offsetof(UJackUMGAccessorCoordinate, SavedCoordinateNameId) == 0x000040, "Member 'UJackUMGAccessorCoordinate::SavedCoordinateNameId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, SelectedCoordinateNameId) == 0x000048, "Member 'UJackUMGAccessorCoordinate::SelectedCoordinateNameId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, MitameNasiTextId) == 0x000050, "Member 'UJackUMGAccessorCoordinate::MitameNasiTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, MitameChangeableTextId) == 0x000058, "Member 'UJackUMGAccessorCoordinate::MitameChangeableTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, MitameUnchangeableTextId) == 0x000060, "Member 'UJackUMGAccessorCoordinate::MitameUnchangeableTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, LockReasonLevelTextId) == 0x000068, "Member 'UJackUMGAccessorCoordinate::LockReasonLevelTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, LockReasonNoroiTextId) == 0x000070, "Member 'UJackUMGAccessorCoordinate::LockReasonNoroiTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, LockReasonVehicleTextId) == 0x000078, "Member 'UJackUMGAccessorCoordinate::LockReasonVehicleTextId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, EquippedMitameIcon) == 0x000080, "Member 'UJackUMGAccessorCoordinate::EquippedMitameIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, NoEquipmentMitameIcon) == 0x000098, "Member 'UJackUMGAccessorCoordinate::NoEquipmentMitameIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCoordinate, CanChangeFlags) == 0x0000B0, "Member 'UJackUMGAccessorCoordinate::CanChangeFlags' has a wrong offset!");

// Class JackGame.JackAutoEyeComplianceTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackAutoEyeComplianceTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAutoEyeComplianceTrack">();
	}
	static class UJackAutoEyeComplianceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAutoEyeComplianceTrack>();
	}
};
static_assert(alignof(UJackAutoEyeComplianceTrack) == 0x000008, "Wrong alignment on UJackAutoEyeComplianceTrack");
static_assert(sizeof(UJackAutoEyeComplianceTrack) == 0x0000A8, "Wrong size on UJackAutoEyeComplianceTrack");

// Class JackGame.JackAutoEyeComplianceTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackAutoEyeComplianceTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAutoEyeComplianceTrackInst">();
	}
	static class UJackAutoEyeComplianceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAutoEyeComplianceTrackInst>();
	}
};
static_assert(alignof(UJackAutoEyeComplianceTrackInst) == 0x000008, "Wrong alignment on UJackAutoEyeComplianceTrackInst");
static_assert(sizeof(UJackAutoEyeComplianceTrackInst) == 0x000040, "Wrong size on UJackAutoEyeComplianceTrackInst");

// Class JackGame.JackUMGItemSyousai
// 0x00E0 (0x0118 - 0x0038)
class UJackUMGItemSyousai : public UObject
{
public:
	bool                                          bIsError;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_Bag                                 BagType;                                           // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x2];                                       // 0x003A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IndexInBag;                                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PictorialBookNo;                                   // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ListItemName;                                      // 0x0068(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CountStack;                                        // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SmallIcon;                                         // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                BookIconTexture;                                   // 0x0090(0x0018)(BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGItemOsyareType                        UIOsyareType;                                      // 0x00A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_Classification                      ClassType;                                         // 0x00A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ClassText;                                         // 0x00B0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EJackUMGItemClassification                    UIClassType;                                       // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rarity;                                            // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00D0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         BuyPrice;                                          // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SellPrice;                                         // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackExchange                                 ExchangeType;                                      // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSoldOut;                                        // 0x00F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNeed;                                           // 0x00F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAvailable;                                      // 0x00F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F4[0x4];                                       // 0x00F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   UsingActionID;                                     // 0x00F8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UsingEvent;                                        // 0x0100(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanConsume;                                       // 0x0108(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_SellType                            SellType;                                          // 0x0109(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanBuy;                                           // 0x010A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_DiscardType                         DiscardType;                                       // 0x010B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaveAtSort;                                      // 0x010C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreEquipmentBag;                                // 0x010D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsActive;                                         // 0x010E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x010F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          EquippedRegion;                                    // 0x0110(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentMultiple                        EquipmentMultiple;                                 // 0x0111(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          EquipmentRegion;                                   // 0x0112(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          MultipleEquipmentRegion;                           // 0x0113(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          ReleaseRegion;                                     // 0x0114(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_EquipmentSE                         EquipmentSE;                                       // 0x0115(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_116[0x2];                                      // 0x0116(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 CountItemInBag(EJackUMGCountBagItemType InCountBagType);
	void GetItemIdFromPictorialBookNo(class FName* OutItemId);
	void SetBagType(EJackItem_Bag InBagType);

	bool IsBothHandsEquipment() const;
	bool IsError() const;
	bool IsSuccessful() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemSyousai">();
	}
	static class UJackUMGItemSyousai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemSyousai>();
	}
};
static_assert(alignof(UJackUMGItemSyousai) == 0x000008, "Wrong alignment on UJackUMGItemSyousai");
static_assert(sizeof(UJackUMGItemSyousai) == 0x000118, "Wrong size on UJackUMGItemSyousai");
static_assert(offsetof(UJackUMGItemSyousai, bIsError) == 0x000038, "Member 'UJackUMGItemSyousai::bIsError' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, BagType) == 0x000039, "Member 'UJackUMGItemSyousai::BagType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, IndexInBag) == 0x00003C, "Member 'UJackUMGItemSyousai::IndexInBag' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, PictorialBookNo) == 0x000040, "Member 'UJackUMGItemSyousai::PictorialBookNo' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ItemID) == 0x000048, "Member 'UJackUMGItemSyousai::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ItemName) == 0x000050, "Member 'UJackUMGItemSyousai::ItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ListItemName) == 0x000068, "Member 'UJackUMGItemSyousai::ListItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, CountStack) == 0x000080, "Member 'UJackUMGItemSyousai::CountStack' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, SmallIcon) == 0x000088, "Member 'UJackUMGItemSyousai::SmallIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, BookIconTexture) == 0x000090, "Member 'UJackUMGItemSyousai::BookIconTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, UIOsyareType) == 0x0000A8, "Member 'UJackUMGItemSyousai::UIOsyareType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ClassType) == 0x0000A9, "Member 'UJackUMGItemSyousai::ClassType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ClassText) == 0x0000B0, "Member 'UJackUMGItemSyousai::ClassText' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, UIClassType) == 0x0000C8, "Member 'UJackUMGItemSyousai::UIClassType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, Rarity) == 0x0000CC, "Member 'UJackUMGItemSyousai::Rarity' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, Description) == 0x0000D0, "Member 'UJackUMGItemSyousai::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, BuyPrice) == 0x0000E8, "Member 'UJackUMGItemSyousai::BuyPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, SellPrice) == 0x0000EC, "Member 'UJackUMGItemSyousai::SellPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ExchangeType) == 0x0000F0, "Member 'UJackUMGItemSyousai::ExchangeType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bIsSoldOut) == 0x0000F1, "Member 'UJackUMGItemSyousai::bIsSoldOut' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bIsNeed) == 0x0000F2, "Member 'UJackUMGItemSyousai::bIsNeed' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bIsAvailable) == 0x0000F3, "Member 'UJackUMGItemSyousai::bIsAvailable' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, UsingActionID) == 0x0000F8, "Member 'UJackUMGItemSyousai::UsingActionID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, UsingEvent) == 0x000100, "Member 'UJackUMGItemSyousai::UsingEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bCanConsume) == 0x000108, "Member 'UJackUMGItemSyousai::bCanConsume' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, SellType) == 0x000109, "Member 'UJackUMGItemSyousai::SellType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bCanBuy) == 0x00010A, "Member 'UJackUMGItemSyousai::bCanBuy' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, DiscardType) == 0x00010B, "Member 'UJackUMGItemSyousai::DiscardType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bLeaveAtSort) == 0x00010C, "Member 'UJackUMGItemSyousai::bLeaveAtSort' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bStoreEquipmentBag) == 0x00010D, "Member 'UJackUMGItemSyousai::bStoreEquipmentBag' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bIsActive) == 0x00010E, "Member 'UJackUMGItemSyousai::bIsActive' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, bIsEquipped) == 0x00010F, "Member 'UJackUMGItemSyousai::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, EquippedRegion) == 0x000110, "Member 'UJackUMGItemSyousai::EquippedRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, EquipmentMultiple) == 0x000111, "Member 'UJackUMGItemSyousai::EquipmentMultiple' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, EquipmentRegion) == 0x000112, "Member 'UJackUMGItemSyousai::EquipmentRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, MultipleEquipmentRegion) == 0x000113, "Member 'UJackUMGItemSyousai::MultipleEquipmentRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, ReleaseRegion) == 0x000114, "Member 'UJackUMGItemSyousai::ReleaseRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGItemSyousai, EquipmentSE) == 0x000115, "Member 'UJackUMGItemSyousai::EquipmentSE' has a wrong offset!");

// Class JackGame.JackColorFadeTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackColorFadeTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackColorFadeTrackInst">();
	}
	static class UJackColorFadeTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackColorFadeTrackInst>();
	}
};
static_assert(alignof(UJackColorFadeTrackInst) == 0x000008, "Wrong alignment on UJackColorFadeTrackInst");
static_assert(sizeof(UJackColorFadeTrackInst) == 0x000040, "Wrong size on UJackColorFadeTrackInst");

// Class JackGame.JackLookAtBaseComponent
// 0x01E0 (0x0380 - 0x01A0)
class UJackLookAtBaseComponent : public UJackCharacterComponent
{
public:
	class FName                                   LookAtBaseSocket;                                  // 0x01A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LookAtForwardSocket;                               // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAxis                                         LookAtForwardAxis;                                 // 0x01B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtMobileRegionPitchUp;                         // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtMobileRegionPitchDown;                       // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtMobileRegionYawLeft;                         // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtMobileRegionYawRight;                        // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtInterpSpeed;                                 // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReturnInterpSpeed;                                 // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         InterpAngleSpeed;                                  // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   InterpCurve;                                       // 0x01D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D1[0x3];                                      // 0x01D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InitialLookAtDistance;                             // 0x01D4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SecondNodeLookAtInterpSpeed;                       // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SecondNodeReturnInterpSpeed;                       // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   SecondNodeInterpCurve;                             // 0x01E0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x19F];                                    // 0x01E1(0x019F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void LookAtCharacter(class AJackCharacter* Character, class FName Socket);
	void LookAtEnd();
	void LookAtLocation(const struct FVector& Location);
	void SetLookAtMobileRegion(float PitchUp, float PitchDown, float YawLeft, float YawRight);
	void SetLookAtSingleNode(bool bFlag, bool bRateToZeroIfNotLookAt);
	void SetLookAtSpeed(float InSpeed);

	float GetLookAtApplyRate() const;
	float GetLookAtApplySecondNodeRate() const;
	void GetLookAtClamp(EJackLookAtControlBone ControlBone, struct FJackLookAtBoneSetting* OutLookAtBoneSetting) const;
	struct FVector GetLookAtInterpLocation() const;
	struct FVector GetLookAtLocation() const;
	bool IsActive() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLookAtBaseComponent">();
	}
	static class UJackLookAtBaseComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLookAtBaseComponent>();
	}
};
static_assert(alignof(UJackLookAtBaseComponent) == 0x000008, "Wrong alignment on UJackLookAtBaseComponent");
static_assert(sizeof(UJackLookAtBaseComponent) == 0x000380, "Wrong size on UJackLookAtBaseComponent");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtBaseSocket) == 0x0001A0, "Member 'UJackLookAtBaseComponent::LookAtBaseSocket' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtForwardSocket) == 0x0001A8, "Member 'UJackLookAtBaseComponent::LookAtForwardSocket' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtForwardAxis) == 0x0001B0, "Member 'UJackLookAtBaseComponent::LookAtForwardAxis' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtMobileRegionPitchUp) == 0x0001B4, "Member 'UJackLookAtBaseComponent::LookAtMobileRegionPitchUp' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtMobileRegionPitchDown) == 0x0001B8, "Member 'UJackLookAtBaseComponent::LookAtMobileRegionPitchDown' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtMobileRegionYawLeft) == 0x0001BC, "Member 'UJackLookAtBaseComponent::LookAtMobileRegionYawLeft' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtMobileRegionYawRight) == 0x0001C0, "Member 'UJackLookAtBaseComponent::LookAtMobileRegionYawRight' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, LookAtInterpSpeed) == 0x0001C4, "Member 'UJackLookAtBaseComponent::LookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, ReturnInterpSpeed) == 0x0001C8, "Member 'UJackLookAtBaseComponent::ReturnInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, InterpAngleSpeed) == 0x0001CC, "Member 'UJackLookAtBaseComponent::InterpAngleSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, InterpCurve) == 0x0001D0, "Member 'UJackLookAtBaseComponent::InterpCurve' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, InitialLookAtDistance) == 0x0001D4, "Member 'UJackLookAtBaseComponent::InitialLookAtDistance' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, SecondNodeLookAtInterpSpeed) == 0x0001D8, "Member 'UJackLookAtBaseComponent::SecondNodeLookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, SecondNodeReturnInterpSpeed) == 0x0001DC, "Member 'UJackLookAtBaseComponent::SecondNodeReturnInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtBaseComponent, SecondNodeInterpCurve) == 0x0001E0, "Member 'UJackLookAtBaseComponent::SecondNodeInterpCurve' has a wrong offset!");

// Class JackGame.JackLookAtIKTrack
// 0x0028 (0x00D0 - 0x00A8)
class UJackLookAtIKTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   LookAtGroupName;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtBoneName;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionThreshold;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackLookAtTrackInfo>           LookAtInfos;                                       // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLookAtIKTrack">();
	}
	static class UJackLookAtIKTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLookAtIKTrack>();
	}
};
static_assert(alignof(UJackLookAtIKTrack) == 0x000008, "Wrong alignment on UJackLookAtIKTrack");
static_assert(sizeof(UJackLookAtIKTrack) == 0x0000D0, "Wrong size on UJackLookAtIKTrack");
static_assert(offsetof(UJackLookAtIKTrack, LookAtGroupName) == 0x0000A8, "Member 'UJackLookAtIKTrack::LookAtGroupName' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrack, LookAtBoneName) == 0x0000B0, "Member 'UJackLookAtIKTrack::LookAtBoneName' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrack, PositionThreshold) == 0x0000B8, "Member 'UJackLookAtIKTrack::PositionThreshold' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrack, LookAtInfos) == 0x0000C0, "Member 'UJackLookAtIKTrack::LookAtInfos' has a wrong offset!");

// Class JackGame.JackLookAtComponent
// 0x0060 (0x03E0 - 0x0380)
class UJackLookAtComponent : public UJackLookAtBaseComponent
{
public:
	uint8                                         Pad_380[0x60];                                     // 0x0380(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLookAtComponent">();
	}
	static class UJackLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLookAtComponent>();
	}
};
static_assert(alignof(UJackLookAtComponent) == 0x000008, "Wrong alignment on UJackLookAtComponent");
static_assert(sizeof(UJackLookAtComponent) == 0x0003E0, "Wrong size on UJackLookAtComponent");

// Class JackGame.JackUMGDispEquipmentState
// 0x0040 (0x0078 - 0x0038)
class UJackUMGDispEquipmentState final : public UObject
{
public:
	EJackCharacter                                CharType;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CharName;                                          // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UTexture2D*                             FaceIcon;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipment;                                      // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChanged;                                        // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGItemClassification                    ClassType;                                         // 0x0062(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_63[0x5];                                       // 0x0063(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGEquipmentParam>         Params_0;                                          // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGDispEquipmentState">();
	}
	static class UJackUMGDispEquipmentState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGDispEquipmentState>();
	}
};
static_assert(alignof(UJackUMGDispEquipmentState) == 0x000008, "Wrong alignment on UJackUMGDispEquipmentState");
static_assert(sizeof(UJackUMGDispEquipmentState) == 0x000078, "Wrong size on UJackUMGDispEquipmentState");
static_assert(offsetof(UJackUMGDispEquipmentState, CharType) == 0x000038, "Member 'UJackUMGDispEquipmentState::CharType' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, CharName) == 0x000040, "Member 'UJackUMGDispEquipmentState::CharName' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, FaceIcon) == 0x000058, "Member 'UJackUMGDispEquipmentState::FaceIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, bIsEquipment) == 0x000060, "Member 'UJackUMGDispEquipmentState::bIsEquipment' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, bIsChanged) == 0x000061, "Member 'UJackUMGDispEquipmentState::bIsChanged' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, ClassType) == 0x000062, "Member 'UJackUMGDispEquipmentState::ClassType' has a wrong offset!");
static_assert(offsetof(UJackUMGDispEquipmentState, Params_0) == 0x000068, "Member 'UJackUMGDispEquipmentState::Params_0' has a wrong offset!");

// Class JackGame.JackClothResetDistanceTrackInst
// 0x0058 (0x0090 - 0x0038)
class UJackClothResetDistanceTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackClothResetDistanceTrackInst">();
	}
	static class UJackClothResetDistanceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackClothResetDistanceTrackInst>();
	}
};
static_assert(alignof(UJackClothResetDistanceTrackInst) == 0x000008, "Wrong alignment on UJackClothResetDistanceTrackInst");
static_assert(sizeof(UJackClothResetDistanceTrackInst) == 0x000090, "Wrong size on UJackClothResetDistanceTrackInst");

// Class JackGame.JackAutoLookAtComponent
// 0x0060 (0x0440 - 0x03E0)
class UJackAutoLookAtComponent final : public UJackLookAtComponent
{
public:
	uint8                                         Pad_3E0[0x60];                                     // 0x03E0(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoLookAtEnbaledWithPurpose(EJackCharacterAutoLookAtPurpose InType, bool bEnabled);

	bool IsAutoLookAtEnbaled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAutoLookAtComponent">();
	}
	static class UJackAutoLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAutoLookAtComponent>();
	}
};
static_assert(alignof(UJackAutoLookAtComponent) == 0x000008, "Wrong alignment on UJackAutoLookAtComponent");
static_assert(sizeof(UJackAutoLookAtComponent) == 0x000440, "Wrong size on UJackAutoLookAtComponent");

// Class JackGame.JackAutoMoveAnimationRateTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackAutoMoveAnimationRateTrack final : public UInterpTrackFloatBase
{
public:
	bool                                          bIsOverrideEnbale;                                 // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAutoMoveAnimationRateTrack">();
	}
	static class UJackAutoMoveAnimationRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAutoMoveAnimationRateTrack>();
	}
};
static_assert(alignof(UJackAutoMoveAnimationRateTrack) == 0x000008, "Wrong alignment on UJackAutoMoveAnimationRateTrack");
static_assert(sizeof(UJackAutoMoveAnimationRateTrack) == 0x0000B8, "Wrong size on UJackAutoMoveAnimationRateTrack");
static_assert(offsetof(UJackAutoMoveAnimationRateTrack, bIsOverrideEnbale) == 0x0000B0, "Member 'UJackAutoMoveAnimationRateTrack::bIsOverrideEnbale' has a wrong offset!");

// Class JackGame.JackLoadReductionEnableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackLoadReductionEnableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLoadReductionEnableTrackInst">();
	}
	static class UJackLoadReductionEnableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLoadReductionEnableTrackInst>();
	}
};
static_assert(alignof(UJackLoadReductionEnableTrackInst) == 0x000008, "Wrong alignment on UJackLoadReductionEnableTrackInst");
static_assert(sizeof(UJackLoadReductionEnableTrackInst) == 0x000040, "Wrong size on UJackLoadReductionEnableTrackInst");

// Class JackGame.JackCharacterTickIntervalManager
// 0x0050 (0x03E8 - 0x0398)
class AJackCharacterTickIntervalManager : public AActor
{
public:
	TArray<struct FJackCharacterTickIntervalSetting> CharacterTickIntervalSetting;                      // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackCharacterDisplayLimitSetting> CharacterDisplayLimitSetting;                      // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B8[0x30];                                     // 0x03B8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterTickIntervalManager">();
	}
	static class AJackCharacterTickIntervalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCharacterTickIntervalManager>();
	}
};
static_assert(alignof(AJackCharacterTickIntervalManager) == 0x000008, "Wrong alignment on AJackCharacterTickIntervalManager");
static_assert(sizeof(AJackCharacterTickIntervalManager) == 0x0003E8, "Wrong size on AJackCharacterTickIntervalManager");
static_assert(offsetof(AJackCharacterTickIntervalManager, CharacterTickIntervalSetting) == 0x000398, "Member 'AJackCharacterTickIntervalManager::CharacterTickIntervalSetting' has a wrong offset!");
static_assert(offsetof(AJackCharacterTickIntervalManager, CharacterDisplayLimitSetting) == 0x0003A8, "Member 'AJackCharacterTickIntervalManager::CharacterDisplayLimitSetting' has a wrong offset!");

// Class JackGame.JackAutoMoveAnimationRateTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackAutoMoveAnimationRateTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAutoMoveAnimationRateTrackInst">();
	}
	static class UJackAutoMoveAnimationRateTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAutoMoveAnimationRateTrackInst>();
	}
};
static_assert(alignof(UJackAutoMoveAnimationRateTrackInst) == 0x000008, "Wrong alignment on UJackAutoMoveAnimationRateTrackInst");
static_assert(sizeof(UJackAutoMoveAnimationRateTrackInst) == 0x000038, "Wrong size on UJackAutoMoveAnimationRateTrackInst");

// Class JackGame.JackAvoidingBlindComponent
// 0x0010 (0x0138 - 0x0128)
class UJackAvoidingBlindComponent final : public UActorComponent
{
public:
	bool                                          bHide;                                             // 0x0128(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxFadeSeconds;                                    // 0x012C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         FadeSeconds;                                       // 0x0130(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAvoidingBlindComponent">();
	}
	static class UJackAvoidingBlindComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAvoidingBlindComponent>();
	}
};
static_assert(alignof(UJackAvoidingBlindComponent) == 0x000008, "Wrong alignment on UJackAvoidingBlindComponent");
static_assert(sizeof(UJackAvoidingBlindComponent) == 0x000138, "Wrong size on UJackAvoidingBlindComponent");
static_assert(offsetof(UJackAvoidingBlindComponent, bHide) == 0x000128, "Member 'UJackAvoidingBlindComponent::bHide' has a wrong offset!");
static_assert(offsetof(UJackAvoidingBlindComponent, MaxFadeSeconds) == 0x00012C, "Member 'UJackAvoidingBlindComponent::MaxFadeSeconds' has a wrong offset!");
static_assert(offsetof(UJackAvoidingBlindComponent, FadeSeconds) == 0x000130, "Member 'UJackAvoidingBlindComponent::FadeSeconds' has a wrong offset!");

// Class JackGame.JackPlayerCameraData
// 0x0318 (0x0358 - 0x0040)
class UJackPlayerCameraData : public UJackCameraData
{
public:
	float                                         RotationRateByPlayerMovement;                      // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationSpeedByPlayerMovement;                     // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRotationRemainingMode;                          // 0x0048(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraYawRotationEnabledByActorMovement;          // 0x0049(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraPitchRotationEnabledByActorMovement;        // 0x004A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCameraPitchRotationEnabledOnlyNoInputXY;          // 0x004B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FollowCharacter_DiableAngle;                       // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFollowCharacter_DisablePitch;                     // 0x0050(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CenteredMaxPitch;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenteredMinPitch;                                  // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenteringMaxPitch;                                 // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenteringMinPitch;                                 // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenteringRotMoveRate;                              // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCenteringRotFixMode;                              // 0x0068(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CenteringRotMoveRateFixMode;                       // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CenteringRotMoveRateFixMaxSpeed;                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteredMaxPitch;                              // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteredMinPitch;                              // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteringMaxPitch;                             // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteringMinPitch;                             // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteringRotMoveRate;                          // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomCenteringRotFixMode;                          // 0x0088(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomCenteringRotMoveRateFixMode;                   // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCenteringRotMoveRateFixMaxSpeed;               // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceCollision;                                   // 0x0094(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraCollisionRadius;                             // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraVisibleCollisionRadius;                      // 0x009C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CameraCollisionChannel;                            // 0x00A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlindAvoidanceTraceCollisionUpDown;               // 0x00A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlindAvoidanceTraceCollisionLeftRight;            // 0x00A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x1];                                       // 0x00A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlindAvoidance_CheckGroundRayZOffset;              // 0x00A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlindAvoidance_CheckCeilingRayZOffset;             // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlindAvoidance_CheckWallRayYawAngle;               // 0x00AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlindAvoidance_RotationAngle;                      // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlindAvoidance_RotationSpeed;                      // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceAvoidancePitchRotationCheckLength;            // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmLengthHitCheckLast;                            // 0x00BC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bArmLengthCreatePrevCameraLength;                  // 0x00BD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DistanceMin;                                       // 0x00C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceMax;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraLocationLerpSpeed;                           // 0x00C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistanceMinInterpSpeed;                      // 0x00CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistanceMaxInterpSpeed;                      // 0x00D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraDistanceHitCollideInterpSpeed;               // 0x00D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLength_LengthenSpeedInPitchOver;                // 0x00D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArmLength_ShortenSpeedInPitchOver;                 // 0x00DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OffCharaMoveRotationCameraLookAtDistance;          // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContinusContactCollisionAddArmLength;              // 0x00E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CheckOffInnerArmLength;                            // 0x00E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotationMin;                                   // 0x00EC(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotationMax;                                   // 0x00F8(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPawnPitchRollForceZero;                           // 0x0104(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_105[0x3];                                      // 0x0105(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                TargetOffsetInBlinding;                            // 0x0108(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetOffsetInIdling;                              // 0x0114(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZLerpSpringDamper;                                // 0x0120(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZNoLerp;                                          // 0x0121(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_122[0x2];                                      // 0x0122(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InterpTargetLocation_SpeedXY;                      // 0x0124(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_Speed;                        // 0x0128(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_MinLimitZ;                    // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_MaxLimitZ;                    // 0x0130(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookAtInterpDistanceMax;                           // 0x0134(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerControllCameraRotationDirectSetInZoomMode;  // 0x0138(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_139[0x3];                                      // 0x0139(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AddPitchInputSpeedVerySlow;                        // 0x013C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedVerySlow2;                       // 0x0140(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedSlow;                            // 0x0144(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedSlow2;                           // 0x0148(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeed;                                // 0x014C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeed2;                               // 0x0150(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedLittleFast;                      // 0x0154(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedLittleFast2;                     // 0x0158(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedFast;                            // 0x015C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputSpeedFast2;                           // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateVerySlow;                 // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateVerySlow2;                // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateSlow;                     // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateSlow2;                    // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRate;                         // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRate2;                        // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateLittleFast;               // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateLittleFast2;              // 0x0180(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateFast;                     // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPitchInputMaxSpeedRateFast2;                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedVerySlow;                          // 0x018C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedVerySlow2;                         // 0x0190(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedSlow;                              // 0x0194(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedSlow2;                             // 0x0198(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeed;                                  // 0x019C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeed2;                                 // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedLittleFast;                        // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedLittleFast2;                       // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedFast;                              // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputSpeedFast2;                             // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateVerySlow;                   // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateVerySlow2;                  // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateSlow;                       // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateSlow2;                      // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRate;                           // 0x01C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRate2;                          // 0x01C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateLittleFast;                 // 0x01CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateLittleFast2;                // 0x01D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateFast;                       // 0x01D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddYawInputMaxSpeedRateFast2;                      // 0x01D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementVerySlow;       // 0x01DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementVerySlow2;      // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementSlow;           // 0x01E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementSlow2;          // 0x01E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovement;               // 0x01EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovement2;              // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementLittleFast;     // 0x01F4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementLittleFast2;    // 0x01F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementFast;           // 0x01FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UptoChangeSpeedRateByPlayerMovementFast2;          // 0x0200(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementVerySlow;     // 0x0204(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementVerySlow2;    // 0x0208(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementSlow;         // 0x020C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementSlow2;        // 0x0210(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovement;             // 0x0214(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovement2;            // 0x0218(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementLittleFast;   // 0x021C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementLittleFast2;  // 0x0220(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementFast;         // 0x0224(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DowntoChangeSpeedRateByPlayerMovementFast2;        // 0x0228(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementVerySlow;   // 0x022C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementVerySlow2;  // 0x0230(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementSlow;       // 0x0234(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementSlow2;      // 0x0238(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovement;           // 0x023C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovement2;          // 0x0240(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementLittleFast; // 0x0244(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementLittleFast2; // 0x0248(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementFast;       // 0x024C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUptoChangeSpeedRateByPlayerMovementFast2;      // 0x0250(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow; // 0x0254(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow2; // 0x0258(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementSlow;     // 0x025C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementSlow2;    // 0x0260(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovement;         // 0x0264(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovement2;        // 0x0268(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast; // 0x026C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast2; // 0x0270(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementFast;     // 0x0274(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDowntoChangeSpeedRateByPlayerMovementFast2;    // 0x0278(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDoorOutDoorArmLengthLerpSec;                     // 0x027C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraResetPitch;                                  // 0x0280(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCameraResetPitch;                              // 0x0284(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedVerySlow;                      // 0x0288(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedVerySlow2;                     // 0x028C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedSlow;                          // 0x0290(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedSlow2;                         // 0x0294(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeed;                              // 0x0298(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeed2;                             // 0x029C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedLittleFast;                    // 0x02A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedLittleFast2;                   // 0x02A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedFast;                          // 0x02A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeMoveYZSpeedFast2;                         // 0x02AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PhotoModeMaxLimitMove;                             // 0x02B0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PhotoModeMinLimitMove;                             // 0x02BC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhotoModeOffsetCollideInterpSpeed;                 // 0x02C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomModeEnable;                                   // 0x02CC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2CD[0x3];                                      // 0x02CD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomStartStopWaitSec;                              // 0x02D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomSpeed;                                         // 0x02D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDistanceMin;                                   // 0x02D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDistanceMax;                                   // 0x02DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomTargetOffsetInBlinding;                        // 0x02E0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomTargetOffsetInIdling;                          // 0x02EC(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedXYInZoom;                // 0x02F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedInZoom;                  // 0x02FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedXYInZoomMoveStop;        // 0x0300(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedInZoomMoveStop;          // 0x0304(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedXYInZoomMoveStopLagSec;  // 0x0308(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_InputZeroTorrance;            // 0x030C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomMinLookAtBound;                                // 0x0310(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZoomMaxLookAtBound;                                // 0x031C(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomFieldOfView;                                   // 0x0328(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomRotationRateByPlayerMovement;                  // 0x032C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomRotationSpeedByPlayerMovement;                 // 0x0330(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomLookAtCollideCenterRateSpeed;                  // 0x0334(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpTargetLocation_SpeedXY_LookAtCollide;        // 0x0338(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCameraCollisionRadius;                         // 0x033C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCameraVisibleCollisionRadius;                  // 0x0340(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomCameraViewPointInnerLength;                    // 0x0344(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ZoomCameraCollisionChannel;                        // 0x0348(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomContinusContactCollisionAddArmLength;          // 0x034C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZoomArmLengthHitCheckLast;                        // 0x0350(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_351[0x7];                                      // 0x0351(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerCameraData">();
	}
	static class UJackPlayerCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerCameraData>();
	}
};
static_assert(alignof(UJackPlayerCameraData) == 0x000008, "Wrong alignment on UJackPlayerCameraData");
static_assert(sizeof(UJackPlayerCameraData) == 0x000358, "Wrong size on UJackPlayerCameraData");
static_assert(offsetof(UJackPlayerCameraData, RotationRateByPlayerMovement) == 0x000040, "Member 'UJackPlayerCameraData::RotationRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, RotationSpeedByPlayerMovement) == 0x000044, "Member 'UJackPlayerCameraData::RotationSpeedByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bIsRotationRemainingMode) == 0x000048, "Member 'UJackPlayerCameraData::bIsRotationRemainingMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bCameraYawRotationEnabledByActorMovement) == 0x000049, "Member 'UJackPlayerCameraData::bCameraYawRotationEnabledByActorMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bCameraPitchRotationEnabledByActorMovement) == 0x00004A, "Member 'UJackPlayerCameraData::bCameraPitchRotationEnabledByActorMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bCameraPitchRotationEnabledOnlyNoInputXY) == 0x00004B, "Member 'UJackPlayerCameraData::bCameraPitchRotationEnabledOnlyNoInputXY' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, FollowCharacter_DiableAngle) == 0x00004C, "Member 'UJackPlayerCameraData::FollowCharacter_DiableAngle' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bFollowCharacter_DisablePitch) == 0x000050, "Member 'UJackPlayerCameraData::bFollowCharacter_DisablePitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteredMaxPitch) == 0x000054, "Member 'UJackPlayerCameraData::CenteredMaxPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteredMinPitch) == 0x000058, "Member 'UJackPlayerCameraData::CenteredMinPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteringMaxPitch) == 0x00005C, "Member 'UJackPlayerCameraData::CenteringMaxPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteringMinPitch) == 0x000060, "Member 'UJackPlayerCameraData::CenteringMinPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteringRotMoveRate) == 0x000064, "Member 'UJackPlayerCameraData::CenteringRotMoveRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bCenteringRotFixMode) == 0x000068, "Member 'UJackPlayerCameraData::bCenteringRotFixMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteringRotMoveRateFixMode) == 0x00006C, "Member 'UJackPlayerCameraData::CenteringRotMoveRateFixMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CenteringRotMoveRateFixMaxSpeed) == 0x000070, "Member 'UJackPlayerCameraData::CenteringRotMoveRateFixMaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteredMaxPitch) == 0x000074, "Member 'UJackPlayerCameraData::ZoomCenteredMaxPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteredMinPitch) == 0x000078, "Member 'UJackPlayerCameraData::ZoomCenteredMinPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteringMaxPitch) == 0x00007C, "Member 'UJackPlayerCameraData::ZoomCenteringMaxPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteringMinPitch) == 0x000080, "Member 'UJackPlayerCameraData::ZoomCenteringMinPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteringRotMoveRate) == 0x000084, "Member 'UJackPlayerCameraData::ZoomCenteringRotMoveRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bZoomCenteringRotFixMode) == 0x000088, "Member 'UJackPlayerCameraData::bZoomCenteringRotFixMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteringRotMoveRateFixMode) == 0x00008C, "Member 'UJackPlayerCameraData::ZoomCenteringRotMoveRateFixMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCenteringRotMoveRateFixMaxSpeed) == 0x000090, "Member 'UJackPlayerCameraData::ZoomCenteringRotMoveRateFixMaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bTraceCollision) == 0x000094, "Member 'UJackPlayerCameraData::bTraceCollision' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraCollisionRadius) == 0x000098, "Member 'UJackPlayerCameraData::CameraCollisionRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraVisibleCollisionRadius) == 0x00009C, "Member 'UJackPlayerCameraData::CameraVisibleCollisionRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraCollisionChannel) == 0x0000A0, "Member 'UJackPlayerCameraData::CameraCollisionChannel' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bBlindAvoidanceTraceCollisionUpDown) == 0x0000A1, "Member 'UJackPlayerCameraData::bBlindAvoidanceTraceCollisionUpDown' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bBlindAvoidanceTraceCollisionLeftRight) == 0x0000A2, "Member 'UJackPlayerCameraData::bBlindAvoidanceTraceCollisionLeftRight' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, BlindAvoidance_CheckGroundRayZOffset) == 0x0000A4, "Member 'UJackPlayerCameraData::BlindAvoidance_CheckGroundRayZOffset' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, BlindAvoidance_CheckCeilingRayZOffset) == 0x0000A8, "Member 'UJackPlayerCameraData::BlindAvoidance_CheckCeilingRayZOffset' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, BlindAvoidance_CheckWallRayYawAngle) == 0x0000AC, "Member 'UJackPlayerCameraData::BlindAvoidance_CheckWallRayYawAngle' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, BlindAvoidance_RotationAngle) == 0x0000B0, "Member 'UJackPlayerCameraData::BlindAvoidance_RotationAngle' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, BlindAvoidance_RotationSpeed) == 0x0000B4, "Member 'UJackPlayerCameraData::BlindAvoidance_RotationSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ForceAvoidancePitchRotationCheckLength) == 0x0000B8, "Member 'UJackPlayerCameraData::ForceAvoidancePitchRotationCheckLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bArmLengthHitCheckLast) == 0x0000BC, "Member 'UJackPlayerCameraData::bArmLengthHitCheckLast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bArmLengthCreatePrevCameraLength) == 0x0000BD, "Member 'UJackPlayerCameraData::bArmLengthCreatePrevCameraLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DistanceMin) == 0x0000C0, "Member 'UJackPlayerCameraData::DistanceMin' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DistanceMax) == 0x0000C4, "Member 'UJackPlayerCameraData::DistanceMax' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraLocationLerpSpeed) == 0x0000C8, "Member 'UJackPlayerCameraData::CameraLocationLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraDistanceMinInterpSpeed) == 0x0000CC, "Member 'UJackPlayerCameraData::CameraDistanceMinInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraDistanceMaxInterpSpeed) == 0x0000D0, "Member 'UJackPlayerCameraData::CameraDistanceMaxInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraDistanceHitCollideInterpSpeed) == 0x0000D4, "Member 'UJackPlayerCameraData::CameraDistanceHitCollideInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ArmLength_LengthenSpeedInPitchOver) == 0x0000D8, "Member 'UJackPlayerCameraData::ArmLength_LengthenSpeedInPitchOver' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ArmLength_ShortenSpeedInPitchOver) == 0x0000DC, "Member 'UJackPlayerCameraData::ArmLength_ShortenSpeedInPitchOver' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, OffCharaMoveRotationCameraLookAtDistance) == 0x0000E0, "Member 'UJackPlayerCameraData::OffCharaMoveRotationCameraLookAtDistance' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ContinusContactCollisionAddArmLength) == 0x0000E4, "Member 'UJackPlayerCameraData::ContinusContactCollisionAddArmLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CheckOffInnerArmLength) == 0x0000E8, "Member 'UJackPlayerCameraData::CheckOffInnerArmLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ViewRotationMin) == 0x0000EC, "Member 'UJackPlayerCameraData::ViewRotationMin' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ViewRotationMax) == 0x0000F8, "Member 'UJackPlayerCameraData::ViewRotationMax' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bPawnPitchRollForceZero) == 0x000104, "Member 'UJackPlayerCameraData::bPawnPitchRollForceZero' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, TargetOffsetInBlinding) == 0x000108, "Member 'UJackPlayerCameraData::TargetOffsetInBlinding' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, TargetOffsetInIdling) == 0x000114, "Member 'UJackPlayerCameraData::TargetOffsetInIdling' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bZLerpSpringDamper) == 0x000120, "Member 'UJackPlayerCameraData::bZLerpSpringDamper' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bZNoLerp) == 0x000121, "Member 'UJackPlayerCameraData::bZNoLerp' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedXY) == 0x000124, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedXY' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_Speed) == 0x000128, "Member 'UJackPlayerCameraData::InterpTargetLocation_Speed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_MinLimitZ) == 0x00012C, "Member 'UJackPlayerCameraData::InterpTargetLocation_MinLimitZ' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_MaxLimitZ) == 0x000130, "Member 'UJackPlayerCameraData::InterpTargetLocation_MaxLimitZ' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, LookAtInterpDistanceMax) == 0x000134, "Member 'UJackPlayerCameraData::LookAtInterpDistanceMax' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bPlayerControllCameraRotationDirectSetInZoomMode) == 0x000138, "Member 'UJackPlayerCameraData::bPlayerControllCameraRotationDirectSetInZoomMode' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedVerySlow) == 0x00013C, "Member 'UJackPlayerCameraData::AddPitchInputSpeedVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedVerySlow2) == 0x000140, "Member 'UJackPlayerCameraData::AddPitchInputSpeedVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedSlow) == 0x000144, "Member 'UJackPlayerCameraData::AddPitchInputSpeedSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedSlow2) == 0x000148, "Member 'UJackPlayerCameraData::AddPitchInputSpeedSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeed) == 0x00014C, "Member 'UJackPlayerCameraData::AddPitchInputSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeed2) == 0x000150, "Member 'UJackPlayerCameraData::AddPitchInputSpeed2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedLittleFast) == 0x000154, "Member 'UJackPlayerCameraData::AddPitchInputSpeedLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedLittleFast2) == 0x000158, "Member 'UJackPlayerCameraData::AddPitchInputSpeedLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedFast) == 0x00015C, "Member 'UJackPlayerCameraData::AddPitchInputSpeedFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputSpeedFast2) == 0x000160, "Member 'UJackPlayerCameraData::AddPitchInputSpeedFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateVerySlow) == 0x000164, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateVerySlow2) == 0x000168, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateSlow) == 0x00016C, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateSlow2) == 0x000170, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRate) == 0x000174, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRate2) == 0x000178, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRate2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateLittleFast) == 0x00017C, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateLittleFast2) == 0x000180, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateFast) == 0x000184, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddPitchInputMaxSpeedRateFast2) == 0x000188, "Member 'UJackPlayerCameraData::AddPitchInputMaxSpeedRateFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedVerySlow) == 0x00018C, "Member 'UJackPlayerCameraData::AddYawInputSpeedVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedVerySlow2) == 0x000190, "Member 'UJackPlayerCameraData::AddYawInputSpeedVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedSlow) == 0x000194, "Member 'UJackPlayerCameraData::AddYawInputSpeedSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedSlow2) == 0x000198, "Member 'UJackPlayerCameraData::AddYawInputSpeedSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeed) == 0x00019C, "Member 'UJackPlayerCameraData::AddYawInputSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeed2) == 0x0001A0, "Member 'UJackPlayerCameraData::AddYawInputSpeed2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedLittleFast) == 0x0001A4, "Member 'UJackPlayerCameraData::AddYawInputSpeedLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedLittleFast2) == 0x0001A8, "Member 'UJackPlayerCameraData::AddYawInputSpeedLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedFast) == 0x0001AC, "Member 'UJackPlayerCameraData::AddYawInputSpeedFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputSpeedFast2) == 0x0001B0, "Member 'UJackPlayerCameraData::AddYawInputSpeedFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateVerySlow) == 0x0001B4, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateVerySlow2) == 0x0001B8, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateSlow) == 0x0001BC, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateSlow2) == 0x0001C0, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRate) == 0x0001C4, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRate2) == 0x0001C8, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRate2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateLittleFast) == 0x0001CC, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateLittleFast2) == 0x0001D0, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateFast) == 0x0001D4, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, AddYawInputMaxSpeedRateFast2) == 0x0001D8, "Member 'UJackPlayerCameraData::AddYawInputMaxSpeedRateFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementVerySlow) == 0x0001DC, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementVerySlow2) == 0x0001E0, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementSlow) == 0x0001E4, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementSlow2) == 0x0001E8, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovement) == 0x0001EC, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovement2) == 0x0001F0, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovement2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementLittleFast) == 0x0001F4, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementLittleFast2) == 0x0001F8, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementFast) == 0x0001FC, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, UptoChangeSpeedRateByPlayerMovementFast2) == 0x000200, "Member 'UJackPlayerCameraData::UptoChangeSpeedRateByPlayerMovementFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementVerySlow) == 0x000204, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementVerySlow2) == 0x000208, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementSlow) == 0x00020C, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementSlow2) == 0x000210, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovement) == 0x000214, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovement2) == 0x000218, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovement2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementLittleFast) == 0x00021C, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementLittleFast2) == 0x000220, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementFast) == 0x000224, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, DowntoChangeSpeedRateByPlayerMovementFast2) == 0x000228, "Member 'UJackPlayerCameraData::DowntoChangeSpeedRateByPlayerMovementFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementVerySlow) == 0x00022C, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementVerySlow2) == 0x000230, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementSlow) == 0x000234, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementSlow2) == 0x000238, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovement) == 0x00023C, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovement2) == 0x000240, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovement2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementLittleFast) == 0x000244, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementLittleFast2) == 0x000248, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementFast) == 0x00024C, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomUptoChangeSpeedRateByPlayerMovementFast2) == 0x000250, "Member 'UJackPlayerCameraData::ZoomUptoChangeSpeedRateByPlayerMovementFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow) == 0x000254, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow2) == 0x000258, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementSlow) == 0x00025C, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementSlow2) == 0x000260, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovement) == 0x000264, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovement2) == 0x000268, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovement2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast) == 0x00026C, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast2) == 0x000270, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementFast) == 0x000274, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDowntoChangeSpeedRateByPlayerMovementFast2) == 0x000278, "Member 'UJackPlayerCameraData::ZoomDowntoChangeSpeedRateByPlayerMovementFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InDoorOutDoorArmLengthLerpSec) == 0x00027C, "Member 'UJackPlayerCameraData::InDoorOutDoorArmLengthLerpSec' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, CameraResetPitch) == 0x000280, "Member 'UJackPlayerCameraData::CameraResetPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCameraResetPitch) == 0x000284, "Member 'UJackPlayerCameraData::ZoomCameraResetPitch' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedVerySlow) == 0x000288, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedVerySlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedVerySlow2) == 0x00028C, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedVerySlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedSlow) == 0x000290, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedSlow' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedSlow2) == 0x000294, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedSlow2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeed) == 0x000298, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeed2) == 0x00029C, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeed2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedLittleFast) == 0x0002A0, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedLittleFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedLittleFast2) == 0x0002A4, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedLittleFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedFast) == 0x0002A8, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedFast' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMoveYZSpeedFast2) == 0x0002AC, "Member 'UJackPlayerCameraData::PhotoModeMoveYZSpeedFast2' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMaxLimitMove) == 0x0002B0, "Member 'UJackPlayerCameraData::PhotoModeMaxLimitMove' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeMinLimitMove) == 0x0002BC, "Member 'UJackPlayerCameraData::PhotoModeMinLimitMove' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, PhotoModeOffsetCollideInterpSpeed) == 0x0002C8, "Member 'UJackPlayerCameraData::PhotoModeOffsetCollideInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bZoomModeEnable) == 0x0002CC, "Member 'UJackPlayerCameraData::bZoomModeEnable' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomStartStopWaitSec) == 0x0002D0, "Member 'UJackPlayerCameraData::ZoomStartStopWaitSec' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomSpeed) == 0x0002D4, "Member 'UJackPlayerCameraData::ZoomSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDistanceMin) == 0x0002D8, "Member 'UJackPlayerCameraData::ZoomDistanceMin' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomDistanceMax) == 0x0002DC, "Member 'UJackPlayerCameraData::ZoomDistanceMax' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomTargetOffsetInBlinding) == 0x0002E0, "Member 'UJackPlayerCameraData::ZoomTargetOffsetInBlinding' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomTargetOffsetInIdling) == 0x0002EC, "Member 'UJackPlayerCameraData::ZoomTargetOffsetInIdling' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedXYInZoom) == 0x0002F8, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedXYInZoom' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedInZoom) == 0x0002FC, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedInZoom' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedXYInZoomMoveStop) == 0x000300, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedXYInZoomMoveStop' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedInZoomMoveStop) == 0x000304, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedInZoomMoveStop' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedXYInZoomMoveStopLagSec) == 0x000308, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedXYInZoomMoveStopLagSec' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_InputZeroTorrance) == 0x00030C, "Member 'UJackPlayerCameraData::InterpTargetLocation_InputZeroTorrance' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomMinLookAtBound) == 0x000310, "Member 'UJackPlayerCameraData::ZoomMinLookAtBound' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomMaxLookAtBound) == 0x00031C, "Member 'UJackPlayerCameraData::ZoomMaxLookAtBound' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomFieldOfView) == 0x000328, "Member 'UJackPlayerCameraData::ZoomFieldOfView' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomRotationRateByPlayerMovement) == 0x00032C, "Member 'UJackPlayerCameraData::ZoomRotationRateByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomRotationSpeedByPlayerMovement) == 0x000330, "Member 'UJackPlayerCameraData::ZoomRotationSpeedByPlayerMovement' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomLookAtCollideCenterRateSpeed) == 0x000334, "Member 'UJackPlayerCameraData::ZoomLookAtCollideCenterRateSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, InterpTargetLocation_SpeedXY_LookAtCollide) == 0x000338, "Member 'UJackPlayerCameraData::InterpTargetLocation_SpeedXY_LookAtCollide' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCameraCollisionRadius) == 0x00033C, "Member 'UJackPlayerCameraData::ZoomCameraCollisionRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCameraVisibleCollisionRadius) == 0x000340, "Member 'UJackPlayerCameraData::ZoomCameraVisibleCollisionRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCameraViewPointInnerLength) == 0x000344, "Member 'UJackPlayerCameraData::ZoomCameraViewPointInnerLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomCameraCollisionChannel) == 0x000348, "Member 'UJackPlayerCameraData::ZoomCameraCollisionChannel' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, ZoomContinusContactCollisionAddArmLength) == 0x00034C, "Member 'UJackPlayerCameraData::ZoomContinusContactCollisionAddArmLength' has a wrong offset!");
static_assert(offsetof(UJackPlayerCameraData, bZoomArmLengthHitCheckLast) == 0x000350, "Member 'UJackPlayerCameraData::bZoomArmLengthHitCheckLast' has a wrong offset!");

// Class JackGame.JackTalkCameraData
// 0x0018 (0x0370 - 0x0358)
class UJackTalkCameraData : public UJackPlayerCameraData
{
public:
	TArray<float>                                 CanTalkCameraChangedCollisionCheckAngle;           // 0x0358(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         AvoidanceAngle;                                    // 0x0368(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceSpeed;                                    // 0x036C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTalkCameraData">();
	}
	static class UJackTalkCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTalkCameraData>();
	}
};
static_assert(alignof(UJackTalkCameraData) == 0x000008, "Wrong alignment on UJackTalkCameraData");
static_assert(sizeof(UJackTalkCameraData) == 0x000370, "Wrong size on UJackTalkCameraData");
static_assert(offsetof(UJackTalkCameraData, CanTalkCameraChangedCollisionCheckAngle) == 0x000358, "Member 'UJackTalkCameraData::CanTalkCameraChangedCollisionCheckAngle' has a wrong offset!");
static_assert(offsetof(UJackTalkCameraData, AvoidanceAngle) == 0x000368, "Member 'UJackTalkCameraData::AvoidanceAngle' has a wrong offset!");
static_assert(offsetof(UJackTalkCameraData, AvoidanceSpeed) == 0x00036C, "Member 'UJackTalkCameraData::AvoidanceSpeed' has a wrong offset!");

// Class JackGame.JackBGMControlTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackBGMControlTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBGMControlTrackInst">();
	}
	static class UJackBGMControlTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBGMControlTrackInst>();
	}
};
static_assert(alignof(UJackBGMControlTrackInst) == 0x000008, "Wrong alignment on UJackBGMControlTrackInst");
static_assert(sizeof(UJackBGMControlTrackInst) == 0x000048, "Wrong size on UJackBGMControlTrackInst");

// Class JackGame.JackActionCameraParameter
// 0x0018 (0x0050 - 0x0038)
class UJackActionCameraParameter : public UObject
{
public:
	float                                         LineSightCollisionSize;                            // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraCollisionSize;                               // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroundSecurityHeight;                              // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleActionCameraGroundCheck            CameraGroundCheck;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PeriodicFrameCheckTime;                            // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackActionCameraParameter">();
	}
	static class UJackActionCameraParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackActionCameraParameter>();
	}
};
static_assert(alignof(UJackActionCameraParameter) == 0x000008, "Wrong alignment on UJackActionCameraParameter");
static_assert(sizeof(UJackActionCameraParameter) == 0x000050, "Wrong size on UJackActionCameraParameter");
static_assert(offsetof(UJackActionCameraParameter, LineSightCollisionSize) == 0x000038, "Member 'UJackActionCameraParameter::LineSightCollisionSize' has a wrong offset!");
static_assert(offsetof(UJackActionCameraParameter, CameraCollisionSize) == 0x00003C, "Member 'UJackActionCameraParameter::CameraCollisionSize' has a wrong offset!");
static_assert(offsetof(UJackActionCameraParameter, GroundSecurityHeight) == 0x000040, "Member 'UJackActionCameraParameter::GroundSecurityHeight' has a wrong offset!");
static_assert(offsetof(UJackActionCameraParameter, CameraGroundCheck) == 0x000044, "Member 'UJackActionCameraParameter::CameraGroundCheck' has a wrong offset!");
static_assert(offsetof(UJackActionCameraParameter, PeriodicFrameCheckTime) == 0x000048, "Member 'UJackActionCameraParameter::PeriodicFrameCheckTime' has a wrong offset!");

// Class JackGame.JackBattleAIComponent
// 0x0348 (0x0470 - 0x0128)
class UJackBattleAIComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackBattleWeapon*                      BattleWeapon;                                      // 0x0130(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackBattleCharacterCollisionCoordinator* CharacterCollisionCoordinator;                     // 0x0138(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackBattleVoicePlayer*                 BattleVoicePlayer;                                 // 0x0140(0x0008)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148[0x8];                                      // 0x0148(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   CurrentStateName;                                  // 0x0150(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInputEnable;                                      // 0x0158(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_159[0x2B0];                                    // 0x0159(0x02B0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bZoneStartRequest;                                 // 0x0409(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleABPState                           ABPState;                                          // 0x040A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40B[0x5];                                      // 0x040B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  ABPFlags;                                          // 0x0410(0x0010)(Edit, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class FName                                   CurrentOddEffectMotionID;                          // 0x0420(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x1];                                      // 0x0428(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bLookAtEnable;                                     // 0x0429(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42A[0x2];                                      // 0x042A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LookAtUpdateCycleTimer;                            // 0x042C(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackCharacter>          ForceLookAtCharacter;                              // 0x0430(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackStreamObjectsHolder*               ActionResourceHolder;                              // 0x0438(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackStreamObjectsHolder*               ActionVoiceResourceHolder;                         // 0x0440(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackStreamObjectsHolder*               HealVoiceResourceHolder;                           // 0x0448(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_450[0x20];                                     // 0x0450(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyOddEffectMotion(bool bSkipToLoop);
	void ForceDead(bool bForce);
	void ForceDeadWithMontage(bool bForce, class FName MontageName, bool bIgnoreToubatu, EJackDeadRequestType DeadRequestType);
	void OnAnimMontageStarted(class UAnimMontage* Montage);
	void SetABPFlag(EJackBattleABPFlag InABPFlag, bool bEnable);
	void SetABPState(EJackBattleABPState InABPState);

	bool GetABPFlag(EJackBattleABPFlag InABPFlag) const;
	EJackBattleABPState GetABPState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleAIComponent">();
	}
	static class UJackBattleAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleAIComponent>();
	}
};
static_assert(alignof(UJackBattleAIComponent) == 0x000008, "Wrong alignment on UJackBattleAIComponent");
static_assert(sizeof(UJackBattleAIComponent) == 0x000470, "Wrong size on UJackBattleAIComponent");
static_assert(offsetof(UJackBattleAIComponent, BattleWeapon) == 0x000130, "Member 'UJackBattleAIComponent::BattleWeapon' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, CharacterCollisionCoordinator) == 0x000138, "Member 'UJackBattleAIComponent::CharacterCollisionCoordinator' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, BattleVoicePlayer) == 0x000140, "Member 'UJackBattleAIComponent::BattleVoicePlayer' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, CurrentStateName) == 0x000150, "Member 'UJackBattleAIComponent::CurrentStateName' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, bInputEnable) == 0x000158, "Member 'UJackBattleAIComponent::bInputEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, bZoneStartRequest) == 0x000409, "Member 'UJackBattleAIComponent::bZoneStartRequest' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, ABPState) == 0x00040A, "Member 'UJackBattleAIComponent::ABPState' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, ABPFlags) == 0x000410, "Member 'UJackBattleAIComponent::ABPFlags' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, CurrentOddEffectMotionID) == 0x000420, "Member 'UJackBattleAIComponent::CurrentOddEffectMotionID' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, bLookAtEnable) == 0x000429, "Member 'UJackBattleAIComponent::bLookAtEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, LookAtUpdateCycleTimer) == 0x00042C, "Member 'UJackBattleAIComponent::LookAtUpdateCycleTimer' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, ForceLookAtCharacter) == 0x000430, "Member 'UJackBattleAIComponent::ForceLookAtCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, ActionResourceHolder) == 0x000438, "Member 'UJackBattleAIComponent::ActionResourceHolder' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, ActionVoiceResourceHolder) == 0x000440, "Member 'UJackBattleAIComponent::ActionVoiceResourceHolder' has a wrong offset!");
static_assert(offsetof(UJackBattleAIComponent, HealVoiceResourceHolder) == 0x000448, "Member 'UJackBattleAIComponent::HealVoiceResourceHolder' has a wrong offset!");

// Class JackGame.JackCrossFadeTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackCrossFadeTrack final : public UInterpTrack
{
public:
	TArray<struct FJackCrossFadeTrackKey>         KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCrossFadeTrack">();
	}
	static class UJackCrossFadeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCrossFadeTrack>();
	}
};
static_assert(alignof(UJackCrossFadeTrack) == 0x000008, "Wrong alignment on UJackCrossFadeTrack");
static_assert(sizeof(UJackCrossFadeTrack) == 0x0000A0, "Wrong size on UJackCrossFadeTrack");
static_assert(offsetof(UJackCrossFadeTrack, KeyArray) == 0x000090, "Member 'UJackCrossFadeTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackBattleCameraManager
// 0x00F8 (0x0130 - 0x0038)
class UJackBattleCameraManager final : public UObject
{
public:
	uint8                                         Pad_38[0xF8];                                      // 0x0038(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCameraManager">();
	}
	static class UJackBattleCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCameraManager>();
	}
};
static_assert(alignof(UJackBattleCameraManager) == 0x000008, "Wrong alignment on UJackBattleCameraManager");
static_assert(sizeof(UJackBattleCameraManager) == 0x000130, "Wrong size on UJackBattleCameraManager");

// Class JackGame.JackBattleCharacterCollisionCoordinator
// 0x0100 (0x0138 - 0x0038)
class UJackBattleCharacterCollisionCoordinator final : public UObject
{
public:
	uint8                                         Pad_38[0x100];                                     // 0x0038(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBlockingHit(class AActor* SelfActor, class AActor* OtherActor, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCharacterCollisionCoordinator">();
	}
	static class UJackBattleCharacterCollisionCoordinator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCharacterCollisionCoordinator>();
	}
};
static_assert(alignof(UJackBattleCharacterCollisionCoordinator) == 0x000008, "Wrong alignment on UJackBattleCharacterCollisionCoordinator");
static_assert(sizeof(UJackBattleCharacterCollisionCoordinator) == 0x000138, "Wrong size on UJackBattleCharacterCollisionCoordinator");

// Class JackGame.JackTextDataFukidasi
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataFukidasi final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataFukidasi">();
	}
	static class UJackTextDataFukidasi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataFukidasi>();
	}
};
static_assert(alignof(UJackTextDataFukidasi) == 0x000008, "Wrong alignment on UJackTextDataFukidasi");
static_assert(sizeof(UJackTextDataFukidasi) == 0x000038, "Wrong size on UJackTextDataFukidasi");

// Class JackGame.JackWorldSettings
// 0x0008 (0x0570 - 0x0568)
class AJackWorldSettings final : public AWorldSettings
{
public:
	bool                                          bDebugFlag_ShowParticleSystemComponentInfo;        // 0x0568(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_569[0x7];                                      // 0x0569(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWorldSettings">();
	}
	static class AJackWorldSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWorldSettings>();
	}
};
static_assert(alignof(AJackWorldSettings) == 0x000008, "Wrong alignment on AJackWorldSettings");
static_assert(sizeof(AJackWorldSettings) == 0x000570, "Wrong size on AJackWorldSettings");
static_assert(offsetof(AJackWorldSettings, bDebugFlag_ShowParticleSystemComponentInfo) == 0x000568, "Member 'AJackWorldSettings::bDebugFlag_ShowParticleSystemComponentInfo' has a wrong offset!");

// Class JackGame.JackBlendAnimPlayTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackBlendAnimPlayTrackInst final : public UInterpTrackInstAnimControl
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBlendAnimPlayTrackInst">();
	}
	static class UJackBlendAnimPlayTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBlendAnimPlayTrackInst>();
	}
};
static_assert(alignof(UJackBlendAnimPlayTrackInst) == 0x000008, "Wrong alignment on UJackBlendAnimPlayTrackInst");
static_assert(sizeof(UJackBlendAnimPlayTrackInst) == 0x000040, "Wrong size on UJackBlendAnimPlayTrackInst");

// Class JackGame.JackBattleCharacterCollisionManager
// 0x0010 (0x0060 - 0x0050)
class UJackBattleCharacterCollisionManager final : public UJackTickableGameObject
{
public:
	TArray<class UJackBattleCharacterCollisionCoordinator*> Coordinators;                                      // 0x0050(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCharacterCollisionManager">();
	}
	static class UJackBattleCharacterCollisionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCharacterCollisionManager>();
	}
};
static_assert(alignof(UJackBattleCharacterCollisionManager) == 0x000008, "Wrong alignment on UJackBattleCharacterCollisionManager");
static_assert(sizeof(UJackBattleCharacterCollisionManager) == 0x000060, "Wrong size on UJackBattleCharacterCollisionManager");
static_assert(offsetof(UJackBattleCharacterCollisionManager, Coordinators) == 0x000050, "Member 'UJackBattleCharacterCollisionManager::Coordinators' has a wrong offset!");

// Class JackGame.JackBattleCharacterInfo
// 0x01D8 (0x0210 - 0x0038)
class UJackBattleCharacterInfo final : public UObject
{
public:
	bool                                          bActive;                                           // 0x0038(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJackGameCharacter>      GameCharacter;                                     // 0x003C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MightIndex;                                        // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdditionalCreate;                                 // 0x0048(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNigeru;                                           // 0x0049(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNifuramu;                                         // 0x004A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidOddEffectEffect;                           // 0x004B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidOddEffectFacial;                           // 0x004C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkedActionMoveVectorDirty;                      // 0x004D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x102];                                     // 0x004E(0x0102)(Fixing Size After Last Property [ Dumper-7 ])
	EJackBattleFreeMoveType                       FreeMoveType;                                      // 0x0150(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x3];                                      // 0x0151(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FreeMoveOriginLocation;                            // 0x0154(0x000C)(Edit, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShiftMoveEnable;                                  // 0x0160(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_161[0x2F];                                     // 0x0161(0x002F)(Fixing Size After Last Property [ Dumper-7 ])
	EJackEquippedWeaponStyle                      ABP_WeaponStyle;                                   // 0x0190(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           HandEquipItemIDs;                                  // 0x0198(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AController>             DefaultController;                                 // 0x01A8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroyDefaultController;                     // 0x01B0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x3];                                      // 0x01B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TurnCount;                                         // 0x01B4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeadReceivedActionID;                              // 0x01B8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DeadReceivedRenkeiID;                              // 0x01C0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveNormalItem;                                   // 0x01C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHaveRareItem;                                     // 0x01C9(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1CA[0x2];                                      // 0x01CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AActor>                  ZouenLocator;                                      // 0x01CC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AActor>                  CoffinActor;                                       // 0x01D4(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AJackBattleSnowman>      SnowmanActor;                                      // 0x01DC(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OverrideVoicePresetID;                             // 0x01E8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackStreamObjectsHolder*               AdditionalVoiceAssetsObjectHolder;                 // 0x01F0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActionMoveVectorCache;                             // 0x01F8(0x000C)(Edit, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInvalidToubatuMonster;                            // 0x0204(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_205[0x3];                                      // 0x0205(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LatestPlayedActionID;                              // 0x0208(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCharacterInfo">();
	}
	static class UJackBattleCharacterInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCharacterInfo>();
	}
};
static_assert(alignof(UJackBattleCharacterInfo) == 0x000008, "Wrong alignment on UJackBattleCharacterInfo");
static_assert(sizeof(UJackBattleCharacterInfo) == 0x000210, "Wrong size on UJackBattleCharacterInfo");
static_assert(offsetof(UJackBattleCharacterInfo, bActive) == 0x000038, "Member 'UJackBattleCharacterInfo::bActive' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, GameCharacter) == 0x00003C, "Member 'UJackBattleCharacterInfo::GameCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, MightIndex) == 0x000044, "Member 'UJackBattleCharacterInfo::MightIndex' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bAdditionalCreate) == 0x000048, "Member 'UJackBattleCharacterInfo::bAdditionalCreate' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bNigeru) == 0x000049, "Member 'UJackBattleCharacterInfo::bNigeru' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bNifuramu) == 0x00004A, "Member 'UJackBattleCharacterInfo::bNifuramu' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bInvalidOddEffectEffect) == 0x00004B, "Member 'UJackBattleCharacterInfo::bInvalidOddEffectEffect' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bInvalidOddEffectFacial) == 0x00004C, "Member 'UJackBattleCharacterInfo::bInvalidOddEffectFacial' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bMarkedActionMoveVectorDirty) == 0x00004D, "Member 'UJackBattleCharacterInfo::bMarkedActionMoveVectorDirty' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, FreeMoveType) == 0x000150, "Member 'UJackBattleCharacterInfo::FreeMoveType' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, FreeMoveOriginLocation) == 0x000154, "Member 'UJackBattleCharacterInfo::FreeMoveOriginLocation' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bShiftMoveEnable) == 0x000160, "Member 'UJackBattleCharacterInfo::bShiftMoveEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, ABP_WeaponStyle) == 0x000190, "Member 'UJackBattleCharacterInfo::ABP_WeaponStyle' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, HandEquipItemIDs) == 0x000198, "Member 'UJackBattleCharacterInfo::HandEquipItemIDs' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, DefaultController) == 0x0001A8, "Member 'UJackBattleCharacterInfo::DefaultController' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bAutoDestroyDefaultController) == 0x0001B0, "Member 'UJackBattleCharacterInfo::bAutoDestroyDefaultController' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, TurnCount) == 0x0001B4, "Member 'UJackBattleCharacterInfo::TurnCount' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, DeadReceivedActionID) == 0x0001B8, "Member 'UJackBattleCharacterInfo::DeadReceivedActionID' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, DeadReceivedRenkeiID) == 0x0001C0, "Member 'UJackBattleCharacterInfo::DeadReceivedRenkeiID' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bHaveNormalItem) == 0x0001C8, "Member 'UJackBattleCharacterInfo::bHaveNormalItem' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bHaveRareItem) == 0x0001C9, "Member 'UJackBattleCharacterInfo::bHaveRareItem' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, ZouenLocator) == 0x0001CC, "Member 'UJackBattleCharacterInfo::ZouenLocator' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, CoffinActor) == 0x0001D4, "Member 'UJackBattleCharacterInfo::CoffinActor' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, SnowmanActor) == 0x0001DC, "Member 'UJackBattleCharacterInfo::SnowmanActor' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, OverrideVoicePresetID) == 0x0001E8, "Member 'UJackBattleCharacterInfo::OverrideVoicePresetID' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, AdditionalVoiceAssetsObjectHolder) == 0x0001F0, "Member 'UJackBattleCharacterInfo::AdditionalVoiceAssetsObjectHolder' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, ActionMoveVectorCache) == 0x0001F8, "Member 'UJackBattleCharacterInfo::ActionMoveVectorCache' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, bInvalidToubatuMonster) == 0x000204, "Member 'UJackBattleCharacterInfo::bInvalidToubatuMonster' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterInfo, LatestPlayedActionID) == 0x000208, "Member 'UJackBattleCharacterInfo::LatestPlayedActionID' has a wrong offset!");

// Class JackGame.JackBattleZoneParameter
// 0x00F8 (0x0130 - 0x0038)
class UJackBattleZoneParameter : public UObject
{
public:
	int32                                         Common_KeepRemainBattle;                           // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackZoneStartParameter                ZoneStartParameter_Friend;                         // 0x0040(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackZoneStartParameter                ZoneStartParameter_Monster;                        // 0x0060(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FJackZonePointInvokeInfo>       Invoke_ZonePointInvokeInfos;                       // 0x0080(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackZonePointInvokeInfo>       Invoke_ZonePointInvokeInfos_Monster;               // 0x0090(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackCharacterZonePointInfo>    AddBattleStart_CharacterZonePoints;                // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ZoneCharacterCountZonePoints_Alive1;  // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ZoneCharacterCountZonePoints_Alive2;  // 0x00C0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ZoneCharacterCountZonePoints_Alive3;  // 0x00D0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ZoneCharacterCountZonePoints_Monster; // 0x00E0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ProgressTurnZonePoints;               // 0x00F0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 AddTurnStart_ProgressTurnZonePoints_Monster;       // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackDamageZonePointInfo>       AddDamage_DamageZonePointInfos;                    // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackDamageZonePointInfo>       AddDamage_DamageZonePointInfos_Monster;            // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleZoneParameter">();
	}
	static class UJackBattleZoneParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleZoneParameter>();
	}
};
static_assert(alignof(UJackBattleZoneParameter) == 0x000008, "Wrong alignment on UJackBattleZoneParameter");
static_assert(sizeof(UJackBattleZoneParameter) == 0x000130, "Wrong size on UJackBattleZoneParameter");
static_assert(offsetof(UJackBattleZoneParameter, Common_KeepRemainBattle) == 0x000038, "Member 'UJackBattleZoneParameter::Common_KeepRemainBattle' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, ZoneStartParameter_Friend) == 0x000040, "Member 'UJackBattleZoneParameter::ZoneStartParameter_Friend' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, ZoneStartParameter_Monster) == 0x000060, "Member 'UJackBattleZoneParameter::ZoneStartParameter_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, Invoke_ZonePointInvokeInfos) == 0x000080, "Member 'UJackBattleZoneParameter::Invoke_ZonePointInvokeInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, Invoke_ZonePointInvokeInfos_Monster) == 0x000090, "Member 'UJackBattleZoneParameter::Invoke_ZonePointInvokeInfos_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddBattleStart_CharacterZonePoints) == 0x0000A0, "Member 'UJackBattleZoneParameter::AddBattleStart_CharacterZonePoints' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ZoneCharacterCountZonePoints_Alive1) == 0x0000B0, "Member 'UJackBattleZoneParameter::AddTurnStart_ZoneCharacterCountZonePoints_Alive1' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ZoneCharacterCountZonePoints_Alive2) == 0x0000C0, "Member 'UJackBattleZoneParameter::AddTurnStart_ZoneCharacterCountZonePoints_Alive2' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ZoneCharacterCountZonePoints_Alive3) == 0x0000D0, "Member 'UJackBattleZoneParameter::AddTurnStart_ZoneCharacterCountZonePoints_Alive3' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ZoneCharacterCountZonePoints_Monster) == 0x0000E0, "Member 'UJackBattleZoneParameter::AddTurnStart_ZoneCharacterCountZonePoints_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ProgressTurnZonePoints) == 0x0000F0, "Member 'UJackBattleZoneParameter::AddTurnStart_ProgressTurnZonePoints' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddTurnStart_ProgressTurnZonePoints_Monster) == 0x000100, "Member 'UJackBattleZoneParameter::AddTurnStart_ProgressTurnZonePoints_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddDamage_DamageZonePointInfos) == 0x000110, "Member 'UJackBattleZoneParameter::AddDamage_DamageZonePointInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleZoneParameter, AddDamage_DamageZonePointInfos_Monster) == 0x000120, "Member 'UJackBattleZoneParameter::AddDamage_DamageZonePointInfos_Monster' has a wrong offset!");

// Class JackGame.JackBattleCharacterManager
// 0x00B0 (0x00E8 - 0x0038)
class UJackBattleCharacterManager final : public UObject
{
public:
	TArray<class UJackBattleCharacterInfo*>       BattleCharacterInfos;                              // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class UJackBattleCharacterCollisionManager*   BattleCharacterCollisionManager;                   // 0x0048(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 BattleCommandAIClass_Friend;                       // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 BattleCommandAIClass_Monster;                      // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UClass*                                 BattleCommandAIClass_Konran;                       // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x50];                                      // 0x0068(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AJackCharacter>>  RegisteredPauseCharacters;                         // 0x00B8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AJackCharacter>>  UnregisteredPauseCharacters;                       // 0x00C8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AJackCharacter>>  TextureMipLevelsToBeResidentCharacters;            // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)

public:
	TArray<class UJackGameCharacter*> GetActionTargetGameCharacters(const class UJackGameCharacter* CasterGameCharacter, EJackActionTargetListType ActionTargetListType, const struct FJackActionData& ActionData) const;
	TArray<class AJackCharacter*> GetBattleCharacters(bool bAliveOnly, const TArray<EJackMight>& Mights) const;
	TArray<class UJackGameCharacter*> GetBattleGameCharacters(bool bAliveOnly, const TArray<EJackMight>& Mights) const;
	TArray<class AJackCharacter*> GetBattleMonsterCharacters(bool bAliveOnly) const;
	TArray<class AJackCharacter*> GetBattlePlayerCharacters(bool bAliveOnly) const;
	class AJackCharacter* GetControlCharacter() const;
	class UJackGameCharacter* GetControlGameCharacter() const;
	class AJackCharacter* GetLeaderCharacter() const;
	class UJackGameCharacter* GetLeaderGameCharacter() const;
	class AJackCharacter* GetMainPlayerCharacter() const;
	TArray<class UJackGameCharacter*> GetToubatuMonsterGameCharacters() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCharacterManager">();
	}
	static class UJackBattleCharacterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCharacterManager>();
	}
};
static_assert(alignof(UJackBattleCharacterManager) == 0x000008, "Wrong alignment on UJackBattleCharacterManager");
static_assert(sizeof(UJackBattleCharacterManager) == 0x0000E8, "Wrong size on UJackBattleCharacterManager");
static_assert(offsetof(UJackBattleCharacterManager, BattleCharacterInfos) == 0x000038, "Member 'UJackBattleCharacterManager::BattleCharacterInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, BattleCharacterCollisionManager) == 0x000048, "Member 'UJackBattleCharacterManager::BattleCharacterCollisionManager' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, BattleCommandAIClass_Friend) == 0x000050, "Member 'UJackBattleCharacterManager::BattleCommandAIClass_Friend' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, BattleCommandAIClass_Monster) == 0x000058, "Member 'UJackBattleCharacterManager::BattleCommandAIClass_Monster' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, BattleCommandAIClass_Konran) == 0x000060, "Member 'UJackBattleCharacterManager::BattleCommandAIClass_Konran' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, RegisteredPauseCharacters) == 0x0000B8, "Member 'UJackBattleCharacterManager::RegisteredPauseCharacters' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, UnregisteredPauseCharacters) == 0x0000C8, "Member 'UJackBattleCharacterManager::UnregisteredPauseCharacters' has a wrong offset!");
static_assert(offsetof(UJackBattleCharacterManager, TextureMipLevelsToBeResidentCharacters) == 0x0000D8, "Member 'UJackBattleCharacterManager::TextureMipLevelsToBeResidentCharacters' has a wrong offset!");

// Class JackGame.JackBattleCommandAI
// 0x0008 (0x03A0 - 0x0398)
class AJackBattleCommandAI : public AActor
{
public:
	int32                                         ExecTurnCommandCount;                              // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ExecSecondCheckBP(const class UJackGameCharacter* TargetGameCharacter, struct FJackActionData& ActionData, EJackBattleIntelligenceType IntelligenceType);
	struct FJackBattleCommandAI_ExecTurnCommandResult ExecTurnCommand();
	void ExecTurnCommandCore();
	class UJackBattleCharacterManager* GetBattleCharacterManager();
	class AJackBattleManager* GetBattleManager();
	class UJackGameCharacter* GetGameCharacter();
	class AJackCharacter* GetJackCharacter();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAI">();
	}
	static class AJackBattleCommandAI* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleCommandAI>();
	}
};
static_assert(alignof(AJackBattleCommandAI) == 0x000008, "Wrong alignment on AJackBattleCommandAI");
static_assert(sizeof(AJackBattleCommandAI) == 0x0003A0, "Wrong size on AJackBattleCommandAI");
static_assert(offsetof(AJackBattleCommandAI, ExecTurnCommandCount) == 0x000398, "Member 'AJackBattleCommandAI::ExecTurnCommandCount' has a wrong offset!");

// Class JackGame.JackTextDataMenu
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataMenu final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataMenu">();
	}
	static class UJackTextDataMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataMenu>();
	}
};
static_assert(alignof(UJackTextDataMenu) == 0x000008, "Wrong alignment on UJackTextDataMenu");
static_assert(sizeof(UJackTextDataMenu) == 0x000038, "Wrong size on UJackTextDataMenu");

// Class JackGame.JackCoordSoundTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackCoordSoundTrack final : public UInterpTrack
{
public:
	TArray<struct FJackCoordSoundTrackKey>        KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AttachGroupName;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoordSoundTrack">();
	}
	static class UJackCoordSoundTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCoordSoundTrack>();
	}
};
static_assert(alignof(UJackCoordSoundTrack) == 0x000008, "Wrong alignment on UJackCoordSoundTrack");
static_assert(sizeof(UJackCoordSoundTrack) == 0x0000A8, "Wrong size on UJackCoordSoundTrack");
static_assert(offsetof(UJackCoordSoundTrack, KeyArray) == 0x000090, "Member 'UJackCoordSoundTrack::KeyArray' has a wrong offset!");
static_assert(offsetof(UJackCoordSoundTrack, AttachGroupName) == 0x0000A0, "Member 'UJackCoordSoundTrack::AttachGroupName' has a wrong offset!");

// Class JackGame.JackBattleCommandAI_Friend
// 0x00F8 (0x0498 - 0x03A0)
class AJackBattleCommandAI_Friend : public AJackBattleCommandAI
{
public:
	uint8                                         Pad_3A0[0xF8];                                     // 0x03A0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJackBattleCommandAI_ExecTurnCommandResult ExecAnalysisFlow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAI_Friend">();
	}
	static class AJackBattleCommandAI_Friend* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleCommandAI_Friend>();
	}
};
static_assert(alignof(AJackBattleCommandAI_Friend) == 0x000008, "Wrong alignment on AJackBattleCommandAI_Friend");
static_assert(sizeof(AJackBattleCommandAI_Friend) == 0x000498, "Wrong size on AJackBattleCommandAI_Friend");

// Class JackGame.JackBattleCommandAI_Konran
// 0x0020 (0x03C0 - 0x03A0)
class AJackBattleCommandAI_Konran : public AJackBattleCommandAI
{
public:
	uint8                                         KoudouPer_NanimoSinai;                             // 0x03A0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         KoudouPer_KougekiEnemy;                            // 0x03A1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         KoudouPer_KougekiSelf;                             // 0x03A2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         KoudouPer_KougekiFriend;                           // 0x03A3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackKonranNanimoSinaiInfo>     NanimoSinaiInfos;                                  // 0x03A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	EJackKonranKoudouType                         ExecKoudouType;                                    // 0x03B8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x7];                                      // 0x03B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAI_Konran">();
	}
	static class AJackBattleCommandAI_Konran* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleCommandAI_Konran>();
	}
};
static_assert(alignof(AJackBattleCommandAI_Konran) == 0x000008, "Wrong alignment on AJackBattleCommandAI_Konran");
static_assert(sizeof(AJackBattleCommandAI_Konran) == 0x0003C0, "Wrong size on AJackBattleCommandAI_Konran");
static_assert(offsetof(AJackBattleCommandAI_Konran, KoudouPer_NanimoSinai) == 0x0003A0, "Member 'AJackBattleCommandAI_Konran::KoudouPer_NanimoSinai' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Konran, KoudouPer_KougekiEnemy) == 0x0003A1, "Member 'AJackBattleCommandAI_Konran::KoudouPer_KougekiEnemy' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Konran, KoudouPer_KougekiSelf) == 0x0003A2, "Member 'AJackBattleCommandAI_Konran::KoudouPer_KougekiSelf' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Konran, KoudouPer_KougekiFriend) == 0x0003A3, "Member 'AJackBattleCommandAI_Konran::KoudouPer_KougekiFriend' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Konran, NanimoSinaiInfos) == 0x0003A8, "Member 'AJackBattleCommandAI_Konran::NanimoSinaiInfos' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Konran, ExecKoudouType) == 0x0003B8, "Member 'AJackBattleCommandAI_Konran::ExecKoudouType' has a wrong offset!");

// Class JackGame.JackBattleCommandAI_Monster
// 0x0180 (0x0520 - 0x03A0)
class AJackBattleCommandAI_Monster : public AJackBattleCommandAI
{
public:
	class FName                                   MonsterBattleAIID;                                 // 0x03A0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackDataTableMonsterBattleAI          MonsterBattleAIRow;                                // 0x03A8(0x00F8)(Edit, BlueprintVisible, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	int32                                         ExecActionSlotID;                                  // 0x04A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ExecExceptionActionSlotID;                         // 0x04A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleIntelligenceType                   IntelligenceType;                                  // 0x04A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIntelligenceConclusion;                           // 0x04A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleActionPatternType                  ActionPatternType;                                 // 0x04AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4AB[0x1];                                      // 0x04AB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CalcActionStrideTableCount;                        // 0x04AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleMoreActionType                     OriginalMoreActionType;                            // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackBattleMoreActionType                     MoreActionType;                                    // 0x04B1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4B2[0x2];                                      // 0x04B2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MoreActionNumber;                                  // 0x04B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrevExecActionSlotID;                              // 0x04B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PrevExecExceptionActionSlotID;                     // 0x04BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      ExecActionHistory;                                 // 0x04C0(0x0050)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)
	TArray<int32>                                 DebugActionPatternSlotIDs;                         // 0x0510(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	void AdjustMonsterBattleAIRowByCopyMonster();
	void BuildCandidateExceptionActionSlots(const TArray<struct FJackMonsterBattleAI_ActionSlot>& ExceptionActionSlots, TArray<struct FJackMonsterBattleAI_ActionSlot>* OutCandidateActionSlots);
	int32 CalcGetNextBasisActionSlotID(const TArray<int32>& InCandidateSlotIDs, int32 InExecActionSlotID);
	void CreateSlotsKaitenA(TArray<int32>* OutCandidateSlotIDs, int32 CandidateSlotIDsNum, int32 NextBasicActionSlotID);
	void CreateSlotsKaitenB(TArray<int32>* OutCandidateSlotIDs, int32 CandidateSlotIDsNum, int32 NextBasicActionSlotID);
	void CreateSlotsKaitenC(TArray<int32>* OutCandidateSlotIDs, int32 CandidateSlotIDsNum, int32 NextBasicActionSlotID);
	void ExecFirstCheck(const TArray<struct FJackMonsterBattleAI_ActionSlot>& CandidateActionSlots, TArray<struct FJackMonsterBattleAI_ActionSlot>* OutCandidateActionSlots);
	void InitializeMonsterBattleAI(class FName InMonsterBattleAIID);
	void InsertTurnQueue(class UJackGameCharacter* TurnGameCharacter, bool bRootTurn);
	bool IsChangeAITable();
	bool IsRegisteredInterruptAction(class FName InAction);
	bool OnBreakMonsterParts(class UJackMonsterGameCharacter* BreakGameCharacter);
	void OnInterruptActionComplete(const struct FJackActionPlayParam& InActionPlayParam);
	bool RegisterInterruptAction(EJackBattleInterruptActionTiming InTiming, class FName InAction, class UJackGameCharacter* InTarget);
	bool RegisterInterruptActionBySlot(EJackBattleInterruptActionTiming InTiming, int32 ActionSlotID, class UJackGameCharacter* InTarget);
	bool RegisterInterruptActionDetail(EJackBattleInterruptActionTiming InTiming, class FName InAction, class FName InOverrideCastMotion, class FName InOverrideShotMotion, class UJackGameCharacter* InTarget);
	void RestoreMapGroupeCheck();
	void SetGroupeCheckDefaultActionSlots(const TArray<struct FJackMonsterBattleAI_ActionSlot>& ActionSlots);
	void SetGroupeCheckDefaultExceptionActionSlots(const TArray<struct FJackMonsterBattleAI_ActionSlot>& ExceptionActionSlots);
	bool SetMoreAction(bool bInitialize);
	void SetupMoreAction();
	void UpdateActionSlotGroupeCheck(const struct FJackMonsterBattleAI_ActionSlot& ActionSlot);
	void UpdateExceptionActionSlotGroupeCheck(const struct FJackMonsterBattleAI_ActionSlot& ExceptionActionSlot);

	bool CheckActionSlotGroupeCheck(const struct FJackMonsterBattleAI_ActionSlot& ActionSlot) const;
	bool CheckExceptionActionSlotGroupeCheck(const struct FJackMonsterBattleAI_ActionSlot& ActionSlot) const;
	bool CheckNakamaYobiBySlot(int32 ActionSlotID) const;
	TArray<int32> GetDebugActionPatternSlotIDs() const;
	class AActor* GetLocatorActorByTag(class FName InTagName) const;
	TArray<struct FJackMonsterBattleAI_ActionSlot> GetMonsterBattleAI_ActionSlotsBP(struct FJackDataTableMonsterBattleAI& DTMonsterBattleAIRow) const;
	TArray<struct FJackMonsterBattleAI_ActionSlot> GetMonsterBattleAI_ExceptionActionSlotsBP(struct FJackDataTableMonsterBattleAI& DTMonsterBattleAIRow) const;
	TArray<class UJackGameCharacter*> SortCandidateTargetGameCharacters(const TArray<class UJackGameCharacter*>& CandidateTargetGameCharacters, const TArray<struct FJackMonsterBattleAI_ActionSlot>& CandidateActionSlots, int32 CandidateActionSlotID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAI_Monster">();
	}
	static class AJackBattleCommandAI_Monster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleCommandAI_Monster>();
	}
};
static_assert(alignof(AJackBattleCommandAI_Monster) == 0x000008, "Wrong alignment on AJackBattleCommandAI_Monster");
static_assert(sizeof(AJackBattleCommandAI_Monster) == 0x000520, "Wrong size on AJackBattleCommandAI_Monster");
static_assert(offsetof(AJackBattleCommandAI_Monster, MonsterBattleAIID) == 0x0003A0, "Member 'AJackBattleCommandAI_Monster::MonsterBattleAIID' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, MonsterBattleAIRow) == 0x0003A8, "Member 'AJackBattleCommandAI_Monster::MonsterBattleAIRow' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, ExecActionSlotID) == 0x0004A0, "Member 'AJackBattleCommandAI_Monster::ExecActionSlotID' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, ExecExceptionActionSlotID) == 0x0004A4, "Member 'AJackBattleCommandAI_Monster::ExecExceptionActionSlotID' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, IntelligenceType) == 0x0004A8, "Member 'AJackBattleCommandAI_Monster::IntelligenceType' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, bIntelligenceConclusion) == 0x0004A9, "Member 'AJackBattleCommandAI_Monster::bIntelligenceConclusion' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, ActionPatternType) == 0x0004AA, "Member 'AJackBattleCommandAI_Monster::ActionPatternType' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, CalcActionStrideTableCount) == 0x0004AC, "Member 'AJackBattleCommandAI_Monster::CalcActionStrideTableCount' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, OriginalMoreActionType) == 0x0004B0, "Member 'AJackBattleCommandAI_Monster::OriginalMoreActionType' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, MoreActionType) == 0x0004B1, "Member 'AJackBattleCommandAI_Monster::MoreActionType' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, MoreActionNumber) == 0x0004B4, "Member 'AJackBattleCommandAI_Monster::MoreActionNumber' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, PrevExecActionSlotID) == 0x0004B8, "Member 'AJackBattleCommandAI_Monster::PrevExecActionSlotID' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, PrevExecExceptionActionSlotID) == 0x0004BC, "Member 'AJackBattleCommandAI_Monster::PrevExecExceptionActionSlotID' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, ExecActionHistory) == 0x0004C0, "Member 'AJackBattleCommandAI_Monster::ExecActionHistory' has a wrong offset!");
static_assert(offsetof(AJackBattleCommandAI_Monster, DebugActionPatternSlotIDs) == 0x000510, "Member 'AJackBattleCommandAI_Monster::DebugActionPatternSlotIDs' has a wrong offset!");

// Class JackGame.JackBattleCommandAIComponent
// 0x0000 (0x0128 - 0x0128)
class UJackBattleCommandAIComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAIComponent">();
	}
	static class UJackBattleCommandAIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCommandAIComponent>();
	}
};
static_assert(alignof(UJackBattleCommandAIComponent) == 0x000008, "Wrong alignment on UJackBattleCommandAIComponent");
static_assert(sizeof(UJackBattleCommandAIComponent) == 0x000128, "Wrong size on UJackBattleCommandAIComponent");

// Class JackGame.JackTextMacroReplaceManager
// 0x0110 (0x0148 - 0x0038)
class UJackTextMacroReplaceManager : public UObject
{
public:
	class UDataTable*                             MacroInfoDataTable;                                // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TagInfoDataTable;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FixTagInfoDataTable;                               // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FrenchCheckVowelDataTable;                         // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GermanCaseChangeDataTable;                         // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GermanCheckLastIsSDataTable;                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ActionArticleInfoDataTable;                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ItemArticleInfoDataTable;                          // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MeosiSlotItemArticleInfoDataTable;                 // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MeosiSlotMonsterArticleInfoDataTable;              // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             MonsterArticleInfoDataTable;                       // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             NpcArticleInfoDataTable;                           // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             OddEffectArticleInfoDataTable;                     // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             RenkeiArticleInfoDataTable;                        // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0xA0];                                      // 0x00A8(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString DebugMacroReplace(const class FString& InTextStr, const class UDataTable* LongestArticleInfoDataTable, const class UDataTable* LongestValueDataTable);
	bool GetDebugSettingInfoEnableFlag();
	EJackNounGender GetDebugSettingInfoGender();
	bool GetDebugSettingInfoLastIsSFlag();
	bool GetDebugSettingInfoListFlag();
	bool GetDebugSettingInfoLongerStringFlag();
	EJackPatchimType GetDebugSettingInfoPatchim();
	bool GetDebugSettingInfoPlrNounFlag();
	bool GetDebugSettingInfoProNounFlag();
	bool GetDebugSettingInfoSingleFlag();
	bool GetDebugSettingInfoSoloFlag();
	bool GetDebugSettingInfoVowelFlag();
	class FString MacroReplaceBP(const class FString& InTextStr, const TArray<struct FJackMessageArgumentData>& InArgs, bool bList);
	class FString MacroReplaceList(const class FString& InTextStr, bool bList);
	void SetDebugSettingInfoEnableFlag(bool Flag);
	void SetDebugSettingInfoGender(EJackNounGender Gender);
	void SetDebugSettingInfoLastIsSFlag(bool LastIsSFlag);
	void SetDebugSettingInfoListFlag(bool ListFlag);
	void SetDebugSettingInfoLongerStringFlag(bool Flag);
	void SetDebugSettingInfoPatchim(EJackPatchimType Patchim);
	void SetDebugSettingInfoPlrNounFlag(bool PlrNounFlag);
	void SetDebugSettingInfoProNounFlag(bool ProNounFlag);
	void SetDebugSettingInfoSingleFlag(bool SingleFlag);
	void SetDebugSettingInfoSoloFlag(bool SoloFlag);
	void SetDebugSettingInfoVowelFlag(bool VowelFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextMacroReplaceManager">();
	}
	static class UJackTextMacroReplaceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextMacroReplaceManager>();
	}
};
static_assert(alignof(UJackTextMacroReplaceManager) == 0x000008, "Wrong alignment on UJackTextMacroReplaceManager");
static_assert(sizeof(UJackTextMacroReplaceManager) == 0x000148, "Wrong size on UJackTextMacroReplaceManager");
static_assert(offsetof(UJackTextMacroReplaceManager, MacroInfoDataTable) == 0x000038, "Member 'UJackTextMacroReplaceManager::MacroInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, TagInfoDataTable) == 0x000040, "Member 'UJackTextMacroReplaceManager::TagInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, FixTagInfoDataTable) == 0x000048, "Member 'UJackTextMacroReplaceManager::FixTagInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, FrenchCheckVowelDataTable) == 0x000050, "Member 'UJackTextMacroReplaceManager::FrenchCheckVowelDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, GermanCaseChangeDataTable) == 0x000058, "Member 'UJackTextMacroReplaceManager::GermanCaseChangeDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, GermanCheckLastIsSDataTable) == 0x000060, "Member 'UJackTextMacroReplaceManager::GermanCheckLastIsSDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, ActionArticleInfoDataTable) == 0x000068, "Member 'UJackTextMacroReplaceManager::ActionArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, ItemArticleInfoDataTable) == 0x000070, "Member 'UJackTextMacroReplaceManager::ItemArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, MeosiSlotItemArticleInfoDataTable) == 0x000078, "Member 'UJackTextMacroReplaceManager::MeosiSlotItemArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, MeosiSlotMonsterArticleInfoDataTable) == 0x000080, "Member 'UJackTextMacroReplaceManager::MeosiSlotMonsterArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, MonsterArticleInfoDataTable) == 0x000088, "Member 'UJackTextMacroReplaceManager::MonsterArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, NpcArticleInfoDataTable) == 0x000090, "Member 'UJackTextMacroReplaceManager::NpcArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, OddEffectArticleInfoDataTable) == 0x000098, "Member 'UJackTextMacroReplaceManager::OddEffectArticleInfoDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextMacroReplaceManager, RenkeiArticleInfoDataTable) == 0x0000A0, "Member 'UJackTextMacroReplaceManager::RenkeiArticleInfoDataTable' has a wrong offset!");

// Class JackGame.JackCutSceneController
// 0x0280 (0x0618 - 0x0398)
class AJackCutSceneController final : public AActor
{
public:
	UMulticastDelegateProperty_                   CloseRequestDelegate;                              // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayedCutSceneID;                                  // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C0[0xB0];                                     // 0x03C0(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackStreamObjectsHolder*>       MaterialStreamObjectsHolders;                      // 0x0470(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x198];                                    // 0x0480(0x0198)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginCutSceneAllPlay();
	void DebugAutoSendCaption(bool bEnable);
	void DebugAutoSendInterval(float Interval);
	void DebugAutoSkipCaption(bool bEnable);
	void EndCutSceneAllPlay();
	float GetMatineeWindAngle();
	EJackWorldWindLevel GetMatineeWindLevel();
	void InitializeCutSceneSystem(class FName CutSceneID);
	void LatentSetupMatineeActor(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class AMatineeActor* MatineeActor);
	void OnSkipAction(EJackUMGCutSceneSkipEvent InSkipEventType, bool bIsFlag);
	void PostCutSceneStop();
	void PreCutScenePlay();
	void ReleaseMatineeActor(class AMatineeActor* MatineeActor);
	void RequestDisableInactiveForParticle(const TArray<class AActor*>& ActorList);
	void RequestHighQualityTextureActors(const TArray<class AActor*>& ActorList);
	void RequestMovieVolumeFadeOut(float FadeTime);
	void RequestWaitLoadTextureActors(const TArray<class AActor*>& ActorList);
	void SetDebugDisableFixedDynamicResolutionFlagEnable(bool bEnable);
	void SetDebugJumpFlag(bool bEnable);
	void SetDebugTraceDynamicResolutionLogEnable(bool bEnable);
	void SetDebugTracePerformanceLogEnable(bool bEnable);
	void SetupMatineeActor(class AMatineeActor* MatineeActor);
	void TerminateCutSceneSystem();
	void TraceCutSceneMatineeInfo();

	float GetMoviePlayTime() const;
	bool IsDebugDisableFixedDynamicResolutionFlagEnable() const;
	bool IsDebugJump() const;
	bool IsDebugTraceDynamicResolutionLogEnable() const;
	bool IsDebugTracePerformanceLogEnable() const;
	bool IsSetupMatineeActorCompleted() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCutSceneController">();
	}
	static class AJackCutSceneController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCutSceneController>();
	}
};
static_assert(alignof(AJackCutSceneController) == 0x000008, "Wrong alignment on AJackCutSceneController");
static_assert(sizeof(AJackCutSceneController) == 0x000618, "Wrong size on AJackCutSceneController");
static_assert(offsetof(AJackCutSceneController, CloseRequestDelegate) == 0x000398, "Member 'AJackCutSceneController::CloseRequestDelegate' has a wrong offset!");
static_assert(offsetof(AJackCutSceneController, PlayedCutSceneID) == 0x0003B8, "Member 'AJackCutSceneController::PlayedCutSceneID' has a wrong offset!");
static_assert(offsetof(AJackCutSceneController, MaterialStreamObjectsHolders) == 0x000470, "Member 'AJackCutSceneController::MaterialStreamObjectsHolders' has a wrong offset!");

// Class JackGame.JackBattleCommandAIControlComponent
// 0x0018 (0x0140 - 0x0128)
class UJackBattleCommandAIControlComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x18];                                     // 0x0128(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAIControlComponent">();
	}
	static class UJackBattleCommandAIControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCommandAIControlComponent>();
	}
};
static_assert(alignof(UJackBattleCommandAIControlComponent) == 0x000008, "Wrong alignment on UJackBattleCommandAIControlComponent");
static_assert(sizeof(UJackBattleCommandAIControlComponent) == 0x000140, "Wrong size on UJackBattleCommandAIControlComponent");

// Class JackGame.JackBattleCommandAIManager
// 0x00A0 (0x00D8 - 0x0038)
class UJackBattleCommandAIManager final : public UObject
{
public:
	uint8                                         Pad_38[0xA0];                                      // 0x0038(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleCommandAIManager">();
	}
	static class UJackBattleCommandAIManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleCommandAIManager>();
	}
};
static_assert(alignof(UJackBattleCommandAIManager) == 0x000008, "Wrong alignment on UJackBattleCommandAIManager");
static_assert(sizeof(UJackBattleCommandAIManager) == 0x0000D8, "Wrong size on UJackBattleCommandAIManager");

// Class JackGame.JackCoordSoundDisableTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackCoordSoundDisableTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   AttachGroupName;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoordSoundDisableTrack">();
	}
	static class UJackCoordSoundDisableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCoordSoundDisableTrack>();
	}
};
static_assert(alignof(UJackCoordSoundDisableTrack) == 0x000008, "Wrong alignment on UJackCoordSoundDisableTrack");
static_assert(sizeof(UJackCoordSoundDisableTrack) == 0x0000B0, "Wrong size on UJackCoordSoundDisableTrack");
static_assert(offsetof(UJackCoordSoundDisableTrack, AttachGroupName) == 0x0000A8, "Member 'UJackCoordSoundDisableTrack::AttachGroupName' has a wrong offset!");

// Class JackGame.JackBattleEncountParameter
// 0x0030 (0x0068 - 0x0038)
class UJackBattleEncountParameter : public UObject
{
public:
	float                                         PlayerBaseValue;                                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerKiyousaRate;                                 // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeStandbyMember;                             // 0x0040(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MonsterThroughLevelValue;                          // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterUpLevelValue;                               // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterCorrectionValue;                            // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MonsterBaseValue;                                  // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackPreemptiveStrikePersons>   PreemptiveStrikePersonsProbability;                // 0x0058(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleEncountParameter">();
	}
	static class UJackBattleEncountParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleEncountParameter>();
	}
};
static_assert(alignof(UJackBattleEncountParameter) == 0x000008, "Wrong alignment on UJackBattleEncountParameter");
static_assert(sizeof(UJackBattleEncountParameter) == 0x000068, "Wrong size on UJackBattleEncountParameter");
static_assert(offsetof(UJackBattleEncountParameter, PlayerBaseValue) == 0x000038, "Member 'UJackBattleEncountParameter::PlayerBaseValue' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, PlayerKiyousaRate) == 0x00003C, "Member 'UJackBattleEncountParameter::PlayerKiyousaRate' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, bIncludeStandbyMember) == 0x000040, "Member 'UJackBattleEncountParameter::bIncludeStandbyMember' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, MonsterThroughLevelValue) == 0x000044, "Member 'UJackBattleEncountParameter::MonsterThroughLevelValue' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, MonsterUpLevelValue) == 0x000048, "Member 'UJackBattleEncountParameter::MonsterUpLevelValue' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, MonsterCorrectionValue) == 0x00004C, "Member 'UJackBattleEncountParameter::MonsterCorrectionValue' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, MonsterBaseValue) == 0x000050, "Member 'UJackBattleEncountParameter::MonsterBaseValue' has a wrong offset!");
static_assert(offsetof(UJackBattleEncountParameter, PreemptiveStrikePersonsProbability) == 0x000058, "Member 'UJackBattleEncountParameter::PreemptiveStrikePersonsProbability' has a wrong offset!");

// Class JackGame.JackBattleEventInterface
// 0x0000 (0x0038 - 0x0038)
class IJackBattleEventInterface final : public IInterface
{
public:
	void BootEventBattle(class FName EventBattleID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleEventInterface">();
	}
	static class IJackBattleEventInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJackBattleEventInterface>();
	}
};
static_assert(alignof(IJackBattleEventInterface) == 0x000008, "Wrong alignment on IJackBattleEventInterface");
static_assert(sizeof(IJackBattleEventInterface) == 0x000038, "Wrong size on IJackBattleEventInterface");

// Class JackGame.JackBattleFieldGenerator
// 0x0098 (0x0430 - 0x0398)
class AJackBattleFieldGenerator : public AActor
{
public:
	UMulticastDelegateProperty_                   OnCheckActive;                                     // 0x0398(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleStart;                                     // 0x03A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleEnd;                                       // 0x03B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x03C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleFieldRadius;                                 // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bHiddenGrass;                                      // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLowAngleCameraInvalid;                            // 0x03D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D2[0x6];                                      // 0x03D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AVolume*>                        ActiveVolumeArray;                                 // 0x03D8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E8[0x10];                                     // 0x03E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBattleFieldPermitVolumeInfo> PermitVolumeInfoArray;                             // 0x03F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bPinpointLocatorEnable;                            // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_409[0x3];                                      // 0x0409(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackLocator>            PinpointLocator;                                   // 0x040C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_414[0x4];                                      // 0x0414(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AJackBattleFieldGenerator_BlockingVolume*> BlockingVolumeArray;                               // 0x0418(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	bool                                          bActiveInvalid;                                    // 0x0428(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BattleStartDelegate__DelegateSignature(int32 PermitIndex);
	void Delegate__DelegateSignature();
	void UpdateBlockingVolumeNavMesh();

	bool CalcBattleFieldLocation(struct FVector* OutLocation, struct FVector* OutDirection, int32* OutPermitIdex, class AVolume** OutPermitVolume, const struct FVector& InLocation, const struct FVector& InDirection, bool bCalcDirection) const;
	bool CalcPermitVolumeNearestPoint(struct FVector* OutNearestPoint, float* OutDistanceToPoint, struct FJackBattleFieldPermitVolumeInfo* OutPermitVolumeInfo, int32* OutPermitIndex, class AVolume** OutPermitVolume, const struct FVector& Point) const;
	TArray<class AVolume*> GetActiveVolumeArray() const;
	TArray<class AJackBattleFieldGenerator_BlockingVolume*> GetBlockingVolumeArray(int32 PermitIndex) const;
	TArray<class AVolume*> GetPermitVolumeArray() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleFieldGenerator">();
	}
	static class AJackBattleFieldGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleFieldGenerator>();
	}
};
static_assert(alignof(AJackBattleFieldGenerator) == 0x000008, "Wrong alignment on AJackBattleFieldGenerator");
static_assert(sizeof(AJackBattleFieldGenerator) == 0x000430, "Wrong size on AJackBattleFieldGenerator");
static_assert(offsetof(AJackBattleFieldGenerator, OnCheckActive) == 0x000398, "Member 'AJackBattleFieldGenerator::OnCheckActive' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, OnBattleStart) == 0x0003A8, "Member 'AJackBattleFieldGenerator::OnBattleStart' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, OnBattleEnd) == 0x0003B8, "Member 'AJackBattleFieldGenerator::OnBattleEnd' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, Priority) == 0x0003C8, "Member 'AJackBattleFieldGenerator::Priority' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, BattleFieldRadius) == 0x0003CC, "Member 'AJackBattleFieldGenerator::BattleFieldRadius' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, bHiddenGrass) == 0x0003D0, "Member 'AJackBattleFieldGenerator::bHiddenGrass' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, bLowAngleCameraInvalid) == 0x0003D1, "Member 'AJackBattleFieldGenerator::bLowAngleCameraInvalid' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, ActiveVolumeArray) == 0x0003D8, "Member 'AJackBattleFieldGenerator::ActiveVolumeArray' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, PermitVolumeInfoArray) == 0x0003F8, "Member 'AJackBattleFieldGenerator::PermitVolumeInfoArray' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, bPinpointLocatorEnable) == 0x000408, "Member 'AJackBattleFieldGenerator::bPinpointLocatorEnable' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, PinpointLocator) == 0x00040C, "Member 'AJackBattleFieldGenerator::PinpointLocator' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, BlockingVolumeArray) == 0x000418, "Member 'AJackBattleFieldGenerator::BlockingVolumeArray' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldGenerator, bActiveInvalid) == 0x000428, "Member 'AJackBattleFieldGenerator::bActiveInvalid' has a wrong offset!");

// Class JackGame.JackBattleFieldGenerator_BlockingVolume
// 0x0000 (0x03E0 - 0x03E0)
class AJackBattleFieldGenerator_BlockingVolume : public ANavModifierVolume
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleFieldGenerator_BlockingVolume">();
	}
	static class AJackBattleFieldGenerator_BlockingVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleFieldGenerator_BlockingVolume>();
	}
};
static_assert(alignof(AJackBattleFieldGenerator_BlockingVolume) == 0x000008, "Wrong alignment on AJackBattleFieldGenerator_BlockingVolume");
static_assert(sizeof(AJackBattleFieldGenerator_BlockingVolume) == 0x0003E0, "Wrong size on AJackBattleFieldGenerator_BlockingVolume");

// Class JackGame.JackBattleFieldInfo
// 0x0030 (0x0068 - 0x0038)
class UJackBattleFieldInfo final : public UObject
{
public:
	struct FVector                                Location;                                          // 0x0038(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0044(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEscapeEnable;                                     // 0x0054(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackBattleFieldGenerator> Generator;                                         // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PermitIndex;                                       // 0x0060(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsInfinityBattleField() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleFieldInfo">();
	}
	static class UJackBattleFieldInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleFieldInfo>();
	}
};
static_assert(alignof(UJackBattleFieldInfo) == 0x000008, "Wrong alignment on UJackBattleFieldInfo");
static_assert(sizeof(UJackBattleFieldInfo) == 0x000068, "Wrong size on UJackBattleFieldInfo");
static_assert(offsetof(UJackBattleFieldInfo, Location) == 0x000038, "Member 'UJackBattleFieldInfo::Location' has a wrong offset!");
static_assert(offsetof(UJackBattleFieldInfo, Direction) == 0x000044, "Member 'UJackBattleFieldInfo::Direction' has a wrong offset!");
static_assert(offsetof(UJackBattleFieldInfo, Radius) == 0x000050, "Member 'UJackBattleFieldInfo::Radius' has a wrong offset!");
static_assert(offsetof(UJackBattleFieldInfo, bEscapeEnable) == 0x000054, "Member 'UJackBattleFieldInfo::bEscapeEnable' has a wrong offset!");
static_assert(offsetof(UJackBattleFieldInfo, Generator) == 0x000058, "Member 'UJackBattleFieldInfo::Generator' has a wrong offset!");
static_assert(offsetof(UJackBattleFieldInfo, PermitIndex) == 0x000060, "Member 'UJackBattleFieldInfo::PermitIndex' has a wrong offset!");

// Class JackGame.JackBattleFieldManager
// 0x0040 (0x03D8 - 0x0398)
class AJackBattleFieldManager : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDrawEnable;                                  // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDrawEnable_CalcProgram;                      // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDrawEnable_OuterEdgeCollision;               // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A3[0x1];                                      // 0x03A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BattleFieldRadius_Default;                         // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BattleFieldRadius_RangeExtinguish;                 // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCameraDirectionModeEnable;                        // 0x03AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AD[0x3];                                      // 0x03AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AJackBattleFieldGenerator>> BattleFieldGeneratorArray;                         // 0x03B0(0x0010)(Edit, ZeroConstructor, EditConst, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	float                                         GroundGradientAngle;                               // 0x03C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackBattleFieldInfo*                   BattleFieldInfo;                                   // 0x03C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  DebugBattleFieldCollisionActor;                    // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CalcBattleFieldLocationBP(class AJackBattleFieldGenerator** OutGenerator, int32* OutPermitIndex, class AVolume** OutPermitVolume, struct FVector* OutLocation, struct FVector* OutDirection, const struct FVector& EncountLocation, const struct FVector& EncountDirection, EJackBattleEncount EncountType, const class UJackEventBattleInfo* EncountEventBattleInfo, bool ErrorMessageFlag);
	void CalcBattleFieldRadiusBP(float* OutRadius, const class AJackBattleFieldGenerator* Generator, int32 PermitIndex, const class UJackEventBattleInfo* EventBattleInfo);
	void DisplayDebugInfoByBlueprint();
	void FinalizeDebugBattleFieldCollisionByBlueprint();
	TArray<class AJackBattleFieldGenerator*> GetBattleFieldGeneratorArray();

	struct FVector CalcEncountDirectionByBP(const class AJackCharacter* PlayerCharacter, const class AJackCharacter* MonsterCharacter) const;
	void DisplayDebugInfo_GeneratorInfo(const class AJackBattleFieldGenerator* Generator, const struct FVector& TextLocation, int32 PermitIndex, const class AVolume* PermitVolume, float BattleFieldRadius) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleFieldManager">();
	}
	static class AJackBattleFieldManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleFieldManager>();
	}
};
static_assert(alignof(AJackBattleFieldManager) == 0x000008, "Wrong alignment on AJackBattleFieldManager");
static_assert(sizeof(AJackBattleFieldManager) == 0x0003D8, "Wrong size on AJackBattleFieldManager");
static_assert(offsetof(AJackBattleFieldManager, bDebugDrawEnable) == 0x0003A0, "Member 'AJackBattleFieldManager::bDebugDrawEnable' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, bDebugDrawEnable_CalcProgram) == 0x0003A1, "Member 'AJackBattleFieldManager::bDebugDrawEnable_CalcProgram' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, bDebugDrawEnable_OuterEdgeCollision) == 0x0003A2, "Member 'AJackBattleFieldManager::bDebugDrawEnable_OuterEdgeCollision' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, BattleFieldRadius_Default) == 0x0003A4, "Member 'AJackBattleFieldManager::BattleFieldRadius_Default' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, BattleFieldRadius_RangeExtinguish) == 0x0003A8, "Member 'AJackBattleFieldManager::BattleFieldRadius_RangeExtinguish' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, bCameraDirectionModeEnable) == 0x0003AC, "Member 'AJackBattleFieldManager::bCameraDirectionModeEnable' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, BattleFieldGeneratorArray) == 0x0003B0, "Member 'AJackBattleFieldManager::BattleFieldGeneratorArray' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, GroundGradientAngle) == 0x0003C0, "Member 'AJackBattleFieldManager::GroundGradientAngle' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, BattleFieldInfo) == 0x0003C8, "Member 'AJackBattleFieldManager::BattleFieldInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleFieldManager, DebugBattleFieldCollisionActor) == 0x0003D0, "Member 'AJackBattleFieldManager::DebugBattleFieldCollisionActor' has a wrong offset!");

// Class JackGame.JackShadowRadiusThresholdTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackShadowRadiusThresholdTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackShadowRadiusThresholdTrack">();
	}
	static class UJackShadowRadiusThresholdTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackShadowRadiusThresholdTrack>();
	}
};
static_assert(alignof(UJackShadowRadiusThresholdTrack) == 0x000008, "Wrong alignment on UJackShadowRadiusThresholdTrack");
static_assert(sizeof(UJackShadowRadiusThresholdTrack) == 0x0000B0, "Wrong size on UJackShadowRadiusThresholdTrack");

// Class JackGame.JackDebugMenuVariableBool
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableBool final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool GetBool();
	void SetBool(bool NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableBool">();
	}
	static class UJackDebugMenuVariableBool* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableBool>();
	}
};
static_assert(alignof(UJackDebugMenuVariableBool) == 0x000008, "Wrong alignment on UJackDebugMenuVariableBool");
static_assert(sizeof(UJackDebugMenuVariableBool) == 0x000098, "Wrong size on UJackDebugMenuVariableBool");
static_assert(offsetof(UJackDebugMenuVariableBool, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableBool::ValueChanged' has a wrong offset!");

// Class JackGame.JackBattleFukidasiTalkManager
// 0x03F8 (0x0790 - 0x0398)
class AJackBattleFukidasiTalkManager final : public AActor
{
public:
	uint8                                         Pad_398[0x2F0];                                    // 0x0398(0x02F0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackBattleVoicePlayer*>         DirectVoicePlayers;                                // 0x0688(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_698[0xF8];                                     // 0x0698(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckRowMatch_Character(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_String(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TC(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TS(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TSC(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TSV(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TSVC(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TV(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_TVC(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_Type(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	bool CheckRowMatch_Value(const struct FJackBattleFukidasiTalkCondition& SrcCondition, const struct FJackBattleFukidasiTalkCommandInfo& InCommandInfo);
	void CloseScenarioFukidasi();
	class UTexture2D* GetFukidasiFaceIcon(class FName InName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleFukidasiTalkManager">();
	}
	static class AJackBattleFukidasiTalkManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleFukidasiTalkManager>();
	}
};
static_assert(alignof(AJackBattleFukidasiTalkManager) == 0x000008, "Wrong alignment on AJackBattleFukidasiTalkManager");
static_assert(sizeof(AJackBattleFukidasiTalkManager) == 0x000790, "Wrong size on AJackBattleFukidasiTalkManager");
static_assert(offsetof(AJackBattleFukidasiTalkManager, DirectVoicePlayers) == 0x000688, "Member 'AJackBattleFukidasiTalkManager::DirectVoicePlayers' has a wrong offset!");

// Class JackGame.JackBattleGroupManager
// 0x00A8 (0x00E0 - 0x0038)
class UJackBattleGroupManager final : public UObject
{
public:
	bool                                          bInitialized;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackBattleTroop>               Troops;                                            // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	class UJackBattleGroupParameter*              BattleGroupParameter;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, int32>                      PlacementOrder;                                    // 0x0058(0x0050)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x38];                                      // 0x00A8(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleGroupManager">();
	}
	static class UJackBattleGroupManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleGroupManager>();
	}
};
static_assert(alignof(UJackBattleGroupManager) == 0x000008, "Wrong alignment on UJackBattleGroupManager");
static_assert(sizeof(UJackBattleGroupManager) == 0x0000E0, "Wrong size on UJackBattleGroupManager");
static_assert(offsetof(UJackBattleGroupManager, bInitialized) == 0x000038, "Member 'UJackBattleGroupManager::bInitialized' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupManager, Troops) == 0x000040, "Member 'UJackBattleGroupManager::Troops' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupManager, BattleGroupParameter) == 0x000050, "Member 'UJackBattleGroupManager::BattleGroupParameter' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupManager, PlacementOrder) == 0x000058, "Member 'UJackBattleGroupManager::PlacementOrder' has a wrong offset!");

// Class JackGame.JackDepthOfFieldQualityTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackDepthOfFieldQualityTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDepthOfFieldQualityTrackInst">();
	}
	static class UJackDepthOfFieldQualityTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDepthOfFieldQualityTrackInst>();
	}
};
static_assert(alignof(UJackDepthOfFieldQualityTrackInst) == 0x000008, "Wrong alignment on UJackDepthOfFieldQualityTrackInst");
static_assert(sizeof(UJackDepthOfFieldQualityTrackInst) == 0x000040, "Wrong size on UJackDepthOfFieldQualityTrackInst");

// Class JackGame.JackBattleGroupParameter
// 0x01A0 (0x01D8 - 0x0038)
class UJackBattleGroupParameter : public UObject
{
public:
	struct FRotator                               FirstCameraAngle;                                  // 0x0038(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EJackBattleFirstCameraTarget                  FirstCameraTarget;                                 // 0x0044(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               PreparationCameraAngle;                            // 0x0048(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         PreparationCameraCheckCollisionRadius;             // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreparationCameraPositionLimitPitchAngle;          // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPreparationCameraPositionLimitCheckFeet;          // 0x005C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5D[0x1];                                       // 0x005D(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsFriendMoveCollisionCheck;                        // 0x005E(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleTurnDirection                      FriendsTurnDirection;                              // 0x005F(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendsLookAtDistance;                             // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendsLookAtAngle;                                // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendsBackMoveAngle;                              // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FriendsBackMoveLength;                             // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleTurnDirection                      EnemyTurnDirection;                                // 0x0070(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          EnemyTurn1To1Look;                                 // 0x0071(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72[0x2];                                       // 0x0072(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EnemyLookAtDistance;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyLookAtAngle;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsEnemyMoveCollisionCheck;                         // 0x007C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D[0x3];                                       // 0x007D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomEncountBattleFieldInfoRadius;                // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AlignmentDistanceRate;                             // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositioningAcceptRadiusRate;                       // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnStartAngle;                                    // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnEndAngle;                                      // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecliningBaselineLength;                           // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DecliningBaseMoveLength;                           // 0x0098(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroupSortMonsterAddOnly;                          // 0x009C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9D[0x3];                                       // 0x009D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackGroupFormations>           EnemyGroupFormation;                               // 0x00A0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FName, struct FJackGroupFormationsList> EventBattleEnemyGroupFormation;                    // 0x00B0(0x0050)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackGroupFormations>           PlayerGroupFormation;                              // 0x0100(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackGroupFormations>           PlayerGroupGuestFormation;                         // 0x0110(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackGroupFormations>           PlayerGroupFormationBySScenario;                   // 0x0120(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackGroupFormations>           PlayerGroupGuestFormationBySScenario;              // 0x0130(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackGroupGuestExceptionFormationInfo> PlayerGroupGuestExceptionFormation;                // 0x0140(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 GroupPlacedStartingPoint;                          // 0x0150(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         PlayerMinimumGroupScale;                           // 0x0160(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerMaxGroupScaleRate;                           // 0x0164(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyMinimumGroupScale;                            // 0x0168(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyMaxGroupScaleRate;                            // 0x016C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerGroupScaleInterval;                          // 0x0170(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerGroupScaleRate;                              // 0x0174(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyGroupScaleInterval;                           // 0x0178(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyGroupScaleRate;                               // 0x017C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleGroupAlignmentSequence             GroupAlignmentSequence;                            // 0x0180(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroupAutoAdjustment;                              // 0x0181(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_182[0x2];                                      // 0x0182(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         GroupAutoAdjustment_AddCheckNum;                   // 0x0184(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GroupAutoAdjustment_SufferRate;                    // 0x0188(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18C[0x4];                                      // 0x018C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 DummyAngleList;                                    // 0x0190(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         MinimumTroopScale;                                 // 0x01A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTroopScale;                                     // 0x01A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerTroopScalePadding;                           // 0x01A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerTroopScaleRate;                              // 0x01AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRandomLocationRange;                         // 0x01B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayerRandomLocationRangeSecurity;                 // 0x01B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyTroopScalePadding;                            // 0x01B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EnemyTroopScaleRate;                               // 0x01BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InitialPlacementWidth;                             // 0x01C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C4[0x4];                                      // 0x01C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackGroupID_Summarize>         GroupID_Summarize;                                 // 0x01C8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleGroupParameter">();
	}
	static class UJackBattleGroupParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleGroupParameter>();
	}
};
static_assert(alignof(UJackBattleGroupParameter) == 0x000008, "Wrong alignment on UJackBattleGroupParameter");
static_assert(sizeof(UJackBattleGroupParameter) == 0x0001D8, "Wrong size on UJackBattleGroupParameter");
static_assert(offsetof(UJackBattleGroupParameter, FirstCameraAngle) == 0x000038, "Member 'UJackBattleGroupParameter::FirstCameraAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FirstCameraTarget) == 0x000044, "Member 'UJackBattleGroupParameter::FirstCameraTarget' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PreparationCameraAngle) == 0x000048, "Member 'UJackBattleGroupParameter::PreparationCameraAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PreparationCameraCheckCollisionRadius) == 0x000054, "Member 'UJackBattleGroupParameter::PreparationCameraCheckCollisionRadius' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PreparationCameraPositionLimitPitchAngle) == 0x000058, "Member 'UJackBattleGroupParameter::PreparationCameraPositionLimitPitchAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, bPreparationCameraPositionLimitCheckFeet) == 0x00005C, "Member 'UJackBattleGroupParameter::bPreparationCameraPositionLimitCheckFeet' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, IsFriendMoveCollisionCheck) == 0x00005E, "Member 'UJackBattleGroupParameter::IsFriendMoveCollisionCheck' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FriendsTurnDirection) == 0x00005F, "Member 'UJackBattleGroupParameter::FriendsTurnDirection' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FriendsLookAtDistance) == 0x000060, "Member 'UJackBattleGroupParameter::FriendsLookAtDistance' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FriendsLookAtAngle) == 0x000064, "Member 'UJackBattleGroupParameter::FriendsLookAtAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FriendsBackMoveAngle) == 0x000068, "Member 'UJackBattleGroupParameter::FriendsBackMoveAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, FriendsBackMoveLength) == 0x00006C, "Member 'UJackBattleGroupParameter::FriendsBackMoveLength' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyTurnDirection) == 0x000070, "Member 'UJackBattleGroupParameter::EnemyTurnDirection' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyTurn1To1Look) == 0x000071, "Member 'UJackBattleGroupParameter::EnemyTurn1To1Look' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyLookAtDistance) == 0x000074, "Member 'UJackBattleGroupParameter::EnemyLookAtDistance' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyLookAtAngle) == 0x000078, "Member 'UJackBattleGroupParameter::EnemyLookAtAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, IsEnemyMoveCollisionCheck) == 0x00007C, "Member 'UJackBattleGroupParameter::IsEnemyMoveCollisionCheck' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, RandomEncountBattleFieldInfoRadius) == 0x000080, "Member 'UJackBattleGroupParameter::RandomEncountBattleFieldInfoRadius' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, AlignmentDistanceRate) == 0x000084, "Member 'UJackBattleGroupParameter::AlignmentDistanceRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PositioningAcceptRadiusRate) == 0x000088, "Member 'UJackBattleGroupParameter::PositioningAcceptRadiusRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, TurnStartAngle) == 0x00008C, "Member 'UJackBattleGroupParameter::TurnStartAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, TurnEndAngle) == 0x000090, "Member 'UJackBattleGroupParameter::TurnEndAngle' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, DecliningBaselineLength) == 0x000094, "Member 'UJackBattleGroupParameter::DecliningBaselineLength' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, DecliningBaseMoveLength) == 0x000098, "Member 'UJackBattleGroupParameter::DecliningBaseMoveLength' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, bGroupSortMonsterAddOnly) == 0x00009C, "Member 'UJackBattleGroupParameter::bGroupSortMonsterAddOnly' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyGroupFormation) == 0x0000A0, "Member 'UJackBattleGroupParameter::EnemyGroupFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EventBattleEnemyGroupFormation) == 0x0000B0, "Member 'UJackBattleGroupParameter::EventBattleEnemyGroupFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupFormation) == 0x000100, "Member 'UJackBattleGroupParameter::PlayerGroupFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupGuestFormation) == 0x000110, "Member 'UJackBattleGroupParameter::PlayerGroupGuestFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupFormationBySScenario) == 0x000120, "Member 'UJackBattleGroupParameter::PlayerGroupFormationBySScenario' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupGuestFormationBySScenario) == 0x000130, "Member 'UJackBattleGroupParameter::PlayerGroupGuestFormationBySScenario' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupGuestExceptionFormation) == 0x000140, "Member 'UJackBattleGroupParameter::PlayerGroupGuestExceptionFormation' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, GroupPlacedStartingPoint) == 0x000150, "Member 'UJackBattleGroupParameter::GroupPlacedStartingPoint' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerMinimumGroupScale) == 0x000160, "Member 'UJackBattleGroupParameter::PlayerMinimumGroupScale' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerMaxGroupScaleRate) == 0x000164, "Member 'UJackBattleGroupParameter::PlayerMaxGroupScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyMinimumGroupScale) == 0x000168, "Member 'UJackBattleGroupParameter::EnemyMinimumGroupScale' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyMaxGroupScaleRate) == 0x00016C, "Member 'UJackBattleGroupParameter::EnemyMaxGroupScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupScaleInterval) == 0x000170, "Member 'UJackBattleGroupParameter::PlayerGroupScaleInterval' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerGroupScaleRate) == 0x000174, "Member 'UJackBattleGroupParameter::PlayerGroupScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyGroupScaleInterval) == 0x000178, "Member 'UJackBattleGroupParameter::EnemyGroupScaleInterval' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyGroupScaleRate) == 0x00017C, "Member 'UJackBattleGroupParameter::EnemyGroupScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, GroupAlignmentSequence) == 0x000180, "Member 'UJackBattleGroupParameter::GroupAlignmentSequence' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, bGroupAutoAdjustment) == 0x000181, "Member 'UJackBattleGroupParameter::bGroupAutoAdjustment' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, GroupAutoAdjustment_AddCheckNum) == 0x000184, "Member 'UJackBattleGroupParameter::GroupAutoAdjustment_AddCheckNum' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, GroupAutoAdjustment_SufferRate) == 0x000188, "Member 'UJackBattleGroupParameter::GroupAutoAdjustment_SufferRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, DummyAngleList) == 0x000190, "Member 'UJackBattleGroupParameter::DummyAngleList' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, MinimumTroopScale) == 0x0001A0, "Member 'UJackBattleGroupParameter::MinimumTroopScale' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, MaxTroopScale) == 0x0001A4, "Member 'UJackBattleGroupParameter::MaxTroopScale' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerTroopScalePadding) == 0x0001A8, "Member 'UJackBattleGroupParameter::PlayerTroopScalePadding' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerTroopScaleRate) == 0x0001AC, "Member 'UJackBattleGroupParameter::PlayerTroopScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerRandomLocationRange) == 0x0001B0, "Member 'UJackBattleGroupParameter::PlayerRandomLocationRange' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, PlayerRandomLocationRangeSecurity) == 0x0001B4, "Member 'UJackBattleGroupParameter::PlayerRandomLocationRangeSecurity' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyTroopScalePadding) == 0x0001B8, "Member 'UJackBattleGroupParameter::EnemyTroopScalePadding' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, EnemyTroopScaleRate) == 0x0001BC, "Member 'UJackBattleGroupParameter::EnemyTroopScaleRate' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, InitialPlacementWidth) == 0x0001C0, "Member 'UJackBattleGroupParameter::InitialPlacementWidth' has a wrong offset!");
static_assert(offsetof(UJackBattleGroupParameter, GroupID_Summarize) == 0x0001C8, "Member 'UJackBattleGroupParameter::GroupID_Summarize' has a wrong offset!");

// Class JackGame.JackBattleInterruptActionManager
// 0x0070 (0x00A8 - 0x0038)
class UJackBattleInterruptActionManager final : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackBattleInterruptActionRequest*> BattleStartRequests;                               // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<class UJackBattleInterruptActionRequest*> RoundStartRequests;                                // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<class UJackBattleInterruptActionRequest*> TurnEndRequests;                                   // 0x0068(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	TArray<class UJackBattleInterruptActionRequest*> RoundEndRequests;                                  // 0x0078(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)
	EJackBattleInterruptActionTiming              PlayingTiming;                                     // 0x0088(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackActionExec>         PlayingActionExec;                                 // 0x008C(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJackBattleInterruptActionRequest> PlayingRequest;                                    // 0x0094(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         PlayingScene;                                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bPlayingStart;                                     // 0x00A0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleInterruptActionManager">();
	}
	static class UJackBattleInterruptActionManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleInterruptActionManager>();
	}
};
static_assert(alignof(UJackBattleInterruptActionManager) == 0x000008, "Wrong alignment on UJackBattleInterruptActionManager");
static_assert(sizeof(UJackBattleInterruptActionManager) == 0x0000A8, "Wrong size on UJackBattleInterruptActionManager");
static_assert(offsetof(UJackBattleInterruptActionManager, BattleStartRequests) == 0x000048, "Member 'UJackBattleInterruptActionManager::BattleStartRequests' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, RoundStartRequests) == 0x000058, "Member 'UJackBattleInterruptActionManager::RoundStartRequests' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, TurnEndRequests) == 0x000068, "Member 'UJackBattleInterruptActionManager::TurnEndRequests' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, RoundEndRequests) == 0x000078, "Member 'UJackBattleInterruptActionManager::RoundEndRequests' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, PlayingTiming) == 0x000088, "Member 'UJackBattleInterruptActionManager::PlayingTiming' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, PlayingActionExec) == 0x00008C, "Member 'UJackBattleInterruptActionManager::PlayingActionExec' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, PlayingRequest) == 0x000094, "Member 'UJackBattleInterruptActionManager::PlayingRequest' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, PlayingScene) == 0x00009C, "Member 'UJackBattleInterruptActionManager::PlayingScene' has a wrong offset!");
static_assert(offsetof(UJackBattleInterruptActionManager, bPlayingStart) == 0x0000A0, "Member 'UJackBattleInterruptActionManager::bPlayingStart' has a wrong offset!");

// Class JackGame.JackSibariManager
// 0x0020 (0x0058 - 0x0038)
class UJackSibariManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnSibariSettingModify;                             // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetSibariPlayFlag();
	void SetSibariPlayDisplayFlag(bool bFlag);
	void SetSibariPlayFlag(EJackSibari Type, bool bFlag);
	void SibariSettingModifyDelegate__DelegateSignature(EJackSibari Type, bool bFlag);

	const int32 GetSibariPlayCount() const;
	bool IsSibariPlayDisplayFlag() const;
	bool IsSibariPlayFlag(EJackSibari Type) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSibariManager">();
	}
	static class UJackSibariManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSibariManager>();
	}
};
static_assert(alignof(UJackSibariManager) == 0x000008, "Wrong alignment on UJackSibariManager");
static_assert(sizeof(UJackSibariManager) == 0x000058, "Wrong size on UJackSibariManager");
static_assert(offsetof(UJackSibariManager, OnSibariSettingModify) == 0x000038, "Member 'UJackSibariManager::OnSibariSettingModify' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableInt
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableInt final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	int32 GetInt();
	void SetInt(int32 NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableInt">();
	}
	static class UJackDebugMenuVariableInt* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableInt>();
	}
};
static_assert(alignof(UJackDebugMenuVariableInt) == 0x000008, "Wrong alignment on UJackDebugMenuVariableInt");
static_assert(sizeof(UJackDebugMenuVariableInt) == 0x000098, "Wrong size on UJackDebugMenuVariableInt");
static_assert(offsetof(UJackDebugMenuVariableInt, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableInt::ValueChanged' has a wrong offset!");

// Class JackGame.JackBattleLockOn
// 0x00F8 (0x0130 - 0x0038)
class UJackBattleLockOn final : public UObject
{
public:
	uint8                                         Pad_38[0xE8];                                      // 0x0038(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          OwnerCharacter;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_129[0x7];                                      // 0x0129(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleLockOn">();
	}
	static class UJackBattleLockOn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleLockOn>();
	}
};
static_assert(alignof(UJackBattleLockOn) == 0x000008, "Wrong alignment on UJackBattleLockOn");
static_assert(sizeof(UJackBattleLockOn) == 0x000130, "Wrong size on UJackBattleLockOn");
static_assert(offsetof(UJackBattleLockOn, OwnerCharacter) == 0x000120, "Member 'UJackBattleLockOn::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleLockOn, bInitialized) == 0x000128, "Member 'UJackBattleLockOn::bInitialized' has a wrong offset!");

// Class JackGame.JackBattleManager
// 0x0538 (0x08D0 - 0x0398)
class AJackBattleManager : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugFlag_DrawBattleGroup;                        // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawBattleStateInfo;                    // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawRoundInfo;                          // 0x03A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawActionInfo;                         // 0x03A3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawZoneInfo;                           // 0x03A4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawCollisionInfo;                      // 0x03A5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawTeleportInfo;                       // 0x03A6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawVoiceInfo;                          // 0x03A7(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawCharaStatusInfo;                    // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawCharaStateInfo;                     // 0x03A9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawBattleCommandAIInfo;                // 0x03AA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawCharaMovementInfo;                  // 0x03AB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawEventBattleInfo;                    // 0x03AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawCalcInfo;                           // 0x03AD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFlag_DrawCalcInfoIgnoreRefCount;              // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawNakamaYobiInfo;                     // 0x03B4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawActionExtentInfo;                   // 0x03B5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawBattleTextInfo;                     // 0x03B6(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B7[0x1];                                      // 0x03B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFlag_DrawBattleFukidasiInfo;                  // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_BattleFukidasiForce;                     // 0x03BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DebugFlag_BattleFukidasiForceID;                   // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DrawPositioningInfo;                    // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_MonsterNigeru;                          // 0x03C9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFlag_TurnSkip;                                // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_SenseiKougeki;                           // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Nigeru;                                  // 0x03D4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Critical;                                // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Miss;                                    // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Mikawasi;                                // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_TateGuard;                               // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_BukiGuard;                               // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Counter;                                 // 0x03EC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_OddEffect;                               // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_Mitoreru;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_ToubatuEffect;                           // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_HazukasiiNoroi;                          // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_HazukasiiNoroiText;                      // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackHitStopPresetType                        DebugFlag_HitStopPresetType;                       // 0x0404(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_405[0x3];                                      // 0x0405(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFlag_PositioningPlayer;                       // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_PositioningMonster;                      // 0x040C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_BattleFieldHiddenGrass;                  // 0x0410(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_BattleFieldLowAngleCameraInvalid;        // 0x0414(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_ResultSkip;                             // 0x0418(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DropCertainty;                          // 0x0419(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_RareDropCertainty;                      // 0x041A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DropLogOutput;                          // 0x041B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_Drop2000Lottery;                        // 0x041C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_Win;                                    // 0x041D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_Lose;                                   // 0x041E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_DisablePopupBalloon;                    // 0x041F(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_ActionCameraInfo;                       // 0x0420(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugFlag_AutoCameraInfo;                          // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_AutoCameraParam;                         // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugFlag_DistantBranch;                           // 0x042C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_AIFirstCheck;                           // 0x0430(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_AISecondCheck;                          // 0x0431(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_AIFirstCheckLogShow;                    // 0x0432(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_AISecondCheckLogShow;                   // 0x0433(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_PlayerAIDrawCalcInfo;                   // 0x0434(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_PlayerAIFlowTest;                       // 0x0435(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_PlayerAIFlowLogShow;                    // 0x0436(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_PlayerAIFlowBossBattle;                 // 0x0437(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_PlayerAIScoreCheckLogShow;              // 0x0438(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_MonsterAppearSkip;                      // 0x0439(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_MonsterAppearDrawBox;                   // 0x043A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_BattlePreparationCameraDraw;            // 0x043B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugFlag_MonsterSpawnNear;                       // 0x043C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43D[0x3];                                      // 0x043D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Debug_FixDamage;                                   // 0x0440(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_444[0x4];                                      // 0x0444(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DebugBattleCommandAI_ActionPatternSlotIDs;         // 0x0448(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, NativeAccessSpecifierPublic)
	class FName                                   BattleTextCaster;                                  // 0x0458(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BattleTextTarget;                                  // 0x0460(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleTextDamage;                                  // 0x0468(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEncount_InvalidByDebugCmd;                        // 0x046C(0x0001)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEncount_InvalidByBPDebug;                         // 0x046D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleEncount                            Encount_Type;                                      // 0x046E(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46F[0x1];                                      // 0x046F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Encount_Location;                                  // 0x0470(0x000C)(Edit, BlueprintVisible, BlueprintReadOnly, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AJackMonsterCharacter>   Encount_MonsterCharacter;                          // 0x047C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Encount_IntervalSeconds;                           // 0x0484(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Encount_IntervalSecondsWork;                       // 0x0488(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UJackEventBattleInfo>    Encount_EventBattleInfo;                           // 0x048C(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattlePreemptiveAttack                   Encount_PreemptiveAttack;                          // 0x0494(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Encount_Attack;                                    // 0x0495(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_496[0x2];                                      // 0x0496(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackBattleEncountParameter*            EncountParameter;                                  // 0x0498(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Validation_LockOnMovementTest;                     // 0x04A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleMonsterNumLimit;                             // 0x04A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleEndMessageStableWaitTime;                    // 0x04A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleMessageDisplayTime_Normal;                   // 0x04AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleMessageDisplayTime_2Line;                    // 0x04B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BattleMessageDisplayTime_Skip;                     // 0x04B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsheathePreWaitTimeRandomMin;                     // 0x04B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnsheathePreWaitTimeRandomMax;                     // 0x04BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleStatus*                      BattleStatus;                                      // 0x04C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleResultInfo*                  BattleResultInfo;                                  // 0x04C8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleCharacterManager*            BattleCharacterManager;                            // 0x04D0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleGroupManager*                BattleGroupManager;                                // 0x04D8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AJackBattleFieldManager*                BattleFieldManager;                                // 0x04E0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleInterruptActionManager*      BattleInterruptActionManager;                      // 0x04E8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleTurnManager*                 BattleTurnManager;                                 // 0x04F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleCameraManager*               BattleCameraManager;                               // 0x04F8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleSelectionEffect*             BattleSelectionEffect;                             // 0x0500(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackHitStop*                           HitStop;                                           // 0x0508(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleParameter*                   BattleParameter;                                   // 0x0510(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleZoneParameter*               ZoneParameter;                                     // 0x0518(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleCommandAIManager*            BattleCommandAIManager;                            // 0x0520(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AJackBattleFukidasiTalkManager*         BattleFukidasiTalkManager;                         // 0x0528(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleInitialize;                                // 0x0530(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCrashEffectStart;                                // 0x0540(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattlePostInitialize;                            // 0x0550(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnMonsterAppearStart;                              // 0x0560(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleStart;                                     // 0x0570(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleTurnStart;                                 // 0x0580(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleTurnPostActionExit;                        // 0x0590(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRoundEndInterruptCheck;                          // 0x05A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnRoundEnd;                                        // 0x05B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnActionHitComplete;                               // 0x05C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishBlow;                                      // 0x05D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleEnd;                                       // 0x05E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResultStart;                                     // 0x05F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnResultCameraStart;                               // 0x0600(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleExitStart;                                 // 0x0610(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleFinalize;                                  // 0x0620(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleFieldEffectChange;                         // 0x0630(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleCameraStartDelegate;                       // 0x0640(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnBattleCameraEndDelegate;                         // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, BlueprintCallable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPrgCameraSetupDelegate;                          // 0x0660(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPrgCameraStartDelegate;                          // 0x0670(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPrgCameraEndDelegate;                            // 0x0680(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_690[0x140];                                    // 0x0690(0x0140)(Fixing Size After Last Property [ Dumper-7 ])
	class AJackBattleMonsterAppear*               MonsterAppear;                                     // 0x07D0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackBattleResultSequence*              ResultSequence;                                    // 0x07D8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackBattleVoiceResourceChanger*        BattleVoiceResourceChanger;                        // 0x07E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackBattleToubatuEffect> ToubatuEffect;                                     // 0x07E8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackBattleMemberChange> MemberChange;                                      // 0x07F0(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AJackBattleNigeruSequence> NigeruSequence;                                    // 0x07F8(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<EJackBattleAdditionalResourceType, class UJackStreamObjectsHolder*> AdditionalResourceObjectsHolders;                  // 0x0800(0x0050)(Edit, ZeroConstructor, Transient, EditConst, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackBattleMemberChange>    MemberChangeClass;                                 // 0x0850(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackBattleFieldManager>    BattleFieldManagerClass;                           // 0x0858(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     CriticalKaisinEffectClass;                         // 0x0860(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     CriticalTuukonEffectClass;                         // 0x0868(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     JumonBousouEffectClass;                            // 0x0870(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackBattleToubatuEffect>   ToubatuEffectClass;                                // 0x0878(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackBattleParameter>       BattleParameterClass;                              // 0x0880(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackBattleZoneParameter>   ZoneParameterClass;                                // 0x0888(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackBattleEncountParameter> EncountParameterClass;                             // 0x0890(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackHitStop>               HitStopClass;                                      // 0x0898(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     TreasureBoxBattleClass;                            // 0x08A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     TreasureBoxRareBattleClass;                        // 0x08A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackBattleNavigationQueryFilterDict> NavigationQueryFilters;                            // 0x08B0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class AActor>                     OddEffectDokuPostProcessClass;                     // 0x08C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FieldDokuDamageInterval;                           // 0x08C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FieldDokuTurnSec;                                  // 0x08CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void BattleActionHitCompleteDelegate__DelegateSignature(const struct FJackActionResult& ActionResult, const class AJackActionExec* ActionExec);
	void BattleCameraEndDelegate__DelegateSignature(EJackBattleCameraCategory BattleCameraCategory);
	void BattleCameraStartDelegate__DelegateSignature(EJackBattleCameraCategory BattleCameraCategory);
	void BattleFieldEffectChangeDelegate__DelegateSignature(EJackBattleFieldEffectStatus InStatus, bool InEnable);
	void BattleFinishBlowDelegate__DelegateSignature(EJackBattleResult ResultType);
	void BattleInitializeDelegate__DelegateSignature(const struct FJackCommandBattleInitialize& InCommand);
	void BattleSimpleDelegate__DelegateSignature();
	void BattleTurnPostActionExitDelegate__DelegateSignature(class UJackGameCharacter* InTurnGameCharacter);
	void BattleTurnStartDelegate__DelegateSignature(class UJackGameCharacter* TurnGameCharacter, bool bRootTurn);
	TArray<class AJackCharacter*> GetBattleHiddenMonsterCharacters(const struct FVector& CenterLocation, float Radius, float HalfHeight, const TArray<class AJackCharacter*>& ActorsToIgnore);
	class UJackBattleNigeruComponent* GetBattleNigeruComponent();
	class UJackBattleParameter* GetBattleParameter();
	void MonsterAppearParameterInitialize();
	void OnActionHitCompleteFunction(const struct FJackActionResult& ActionResult, const class AJackActionExec* ActionExec);
	void OnBattleEndComplete();
	void OnBattleExitStartComplete();
	void OnBattleFinalizeComplete();
	void OnBattleInitializeComplete();
	void OnBattlePostInitializeBPComplete();
	void OnBattlePostInitializeComplete();
	void OnBattleStartComplete();
	void OnCrashEffectComplete();
	void OnMonsterAppearComplete();
	void OnResultStartComplete();
	void PlayEventBattleInSe();
	void SetFoliageDitherBattleField(EJackBattleFoliageDitherBattleFieldType FoliageDitherBattleFieldType);
	void SetFoliageDitherBattleFieldDirect(const struct FVector& DitherLocation, float DitherBounds);
	void SetFoliageDitherRange(EJackBattleFoliageDitherRangeType FoliageDitherRangeType);
	void SetFoliageDitherRangeDirect(float DitherRange);
	void SetHiddenInBattleField(class AJackCharacter* InCharacter, bool bInHidden);
	bool SetTroopLocation(const struct FVector& InLocation, const EJackMight MightType);

	bool CheckToubatuMonster(class FName MonsterID, class FName ActionID, class FName RenkeiID) const;
	bool CheckUsedRenkei(class FName RenkeiID) const;
	class UJackBattleStatus* GetBattleStatusBP() const;
	class AJackCharacter* GetControlCharacter() const;
	EJackFadeColor GetEndFadeColor() const;
	float GetEndFadeOutDefaultTimeByOther() const;
	float GetEndFadeOutDefaultTimeByWin() const;
	float GetEndFadeTime() const;
	class UMaterialParameterCollection* GetEnvParamMaterialParameterCollection() const;
	class FName GetHiddenExclusionTag() const;
	EJackFadeColor GetStartFadeColor() const;
	float GetStartFadeTime() const;
	bool IsBattleFieldNigeruInvalid() const;
	bool IsEncountable(bool bCheckFieldAttack) const;
	bool IsInBattle(bool bCheckAllSequence) const;
	bool IsNigeruEnable() const;
	bool IsSimpleCameraMode() const;
	bool IsToubatuEffectEnable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleManager">();
	}
	static class AJackBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleManager>();
	}
};
static_assert(alignof(AJackBattleManager) == 0x000008, "Wrong alignment on AJackBattleManager");
static_assert(sizeof(AJackBattleManager) == 0x0008D0, "Wrong size on AJackBattleManager");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawBattleGroup) == 0x0003A0, "Member 'AJackBattleManager::bDebugFlag_DrawBattleGroup' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawBattleStateInfo) == 0x0003A1, "Member 'AJackBattleManager::bDebugFlag_DrawBattleStateInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawRoundInfo) == 0x0003A2, "Member 'AJackBattleManager::bDebugFlag_DrawRoundInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawActionInfo) == 0x0003A3, "Member 'AJackBattleManager::bDebugFlag_DrawActionInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawZoneInfo) == 0x0003A4, "Member 'AJackBattleManager::bDebugFlag_DrawZoneInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawCollisionInfo) == 0x0003A5, "Member 'AJackBattleManager::bDebugFlag_DrawCollisionInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawTeleportInfo) == 0x0003A6, "Member 'AJackBattleManager::bDebugFlag_DrawTeleportInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawVoiceInfo) == 0x0003A7, "Member 'AJackBattleManager::bDebugFlag_DrawVoiceInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawCharaStatusInfo) == 0x0003A8, "Member 'AJackBattleManager::bDebugFlag_DrawCharaStatusInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawCharaStateInfo) == 0x0003A9, "Member 'AJackBattleManager::bDebugFlag_DrawCharaStateInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawBattleCommandAIInfo) == 0x0003AA, "Member 'AJackBattleManager::bDebugFlag_DrawBattleCommandAIInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawCharaMovementInfo) == 0x0003AB, "Member 'AJackBattleManager::bDebugFlag_DrawCharaMovementInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawEventBattleInfo) == 0x0003AC, "Member 'AJackBattleManager::bDebugFlag_DrawEventBattleInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawCalcInfo) == 0x0003AD, "Member 'AJackBattleManager::bDebugFlag_DrawCalcInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_DrawCalcInfoIgnoreRefCount) == 0x0003B0, "Member 'AJackBattleManager::DebugFlag_DrawCalcInfoIgnoreRefCount' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawNakamaYobiInfo) == 0x0003B4, "Member 'AJackBattleManager::bDebugFlag_DrawNakamaYobiInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawActionExtentInfo) == 0x0003B5, "Member 'AJackBattleManager::bDebugFlag_DrawActionExtentInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawBattleTextInfo) == 0x0003B6, "Member 'AJackBattleManager::bDebugFlag_DrawBattleTextInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_DrawBattleFukidasiInfo) == 0x0003B8, "Member 'AJackBattleManager::DebugFlag_DrawBattleFukidasiInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_BattleFukidasiForce) == 0x0003BC, "Member 'AJackBattleManager::DebugFlag_BattleFukidasiForce' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_BattleFukidasiForceID) == 0x0003C0, "Member 'AJackBattleManager::DebugFlag_BattleFukidasiForceID' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DrawPositioningInfo) == 0x0003C8, "Member 'AJackBattleManager::bDebugFlag_DrawPositioningInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_MonsterNigeru) == 0x0003C9, "Member 'AJackBattleManager::bDebugFlag_MonsterNigeru' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_TurnSkip) == 0x0003CC, "Member 'AJackBattleManager::DebugFlag_TurnSkip' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_SenseiKougeki) == 0x0003D0, "Member 'AJackBattleManager::DebugFlag_SenseiKougeki' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Nigeru) == 0x0003D4, "Member 'AJackBattleManager::DebugFlag_Nigeru' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Critical) == 0x0003D8, "Member 'AJackBattleManager::DebugFlag_Critical' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Miss) == 0x0003DC, "Member 'AJackBattleManager::DebugFlag_Miss' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Mikawasi) == 0x0003E0, "Member 'AJackBattleManager::DebugFlag_Mikawasi' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_TateGuard) == 0x0003E4, "Member 'AJackBattleManager::DebugFlag_TateGuard' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_BukiGuard) == 0x0003E8, "Member 'AJackBattleManager::DebugFlag_BukiGuard' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Counter) == 0x0003EC, "Member 'AJackBattleManager::DebugFlag_Counter' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_OddEffect) == 0x0003F0, "Member 'AJackBattleManager::DebugFlag_OddEffect' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_Mitoreru) == 0x0003F4, "Member 'AJackBattleManager::DebugFlag_Mitoreru' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_ToubatuEffect) == 0x0003F8, "Member 'AJackBattleManager::DebugFlag_ToubatuEffect' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_HazukasiiNoroi) == 0x0003FC, "Member 'AJackBattleManager::DebugFlag_HazukasiiNoroi' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_HazukasiiNoroiText) == 0x000400, "Member 'AJackBattleManager::DebugFlag_HazukasiiNoroiText' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_HitStopPresetType) == 0x000404, "Member 'AJackBattleManager::DebugFlag_HitStopPresetType' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_PositioningPlayer) == 0x000408, "Member 'AJackBattleManager::DebugFlag_PositioningPlayer' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_PositioningMonster) == 0x00040C, "Member 'AJackBattleManager::DebugFlag_PositioningMonster' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_BattleFieldHiddenGrass) == 0x000410, "Member 'AJackBattleManager::DebugFlag_BattleFieldHiddenGrass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_BattleFieldLowAngleCameraInvalid) == 0x000414, "Member 'AJackBattleManager::DebugFlag_BattleFieldLowAngleCameraInvalid' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_ResultSkip) == 0x000418, "Member 'AJackBattleManager::bDebugFlag_ResultSkip' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DropCertainty) == 0x000419, "Member 'AJackBattleManager::bDebugFlag_DropCertainty' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_RareDropCertainty) == 0x00041A, "Member 'AJackBattleManager::bDebugFlag_RareDropCertainty' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DropLogOutput) == 0x00041B, "Member 'AJackBattleManager::bDebugFlag_DropLogOutput' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_Drop2000Lottery) == 0x00041C, "Member 'AJackBattleManager::bDebugFlag_Drop2000Lottery' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_Win) == 0x00041D, "Member 'AJackBattleManager::bDebugFlag_Win' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_Lose) == 0x00041E, "Member 'AJackBattleManager::bDebugFlag_Lose' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_DisablePopupBalloon) == 0x00041F, "Member 'AJackBattleManager::bDebugFlag_DisablePopupBalloon' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_ActionCameraInfo) == 0x000420, "Member 'AJackBattleManager::bDebugFlag_ActionCameraInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_AutoCameraInfo) == 0x000424, "Member 'AJackBattleManager::DebugFlag_AutoCameraInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_AutoCameraParam) == 0x000428, "Member 'AJackBattleManager::DebugFlag_AutoCameraParam' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugFlag_DistantBranch) == 0x00042C, "Member 'AJackBattleManager::DebugFlag_DistantBranch' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_AIFirstCheck) == 0x000430, "Member 'AJackBattleManager::bDebugFlag_AIFirstCheck' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_AISecondCheck) == 0x000431, "Member 'AJackBattleManager::bDebugFlag_AISecondCheck' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_AIFirstCheckLogShow) == 0x000432, "Member 'AJackBattleManager::bDebugFlag_AIFirstCheckLogShow' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_AISecondCheckLogShow) == 0x000433, "Member 'AJackBattleManager::bDebugFlag_AISecondCheckLogShow' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_PlayerAIDrawCalcInfo) == 0x000434, "Member 'AJackBattleManager::bDebugFlag_PlayerAIDrawCalcInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_PlayerAIFlowTest) == 0x000435, "Member 'AJackBattleManager::bDebugFlag_PlayerAIFlowTest' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_PlayerAIFlowLogShow) == 0x000436, "Member 'AJackBattleManager::bDebugFlag_PlayerAIFlowLogShow' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_PlayerAIFlowBossBattle) == 0x000437, "Member 'AJackBattleManager::bDebugFlag_PlayerAIFlowBossBattle' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_PlayerAIScoreCheckLogShow) == 0x000438, "Member 'AJackBattleManager::bDebugFlag_PlayerAIScoreCheckLogShow' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_MonsterAppearSkip) == 0x000439, "Member 'AJackBattleManager::bDebugFlag_MonsterAppearSkip' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_MonsterAppearDrawBox) == 0x00043A, "Member 'AJackBattleManager::bDebugFlag_MonsterAppearDrawBox' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_BattlePreparationCameraDraw) == 0x00043B, "Member 'AJackBattleManager::bDebugFlag_BattlePreparationCameraDraw' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bDebugFlag_MonsterSpawnNear) == 0x00043C, "Member 'AJackBattleManager::bDebugFlag_MonsterSpawnNear' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Debug_FixDamage) == 0x000440, "Member 'AJackBattleManager::Debug_FixDamage' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, DebugBattleCommandAI_ActionPatternSlotIDs) == 0x000448, "Member 'AJackBattleManager::DebugBattleCommandAI_ActionPatternSlotIDs' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleTextCaster) == 0x000458, "Member 'AJackBattleManager::BattleTextCaster' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleTextTarget) == 0x000460, "Member 'AJackBattleManager::BattleTextTarget' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleTextDamage) == 0x000468, "Member 'AJackBattleManager::BattleTextDamage' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bEncount_InvalidByDebugCmd) == 0x00046C, "Member 'AJackBattleManager::bEncount_InvalidByDebugCmd' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, bEncount_InvalidByBPDebug) == 0x00046D, "Member 'AJackBattleManager::bEncount_InvalidByBPDebug' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_Type) == 0x00046E, "Member 'AJackBattleManager::Encount_Type' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_Location) == 0x000470, "Member 'AJackBattleManager::Encount_Location' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_MonsterCharacter) == 0x00047C, "Member 'AJackBattleManager::Encount_MonsterCharacter' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_IntervalSeconds) == 0x000484, "Member 'AJackBattleManager::Encount_IntervalSeconds' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_IntervalSecondsWork) == 0x000488, "Member 'AJackBattleManager::Encount_IntervalSecondsWork' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_EventBattleInfo) == 0x00048C, "Member 'AJackBattleManager::Encount_EventBattleInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_PreemptiveAttack) == 0x000494, "Member 'AJackBattleManager::Encount_PreemptiveAttack' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Encount_Attack) == 0x000495, "Member 'AJackBattleManager::Encount_Attack' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, EncountParameter) == 0x000498, "Member 'AJackBattleManager::EncountParameter' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, Validation_LockOnMovementTest) == 0x0004A0, "Member 'AJackBattleManager::Validation_LockOnMovementTest' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleMonsterNumLimit) == 0x0004A4, "Member 'AJackBattleManager::BattleMonsterNumLimit' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleEndMessageStableWaitTime) == 0x0004A8, "Member 'AJackBattleManager::BattleEndMessageStableWaitTime' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleMessageDisplayTime_Normal) == 0x0004AC, "Member 'AJackBattleManager::BattleMessageDisplayTime_Normal' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleMessageDisplayTime_2Line) == 0x0004B0, "Member 'AJackBattleManager::BattleMessageDisplayTime_2Line' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleMessageDisplayTime_Skip) == 0x0004B4, "Member 'AJackBattleManager::BattleMessageDisplayTime_Skip' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, UnsheathePreWaitTimeRandomMin) == 0x0004B8, "Member 'AJackBattleManager::UnsheathePreWaitTimeRandomMin' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, UnsheathePreWaitTimeRandomMax) == 0x0004BC, "Member 'AJackBattleManager::UnsheathePreWaitTimeRandomMax' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleStatus) == 0x0004C0, "Member 'AJackBattleManager::BattleStatus' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleResultInfo) == 0x0004C8, "Member 'AJackBattleManager::BattleResultInfo' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleCharacterManager) == 0x0004D0, "Member 'AJackBattleManager::BattleCharacterManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleGroupManager) == 0x0004D8, "Member 'AJackBattleManager::BattleGroupManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleFieldManager) == 0x0004E0, "Member 'AJackBattleManager::BattleFieldManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleInterruptActionManager) == 0x0004E8, "Member 'AJackBattleManager::BattleInterruptActionManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleTurnManager) == 0x0004F0, "Member 'AJackBattleManager::BattleTurnManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleCameraManager) == 0x0004F8, "Member 'AJackBattleManager::BattleCameraManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleSelectionEffect) == 0x000500, "Member 'AJackBattleManager::BattleSelectionEffect' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, HitStop) == 0x000508, "Member 'AJackBattleManager::HitStop' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleParameter) == 0x000510, "Member 'AJackBattleManager::BattleParameter' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, ZoneParameter) == 0x000518, "Member 'AJackBattleManager::ZoneParameter' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleCommandAIManager) == 0x000520, "Member 'AJackBattleManager::BattleCommandAIManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleFukidasiTalkManager) == 0x000528, "Member 'AJackBattleManager::BattleFukidasiTalkManager' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleInitialize) == 0x000530, "Member 'AJackBattleManager::OnBattleInitialize' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnCrashEffectStart) == 0x000540, "Member 'AJackBattleManager::OnCrashEffectStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattlePostInitialize) == 0x000550, "Member 'AJackBattleManager::OnBattlePostInitialize' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnMonsterAppearStart) == 0x000560, "Member 'AJackBattleManager::OnMonsterAppearStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleStart) == 0x000570, "Member 'AJackBattleManager::OnBattleStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleTurnStart) == 0x000580, "Member 'AJackBattleManager::OnBattleTurnStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleTurnPostActionExit) == 0x000590, "Member 'AJackBattleManager::OnBattleTurnPostActionExit' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnRoundEndInterruptCheck) == 0x0005A0, "Member 'AJackBattleManager::OnRoundEndInterruptCheck' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnRoundEnd) == 0x0005B0, "Member 'AJackBattleManager::OnRoundEnd' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnActionHitComplete) == 0x0005C0, "Member 'AJackBattleManager::OnActionHitComplete' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnFinishBlow) == 0x0005D0, "Member 'AJackBattleManager::OnFinishBlow' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleEnd) == 0x0005E0, "Member 'AJackBattleManager::OnBattleEnd' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnResultStart) == 0x0005F0, "Member 'AJackBattleManager::OnResultStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnResultCameraStart) == 0x000600, "Member 'AJackBattleManager::OnResultCameraStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleExitStart) == 0x000610, "Member 'AJackBattleManager::OnBattleExitStart' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleFinalize) == 0x000620, "Member 'AJackBattleManager::OnBattleFinalize' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleFieldEffectChange) == 0x000630, "Member 'AJackBattleManager::OnBattleFieldEffectChange' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleCameraStartDelegate) == 0x000640, "Member 'AJackBattleManager::OnBattleCameraStartDelegate' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnBattleCameraEndDelegate) == 0x000650, "Member 'AJackBattleManager::OnBattleCameraEndDelegate' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnPrgCameraSetupDelegate) == 0x000660, "Member 'AJackBattleManager::OnPrgCameraSetupDelegate' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnPrgCameraStartDelegate) == 0x000670, "Member 'AJackBattleManager::OnPrgCameraStartDelegate' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OnPrgCameraEndDelegate) == 0x000680, "Member 'AJackBattleManager::OnPrgCameraEndDelegate' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, MonsterAppear) == 0x0007D0, "Member 'AJackBattleManager::MonsterAppear' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, ResultSequence) == 0x0007D8, "Member 'AJackBattleManager::ResultSequence' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleVoiceResourceChanger) == 0x0007E0, "Member 'AJackBattleManager::BattleVoiceResourceChanger' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, ToubatuEffect) == 0x0007E8, "Member 'AJackBattleManager::ToubatuEffect' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, MemberChange) == 0x0007F0, "Member 'AJackBattleManager::MemberChange' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, NigeruSequence) == 0x0007F8, "Member 'AJackBattleManager::NigeruSequence' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, AdditionalResourceObjectsHolders) == 0x000800, "Member 'AJackBattleManager::AdditionalResourceObjectsHolders' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, MemberChangeClass) == 0x000850, "Member 'AJackBattleManager::MemberChangeClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleFieldManagerClass) == 0x000858, "Member 'AJackBattleManager::BattleFieldManagerClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, CriticalKaisinEffectClass) == 0x000860, "Member 'AJackBattleManager::CriticalKaisinEffectClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, CriticalTuukonEffectClass) == 0x000868, "Member 'AJackBattleManager::CriticalTuukonEffectClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, JumonBousouEffectClass) == 0x000870, "Member 'AJackBattleManager::JumonBousouEffectClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, ToubatuEffectClass) == 0x000878, "Member 'AJackBattleManager::ToubatuEffectClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, BattleParameterClass) == 0x000880, "Member 'AJackBattleManager::BattleParameterClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, ZoneParameterClass) == 0x000888, "Member 'AJackBattleManager::ZoneParameterClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, EncountParameterClass) == 0x000890, "Member 'AJackBattleManager::EncountParameterClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, HitStopClass) == 0x000898, "Member 'AJackBattleManager::HitStopClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, TreasureBoxBattleClass) == 0x0008A0, "Member 'AJackBattleManager::TreasureBoxBattleClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, TreasureBoxRareBattleClass) == 0x0008A8, "Member 'AJackBattleManager::TreasureBoxRareBattleClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, NavigationQueryFilters) == 0x0008B0, "Member 'AJackBattleManager::NavigationQueryFilters' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, OddEffectDokuPostProcessClass) == 0x0008C0, "Member 'AJackBattleManager::OddEffectDokuPostProcessClass' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, FieldDokuDamageInterval) == 0x0008C8, "Member 'AJackBattleManager::FieldDokuDamageInterval' has a wrong offset!");
static_assert(offsetof(AJackBattleManager, FieldDokuTurnSec) == 0x0008CC, "Member 'AJackBattleManager::FieldDokuTurnSec' has a wrong offset!");

// Class JackGame.JackDebugMenu
// 0x0048 (0x03E0 - 0x0398)
class AJackDebugMenu final : public AActor
{
public:
	uint8                                         Pad_398[0x48];                                     // 0x0398(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenu">();
	}
	static class AJackDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackDebugMenu>();
	}
};
static_assert(alignof(AJackDebugMenu) == 0x000008, "Wrong alignment on AJackDebugMenu");
static_assert(sizeof(AJackDebugMenu) == 0x0003E0, "Wrong size on AJackDebugMenu");

// Class JackGame.JackTaskBattleMemberChangeCharaIn
// 0x0018 (0x0058 - 0x0040)
class UJackTaskBattleMemberChangeCharaIn final : public UJackTask
{
public:
	TWeakObjectPtr<class AJackCharacter>          Character;                                         // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UAnimMontage>            MemberChangeInAM;                                  // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DitherTime;                                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVoiceEnable;                                      // 0x0054(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTaskBattleMemberChangeCharaIn">();
	}
	static class UJackTaskBattleMemberChangeCharaIn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTaskBattleMemberChangeCharaIn>();
	}
};
static_assert(alignof(UJackTaskBattleMemberChangeCharaIn) == 0x000008, "Wrong alignment on UJackTaskBattleMemberChangeCharaIn");
static_assert(sizeof(UJackTaskBattleMemberChangeCharaIn) == 0x000058, "Wrong size on UJackTaskBattleMemberChangeCharaIn");
static_assert(offsetof(UJackTaskBattleMemberChangeCharaIn, Character) == 0x000040, "Member 'UJackTaskBattleMemberChangeCharaIn::Character' has a wrong offset!");
static_assert(offsetof(UJackTaskBattleMemberChangeCharaIn, MemberChangeInAM) == 0x000048, "Member 'UJackTaskBattleMemberChangeCharaIn::MemberChangeInAM' has a wrong offset!");
static_assert(offsetof(UJackTaskBattleMemberChangeCharaIn, DitherTime) == 0x000050, "Member 'UJackTaskBattleMemberChangeCharaIn::DitherTime' has a wrong offset!");
static_assert(offsetof(UJackTaskBattleMemberChangeCharaIn, bVoiceEnable) == 0x000054, "Member 'UJackTaskBattleMemberChangeCharaIn::bVoiceEnable' has a wrong offset!");

// Class JackGame.JackBattleMonsterAppear
// 0x03B8 (0x0750 - 0x0398)
class AJackBattleMonsterAppear final : public AActor
{
public:
	uint8                                         Pad_398[0x3B8];                                    // 0x0398(0x03B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitBattleAppearance(EJackMonsterAlignmentSequenceEnum InProduction, float PlayTime, float CameraFOV, float TransparencyTime, float WaitingStartAnimationMaxTime, float ArrangementInterval, float CornerMarginRate, float TimerMax, float WaitMax, float SphereRadius, bool CameraSmooth, bool InSymbolPriority, float InParticleCameraFixedDistance, TSoftObjectPtr<class UParticleSystem> InParticleCamera, TSoftObjectPtr<class UParticleSystem> InParticleMonsterS, TSoftObjectPtr<class UParticleSystem> InParticleMonsterM, TSoftObjectPtr<class UParticleSystem> InParticleMonsterL, TSoftObjectPtr<class UParticleSystem> InParticleMonsterLL, TSoftObjectPtr<class USoundBase> InParticleSound, float InRandomEncounterWidthMax, float InRandomEncounterOverCameraAngle, bool IsCenterLocationSwitch);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleMonsterAppear">();
	}
	static class AJackBattleMonsterAppear* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleMonsterAppear>();
	}
};
static_assert(alignof(AJackBattleMonsterAppear) == 0x000008, "Wrong alignment on AJackBattleMonsterAppear");
static_assert(sizeof(AJackBattleMonsterAppear) == 0x000750, "Wrong size on AJackBattleMonsterAppear");

// Class JackGame.JackOddEffectExec
// 0x00C8 (0x0100 - 0x0038)
class UJackOddEffectExec : public UObject
{
public:
	class FName                                   OddEffectID;                                       // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UJackOddEffectExec>> SubOddEffectExecArray;                             // 0x0040(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	struct FJackOddEffectData                     OddEffectData;                                     // 0x0050(0x0058)(Edit, DisableEditOnTemplate, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      CasterGameCharacter;                               // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Depth;                                             // 0x00B0(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackOddEffectSlideRank                       SlideRank;                                         // 0x00B4(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackOddEffectReasonType                      Reason;                                            // 0x00B5(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserveClear;                                     // 0x00B6(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInvalidTurnEndCreateYasumiActionModule;           // 0x00B7(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UParticleSystemComponent>> PlayedEffectParticleSystemComponents;              // 0x00B8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class UAudioComponent>> PlayedLoopAudioComponents;                         // 0x00C8(0x0010)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, ContainsInstancedReference, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class FName                                   PlayedVoiceID;                                     // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPlayedSetCategory;                                // 0x00E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E1[0xB];                                       // 0x00E1(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RemainTurn;                                        // 0x00EC(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UObject*>                        HoldAssets;                                        // 0x00F0(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec">();
	}
	static class UJackOddEffectExec* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec>();
	}
};
static_assert(alignof(UJackOddEffectExec) == 0x000008, "Wrong alignment on UJackOddEffectExec");
static_assert(sizeof(UJackOddEffectExec) == 0x000100, "Wrong size on UJackOddEffectExec");
static_assert(offsetof(UJackOddEffectExec, OddEffectID) == 0x000038, "Member 'UJackOddEffectExec::OddEffectID' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, SubOddEffectExecArray) == 0x000040, "Member 'UJackOddEffectExec::SubOddEffectExecArray' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, OddEffectData) == 0x000050, "Member 'UJackOddEffectExec::OddEffectData' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, CasterGameCharacter) == 0x0000A8, "Member 'UJackOddEffectExec::CasterGameCharacter' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, Depth) == 0x0000B0, "Member 'UJackOddEffectExec::Depth' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, SlideRank) == 0x0000B4, "Member 'UJackOddEffectExec::SlideRank' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, Reason) == 0x0000B5, "Member 'UJackOddEffectExec::Reason' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, bReserveClear) == 0x0000B6, "Member 'UJackOddEffectExec::bReserveClear' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, bInvalidTurnEndCreateYasumiActionModule) == 0x0000B7, "Member 'UJackOddEffectExec::bInvalidTurnEndCreateYasumiActionModule' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, PlayedEffectParticleSystemComponents) == 0x0000B8, "Member 'UJackOddEffectExec::PlayedEffectParticleSystemComponents' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, PlayedLoopAudioComponents) == 0x0000C8, "Member 'UJackOddEffectExec::PlayedLoopAudioComponents' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, PlayedVoiceID) == 0x0000D8, "Member 'UJackOddEffectExec::PlayedVoiceID' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, bPlayedSetCategory) == 0x0000E0, "Member 'UJackOddEffectExec::bPlayedSetCategory' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, RemainTurn) == 0x0000EC, "Member 'UJackOddEffectExec::RemainTurn' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExec, HoldAssets) == 0x0000F0, "Member 'UJackOddEffectExec::HoldAssets' has a wrong offset!");

// Class JackGame.JackOddEffectExec_KooriDuke
// 0x0010 (0x0110 - 0x0100)
class UJackOddEffectExec_KooriDuke final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_KooriDuke">();
	}
	static class UJackOddEffectExec_KooriDuke* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_KooriDuke>();
	}
};
static_assert(alignof(UJackOddEffectExec_KooriDuke) == 0x000008, "Wrong alignment on UJackOddEffectExec_KooriDuke");
static_assert(sizeof(UJackOddEffectExec_KooriDuke) == 0x000110, "Wrong size on UJackOddEffectExec_KooriDuke");

// Class JackGame.JackBattleNigeruSequence
// 0x0108 (0x04A0 - 0x0398)
class AJackBattleNigeruSequence final : public AActor
{
public:
	uint8                                         Pad_398[0xE8];                                     // 0x0398(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNigeruSuccess;                                    // 0x0480(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNigeruSequenceEnd;                                // 0x0481(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_482[0x6];                                      // 0x0482(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               NigeruEffectAssetHolder;                           // 0x0488(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class AActor>                  NigeruEffect;                                      // 0x0490(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_498[0x8];                                      // 0x0498(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ExecEvent(EJackBattleNigeruSequenceEventType EventType, class FName Param);

	bool IsNigeruSuccess() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleNigeruSequence">();
	}
	static class AJackBattleNigeruSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleNigeruSequence>();
	}
};
static_assert(alignof(AJackBattleNigeruSequence) == 0x000008, "Wrong alignment on AJackBattleNigeruSequence");
static_assert(sizeof(AJackBattleNigeruSequence) == 0x0004A0, "Wrong size on AJackBattleNigeruSequence");
static_assert(offsetof(AJackBattleNigeruSequence, bNigeruSuccess) == 0x000480, "Member 'AJackBattleNigeruSequence::bNigeruSuccess' has a wrong offset!");
static_assert(offsetof(AJackBattleNigeruSequence, bNigeruSequenceEnd) == 0x000481, "Member 'AJackBattleNigeruSequence::bNigeruSequenceEnd' has a wrong offset!");
static_assert(offsetof(AJackBattleNigeruSequence, NigeruEffectAssetHolder) == 0x000488, "Member 'AJackBattleNigeruSequence::NigeruEffectAssetHolder' has a wrong offset!");
static_assert(offsetof(AJackBattleNigeruSequence, NigeruEffect) == 0x000490, "Member 'AJackBattleNigeruSequence::NigeruEffect' has a wrong offset!");

// Class JackGame.JackBattleResultInfo
// 0x0040 (0x0078 - 0x0038)
class UJackBattleResultInfo final : public UObject
{
public:
	EJackBattleResult                             BattleResultType;                                  // 0x0038(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundCount;                                        // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerPartyTotalTurnCount;                         // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropExp;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackBattleResultExpInfo>       CharacterExpInfos;                                 // 0x0048(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	int32                                         SibariExpMonsterLevel;                             // 0x0058(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DropGold;                                          // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackDropItemStructs>           DropItem;                                          // 0x0060(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EJackVehicleModelId                           DropVehicle;                                       // 0x0070(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleResultInfo">();
	}
	static class UJackBattleResultInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleResultInfo>();
	}
};
static_assert(alignof(UJackBattleResultInfo) == 0x000008, "Wrong alignment on UJackBattleResultInfo");
static_assert(sizeof(UJackBattleResultInfo) == 0x000078, "Wrong size on UJackBattleResultInfo");
static_assert(offsetof(UJackBattleResultInfo, BattleResultType) == 0x000038, "Member 'UJackBattleResultInfo::BattleResultType' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, RoundCount) == 0x00003C, "Member 'UJackBattleResultInfo::RoundCount' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, PlayerPartyTotalTurnCount) == 0x000040, "Member 'UJackBattleResultInfo::PlayerPartyTotalTurnCount' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, DropExp) == 0x000044, "Member 'UJackBattleResultInfo::DropExp' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, CharacterExpInfos) == 0x000048, "Member 'UJackBattleResultInfo::CharacterExpInfos' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, SibariExpMonsterLevel) == 0x000058, "Member 'UJackBattleResultInfo::SibariExpMonsterLevel' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, DropGold) == 0x00005C, "Member 'UJackBattleResultInfo::DropGold' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, DropItem) == 0x000060, "Member 'UJackBattleResultInfo::DropItem' has a wrong offset!");
static_assert(offsetof(UJackBattleResultInfo, DropVehicle) == 0x000070, "Member 'UJackBattleResultInfo::DropVehicle' has a wrong offset!");

// Class JackGame.JackOddEffectExec_TyouTaberu
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_TyouTaberu final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_TyouTaberu">();
	}
	static class UJackOddEffectExec_TyouTaberu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_TyouTaberu>();
	}
};
static_assert(alignof(UJackOddEffectExec_TyouTaberu) == 0x000008, "Wrong alignment on UJackOddEffectExec_TyouTaberu");
static_assert(sizeof(UJackOddEffectExec_TyouTaberu) == 0x000100, "Wrong size on UJackOddEffectExec_TyouTaberu");

// Class JackGame.JackBattleResultSequence
// 0x0138 (0x04D0 - 0x0398)
class AJackBattleResultSequence final : public AActor
{
public:
	uint8                                         Pad_398[0x128];                                    // 0x0398(0x0128)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               ResultZenmetuAssetHolder;                          // 0x04C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4C8[0x8];                                      // 0x04C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleResultSequence">();
	}
	static class AJackBattleResultSequence* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBattleResultSequence>();
	}
};
static_assert(alignof(AJackBattleResultSequence) == 0x000008, "Wrong alignment on AJackBattleResultSequence");
static_assert(sizeof(AJackBattleResultSequence) == 0x0004D0, "Wrong size on AJackBattleResultSequence");
static_assert(offsetof(AJackBattleResultSequence, ResultZenmetuAssetHolder) == 0x0004C0, "Member 'AJackBattleResultSequence::ResultZenmetuAssetHolder' has a wrong offset!");

// Class JackGame.JackBattleSelectionEffect
// 0x0018 (0x0068 - 0x0050)
class UJackBattleSelectionEffect final : public UJackTickableGameObject
{
public:
	class FName                                   SelectionActionID;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackBattleSelectionCharacterInfo> SelectionCharacterInfos;                           // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleSelectionEffect">();
	}
	static class UJackBattleSelectionEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleSelectionEffect>();
	}
};
static_assert(alignof(UJackBattleSelectionEffect) == 0x000008, "Wrong alignment on UJackBattleSelectionEffect");
static_assert(sizeof(UJackBattleSelectionEffect) == 0x000068, "Wrong size on UJackBattleSelectionEffect");
static_assert(offsetof(UJackBattleSelectionEffect, SelectionActionID) == 0x000050, "Member 'UJackBattleSelectionEffect::SelectionActionID' has a wrong offset!");
static_assert(offsetof(UJackBattleSelectionEffect, SelectionCharacterInfos) == 0x000058, "Member 'UJackBattleSelectionEffect::SelectionCharacterInfos' has a wrong offset!");

// Class JackGame.JackOddEffectExec_TokiWoUbau
// 0x0010 (0x0110 - 0x0100)
class UJackOddEffectExec_TokiWoUbau final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_TokiWoUbau">();
	}
	static class UJackOddEffectExec_TokiWoUbau* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_TokiWoUbau>();
	}
};
static_assert(alignof(UJackOddEffectExec_TokiWoUbau) == 0x000008, "Wrong alignment on UJackOddEffectExec_TokiWoUbau");
static_assert(sizeof(UJackOddEffectExec_TokiWoUbau) == 0x000110, "Wrong size on UJackOddEffectExec_TokiWoUbau");

// Class JackGame.JackBattleStatus
// 0x00F8 (0x0130 - 0x0038)
class UJackBattleStatus final : public UObject
{
public:
	bool                                          bBattleInitializeCall;                             // 0x0038(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleInitializeComplete;                         // 0x0039(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattlePostInitializeBPComplete;                   // 0x003A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMonsterAppearComplete;                            // 0x003B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleStartCall;                                  // 0x003C(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleEndCall;                                    // 0x003D(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleEndBPComplete;                              // 0x003E(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleStartMenu_Complete;                         // 0x003F(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleStartMenu_Tatakau;                          // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleStartMenu_Nigeru;                           // 0x0041(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSakusenChange_End;                                // 0x0042(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteTurn_SelectComplete;                       // 0x0043(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteTurn_Complete;                             // 0x0044(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteTurn_SakusenNigeru;                        // 0x0045(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteTurn_ChangeToAI;                           // 0x0046(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteTurn_MemberChange;                         // 0x0047(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCrashEffect;                                  // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipMonsterAppear;                                // 0x0049(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipResult;                                       // 0x004A(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInterruptSakusenMenu;                             // 0x004B(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNigeruSuccess;                                    // 0x004C(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishBlowComplete;                               // 0x004D(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRecentlyFastMode;                                 // 0x004E(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleSpeedMode                          BattleSpeedMode;                                   // 0x004F(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleCameraMode                         BattleCameraMode;                                  // 0x0050(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleResult                             BattleResultType;                                  // 0x0051(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackBattleNigeruConditionType                NigeruConditionType;                               // 0x0052(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBattleFieldNigeruInvalid;                         // 0x0053(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackDropItemStructs>           DropItem;                                          // 0x0058(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	EJackVehicleModelId                           DropVehicle;                                       // 0x0068(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         RoundCount;                                        // 0x006C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NakamaTurnSkipSharedTurnCount;                     // 0x0070(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NigeruCount;                                       // 0x0074(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackOddEffect_OnTurnStartResult       OddEffect_OnTurnStartResult;                       // 0x0078(0x0028)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FJackOddEffect_OnTurnEndResult         OddEffect_OnTurnEndResult;                         // 0x00A0(0x0020)(Edit, EditConst, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class AJackCharacter>>  ZoneStartCharacterArray;                           // 0x00C0(0x0010)(Edit, ZeroConstructor, EditConst, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         HaouZanTeachP007;                                  // 0x00D0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D4[0x4];                                       // 0x00D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           UsedRenkeiIDs;                                     // 0x00D8(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPublic)
	TArray<struct FJackBattleExtraToubatuCountInfo> ExtraToubatuMonsters;                              // 0x00E8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, EditConst, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AJackCharacter>          PlayedTurnCharacterEffectCharacter;                // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackBattleFieldFoliageDitherInfo      BattleFieldFoliageDitherInfo;                      // 0x0100(0x0028)(Edit, DisableEditOnTemplate, Transient, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void IncrementHaouZanTeachP007();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleStatus">();
	}
	static class UJackBattleStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleStatus>();
	}
};
static_assert(alignof(UJackBattleStatus) == 0x000008, "Wrong alignment on UJackBattleStatus");
static_assert(sizeof(UJackBattleStatus) == 0x000130, "Wrong size on UJackBattleStatus");
static_assert(offsetof(UJackBattleStatus, bBattleInitializeCall) == 0x000038, "Member 'UJackBattleStatus::bBattleInitializeCall' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleInitializeComplete) == 0x000039, "Member 'UJackBattleStatus::bBattleInitializeComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattlePostInitializeBPComplete) == 0x00003A, "Member 'UJackBattleStatus::bBattlePostInitializeBPComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bMonsterAppearComplete) == 0x00003B, "Member 'UJackBattleStatus::bMonsterAppearComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleStartCall) == 0x00003C, "Member 'UJackBattleStatus::bBattleStartCall' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleEndCall) == 0x00003D, "Member 'UJackBattleStatus::bBattleEndCall' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleEndBPComplete) == 0x00003E, "Member 'UJackBattleStatus::bBattleEndBPComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleStartMenu_Complete) == 0x00003F, "Member 'UJackBattleStatus::bBattleStartMenu_Complete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleStartMenu_Tatakau) == 0x000040, "Member 'UJackBattleStatus::bBattleStartMenu_Tatakau' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleStartMenu_Nigeru) == 0x000041, "Member 'UJackBattleStatus::bBattleStartMenu_Nigeru' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bSakusenChange_End) == 0x000042, "Member 'UJackBattleStatus::bSakusenChange_End' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bExecuteTurn_SelectComplete) == 0x000043, "Member 'UJackBattleStatus::bExecuteTurn_SelectComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bExecuteTurn_Complete) == 0x000044, "Member 'UJackBattleStatus::bExecuteTurn_Complete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bExecuteTurn_SakusenNigeru) == 0x000045, "Member 'UJackBattleStatus::bExecuteTurn_SakusenNigeru' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bExecuteTurn_ChangeToAI) == 0x000046, "Member 'UJackBattleStatus::bExecuteTurn_ChangeToAI' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bExecuteTurn_MemberChange) == 0x000047, "Member 'UJackBattleStatus::bExecuteTurn_MemberChange' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bSkipCrashEffect) == 0x000048, "Member 'UJackBattleStatus::bSkipCrashEffect' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bSkipMonsterAppear) == 0x000049, "Member 'UJackBattleStatus::bSkipMonsterAppear' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bSkipResult) == 0x00004A, "Member 'UJackBattleStatus::bSkipResult' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bInterruptSakusenMenu) == 0x00004B, "Member 'UJackBattleStatus::bInterruptSakusenMenu' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bNigeruSuccess) == 0x00004C, "Member 'UJackBattleStatus::bNigeruSuccess' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bFinishBlowComplete) == 0x00004D, "Member 'UJackBattleStatus::bFinishBlowComplete' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bRecentlyFastMode) == 0x00004E, "Member 'UJackBattleStatus::bRecentlyFastMode' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, BattleSpeedMode) == 0x00004F, "Member 'UJackBattleStatus::BattleSpeedMode' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, BattleCameraMode) == 0x000050, "Member 'UJackBattleStatus::BattleCameraMode' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, BattleResultType) == 0x000051, "Member 'UJackBattleStatus::BattleResultType' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, NigeruConditionType) == 0x000052, "Member 'UJackBattleStatus::NigeruConditionType' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, bBattleFieldNigeruInvalid) == 0x000053, "Member 'UJackBattleStatus::bBattleFieldNigeruInvalid' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, DropItem) == 0x000058, "Member 'UJackBattleStatus::DropItem' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, DropVehicle) == 0x000068, "Member 'UJackBattleStatus::DropVehicle' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, RoundCount) == 0x00006C, "Member 'UJackBattleStatus::RoundCount' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, NakamaTurnSkipSharedTurnCount) == 0x000070, "Member 'UJackBattleStatus::NakamaTurnSkipSharedTurnCount' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, NigeruCount) == 0x000074, "Member 'UJackBattleStatus::NigeruCount' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, OddEffect_OnTurnStartResult) == 0x000078, "Member 'UJackBattleStatus::OddEffect_OnTurnStartResult' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, OddEffect_OnTurnEndResult) == 0x0000A0, "Member 'UJackBattleStatus::OddEffect_OnTurnEndResult' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, ZoneStartCharacterArray) == 0x0000C0, "Member 'UJackBattleStatus::ZoneStartCharacterArray' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, HaouZanTeachP007) == 0x0000D0, "Member 'UJackBattleStatus::HaouZanTeachP007' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, UsedRenkeiIDs) == 0x0000D8, "Member 'UJackBattleStatus::UsedRenkeiIDs' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, ExtraToubatuMonsters) == 0x0000E8, "Member 'UJackBattleStatus::ExtraToubatuMonsters' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, PlayedTurnCharacterEffectCharacter) == 0x0000F8, "Member 'UJackBattleStatus::PlayedTurnCharacterEffectCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleStatus, BattleFieldFoliageDitherInfo) == 0x000100, "Member 'UJackBattleStatus::BattleFieldFoliageDitherInfo' has a wrong offset!");

// Class JackGame.JackBattleTurnManager
// 0x0338 (0x0370 - 0x0038)
class UJackBattleTurnManager final : public UObject
{
public:
	TWeakObjectPtr<class UJackGameCharacter>      TurnGameCharacter;                                 // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameCharacter>      PrevTurnGameCharacter;                             // 0x0040(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x328];                                     // 0x0048(0x0328)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InsertTurnQueue(class UJackGameCharacter* InsertGameCharacter, bool bHead, bool bRootTurn);
	bool RemoveTurnQueue(class UJackGameCharacter* RemoveGameCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleTurnManager">();
	}
	static class UJackBattleTurnManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleTurnManager>();
	}
};
static_assert(alignof(UJackBattleTurnManager) == 0x000008, "Wrong alignment on UJackBattleTurnManager");
static_assert(sizeof(UJackBattleTurnManager) == 0x000370, "Wrong size on UJackBattleTurnManager");
static_assert(offsetof(UJackBattleTurnManager, TurnGameCharacter) == 0x000038, "Member 'UJackBattleTurnManager::TurnGameCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleTurnManager, PrevTurnGameCharacter) == 0x000040, "Member 'UJackBattleTurnManager::PrevTurnGameCharacter' has a wrong offset!");

// Class JackGame.JackMonsterDatabase
// 0x0058 (0x0090 - 0x0038)
class UJackMonsterDatabase final : public UObject
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class FName GetDTMonsterBattleAIID(struct FJackMonsterData& MonsterData);
	static struct FJackDataTableMonsterBattleAI GetDTMonsterBattleAIRow(struct FJackMonsterData& MonsterData);
	static struct FJackDataTableMonsterDrop GetDTMonsterDropRow(struct FJackMonsterData& MonsterData);
	static struct FJackDataTableMonster GetDTMonsterRow(struct FJackMonsterData& MonsterData);
	static bool IsValidDTMonsterBattleAIRow(struct FJackDataTableMonsterBattleAI& DTMonsterBattleAIRow);
	static bool IsValidDTMonsterDropRow(struct FJackDataTableMonsterDrop& DTMonsterDropRow);
	static bool IsValidDTMonsterRow(struct FJackDataTableMonster& DTMonsterRow);
	static bool IsValidMonsterData(struct FJackMonsterData& MonsterData);

	struct FJackDataTableMonsterBattleAI GetDTMonsterBattleAIRowByID(class FName MonsterBattleAIID);
	class FName GetMonsterDisplayName(class FName MonsterID);

	struct FJackMonsterData GetMonsterData(const struct FJackLDT_Monster& LDT_Monster) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterDatabase">();
	}
	static class UJackMonsterDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterDatabase>();
	}
};
static_assert(alignof(UJackMonsterDatabase) == 0x000008, "Wrong alignment on UJackMonsterDatabase");
static_assert(sizeof(UJackMonsterDatabase) == 0x000090, "Wrong size on UJackMonsterDatabase");

// Class JackGame.JackBattleInterruptActionRequest
// 0x0308 (0x0340 - 0x0038)
class UJackBattleInterruptActionRequest final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackActionPlayParam                   ActionPlayParam;                                   // 0x0040(0x0290)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D0[0x70];                                     // 0x02D0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleInterruptActionRequest">();
	}
	static class UJackBattleInterruptActionRequest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleInterruptActionRequest>();
	}
};
static_assert(alignof(UJackBattleInterruptActionRequest) == 0x000010, "Wrong alignment on UJackBattleInterruptActionRequest");
static_assert(sizeof(UJackBattleInterruptActionRequest) == 0x000340, "Wrong size on UJackBattleInterruptActionRequest");
static_assert(offsetof(UJackBattleInterruptActionRequest, ActionPlayParam) == 0x000040, "Member 'UJackBattleInterruptActionRequest::ActionPlayParam' has a wrong offset!");

// Class JackGame.JackBattleVoicePlayer
// 0x0180 (0x01D0 - 0x0050)
class UJackBattleVoicePlayer final : public UJackTickableGameObject
{
public:
	uint8                                         Pad_50[0xE0];                                      // 0x0050(0x00E0)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          OwnerCharacter;                                    // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   DirectVoicePresetID;                               // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bSound2D;                                          // 0x0140(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RequestedVoiceID;                                  // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x8];                                      // 0x0150(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   PlayingVoiceID;                                    // 0x0158(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayingRemainDelayTime;                            // 0x0168(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAudioComponent>         PlayingAudioComponent;                             // 0x016C(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnTemplate, Transient, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_174[0x4];                                      // 0x0174(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UJackStreamObjectsHolder*> VoiceResourceObjectsHolders;                       // 0x0178(0x0050)(Edit, ZeroConstructor, DisableEditOnTemplate, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C8[0x8];                                      // 0x01C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleVoicePlayer">();
	}
	static class UJackBattleVoicePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleVoicePlayer>();
	}
};
static_assert(alignof(UJackBattleVoicePlayer) == 0x000008, "Wrong alignment on UJackBattleVoicePlayer");
static_assert(sizeof(UJackBattleVoicePlayer) == 0x0001D0, "Wrong size on UJackBattleVoicePlayer");
static_assert(offsetof(UJackBattleVoicePlayer, OwnerCharacter) == 0x000130, "Member 'UJackBattleVoicePlayer::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, DirectVoicePresetID) == 0x000138, "Member 'UJackBattleVoicePlayer::DirectVoicePresetID' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, bSound2D) == 0x000140, "Member 'UJackBattleVoicePlayer::bSound2D' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, RequestedVoiceID) == 0x000148, "Member 'UJackBattleVoicePlayer::RequestedVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, PlayingVoiceID) == 0x000158, "Member 'UJackBattleVoicePlayer::PlayingVoiceID' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, PlayingRemainDelayTime) == 0x000168, "Member 'UJackBattleVoicePlayer::PlayingRemainDelayTime' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, PlayingAudioComponent) == 0x00016C, "Member 'UJackBattleVoicePlayer::PlayingAudioComponent' has a wrong offset!");
static_assert(offsetof(UJackBattleVoicePlayer, VoiceResourceObjectsHolders) == 0x000178, "Member 'UJackBattleVoicePlayer::VoiceResourceObjectsHolders' has a wrong offset!");

// Class JackGame.JackMonsterOptimizeComponent
// 0x0050 (0x01F0 - 0x01A0)
class UJackMonsterOptimizeComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x50];                                     // 0x01A0(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSymbolEncountDisabled(bool bDisabled);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterOptimizeComponent">();
	}
	static class UJackMonsterOptimizeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterOptimizeComponent>();
	}
};
static_assert(alignof(UJackMonsterOptimizeComponent) == 0x000008, "Wrong alignment on UJackMonsterOptimizeComponent");
static_assert(sizeof(UJackMonsterOptimizeComponent) == 0x0001F0, "Wrong size on UJackMonsterOptimizeComponent");

// Class JackGame.JackBattleWeapon
// 0x0118 (0x0150 - 0x0038)
class UJackBattleWeapon final : public UObject
{
public:
	uint8                                         Pad_38[0xE8];                                      // 0x0038(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          OwnerCharacter;                                    // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInitialized;                                      // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUnsheathe;                                        // 0x0129(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBougyoStart;                                      // 0x012A(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bBougyoIdle;                                       // 0x012B(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           MontageKeys;                                       // 0x0130(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EJackBattleWeaponMontageKey                   CurrentDefaultSlotMontageKeyType;                  // 0x0140(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_141[0xF];                                      // 0x0141(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnOwnerMontageStarted(class UAnimMontage* OwnerMontage);
	void OnOwnerPlayAnimMontageByKey(class FName AnimMontageKey, class UAnimMontage* AnimMontage);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBattleWeapon">();
	}
	static class UJackBattleWeapon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBattleWeapon>();
	}
};
static_assert(alignof(UJackBattleWeapon) == 0x000008, "Wrong alignment on UJackBattleWeapon");
static_assert(sizeof(UJackBattleWeapon) == 0x000150, "Wrong size on UJackBattleWeapon");
static_assert(offsetof(UJackBattleWeapon, OwnerCharacter) == 0x000120, "Member 'UJackBattleWeapon::OwnerCharacter' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, bInitialized) == 0x000128, "Member 'UJackBattleWeapon::bInitialized' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, bUnsheathe) == 0x000129, "Member 'UJackBattleWeapon::bUnsheathe' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, bBougyoStart) == 0x00012A, "Member 'UJackBattleWeapon::bBougyoStart' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, bBougyoIdle) == 0x00012B, "Member 'UJackBattleWeapon::bBougyoIdle' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, MontageKeys) == 0x000130, "Member 'UJackBattleWeapon::MontageKeys' has a wrong offset!");
static_assert(offsetof(UJackBattleWeapon, CurrentDefaultSlotMontageKeyType) == 0x000140, "Member 'UJackBattleWeapon::CurrentDefaultSlotMontageKeyType' has a wrong offset!");

// Class JackGame.JackBGMControlTrack
// 0x0038 (0x00E8 - 0x00B0)
class UJackBGMControlTrack final : public UInterpTrackFloatBase
{
public:
	class UDataTable*                             BGMDataTable;                                      // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDQ11BGM;                                     // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundBase*>                     PreLoadBGM;                                        // 0x00C0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackBGMControlTrackKey>        KeyArray;                                          // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsStartedCSSkip;                                  // 0x00E0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBGMControlTrack">();
	}
	static class UJackBGMControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBGMControlTrack>();
	}
};
static_assert(alignof(UJackBGMControlTrack) == 0x000008, "Wrong alignment on UJackBGMControlTrack");
static_assert(sizeof(UJackBGMControlTrack) == 0x0000E8, "Wrong size on UJackBGMControlTrack");
static_assert(offsetof(UJackBGMControlTrack, BGMDataTable) == 0x0000B0, "Member 'UJackBGMControlTrack::BGMDataTable' has a wrong offset!");
static_assert(offsetof(UJackBGMControlTrack, bForceDQ11BGM) == 0x0000B8, "Member 'UJackBGMControlTrack::bForceDQ11BGM' has a wrong offset!");
static_assert(offsetof(UJackBGMControlTrack, PreLoadBGM) == 0x0000C0, "Member 'UJackBGMControlTrack::PreLoadBGM' has a wrong offset!");
static_assert(offsetof(UJackBGMControlTrack, KeyArray) == 0x0000D0, "Member 'UJackBGMControlTrack::KeyArray' has a wrong offset!");
static_assert(offsetof(UJackBGMControlTrack, bIsStartedCSSkip) == 0x0000E0, "Member 'UJackBGMControlTrack::bIsStartedCSSkip' has a wrong offset!");

// Class JackGame.JackMonsterPopManager
// 0x0158 (0x04F0 - 0x0398)
class AJackMonsterPopManager : public AActor
{
public:
	uint8                                         Pad_398[0x114];                                    // 0x0398(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         GeneratorActiveRadius;                             // 0x04AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         GeneratorActiveThresholdWidth;                     // 0x04B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B4[0x4];                                      // 0x04B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackPopDistanceParams>         PopDistances;                                      // 0x04B8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FJackPopDistanceParams>         PopDistancesDuringBattle;                          // 0x04C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	TArray<struct FJackPopDistanceParamsByPL>     PopDistancesByPL;                                  // 0x04D8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E8[0x8];                                      // 0x04E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBattleFinalize();
	void OnBattleInitialize(const struct FJackCommandBattleInitialize& InCommand);
	void OnSibariSettingModify(EJackSibari Type, bool bFlag);

	bool IsAnnihilation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopManager">();
	}
	static class AJackMonsterPopManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterPopManager>();
	}
};
static_assert(alignof(AJackMonsterPopManager) == 0x000008, "Wrong alignment on AJackMonsterPopManager");
static_assert(sizeof(AJackMonsterPopManager) == 0x0004F0, "Wrong size on AJackMonsterPopManager");
static_assert(offsetof(AJackMonsterPopManager, GeneratorActiveRadius) == 0x0004AC, "Member 'AJackMonsterPopManager::GeneratorActiveRadius' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopManager, GeneratorActiveThresholdWidth) == 0x0004B0, "Member 'AJackMonsterPopManager::GeneratorActiveThresholdWidth' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopManager, PopDistances) == 0x0004B8, "Member 'AJackMonsterPopManager::PopDistances' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopManager, PopDistancesDuringBattle) == 0x0004C8, "Member 'AJackMonsterPopManager::PopDistancesDuringBattle' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopManager, PopDistancesByPL) == 0x0004D8, "Member 'AJackMonsterPopManager::PopDistancesByPL' has a wrong offset!");

// Class JackGame.JackBlendAnimOverrideTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackBlendAnimOverrideTrack final : public UInterpTrack
{
public:
	TArray<struct FJackBlendAnimOverrideTrackKeyInfo> KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBlendAnimOverrideTrack">();
	}
	static class UJackBlendAnimOverrideTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBlendAnimOverrideTrack>();
	}
};
static_assert(alignof(UJackBlendAnimOverrideTrack) == 0x000008, "Wrong alignment on UJackBlendAnimOverrideTrack");
static_assert(sizeof(UJackBlendAnimOverrideTrack) == 0x0000A0, "Wrong size on UJackBlendAnimOverrideTrack");
static_assert(offsetof(UJackBlendAnimOverrideTrack, KeyArray) == 0x000090, "Member 'UJackBlendAnimOverrideTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackBlendAnimOverrideTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackBlendAnimOverrideTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBlendAnimOverrideTrackInst">();
	}
	static class UJackBlendAnimOverrideTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBlendAnimOverrideTrackInst>();
	}
};
static_assert(alignof(UJackBlendAnimOverrideTrackInst) == 0x000008, "Wrong alignment on UJackBlendAnimOverrideTrackInst");
static_assert(sizeof(UJackBlendAnimOverrideTrackInst) == 0x000040, "Wrong size on UJackBlendAnimOverrideTrackInst");

// Class JackGame.JackBlendAnimPlayTrack
// 0x0018 (0x00E8 - 0x00D0)
class UJackBlendAnimPlayTrack final : public UInterpTrackAnimControl
{
public:
	TArray<struct FJackBlendAnimPlayTrackKey>     AnimExtraKey;                                      // 0x00D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DefaultInterpSec;                                  // 0x00E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBlendAnimPlayTrack">();
	}
	static class UJackBlendAnimPlayTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBlendAnimPlayTrack>();
	}
};
static_assert(alignof(UJackBlendAnimPlayTrack) == 0x000008, "Wrong alignment on UJackBlendAnimPlayTrack");
static_assert(sizeof(UJackBlendAnimPlayTrack) == 0x0000E8, "Wrong size on UJackBlendAnimPlayTrack");
static_assert(offsetof(UJackBlendAnimPlayTrack, AnimExtraKey) == 0x0000D0, "Member 'UJackBlendAnimPlayTrack::AnimExtraKey' has a wrong offset!");
static_assert(offsetof(UJackBlendAnimPlayTrack, DefaultInterpSec) == 0x0000E0, "Member 'UJackBlendAnimPlayTrack::DefaultInterpSec' has a wrong offset!");

// Class JackGame.JackMoveTrackInst
// 0x0020 (0x0070 - 0x0050)
class UJackMoveTrackInst final : public UInterpTrackInstMove
{
public:
	bool                                          bDefaultAdjustMeshHeightEnable;                    // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustRotateByDirection;                          // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustMoveRotateInitializeFlag;                   // 0x0052(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x1];                                       // 0x0053(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               AdjustMoveRotate;                                  // 0x0054(0x000C)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LastPosition;                                      // 0x0060(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0xC];                                       // 0x0064(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMoveTrackInst">();
	}
	static class UJackMoveTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMoveTrackInst>();
	}
};
static_assert(alignof(UJackMoveTrackInst) == 0x000008, "Wrong alignment on UJackMoveTrackInst");
static_assert(sizeof(UJackMoveTrackInst) == 0x000070, "Wrong size on UJackMoveTrackInst");
static_assert(offsetof(UJackMoveTrackInst, bDefaultAdjustMeshHeightEnable) == 0x000050, "Member 'UJackMoveTrackInst::bDefaultAdjustMeshHeightEnable' has a wrong offset!");
static_assert(offsetof(UJackMoveTrackInst, bAdjustRotateByDirection) == 0x000051, "Member 'UJackMoveTrackInst::bAdjustRotateByDirection' has a wrong offset!");
static_assert(offsetof(UJackMoveTrackInst, bAdjustMoveRotateInitializeFlag) == 0x000052, "Member 'UJackMoveTrackInst::bAdjustMoveRotateInitializeFlag' has a wrong offset!");
static_assert(offsetof(UJackMoveTrackInst, AdjustMoveRotate) == 0x000054, "Member 'UJackMoveTrackInst::AdjustMoveRotate' has a wrong offset!");
static_assert(offsetof(UJackMoveTrackInst, LastPosition) == 0x000060, "Member 'UJackMoveTrackInst::LastPosition' has a wrong offset!");

// Class JackGame.JackBowgunTargetComponent
// 0x0010 (0x0138 - 0x0128)
class UJackBowgunTargetComponent final : public UActorComponent
{
public:
	UMulticastDelegateProperty_                   OnHitArrow;                                        // 0x0128(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void OnHitArrowSignature__DelegateSignature();
	void OnInteractCallback(class AActor* OtherActor, class UJackInteractiveActorComponent* InteractiveActorComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBowgunTargetComponent">();
	}
	static class UJackBowgunTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBowgunTargetComponent>();
	}
};
static_assert(alignof(UJackBowgunTargetComponent) == 0x000008, "Wrong alignment on UJackBowgunTargetComponent");
static_assert(sizeof(UJackBowgunTargetComponent) == 0x000138, "Wrong size on UJackBowgunTargetComponent");
static_assert(offsetof(UJackBowgunTargetComponent, OnHitArrow) == 0x000128, "Member 'UJackBowgunTargetComponent::OnHitArrow' has a wrong offset!");

// Class JackGame.JackBoxComponent
// 0x0020 (0x0780 - 0x0760)
class UJackBoxComponent final : public UBoxComponent
{
public:
	class FString                                 AutoAttachComponentName;                           // 0x0760(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AutoAttachSocketName;                              // 0x0770(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               AutoAttachType;                                    // 0x0778(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_779[0x7];                                      // 0x0779(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBoxComponent">();
	}
	static class UJackBoxComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackBoxComponent>();
	}
};
static_assert(alignof(UJackBoxComponent) == 0x000010, "Wrong alignment on UJackBoxComponent");
static_assert(sizeof(UJackBoxComponent) == 0x000780, "Wrong size on UJackBoxComponent");
static_assert(offsetof(UJackBoxComponent, AutoAttachComponentName) == 0x000760, "Member 'UJackBoxComponent::AutoAttachComponentName' has a wrong offset!");
static_assert(offsetof(UJackBoxComponent, AutoAttachSocketName) == 0x000770, "Member 'UJackBoxComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UJackBoxComponent, AutoAttachType) == 0x000778, "Member 'UJackBoxComponent::AutoAttachType' has a wrong offset!");

// Class JackGame.JackMeosiSlotItemDef
// 0x0000 (0x0038 - 0x0038)
class UJackMeosiSlotItemDef final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotItemDef">();
	}
	static class UJackMeosiSlotItemDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotItemDef>();
	}
};
static_assert(alignof(UJackMeosiSlotItemDef) == 0x000008, "Wrong alignment on UJackMeosiSlotItemDef");
static_assert(sizeof(UJackMeosiSlotItemDef) == 0x000038, "Wrong size on UJackMeosiSlotItemDef");

// Class JackGame.JackCameraBattleResult
// 0x0010 (0x03A8 - 0x0398)
class AJackCameraBattleResult final : public AActor
{
public:
	class USceneComponent*                        SceneComponent;                                    // 0x0398(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCameraAnimInst*                        CameraAnimInst;                                    // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraBattleResult">();
	}
	static class AJackCameraBattleResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCameraBattleResult>();
	}
};
static_assert(alignof(AJackCameraBattleResult) == 0x000008, "Wrong alignment on AJackCameraBattleResult");
static_assert(sizeof(AJackCameraBattleResult) == 0x0003A8, "Wrong size on AJackCameraBattleResult");
static_assert(offsetof(AJackCameraBattleResult, SceneComponent) == 0x000398, "Member 'AJackCameraBattleResult::SceneComponent' has a wrong offset!");
static_assert(offsetof(AJackCameraBattleResult, CameraAnimInst) == 0x0003A0, "Member 'AJackCameraBattleResult::CameraAnimInst' has a wrong offset!");

// Class JackGame.JackCameraLightDisableTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackCameraLightDisableTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraLightDisableTrack">();
	}
	static class UJackCameraLightDisableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCameraLightDisableTrack>();
	}
};
static_assert(alignof(UJackCameraLightDisableTrack) == 0x000008, "Wrong alignment on UJackCameraLightDisableTrack");
static_assert(sizeof(UJackCameraLightDisableTrack) == 0x0000A8, "Wrong size on UJackCameraLightDisableTrack");

// Class JackGame.JackMeosiSlotReels
// 0x0038 (0x03D0 - 0x0398)
class AJackMeosiSlotReels final : public AActor
{
public:
	class UJackMeosiSlotReelUnit*                 SlotReelUnit;                                      // 0x0398(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RevPerSeconds;                                     // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x2C];                                     // 0x03A4(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void EnableReelStopReception();
	bool EndInertiaMovement(EJackMeosiSlotReelStopTimes InReelStopTimes);
	void InertiaMovementStart_CenterReel(const struct FJackMeosiSlotSoundEffect& InSoundEffect, EJackMeosiSlotReelStopTimes InReelStopTimes);
	void InertiaMovementStart_LeftReel(const struct FJackMeosiSlotSoundEffect& InSoundEffect, EJackMeosiSlotReelStopTimes InReelStopTimes);
	void InertiaMovementStart_RightReel(const struct FJackMeosiSlotSoundEffect& InSoundEffect, EJackMeosiSlotReelStopTimes InReelStopTimes);
	void ReelRevolvingBrake(EJackMeosiSlotReel InReelIndex, float InCorrection);
	void ReelRevolvingStart_Default(const struct FJackMeosiSlotSoundEffect& InSoundEffect);
	void SetReelCurrent(EJackMeosiSlotReel InReelIndex, float InCurrent);
	void StartReelRevolving(EJackMeosiSlotReel InReelIndex);

	class UTexture* GetReelBaseTexture(EJackMeosiSlotPicture InReelPicture) const;
	float GetReelCorrection(EJackMeosiSlotReel InReelIndex) const;
	float GetReelCurrent(EJackMeosiSlotReel InReelIndex) const;
	float GetReelDegree(EJackMeosiSlotReel InReelIndex) const;
	class UTexture* GetReelMaskTexture(EJackMeosiSlotPicture InReelPicture) const;
	int32 GetReelMeatPos(EJackMeosiSlotReel InReelIndex) const;
	float GetReelStopPos(EJackMeosiSlotReel InReelIndex) const;
	EJackMeosiSlotReelStopTimes GetReelStopTimes() const;
	struct FJackMeosiSlotVariableReelParam GetVariableParam() const;
	bool IsActive() const;
	bool IsExactlyPressSucceeded(EJackMeosiSlotReel InReelIndex) const;
	bool IsStopReceptionEnabled(EJackMeosiSlotReel InReelIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotReels">();
	}
	static class AJackMeosiSlotReels* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMeosiSlotReels>();
	}
};
static_assert(alignof(AJackMeosiSlotReels) == 0x000008, "Wrong alignment on AJackMeosiSlotReels");
static_assert(sizeof(AJackMeosiSlotReels) == 0x0003D0, "Wrong size on AJackMeosiSlotReels");
static_assert(offsetof(AJackMeosiSlotReels, SlotReelUnit) == 0x000398, "Member 'AJackMeosiSlotReels::SlotReelUnit' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotReels, RevPerSeconds) == 0x0003A0, "Member 'AJackMeosiSlotReels::RevPerSeconds' has a wrong offset!");

// Class JackGame.JackCameraLightEnableTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackCameraLightEnableTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCameraLightEnableTrack">();
	}
	static class UJackCameraLightEnableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCameraLightEnableTrack>();
	}
};
static_assert(alignof(UJackCameraLightEnableTrack) == 0x000008, "Wrong alignment on UJackCameraLightEnableTrack");
static_assert(sizeof(UJackCameraLightEnableTrack) == 0x0000A8, "Wrong size on UJackCameraLightEnableTrack");

// Class JackGame.JackCaptionBlendRateTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackCaptionBlendRateTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCaptionBlendRateTrack">();
	}
	static class UJackCaptionBlendRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCaptionBlendRateTrack>();
	}
};
static_assert(alignof(UJackCaptionBlendRateTrack) == 0x000008, "Wrong alignment on UJackCaptionBlendRateTrack");
static_assert(sizeof(UJackCaptionBlendRateTrack) == 0x0000B0, "Wrong size on UJackCaptionBlendRateTrack");

// Class JackGame.JackCaptionTrack
// 0x0118 (0x01A8 - 0x0090)
class UJackCaptionTrack final : public UInterpTrack
{
public:
	TArray<struct FJackCaptionTrackKey>           CaptionTrack;                                      // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TMap<class FString, class USoundBase*>        VoiceResouce;                                      // 0x00A0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsVoiceLoadComplete;                              // 0x00F0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UDataTable*>        LipDataTable;                                      // 0x00F8(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsLipDataTableLoadComplete;                       // 0x0148(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FString, class UDataTable*>        VoiceTimelineDataTable;                            // 0x0150(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	bool                                          bIsVoiceTimelineDataTableLoadComplete;             // 0x01A0(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCaptionTrack">();
	}
	static class UJackCaptionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCaptionTrack>();
	}
};
static_assert(alignof(UJackCaptionTrack) == 0x000008, "Wrong alignment on UJackCaptionTrack");
static_assert(sizeof(UJackCaptionTrack) == 0x0001A8, "Wrong size on UJackCaptionTrack");
static_assert(offsetof(UJackCaptionTrack, CaptionTrack) == 0x000090, "Member 'UJackCaptionTrack::CaptionTrack' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, VoiceResouce) == 0x0000A0, "Member 'UJackCaptionTrack::VoiceResouce' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, bIsVoiceLoadComplete) == 0x0000F0, "Member 'UJackCaptionTrack::bIsVoiceLoadComplete' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, LipDataTable) == 0x0000F8, "Member 'UJackCaptionTrack::LipDataTable' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, bIsLipDataTableLoadComplete) == 0x000148, "Member 'UJackCaptionTrack::bIsLipDataTableLoadComplete' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, VoiceTimelineDataTable) == 0x000150, "Member 'UJackCaptionTrack::VoiceTimelineDataTable' has a wrong offset!");
static_assert(offsetof(UJackCaptionTrack, bIsVoiceTimelineDataTableLoadComplete) == 0x0001A0, "Member 'UJackCaptionTrack::bIsVoiceTimelineDataTableLoadComplete' has a wrong offset!");

// Class JackGame.JackOddEffectExec_Hot
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_Hot : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Hot">();
	}
	static class UJackOddEffectExec_Hot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Hot>();
	}
};
static_assert(alignof(UJackOddEffectExec_Hot) == 0x000008, "Wrong alignment on UJackOddEffectExec_Hot");
static_assert(sizeof(UJackOddEffectExec_Hot) == 0x000108, "Wrong size on UJackOddEffectExec_Hot");

// Class JackGame.JackCaptionTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackCaptionTrackInst final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCaptionTrackInst">();
	}
	static class UJackCaptionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCaptionTrackInst>();
	}
};
static_assert(alignof(UJackCaptionTrackInst) == 0x000008, "Wrong alignment on UJackCaptionTrackInst");
static_assert(sizeof(UJackCaptionTrackInst) == 0x000040, "Wrong size on UJackCaptionTrackInst");
static_assert(offsetof(UJackCaptionTrackInst, LastUpdatePosition) == 0x000038, "Member 'UJackCaptionTrackInst::LastUpdatePosition' has a wrong offset!");

// Class JackGame.JackOddEffectExec_HazukasiiNoroi
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_HazukasiiNoroi final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_HazukasiiNoroi">();
	}
	static class UJackOddEffectExec_HazukasiiNoroi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_HazukasiiNoroi>();
	}
};
static_assert(alignof(UJackOddEffectExec_HazukasiiNoroi) == 0x000008, "Wrong alignment on UJackOddEffectExec_HazukasiiNoroi");
static_assert(sizeof(UJackOddEffectExec_HazukasiiNoroi) == 0x000100, "Wrong size on UJackOddEffectExec_HazukasiiNoroi");

// Class JackGame.JackCategoryHiddenManager
// 0x0458 (0x07F0 - 0x0398)
class AJackCategoryHiddenManager : public AActor
{
public:
	TArray<TSubclassOf<class AActor>>             Dictionary_Object;                                 // 0x0398(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             Dictionary_Object_Battle;                          // 0x03A8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             Dictionary_Object_CutScene;                        // 0x03B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TSubclassOf<class AActor>>             Dictionary_EventMonster;                           // 0x03C8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ExclusionList;                                     // 0x03D8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E8[0x408];                                    // 0x03E8(0x0408)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddExclusionTag(class FName InTag);
	void CategoryHidden(EJackCategoryHiddenType InType, EJackCategoryHiddenLayer Layer, bool bInHidden, bool bCollisionOption_Object);
	TArray<class FName> GetExclusionList();
	bool IsCategoryHidden(EJackCategoryHiddenType InType);
	void RemoveExclusionTag(class FName InTag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCategoryHiddenManager">();
	}
	static class AJackCategoryHiddenManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCategoryHiddenManager>();
	}
};
static_assert(alignof(AJackCategoryHiddenManager) == 0x000008, "Wrong alignment on AJackCategoryHiddenManager");
static_assert(sizeof(AJackCategoryHiddenManager) == 0x0007F0, "Wrong size on AJackCategoryHiddenManager");
static_assert(offsetof(AJackCategoryHiddenManager, Dictionary_Object) == 0x000398, "Member 'AJackCategoryHiddenManager::Dictionary_Object' has a wrong offset!");
static_assert(offsetof(AJackCategoryHiddenManager, Dictionary_Object_Battle) == 0x0003A8, "Member 'AJackCategoryHiddenManager::Dictionary_Object_Battle' has a wrong offset!");
static_assert(offsetof(AJackCategoryHiddenManager, Dictionary_Object_CutScene) == 0x0003B8, "Member 'AJackCategoryHiddenManager::Dictionary_Object_CutScene' has a wrong offset!");
static_assert(offsetof(AJackCategoryHiddenManager, Dictionary_EventMonster) == 0x0003C8, "Member 'AJackCategoryHiddenManager::Dictionary_EventMonster' has a wrong offset!");
static_assert(offsetof(AJackCategoryHiddenManager, ExclusionList) == 0x0003D8, "Member 'AJackCategoryHiddenManager::ExclusionList' has a wrong offset!");

// Class JackGame.JackCharacterAutoSECallback
// 0x0008 (0x00A0 - 0x0098)
class UJackCharacterAutoSECallback final : public USQEXSEADAutoSeComponentCallbackDefault
{
public:
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterAutoSECallback">();
	}
	static class UJackCharacterAutoSECallback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterAutoSECallback>();
	}
};
static_assert(alignof(UJackCharacterAutoSECallback) == 0x000008, "Wrong alignment on UJackCharacterAutoSECallback");
static_assert(sizeof(UJackCharacterAutoSECallback) == 0x0000A0, "Wrong size on UJackCharacterAutoSECallback");

// Class JackGame.JackCharacterCaptureCameraCharacterClassLoadManager
// 0x0028 (0x0060 - 0x0038)
class UJackCharacterCaptureCameraCharacterClassLoadManager final : public UObject
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestAsyncLoadCallback(const TArray<struct FSoftObjectPath>& TargetsToStream, const TArray<class UObject*>& LoadedObjects, int32 Index_0, const class FString& ClassPathName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterCaptureCameraCharacterClassLoadManager">();
	}
	static class UJackCharacterCaptureCameraCharacterClassLoadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterCaptureCameraCharacterClassLoadManager>();
	}
};
static_assert(alignof(UJackCharacterCaptureCameraCharacterClassLoadManager) == 0x000008, "Wrong alignment on UJackCharacterCaptureCameraCharacterClassLoadManager");
static_assert(sizeof(UJackCharacterCaptureCameraCharacterClassLoadManager) == 0x000060, "Wrong size on UJackCharacterCaptureCameraCharacterClassLoadManager");

// Class JackGame.JackOddEffectExec_NakamaTurnSkip
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_NakamaTurnSkip final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_NakamaTurnSkip">();
	}
	static class UJackOddEffectExec_NakamaTurnSkip* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_NakamaTurnSkip>();
	}
};
static_assert(alignof(UJackOddEffectExec_NakamaTurnSkip) == 0x000008, "Wrong alignment on UJackOddEffectExec_NakamaTurnSkip");
static_assert(sizeof(UJackOddEffectExec_NakamaTurnSkip) == 0x000100, "Wrong size on UJackOddEffectExec_NakamaTurnSkip");

// Class JackGame.JackCharacterCaptureCamera
// 0x00C0 (0x0470 - 0x03B0)
class AJackCharacterCaptureCamera : public ASceneCapture2D
{
public:
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        CapturePartsComponent;                             // 0x03B8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TurnTableComponent;                                // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x30];                                     // 0x03C8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackCaptureCharacterInfo>      MenuCharacterInfos;                                // 0x03F8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MonsterAnimationRepeatInterval;                    // 0x0408(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          DebugDrawToDefaultScene;                           // 0x040C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40D[0x3];                                      // 0x040D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AReflectionCapture>         ReflectionCaptureClass;                            // 0x0410(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_418[0x8];                                      // 0x0418(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDisableFieldLights;                               // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowParticleRenderingInScneCapture;              // 0x0421(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_422[0x46];                                     // 0x0422(0x0046)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bSquareViewport;                                   // 0x0468(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bOverrideMinAutoScalingFactorBySystemResolution;   // 0x0469(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_46A[0x6];                                      // 0x046A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BeginLookAt(const struct FVector& LookAtLocation, int32 Index_0);
	bool CreateMenuFriendCharacter(class FName FriendID);
	bool CreateMenuMonsterCharacter(class FName MonsterID, int32 Index_0);
	void DestroyMenuCharacters();
	void EndLookAt(int32 Index_0);
	bool PlayCharacterAnimMontage(class UAnimMontage* AnimMontage, int32 Index_0);
	bool PlayCharacterAnimMontageByKey(class FName AnimMontageKey, bool bLoop, bool bRepeat, int32 Index_0, float* OutAnimDuration, float* OutAnimRepeatTime);
	bool PlayCharacterAnimSequence(TSoftObjectPtr<class UAnimSequence> AnimSequenceAsset, int32 Index_0);
	bool PlayWeaponAnimMontageByKey(class FName MontageKey, EJackEquippedHand Hand, int32 Index_0);
	void RefreshCharacterStatus(int32 Index_0);
	void RequestAsyncLoadCallback(const TArray<struct FSoftObjectPath>& TargetsToStream, const TArray<class UObject*>& LoadedObjects, int32 Index_0, const class FString& ClassPathName);
	void RequestAsyncLoadyCharacterAnimCallback(const TArray<struct FSoftObjectPath>& TargetsToStream, const TArray<class UObject*>& LoadedObjects, int32 Index_0, class FName RequestCharacterId);
	void SetAnimationFlagOfInBattle(bool bInBattle, int32 Index_0);
	void SetAnimDynamicsIdlingCount(int32 IdlingCount, int32 Index_0);
	void SetCameraFieldOfView(float FieldOfView);
	void SetCameraLocation(const struct FVector& InPosition);
	void SetCameraPitch(float Pitch);
	void SetCharacterRelativeLocation(const struct FVector& Location, int32 Index_0);
	void SetCharacterRelativeRotation(const struct FRotator& Rotation, int32 Index_0);
	void SetDisableFieldLights(bool bDisable);
	void SetEnableCaptureEnvrionmentObjects(bool bEnable);
	void SetEnabledCapture(bool bEnabled);
	void SetLightParameter(const TArray<struct FJackZukanMotionDirectionalLightParameter>& DirectionalLightParameterList, const TArray<struct FJackZukanMotionPointLightParameter>& PointLightParameterList);
	void SetTexturesCinematicMipLevel(bool bToBeResident, int32 Index_0);
	void SetTurnTableRotation(const struct FRotator& Rotation);
	void SetTurnTableScale(float Scale);
	void SetWallpaperDistance(float Distance);
	void SpawnLoadedCharacter(bool bIgnoreEquipmentCoordinate);
	void StabilizeCharacterPose(int32 Index_0);

	bool DoesExistSpawnedCharacter() const;
	float GetCameraFieldOfView() const;
	struct FVector GetCameraLocation() const;
	float GetCameraPitch() const;
	struct FVector GetCharacterRelativeLocation(int32 Index_0) const;
	struct FRotator GetCharacterRelativeRotation(int32 Index_0) const;
	class AJackCharacter* GetJackCharacter(int32 Index_0) const;
	class FName GetMonsterZukanId(class FName MonsterID) const;
	float GetRepeatMontageTimer(int32 Index_0) const;
	struct FRotator GetTurnTableRotation() const;
	float GetTurnTableScale() const;
	bool IsEnabledCapture() const;
	bool IsLoadingAnyCharacterAnimations() const;
	bool IsLoadingAnyCharacters() const;
	bool IsToBeWantsTexturesCinematicMipLevel(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterCaptureCamera">();
	}
	static class AJackCharacterCaptureCamera* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCharacterCaptureCamera>();
	}
};
static_assert(alignof(AJackCharacterCaptureCamera) == 0x000008, "Wrong alignment on AJackCharacterCaptureCamera");
static_assert(sizeof(AJackCharacterCaptureCamera) == 0x000470, "Wrong size on AJackCharacterCaptureCamera");
static_assert(offsetof(AJackCharacterCaptureCamera, CapturePartsComponent) == 0x0003B8, "Member 'AJackCharacterCaptureCamera::CapturePartsComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, TurnTableComponent) == 0x0003C0, "Member 'AJackCharacterCaptureCamera::TurnTableComponent' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, MenuCharacterInfos) == 0x0003F8, "Member 'AJackCharacterCaptureCamera::MenuCharacterInfos' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, MonsterAnimationRepeatInterval) == 0x000408, "Member 'AJackCharacterCaptureCamera::MonsterAnimationRepeatInterval' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, DebugDrawToDefaultScene) == 0x00040C, "Member 'AJackCharacterCaptureCamera::DebugDrawToDefaultScene' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, ReflectionCaptureClass) == 0x000410, "Member 'AJackCharacterCaptureCamera::ReflectionCaptureClass' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, bDisableFieldLights) == 0x000420, "Member 'AJackCharacterCaptureCamera::bDisableFieldLights' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, bAllowParticleRenderingInScneCapture) == 0x000421, "Member 'AJackCharacterCaptureCamera::bAllowParticleRenderingInScneCapture' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, bSquareViewport) == 0x000468, "Member 'AJackCharacterCaptureCamera::bSquareViewport' has a wrong offset!");
static_assert(offsetof(AJackCharacterCaptureCamera, bOverrideMinAutoScalingFactorBySystemResolution) == 0x000469, "Member 'AJackCharacterCaptureCamera::bOverrideMinAutoScalingFactorBySystemResolution' has a wrong offset!");

// Class JackGame.JackCharacterComponentDebugger
// 0x0000 (0x0038 - 0x0038)
class IJackCharacterComponentDebugger final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterComponentDebugger">();
	}
	static class IJackCharacterComponentDebugger* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJackCharacterComponentDebugger>();
	}
};
static_assert(alignof(IJackCharacterComponentDebugger) == 0x000008, "Wrong alignment on IJackCharacterComponentDebugger");
static_assert(sizeof(IJackCharacterComponentDebugger) == 0x000038, "Wrong size on IJackCharacterComponentDebugger");

// Class JackGame.JackCharacterManager
// 0x00E0 (0x0478 - 0x0398)
class AJackCharacterManager final : public AActor
{
public:
	uint8                                         Pad_398[0xD8];                                     // 0x0398(0x00D8)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackCharacter>          TalkingNpc;                                        // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterManager">();
	}
	static class AJackCharacterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCharacterManager>();
	}
};
static_assert(alignof(AJackCharacterManager) == 0x000008, "Wrong alignment on AJackCharacterManager");
static_assert(sizeof(AJackCharacterManager) == 0x000478, "Wrong size on AJackCharacterManager");
static_assert(offsetof(AJackCharacterManager, TalkingNpc) == 0x000470, "Member 'AJackCharacterManager::TalkingNpc' has a wrong offset!");

// Class JackGame.JackCharacterMovementTrack
// 0x0000 (0x00F0 - 0x00F0)
class UJackCharacterMovementTrack final : public UJackMoveTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterMovementTrack">();
	}
	static class UJackCharacterMovementTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterMovementTrack>();
	}
};
static_assert(alignof(UJackCharacterMovementTrack) == 0x000008, "Wrong alignment on UJackCharacterMovementTrack");
static_assert(sizeof(UJackCharacterMovementTrack) == 0x0000F0, "Wrong size on UJackCharacterMovementTrack");

// Class JackGame.JackCharacterMovementTrackInst
// 0x0000 (0x0050 - 0x0050)
class UJackCharacterMovementTrackInst final : public UInterpTrackInstMove
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterMovementTrackInst">();
	}
	static class UJackCharacterMovementTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterMovementTrackInst>();
	}
};
static_assert(alignof(UJackCharacterMovementTrackInst) == 0x000008, "Wrong alignment on UJackCharacterMovementTrackInst");
static_assert(sizeof(UJackCharacterMovementTrackInst) == 0x000050, "Wrong size on UJackCharacterMovementTrackInst");

// Class JackGame.JackPlayableMovementMode
// 0x0008 (0x0040 - 0x0038)
class UJackPlayableMovementMode : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableMovementMode">();
	}
	static class UJackPlayableMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableMovementMode>();
	}
};
static_assert(alignof(UJackPlayableMovementMode) == 0x000008, "Wrong alignment on UJackPlayableMovementMode");
static_assert(sizeof(UJackPlayableMovementMode) == 0x000040, "Wrong size on UJackPlayableMovementMode");

// Class JackGame.JackPlayableDefaultMovementMode
// 0x0000 (0x0040 - 0x0040)
class UJackPlayableDefaultMovementMode : public UJackPlayableMovementMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableDefaultMovementMode">();
	}
	static class UJackPlayableDefaultMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableDefaultMovementMode>();
	}
};
static_assert(alignof(UJackPlayableDefaultMovementMode) == 0x000008, "Wrong alignment on UJackPlayableDefaultMovementMode");
static_assert(sizeof(UJackPlayableDefaultMovementMode) == 0x000040, "Wrong size on UJackPlayableDefaultMovementMode");

// Class JackGame.JackPlayableOsihikiMovementMode
// 0x0018 (0x0058 - 0x0040)
class UJackPlayableOsihikiMovementMode final : public UJackPlayableDefaultMovementMode
{
public:
	TWeakObjectPtr<class AJackInteractiveActor>   HauledActor;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_48[0x10];                                      // 0x0048(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetOsihikiActor(class AJackInteractiveActor* InActor);
	void SetOsihikiMovementScale(float InMovementScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableOsihikiMovementMode">();
	}
	static class UJackPlayableOsihikiMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableOsihikiMovementMode>();
	}
};
static_assert(alignof(UJackPlayableOsihikiMovementMode) == 0x000008, "Wrong alignment on UJackPlayableOsihikiMovementMode");
static_assert(sizeof(UJackPlayableOsihikiMovementMode) == 0x000058, "Wrong size on UJackPlayableOsihikiMovementMode");
static_assert(offsetof(UJackPlayableOsihikiMovementMode, HauledActor) == 0x000040, "Member 'UJackPlayableOsihikiMovementMode::HauledActor' has a wrong offset!");

// Class JackGame.JackCharacterSystem
// 0x0078 (0x00B0 - 0x0038)
class UJackCharacterSystem : public UObject
{
public:
	class UJackGameCharacterManager*              GameCharacterManager;                              // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackDressupCoordinateManager*          DressupCoordinateManager;                          // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FieldAttackMaxDamageRate;                          // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiIconDistance;                              // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiIconVanishDistance;                        // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiDistance;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiForceVanishDistance;                       // 0x0058(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMin_NormalVisible;                      // 0x005C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMax_NormalVisible;                      // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMin_NormalInvisible;                    // 0x0064(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMax_NormalInvisible;                    // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMin_ShortVisible;                       // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMax_ShortVisible;                       // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMin_ShortInvisible;                     // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FukidasiSecMax_ShortInvisible;                     // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackCharacterCoordinateLODInfo        SlaveMeshOverrideLODInfos[0x2];                    // 0x0080(0x0010)(Edit, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackActiveTokugiSpecialConditionSetting> ActiveTokugiSpecialConditionSetting;               // 0x00A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	class AJackMonsterCharacter* CreateMonster(class UClass* InClass, class AActor* InOwner, const struct FVector& InLocation, const struct FRotator& InRotator);
	void RecoverPartyMembers(EJackCharacterRecover RecoverType, bool bRevive);

	const class UJackGameCharacterManager* GetGameCharacterManager() const;
	const class UJackGamePlayer* GetGamePlayer() const;
	int32 GetRemainingExpToNextLevel(class UJackGameCharacter* InGameCharacter) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterSystem">();
	}
	static class UJackCharacterSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterSystem>();
	}
};
static_assert(alignof(UJackCharacterSystem) == 0x000008, "Wrong alignment on UJackCharacterSystem");
static_assert(sizeof(UJackCharacterSystem) == 0x0000B0, "Wrong size on UJackCharacterSystem");
static_assert(offsetof(UJackCharacterSystem, GameCharacterManager) == 0x000038, "Member 'UJackCharacterSystem::GameCharacterManager' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, DressupCoordinateManager) == 0x000040, "Member 'UJackCharacterSystem::DressupCoordinateManager' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FieldAttackMaxDamageRate) == 0x000048, "Member 'UJackCharacterSystem::FieldAttackMaxDamageRate' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiIconDistance) == 0x00004C, "Member 'UJackCharacterSystem::FukidasiIconDistance' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiIconVanishDistance) == 0x000050, "Member 'UJackCharacterSystem::FukidasiIconVanishDistance' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiDistance) == 0x000054, "Member 'UJackCharacterSystem::FukidasiDistance' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiForceVanishDistance) == 0x000058, "Member 'UJackCharacterSystem::FukidasiForceVanishDistance' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMin_NormalVisible) == 0x00005C, "Member 'UJackCharacterSystem::FukidasiSecMin_NormalVisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMax_NormalVisible) == 0x000060, "Member 'UJackCharacterSystem::FukidasiSecMax_NormalVisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMin_NormalInvisible) == 0x000064, "Member 'UJackCharacterSystem::FukidasiSecMin_NormalInvisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMax_NormalInvisible) == 0x000068, "Member 'UJackCharacterSystem::FukidasiSecMax_NormalInvisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMin_ShortVisible) == 0x00006C, "Member 'UJackCharacterSystem::FukidasiSecMin_ShortVisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMax_ShortVisible) == 0x000070, "Member 'UJackCharacterSystem::FukidasiSecMax_ShortVisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMin_ShortInvisible) == 0x000074, "Member 'UJackCharacterSystem::FukidasiSecMin_ShortInvisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, FukidasiSecMax_ShortInvisible) == 0x000078, "Member 'UJackCharacterSystem::FukidasiSecMax_ShortInvisible' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, SlaveMeshOverrideLODInfos) == 0x000080, "Member 'UJackCharacterSystem::SlaveMeshOverrideLODInfos' has a wrong offset!");
static_assert(offsetof(UJackCharacterSystem, ActiveTokugiSpecialConditionSetting) == 0x0000A0, "Member 'UJackCharacterSystem::ActiveTokugiSpecialConditionSetting' has a wrong offset!");

// Class JackGame.JackCharacterUIComponent
// 0x0000 (0x01A0 - 0x01A0)
class UJackCharacterUIComponent final : public UJackCharacterComponent
{
public:
	void CloseNamePlate();
	void HideAngryIcon();
	void HideEmotionEffect(EJackMonsterEmotionIcon EmotionIcon);
	void OpenMonsterNamePlate();
	void OpenNamePlate(const class FString& Message);
	void ShowAngryIcon();
	void ShowEmotionEffect(EJackMonsterEmotionIcon EmotionIcon);
	void ShowExclamationEffect();
	void ShowQuestionEffect();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCharacterUIComponent">();
	}
	static class UJackCharacterUIComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCharacterUIComponent>();
	}
};
static_assert(alignof(UJackCharacterUIComponent) == 0x000008, "Wrong alignment on UJackCharacterUIComponent");
static_assert(sizeof(UJackCharacterUIComponent) == 0x0001A0, "Wrong size on UJackCharacterUIComponent");

// Class JackGame.JackOddEffectExec_Kabawareru
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Kabawareru final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Kabawareru">();
	}
	static class UJackOddEffectExec_Kabawareru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Kabawareru>();
	}
};
static_assert(alignof(UJackOddEffectExec_Kabawareru) == 0x000008, "Wrong alignment on UJackOddEffectExec_Kabawareru");
static_assert(sizeof(UJackOddEffectExec_Kabawareru) == 0x000100, "Wrong size on UJackOddEffectExec_Kabawareru");

// Class JackGame.JackUMGSibariPlay
// 0x0000 (0x0400 - 0x0400)
class UJackUMGSibariPlay : public UJackUMGWindowBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSibariPlay">();
	}
	static class UJackUMGSibariPlay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSibariPlay>();
	}
};
static_assert(alignof(UJackUMGSibariPlay) == 0x000008, "Wrong alignment on UJackUMGSibariPlay");
static_assert(sizeof(UJackUMGSibariPlay) == 0x000400, "Wrong size on UJackUMGSibariPlay");

// Class JackGame.JackCheatManager
// 0x0000 (0x0088 - 0x0088)
class UJackCheatManager final : public UCheatManager
{
public:
	void ActionLearn(class FName TargetName, class FName ActionID);
	void ActionLearnJumon();
	void ActionPlay(class FName ActionID);
	void ActionPreview(class FName TargetCharacterName);
	void ArasuziDebugFlagSet(class FName ArasuziId, bool bPlayThroughSecond);
	void AssetRegistryEnabled(bool bEnabled);
	void AudioMasterVolume(float Volume);
	void AudioSEADVolume(float Volume);
	void AutoRun();
	void BattleActionCameraDebugMode();
	void BattleActionCameraInfo();
	void BattleActionExtentInfo();
	void BattleActionInfo();
	void BattleAIFirstCheckChange();
	void BattleAIFirstCheckLogShow();
	void BattleAISecondCheckChange();
	void BattleAISecondCheckLogShow();
	void BattleAutoCameraInfo(int32 Value);
	void BattleAutoCameraParam(int32 Value);
	void BattleBackJump();
	void BattleBackJumpForceByAutoCamera();
	void BattleBackJumpThresholdLength(float Length);
	void BattleBukiGuard(int32 Value);
	void BattleCalcInfo();
	void BattleCameraMode(int32 Value);
	void BattleCharaInfo();
	void BattleCharaStateInfo();
	void BattleCollisionInfo();
	void BattleCommandAIActionPattern(int32 Order1, int32 Order2, int32 Order3, int32 Order4, int32 Order5, int32 Order6);
	void BattleCommandAIChangeActionPattern(class FName ActionPatternTypeName);
	void BattleCommandAIChangeIntelligence(class FName IntelligenceTypeName);
	void BattleCommandAIInfo();
	void BattleCommandAISet(const class FName& BattleAIID, const class FName& TargetCharacterName);
	void BattleCounter(int32 Value);
	void BattleCritical(int32 Value);
	void BattleDataTableCheck();
	void BattleDead(class FName TargetName);
	void BattleDistantBranch(int32 Value);
	void BattleDropCertainty();
	void BattleEncountEnable();
	void BattleEventBattleInfo();
	void BattleFieldFailSafe(int32 FailSafeType);
	void BattleFieldHiddenGrass(int32 Value);
	void BattleFieldInfo();
	void BattleFieldLowAngleCameraInvalid(int32 Value);
	void BattleFixDamage(int32 Damage);
	void BattleFukidasiForce();
	void BattleFukidasiForceID(class FName FukidasiID);
	void BattleFukidasiInfo(int32 Value);
	void BattleFukidasiPush(class FName FukidasiTextID);
	void BattleFukidasiReset();
	void BattleGroupInfo();
	void BattleGuestNPCControl(int32 Value);
	void BattleHazukasiiNoroi(int32 Value);
	void BattleHazukasiiNoroiText(int32 Value);
	void BattleHitStop(class FName HitStopPresetTypeEnumName);
	void BattleLockOnMovementTest();
	void BattleLose();
	void BattleMikawasi(int32 Value);
	void BattleMiss(int32 Value);
	void BattleMitoreru(int32 Value);
	void BattleMonsterAppearDrawBox();
	void BattleMonsterAppearSkip();
	void BattleMonsterLimit(int32 Value);
	void BattleMonsterNigeru(int32 Value);
	void BattleMonsterSpawn(class FName MonsterID);
	void BattleMovementInfo();
	void BattleNakamaYobiInfo();
	void BattleNigeru(int32 Value);
	void BattleOddEffect(int32 Value);
	void BattleOpen();
	void BattlePerfInfo();
	void BattlePlayerAICalcInfo();
	void BattlePlayerAIFlowBossBattle();
	void BattlePlayerAIFlowLogShow();
	void BattlePlayerAIScoreCheckLogShow();
	void BattlePlayerAITestFlow();
	void BattlePlayerMoveSpeedInterpIn(float InterpTimeCoeff);
	void BattlePlayerMoveSpeedInterpOut(float InterpTimeCoeff);
	void BattlePlayerMoveTest(int32 TestMode);
	void BattlePlayerMoveTurnToEnable(bool bEnable);
	void BattlePopupBalloon();
	void BattlePositioningInfo();
	void BattlePositioningMonster(int32 Value);
	void BattlePositioningPlayer(int32 Value);
	void BattlePreparationCameraDrawSphere();
	void BattleRareDropCertainty();
	void BattleResultDrop2000Lottery();
	void BattleResultDropLog();
	void BattleResultSkip();
	void BattleRoundInfo();
	void BattleSenseiKougeki(int32 Value);
	void BattleSpeedMode(int32 Value);
	void BattleSpeedModeParam(float TimeDilation, float TimeDilationByVeryFast);
	void BattleStateInfo();
	void BattleTateGuard(int32 Value);
	void BattleTeleportInfo();
	void BattleTextDebug_Action(class FName ActionID, EJackActionTextType TextType);
	void BattleTextDebug_OddEffect(class FName OddEffectID, EJackActionTextType TextType);
	void BattleTextDebug_SetTag(class FName InCaster, class FName InTarget, int32 InDamage);
	void BattleTextDebug_TextID(class FName TextID);
	void BattleTextInfo();
	void BattleToubatuEffect(int32 Value);
	void BattleTurnSkip(int32 Value);
	void BattleVoiceInfo();
	void BattleVoiceLanguage(class FName Language);
	void BattleWin();
	void BattleZoneInfo();
	void BGMVolumeEditor();
	void BlockingLoadForceHighPriority();
	void BoukenGuideIdDebugReset();
	void BoukenGuideIdDebugSet(class FName InBoukenGuideId);
	void BowgunGet();
	void ChangePadModePS4();
	void ChangePadModeVita();
	void CharacterCaptureDebugMode(bool bShowInfo, bool bShowTargetSize);
	void CharacterCaptureEnableFixedColor(bool bEnable);
	void CharacterCaptureSetFixedColor(float Intensity);
	void CharacterCheatParameter(const class FName& ParameterName, float ParameterValue, const class FName& TargetCharacterName);
	void CharacterCheatParameterInfo();
	void CharacterCheatParameterMode(const class FName& Mode);
	void CharacterCheatParameterReset(const class FName& TargetCharacterName);
	void CheckAcquiredAchievementTrophyList();
	void CheckRegion();
	void ClearCameraFade();
	void ClearFontCache();
	void ClearInstallDummyResult();
	void ClearPreloadMap();
	void CloseMiniMap(bool bRemoveWidget, bool bForceRemove);
	void CloseText();
	void ClothAllEnabled(bool bEnabled);
	void ClothNPCEnabled(bool bEnabled);
	void CommandReceiverInfo();
	void CopyMonsterLookUpDefeatLogs();
	void Crash();
	void CrashDumpTest();
	void CutSceneFinish(class FName InCSStart, class FName InCSEnd);
	void DebugAutoRun();
	void DebugBGMVolume();
	void DebugGameCamera();
	void DebugLoadGame(int32 SlotIndex);
	void DebugMenu();
	void DebugMenuEnabled(bool bEnabled);
	void DebugMenuItemExec(const class FString& MenuFullPath);
	void DebugSaveGame(int32 SlotIndex);
	void DebugSpawnAllPartyCharacters();
	void DebugVehicleMinimumSizeRadius(bool bOn);
	void DefragGPUResources();
	void DestroyActorByName(const class FString& Name_0);
	void DisableAchievementAcquisition(bool bDisable);
	void DisableBattlePhotoMode(bool bIsDisable);
	void DisableCharacterTickInterval(bool bDisable);
	void DisableCutSceneFixedDynamicResolution();
	void DisableFlagBreakPoint(const class FString& FlagCategory, class FName FlagName, const class FString& AccessType);
	void DisableLoadReductionForNPC(bool bDisable);
	void DispersionEnable();
	void DispersionInfo();
	void DisplayAchievementInfo();
	void DisplayCameraModeStack();
	void DisplayCharacterComponentInfo(const class FString& ComponentName);
	void DisplayCharacterInfo();
	void DisplayCharacterTickIntervalInfo();
	void DisplayChurchInfo();
	void DisplayCoinInfo();
	void DisplayDebugInfo();
	void DisplayEOSCommandLine();
	void DisplayEquipmentInfo();
	void DisplayExecutedRenkeiInfo(bool bMonsterRenkei);
	void DisplayFukkatunojumonInfo();
	void DisplayGamePlayerInfo();
	void DisplayGamma(float Gamma);
	void DisplayGCInfo();
	void DisplayHasItemObjectInfo();
	void DisplayInnInfo();
	void DisplayInstallInfo();
	void DisplayItemGetIcon(class FName ItemID);
	void DisplayItemGettableObjectInfo();
	void DisplayItemInfo();
	void DisplayItemPresentInfo();
	void DisplayKiraInfo();
	void DisplayMapInfo();
	void DisplayMedalInfo();
	void DisplayModeSelectCameraInfo();
	void DisplayNPCInfo(const class FString& CharacterName);
	void DisplayNPCStat();
	void DisplayPlayerCamera();
	void DisplayPreloadInfo();
	void DisplayRecipeBookInfo();
	void DisplayRuraInfo();
	void DisplaySaveDataInfo();
	void DisplayShopInfo();
	void DisplaySibariInfo();
	void DisplaySoundDebugInfo(class FName CharacterID);
	void DisplaySQEXNGWordInfo();
	void DisplayTabiNoKokoroe(class FName TabiNoKokoroeID);
	void DisplayTextIdInfo();
	void DisplayTextMacroReplaceInfo();
	void DisplayUIFukidasiIconInfo();
	void DisplayUIMenuInfo();
	void DisplayUIMenuList();
	void DisplayUISelectedItem();
	void DisplayUiStaffRollInfo();
	void DisplayUiStaffRollWarningInfo();
	void DisplayWeatherInfo();
	void DisplayWorldInfo();
	void DumpAssetNameSpecifiedVersion(const class FString& UE4Version);
	void DumpAssetNumberEachVersion();
	void DumpConsoleCommandsAll();
	void DumpConsoleCommandsJack();
	void DumpConsoleCommandsUE4();
	void DumpDressupCoordinate();
	void DumpFlag();
	void DumpFukkatunojumonCommand(int32 ScenarioNumber);
	void DumpMapSymbolInfo();
	void DumpObjectCount(int32 Type, const class FString& SearchWord);
	void DumpPlayerCoordinateInfo();
	void DumpRedmineInfo();
	void DumpReferencingObject(const class FString& Name_0);
	void DynamicResolution();
	void EmptyPCFootmark();
	void EnableDisplayDebugLog(bool bEnable);
	void EnableFlagBreakPoint(const class FString& FlagCategory, class FName FlagName, const class FString& AccessType);
	void EnableP001Voice(bool bEnable);
	void Exec2DCasino(class FName InGameName);
	void ExportSaveData();
	void FindOnMemoryObject(const class FString& Name_0);
	void FixedTimeStep30();
	void FixedTimeStep60();
	void FixupLooks();
	void FlagLogOff(int32 Slot);
	void FlagLogOn(int32 Slot);
	void FlagLogPrint(int32 Slot);
	void FootIKAllDisabled(bool bDisabled);
	void FootIKNPCDisabled(bool bDisabled);
	void ForceAcquireAchievementAll();
	void ForceAcquireAchievementDirect(class FName AchievementID);
	void ForceAddDefeatMonsterCount(class FName MonsterID, int32 AddCount);
	void ForceClearAchievementQueue();
	void ForceClearedSecondPlaythrough(bool bFlag);
	void ForceCutSceneDebug(bool bEnable);
	void ForceDebugBreak();
	void ForceDepositGold(int32 Gold_0);
	void ForceDisableNewMark(class FName ItemID);
	void ForceDiscardBagAll();
	void ForceDiscardItem(class FName ItemID);
	void ForceDisplayFukidasi(class FName FukidasiID);
	void ForceEquipItemAttach(EJackCharacter CharacterType, EJackEquipmentRegion RegionType, class FName ItemID, bool bUseAuto);
	void ForceEquipItemDetach(EJackCharacter CharacterType, EJackEquipmentRegion RegionType);
	void ForceExchangeCoinItem(class FName ExchangeId);
	void ForceExchangeMedalItem(class FName ExchangeId);
	void ForceExchangeShopFlag(bool bFlag);
	void ForceExperienceRecipeAll(int32 Result);
	void ForceExperienceRecipeAllRandom();
	void ForceExperienceRecipeRank(class FName RecipeName, int32 Result);
	void ForceExperienceRecipeRankIndex(int32 RecipeIndex, int32 Result);
	void ForceExperienceRecipeRankParts(class FName PartsName, int32 Result);
	void ForceFukkatunojumon(const class FString& PlayerName, int32 ScenarioProgress);
	void ForceFukkatunojumonDecode(const class FString& InStr);
	void ForceFukkatunojumonEncode();
	void ForceGarbageCollection(bool bFullPurge);
	void ForceGC(bool bFullPurge);
	void ForceGetItem(class FName ItemID, int32 ItemCount);
	void ForceGetItemToBag(class FName ItemID, int32 ItemCount, EJackItem_Bag BagType);
	void ForceHaveStampPage4Flag(bool bFlag);
	void ForceHiddenNPC(bool bHidden, float Distance);
	void ForceLearningBrowsedRecipeBook(class FName RecipeBookID);
	void ForceLearningBrowsedRecipeBookAcquiredAll();
	void ForceLearningBrowsedRecipeBookAll();
	void ForceLearningBrowsedRecipeBookForItemId(class FName ItemID);
	void ForceLearningRecipeBook(class FName RecipeBookID);
	void ForceLearningRecipeBookAll();
	void ForceLearningRecipeBookFItemId(class FName ItemID);
	void ForceLossBrowsedRecipeBook(class FName RecipeBookID);
	void ForceLossBrowsedRecipeBookAll();
	void ForceLossBrowsedRecipeBookForItemId(class FName ItemID);
	void ForceLossRecipeBook(class FName RecipeBookID);
	void ForceLossRecipeBookAll();
	void ForceLossRecipeBookFromItemId(class FName ItemID);
	void ForceMapJumpDebug(bool bEnable);
	void ForceMoveItem(EJackItem_Bag BagTypeDst, EJackItem_Bag BagTypeSrc, int32 Index_0, int32 ItemCount);
	void ForceParameterSettingPowerAwakening();
	void ForceParameterSettingWhenBackToThePast();
	void ForceReceiveItemPresent(class FName DlcId);
	void ForceRecordExecuteMonsterRenkei(class FName MonsterRenkeiID);
	void ForceRecordExecuteRenkei(class FName RenkeiID);
	void ForceRecordRideMonsterVehicle(EJackVehicle VehicleID);
	void ForceRemoveDefeatMonster(class FName MonsterID);
	void ForceSavingBackToThePastInfo();
	void ForceSetBattleCountBySwordAttack(int32 Count);
	void ForceSetBattlePlayerAICalcScoreTimeMax(float TimeMax);
	void ForceSetBattleVictoryCount(int32 Count);
	void ForceSetBlowAwayMonsterCount(int32 Count);
	void ForceSetCampCount(int32 Count);
	void ForceSetCoinCount(int32 Count);
	void ForceSetDefeatMetalMonsterTotalCount(int32 Count);
	void ForceSetDefeatMonsterTotalCount(int32 Count);
	void ForceSetDefeatMonsterZukanCount(class FName MonsterZukanID, int32 Count);
	void ForceSetEnableOverrideTranslationText();
	void ForceSetHazukasiiNoroiTalkMessage(int32 Index_0);
	void ForceSetHazukasiiNoroiTalkRate(int32 Rate);
	void ForceSetInnStayCount(int32 Count);
	void ForceSetItemGettableObjectFlag(class FName ID, bool bGetFlag);
	void ForceSetItemIndex(EJackItem_Bag BagType, int32 DstIndex, int32 SrcIndex);
	void ForceSetItemTotalGetCount(class FName ItemID, int32 Count);
	void ForceSetItemUseCount(class FName ItemID, int32 Count);
	void ForceSetKaziCreatePlayCount(int32 InCount);
	void ForceSetKaziRetryPlayCount(int32 InCount);
	void ForceSetKiraReplacementSec(float Seconds);
	void ForceSetMedalCount(int32 Count);
	void ForceSetObjectDestructionCount(int32 Count);
	void ForceSetPlaythrough(int32 Through);
	void ForceSetQuestClearCount(int32 Count);
	void ForceSetRenkeiUseCount(int32 Count);
	void ForceSetSibariPlayDisplayFlag(bool bFlag);
	void ForceSetSibariPlayFlag(EJackSibari Type, bool bFlag);
	void ForceSetTokugiUseCount(class FName ActionID, int32 Count);
	void ForceSetUsoTalkMessage(int32 Index_0);
	void ForceSetUsoWoTsukuTalkRate(int32 Rate);
	void ForceSetWorldTime(int32 Hour, int32 Min, int32 Sec, bool bResetNPCSchedule);
	void FrameSkip();
	void FrameTimeControl(int32 Mode);
	void FreeCamera();
	void FriendJoin(class FName InName);
	void FriendLeave(class FName InName);
	void FriendLeaveKeepItems(class FName InName);
	void FusigiKaziGetNowGaugeValue();
	void FusigiKaziSetGaugeValue();
	void FusigiKaziSetSuccessNum();
	void FusigiKaziSetTemperature();
	void GatherOnMemoryObject(const class FString& StrAddr);
	void GetFlag(const class FString& FlagCategory, class FName FlagName);
	void Gold(int32 InGold);
	void GuestNpcJoin(class FName InName);
	void GuestNpcLeave(class FName InName);
	void GuestNpcWarp(EJackCharacter InType);
	void HDVibration(int32 Mode);
	void HiddenActorByName(const class FString& Name_0, bool bHidden);
	void HiddenNPCBy(float Distance);
	void HideScreenShotCopyright();
	void HPSet(class FName InName, int32 NewHP);
	void ImportSaveData();
	void IncrementalGC();
	void JackHelp();
	void JumonForget(class FName InName);
	void JumonGet(class FName InName);
	void KaziFlagSet(bool InFlag);
	void KillOffMonsters();
	void KillOffPlayers();
	void LevelPause();
	void LevelSet(class FName InName, int32 InLevel);
	void LoadGame(int32 SlotIndex);
	void LoadingTipsDebug(class FName InTipsNo);
	void LoadingTipsSwitchTime(float InTipsSwitchTime);
	void LoadingTipsView(class FName InTipsNo);
	void LoadSavedGame(int32 SlotIndex);
	void LoadSystem();
	void LockAllAchievements();
	void LogAssetInfo(const class FString& AssetPath);
	void LogAssetList(const class FString& AssetPath);
	void LogItemPictorialBookInfo();
	void LogLevelPackageInfo();
	void LogLevelPackageList();
	void LogMapStartPackageInfo(const class FName MapStartName);
	void LogMapStartPackageList(const class FName MapStartName);
	void LogMemoryPackageInfo();
	void LogMemoryPackageList();
	void LogNPCInfo(int32 Mode);
	void LogPackageInfo(const class FString& PackagePath);
	void LogPackageList(const class FString& PackagePath);
	void LogShowTextMacroReplace();
	void MeasureLetterSize();
	void MonsterForceLotteryType(const class FName& InLotteryType);
	void MonsterGeneratorEnabled();
	void MonsterLotteryNumMax(int32 InSpecifyCost);
	void MonsterSensorEnabled();
	void MonsterSpawn(const class FName& MonsterID);
	void MonsterSpawnNear();
	void MonsterSpawnWithSubstance(const class FName& MonsterID, const class FName& SubstanceId);
	void MPMax(class FName InName);
	void MPSet(class FName InName, int32 NewMP);
	void MSC(const class FName& DebugCommandMacroShortCut);
	void MusicDirectLoadMode();
	void MuteAudio();
	void Muteki(class FName InName, bool bEnabled);
	void NotUnlockUE4Achievements(bool bIsProhibit);
	void OddEffectClear(class FName OddEffectID, class FName TargetName);
	void OddEffectClearBad(class FName TargetName);
	void OddEffectClearBattleEnd();
	void OddEffectClearGood(class FName TargetName);
	void OddEffectInfo();
	void OddEffectSet(class FName OddEffectID, class FName TargetName);
	void OddEffectSetBad(class FName TargetName);
	void OddEffectSetGood(class FName TargetName);
	void OddEffectSetTakusan(class FName TargetName);
	void OpenImeNameEntry();
	void OpenMiniMap();
	void OpenPresentCodeInputScreen();
	void OpenProductBrowse(class FName DlcId);
	void Output2DGameDataText();
	void OutputGameDataText();
	void PackagesLoadList(const class FString& Search);
	void ParticleInfo();
	void PartyTalkCameraSetting();
	void PartyTalkFriendJoin(EJackCharacter InType);
	void PartyTalkTestTalk(class FName InTextNo);
	void PauseActorByName(const class FString& Name_0, bool bPause);
	void PauseItemGettableObject(bool bPause);
	void PerchMovement(bool bEnable);
	void PhotoMode_CameraReturnDisable();
	void PhotoMode_CameraReturnEnable();
	void PhotoMode_CharacterEnter();
	void PhotoMode_CharacterHeadLookAt();
	void PhotoMode_CharacterHeadLookAtEnd();
	void PhotoMode_CharacterLeave();
	void PhotoMode_CharacterLookAt();
	void PhotoMode_DispDebugInfo();
	void PhotoMode_DispRelocateCharaDistance();
	void PhotoMode_DispRelocateRadius();
	void PhotoMode_PlayCharacterEmotion(const class FName& EmotionName);
	void PhotoMode_PlayCharacterEmotionDebug();
	void PhotoMode_SetAlignmentCharaDistance(float InDistance);
	void PhotoMode_SetAlignmentCharaShift(float InShift);
	void PhotoMode_SetAlignmentType(int32 InType);
	void PhotoMode_SetAlignmentWtypeCharaDepth(float InDepth);
	void PhotoMode_SetAlignmentWtypeCharaDistance(float InDepth);
	void PhotoMode_SetHiddenCharacter(bool bInHidden);
	void PhotoMode_SetLookAtType(int32 InType);
	void PhotoMode_SetRelocateCharaDistance(float InDistance);
	void PhotoMode_SetRelocateRadius(float InRadius);
	void PhotoMode_StopCharacterEmotion();
	void PhotoMode_TeleportCharacter(float InX, float InY, float InZ, float InYaw);
	void PhotoModeDebugSavePath(const class FString& InSavePath);
	void PhotoModeErrorTest(int32 ErrorNo);
	void PlatformSpecificText(const class FString& InText);
	void Play2DMovie(class FName InCutSceneID);
	void PlayEffect(const class FString& ParticlePath);
	void PlayerMakerUpdateOnTeleport(bool bEnable);
	void PreloadMap(const class FName MapStartName);
	void PreloadMemoryOutPut();
	void PreloadOnOff();
	void PreloadOutPutLog();
	void PreloadStopWatchStart(class FName KeyName);
	void PreloadStopWatchStop(class FName KeyName);
	void PreloadSubLevelFastMode(int32 InMode);
	void PrintFontList();
	void PrintLetters();
	void PrintSimpleText(const class FName& InTextId);
	void PrintSimpleTextArgs(const TArray<class FString>& ParamList);
	void PrintText(const class FName& InTextId);
	void PrintTextArgs(const TArray<class FString>& ParamList);
	void QuestParamaterLogOutput(bool bOnlyValidData);
	void QuestProgressSet(class FName QuestId, int32 ProgressFlag);
	void RandInfo();
	void RandomEncountImmediately();
	void ReacquiredJackUE4Achievement(EJackAchievementCategory InCategory, EJackAchievementCondition InCondition);
	void RecoverAll(bool bRevive);
	void RefreshItemGettableObject();
	void RefreshMonsterDeploy();
	void RemoveFlagBreakPoint(const class FString& FlagCategory, class FName FlagName);
	void RemoveScenario();
	void RenkeiAvailable();
	void RenkeiCutInFastestTimeZero();
	void RenkeiFormationView();
	void RenkeiSpectacleShowResult(int32 Value);
	void ResetFlags(const class FString& FlagCategory);
	void ResetGamePlayerCondition();
	void RiremitoJump(const class FName& InJumpTag);
	void RootMotionDisabled(bool bDisabled);
	void RunMacro(const class FName& DebugCommandMacro);
	void RunRate(float PlayRate);
	void RuraDebugCheck(bool bStart);
	void RuraJump(const class FName& InJumpTag);
	void SakusenSet(class FName InName, class FName SakusenName);
	void SaveGame(int32 SlotIndex);
	void SaveGame2D(int32 SlotIndex);
	void SaveMapJourney();
	void SaveSystem(int32 SlotIndex);
	void SerifuWindowInvisible(bool bInvisible);
	void SetAchievedSibariSetting(int32 Index_0, bool bEnable);
	void SetAchievementForcedUnlockFlag(bool IsForcedFlag);
	void SetActorHiddenInGame(const class FString& PatternStr);
	void SetActorNotHiddenInGame(const class FString& PatternStr);
	void SetActorRotation(float Pitch, float Yaw, float Roll);
	void SetAutoCaptionInterval(float TimeSec);
	void SetAutomaticFeedOfSpeechEnable(bool bEnable);
	void SetAutomaticFeedOfSpeechShowUIInterval(float TimeSec);
	void SetBGMOrchestraDiscVersion(bool bIsOrchestra);
	void SetCharacterFixedTickIntervalDistance(bool bEnable, float Distance1Int, float Distance2Int);
	void SetControlledCharacterType(EJackCharacter CharacterType);
	void SetControlRotation(float CameraRoll, float CameraPitch, float CameraYaw);
	void SetCSBatchArray(const class FString& FilePath);
	void SetCutSceneAutomaticFeedOfSpeechIntervalInLoopVoice(float TimeSec);
	void SetCutSceneAutomaticFeedOfSpeechIntervalInText(float TimeSec);
	void SetCutSceneAutomaticFeedOfSpeechIntervalInVoice(float TimeSec);
	void SetCutSceneOneLetterInterval(float TimeSec);
	void SetEditionType(EJackEdition InEditionType);
	void SetEnabledLiveStreaming(bool bEnable);
	void SetEnabledScreenShot(bool bEnable);
	void SetEnabledSharePlay(bool bEnable);
	void SetEnabledVideoRecording(bool bEnable);
	void SetEncountEnabled(bool bEnabled);
	void SetFlag(const class FString& FlagCategory, class FName FlagName, const class FString& Value);
	void SetFollowingCharactersActionCursorType(int32 Index_0);
	void SetFollowingFriendCharactersAnimationType(int32 Index_0);
	void SetFukkatuNoJumon(const class FString& InTitle);
	void SetGameplayTime(int32 GameplayTime);
	void SetGCInterval(int32 Interval);
	void SetHiddenFollowingFriendCharacterByCharacterType(EJackCharacter CharacterType, bool bHidden);
	void SetHiddenFollowingFriendCharacters(bool bHidden);
	void SetInstallDummyResult(int64 Result);
	void SetMapVisit(class FName InMapVolumeID, bool InVisited);
	void SetMiniMapVisible(bool bVisible);
	void SetModeSelectCameraPlayWait(int32 InValue);
	void SetModeSelectCameraWait(int32 InValue);
	void SetMonsterOptimize(bool bEnabled);
	void SetNamaeInputOffsetX(float InOffset);
	void SetOffAchievementMessage(bool bOn);
	void SetOffTutorialMessage(bool bOn);
	void SetPlayerCameraDataArmLength(float ArmLengthMin, float ArmLengthMax);
	void SetPlayerCameraLightDisable(bool bDisable);
	void SetPlayerCameraRotateSpeedRateForPlayerMovement(float Rate);
	void SetPlayerCameraSpeedId(const class FString& RoomOrFieldOrPlayerMove, int32 ID);
	void SetPlayerCameraSpeedIdParamAddPitchInputMaxSpeedRate(int32 ID, float Rate);
	void SetPlayerCameraSpeedIdParamAddPitchInputSpeed(int32 ID, float Rate);
	void SetPlayerCameraSpeedIdParamAddYawInputMaxSpeedRate(int32 ID, float Rate);
	void SetPlayerCameraSpeedIdParamAddYawInputSpeed(int32 ID, float Rate);
	void SetPlayerCameraSpeedIdParamDowntoChangeSpeedRateByPlayerMovement(int32 ID, float Rate);
	void SetPlayerCameraSpeedIdParamUptoChangeSpeedRateByPlayerMovement(int32 ID, float Rate);
	void SetPlayerName(const class FString& PlayerName);
	void SetSaveLoadForceFailResult(EJackSaveLoadResult InForceFailResult);
	void SetSeisui();
	void SetShareEnable(bool bEnable);
	void SetTextLogEnabled(bool bEnabled);
	void SetTitleDelayTime(float InTime);
	void SetTitleFadeTime(float InTime);
	void SetToherosu();
	void SetUseDQ8BGM(bool bIsUseDQ8BGM);
	void SetVoiceLanguage(class FName Language);
	void SetWaitChangingMEToBGMDefault(bool bIsWait);
	void SetWorldMapVisible(bool bVisible);
	void ShowBehaviorNGCutScene();
	void ShowClothCollisions();
	void ShowCutSceneMovieTimelineInfo();
	void ShowCutSceneTextureLoadInfo();
	void ShowFlagBreakPoints();
	void ShowGuestFollowTargetLine();
	void ShowLastBehaviorName();
	void ShowMonsterGeneratorInfo();
	void ShowMonsterSensor();
	void ShowMonsterSymbolInfo();
	void ShowParticleEffectComponentInWorldSettings();
	void ShowPartyTalkingSafeArea();
	void ShowPartyTalkSafeAreaInfo();
	void ShowPartyTalkSafeAreaLine();
	void ShowRandomEncountInfo();
	void Slomo3x();
	void SlomoDown();
	void SlomoReset();
	void SlomoUp();
	void SpawnActor(TSubclassOf<class AActor> Class_0);
	void StartCSAutoMovieCapture();
	void StopCSAutoMovieCapture();
	void StopLoadingScreen();
	void StreamedObjectsToBeResident();
	void TabiNoKokoroeTaughtFlagSet(class FName TabiNoKokoroeID, bool bNewFlag);
	void TeleportLocation(float X, float Y, float Z);
	void TeleportMapStart();
	void TenseiCheck(int32 Mode);
	void TenseiTest(class FName TenseiId);
	void TestDressupCoordinate();
	void ToggleAutoSaveEnabled();
	void ToggleDisplayRuby();
	void ToggleHandheldBoostMode();
	void ToggleReturnToAutoSaveVolumeEnable();
	void ToggleSaveLoadForceFailMode();
	void TokugiClose(class FName TokugiPanelID, bool bConsumePoint);
	void TokugiOpen(class FName TokugiPanelID, bool bConsumePoint);
	void TokugiPoint(EJackCharacter TargetCharacter, int32 Point);
	void TraceCutSceneDynamicResolutionLog();
	void TraceCutSceneMatineeInfo();
	void TraceCutScenePerformanceLog();
	void TrialAchievementTest(bool bIsTrialTest);
	void TryLoadAsset(const class FString& AssetPath);
	void TryLoadLevel(const class FString& LevelPath);
	void TryLoadPackage(const class FString& PackagePath);
	void UpdateFollowingFriendCharacters(bool bRelocation);
	void UpdatePackageStatus();
	void UpdatePartyFromCutScene();
	void ValidateMemory(int32 Type);
	void VehicleSpawn(const class FString& VehicleName);
	void WaitVoiceMessageForCS(bool bEnable);
	void ZoneEnable();
	void ZoneKeepRemainTurn(int32 Value);
	void ZonePoint(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCheatManager">();
	}
	static class UJackCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCheatManager>();
	}
};
static_assert(alignof(UJackCheatManager) == 0x000008, "Wrong alignment on UJackCheatManager");
static_assert(sizeof(UJackCheatManager) == 0x000088, "Wrong size on UJackCheatManager");

// Class JackGame.JackClothResetDistanceTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackClothResetDistanceTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackClothResetDistanceTrack">();
	}
	static class UJackClothResetDistanceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackClothResetDistanceTrack>();
	}
};
static_assert(alignof(UJackClothResetDistanceTrack) == 0x000008, "Wrong alignment on UJackClothResetDistanceTrack");
static_assert(sizeof(UJackClothResetDistanceTrack) == 0x0000B0, "Wrong size on UJackClothResetDistanceTrack");

// Class JackGame.JackOddEffectExec_AutoKaifuku
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_AutoKaifuku final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_AutoKaifuku">();
	}
	static class UJackOddEffectExec_AutoKaifuku* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_AutoKaifuku>();
	}
};
static_assert(alignof(UJackOddEffectExec_AutoKaifuku) == 0x000008, "Wrong alignment on UJackOddEffectExec_AutoKaifuku");
static_assert(sizeof(UJackOddEffectExec_AutoKaifuku) == 0x000108, "Wrong size on UJackOddEffectExec_AutoKaifuku");

// Class JackGame.JackCoffinCharacter
// 0x0000 (0x10F0 - 0x10F0)
class AJackCoffinCharacter : public AJackCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoffinCharacter">();
	}
	static class AJackCoffinCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackCoffinCharacter>();
	}
};
static_assert(alignof(AJackCoffinCharacter) == 0x000010, "Wrong alignment on AJackCoffinCharacter");
static_assert(sizeof(AJackCoffinCharacter) == 0x0010F0, "Wrong size on AJackCoffinCharacter");

// Class JackGame.JackUMGSerifuWindowLatentMessageEndResult
// 0x0018 (0x0050 - 0x0038)
class UJackUMGSerifuWindowLatentMessageEndResult final : public UObject
{
public:
	class UJackUMGSerifuWindowController*         Sender;                                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   CurrentTextID;                                     // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectDialogIndex;                                 // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSerifuWindowLatentMessageEndResult">();
	}
	static class UJackUMGSerifuWindowLatentMessageEndResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSerifuWindowLatentMessageEndResult>();
	}
};
static_assert(alignof(UJackUMGSerifuWindowLatentMessageEndResult) == 0x000008, "Wrong alignment on UJackUMGSerifuWindowLatentMessageEndResult");
static_assert(sizeof(UJackUMGSerifuWindowLatentMessageEndResult) == 0x000050, "Wrong size on UJackUMGSerifuWindowLatentMessageEndResult");
static_assert(offsetof(UJackUMGSerifuWindowLatentMessageEndResult, Sender) == 0x000038, "Member 'UJackUMGSerifuWindowLatentMessageEndResult::Sender' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowLatentMessageEndResult, CurrentTextID) == 0x000040, "Member 'UJackUMGSerifuWindowLatentMessageEndResult::CurrentTextID' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowLatentMessageEndResult, SelectDialogIndex) == 0x000048, "Member 'UJackUMGSerifuWindowLatentMessageEndResult::SelectDialogIndex' has a wrong offset!");

// Class JackGame.JackMapJumpVolume
// 0x0030 (0x0400 - 0x03D0)
class AJackMapJumpVolume final : public ATriggerVolume
{
public:
	struct FJackLDT_MapStart                      MapStart;                                          // 0x03D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackMapJumpVolumeInfo                 MapJumpVolumeInfo;                                 // 0x03E0(0x0007)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E7[0x1];                                      // 0x03E7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   TriggerMapChangeDelegate;                          // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bTriggerEnabled;                                   // 0x03F8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoTriggerMapChange;                             // 0x03F9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3FA[0x6];                                      // 0x03FA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTextRenderComponent* GetDebugTextComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMapJumpVolume">();
	}
	static class AJackMapJumpVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMapJumpVolume>();
	}
};
static_assert(alignof(AJackMapJumpVolume) == 0x000008, "Wrong alignment on AJackMapJumpVolume");
static_assert(sizeof(AJackMapJumpVolume) == 0x000400, "Wrong size on AJackMapJumpVolume");
static_assert(offsetof(AJackMapJumpVolume, MapStart) == 0x0003D0, "Member 'AJackMapJumpVolume::MapStart' has a wrong offset!");
static_assert(offsetof(AJackMapJumpVolume, MapJumpVolumeInfo) == 0x0003E0, "Member 'AJackMapJumpVolume::MapJumpVolumeInfo' has a wrong offset!");
static_assert(offsetof(AJackMapJumpVolume, TriggerMapChangeDelegate) == 0x0003E8, "Member 'AJackMapJumpVolume::TriggerMapChangeDelegate' has a wrong offset!");
static_assert(offsetof(AJackMapJumpVolume, bTriggerEnabled) == 0x0003F8, "Member 'AJackMapJumpVolume::bTriggerEnabled' has a wrong offset!");
static_assert(offsetof(AJackMapJumpVolume, bAutoTriggerMapChange) == 0x0003F9, "Member 'AJackMapJumpVolume::bAutoTriggerMapChange' has a wrong offset!");

// Class JackGame.JackCoinManager
// 0x0040 (0x0078 - 0x0038)
class UJackCoinManager : public UObject
{
public:
	class UDataTable*                             CoinShopDataTable;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CoinExchangeDataTable;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CoinExchangeShopDataTable;                         // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x28];                                      // 0x0050(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugBpValueGetSet();
	bool ExchangeItem(class FName PrizeId, int32 PrizeCount);

	bool CheckPrizeMamonoExchange(class FName PrizeId) const;
	bool CheckPrizeSoldOut(class FName PrizeId) const;
	bool GetCoinExchangeDataTable(class FName PrizeId, struct FJackDataTableCoinExchange* OutCoinExchangeTable) const;
	bool GetCoinShopDataTable(class FName ShopId, struct FJackDataTableCoinShop* OutCoinShopTable) const;
	TArray<struct FJackCoin_ExchageItem> GetExchangeItemList(class FName ShopId, bool bSort) const;
	int32 GetHaveCoinNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoinManager">();
	}
	static class UJackCoinManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCoinManager>();
	}
};
static_assert(alignof(UJackCoinManager) == 0x000008, "Wrong alignment on UJackCoinManager");
static_assert(sizeof(UJackCoinManager) == 0x000078, "Wrong size on UJackCoinManager");
static_assert(offsetof(UJackCoinManager, CoinShopDataTable) == 0x000038, "Member 'UJackCoinManager::CoinShopDataTable' has a wrong offset!");
static_assert(offsetof(UJackCoinManager, CoinExchangeDataTable) == 0x000040, "Member 'UJackCoinManager::CoinExchangeDataTable' has a wrong offset!");
static_assert(offsetof(UJackCoinManager, CoinExchangeShopDataTable) == 0x000048, "Member 'UJackCoinManager::CoinExchangeShopDataTable' has a wrong offset!");

// Class JackGame.JackPhysicalCollideBase
// 0x0000 (0x0038 - 0x0038)
class UJackPhysicalCollideBase : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicalCollideBase">();
	}
	static class UJackPhysicalCollideBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicalCollideBase>();
	}
};
static_assert(alignof(UJackPhysicalCollideBase) == 0x000008, "Wrong alignment on UJackPhysicalCollideBase");
static_assert(sizeof(UJackPhysicalCollideBase) == 0x000038, "Wrong size on UJackPhysicalCollideBase");

// Class JackGame.JackOddEffectManager
// 0x0118 (0x0150 - 0x0038)
class UJackOddEffectManager final : public UObject
{
public:
	bool                                          bDebugFlag_DrawOddEffectInfo;                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x107];                                     // 0x0039(0x0107)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackOddEffectTemporaryMaterial*> TemporaryMaterials;                                // 0x0140(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, NativeAccessSpecifierPrivate)

public:
	static bool IsOddEffect(const class UJackGameCharacter* GameCharacter, class FName OddEffectID);
	static bool IsOddEffectByCategory(const class UJackGameCharacter* GameCharacter, EJackOddEffectCategoryType CategoryType);
	static bool IsOddEffectByStatus(const class UJackGameCharacter* GameCharacter, class FName OddEffectStatusID);

	void ClearOddEffectBP(class UJackGameCharacter* GameCharacter, class FName OddEffectID);
	void ClearOddEffectByCategoryBP(class UJackGameCharacter* GameCharacter, EJackOddEffectCategoryType CategoryType);
	class UObject* LoadOddEffectBP(const struct FJackLDT_OddEffect& LDT_OddEffect, const struct FLatentActionInfo& LatentInfo);
	void SetOddEffectBP(class UJackGameCharacter* GameCharacter, const struct FJackLDT_OddEffect& LDT_OddEffect);
	void SetOddEffectWithCasterBP(class UJackGameCharacter* GameCharacter, const struct FJackLDT_OddEffect& LDT_OddEffect, class UJackGameCharacter* CasterCharacter);
	void StopOddEffectEffectBP(class UJackGameCharacter* GameCharacter, bool bImmediately);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectManager">();
	}
	static class UJackOddEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectManager>();
	}
};
static_assert(alignof(UJackOddEffectManager) == 0x000008, "Wrong alignment on UJackOddEffectManager");
static_assert(sizeof(UJackOddEffectManager) == 0x000150, "Wrong size on UJackOddEffectManager");
static_assert(offsetof(UJackOddEffectManager, bDebugFlag_DrawOddEffectInfo) == 0x000038, "Member 'UJackOddEffectManager::bDebugFlag_DrawOddEffectInfo' has a wrong offset!");
static_assert(offsetof(UJackOddEffectManager, TemporaryMaterials) == 0x000140, "Member 'UJackOddEffectManager::TemporaryMaterials' has a wrong offset!");

// Class JackGame.JackUMGTokugiPieceBase
// 0x0080 (0x0260 - 0x01E0)
class UJackUMGTokugiPieceBase : public UJackUMGTokugiParts
{
public:
	uint8                                         Pad_1E0[0x58];                                     // 0x01E0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SideSideTexture;                                   // 0x0238(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             BackSideTexture;                                   // 0x0240(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     CircleMaterial;                                    // 0x0248(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     Circle1Material;                                   // 0x0250(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SealedTexture;                                     // 0x0258(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSealedVisible(bool bIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPieceBase">();
	}
	static class UJackUMGTokugiPieceBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPieceBase>();
	}
};
static_assert(alignof(UJackUMGTokugiPieceBase) == 0x000008, "Wrong alignment on UJackUMGTokugiPieceBase");
static_assert(sizeof(UJackUMGTokugiPieceBase) == 0x000260, "Wrong size on UJackUMGTokugiPieceBase");
static_assert(offsetof(UJackUMGTokugiPieceBase, SideSideTexture) == 0x000238, "Member 'UJackUMGTokugiPieceBase::SideSideTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPieceBase, BackSideTexture) == 0x000240, "Member 'UJackUMGTokugiPieceBase::BackSideTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPieceBase, CircleMaterial) == 0x000248, "Member 'UJackUMGTokugiPieceBase::CircleMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPieceBase, Circle1Material) == 0x000250, "Member 'UJackUMGTokugiPieceBase::Circle1Material' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPieceBase, SealedTexture) == 0x000258, "Member 'UJackUMGTokugiPieceBase::SealedTexture' has a wrong offset!");

// Class JackGame.JackUMGTokugiPiece
// 0x0080 (0x02E0 - 0x0260)
class UJackUMGTokugiPiece : public UJackUMGTokugiPieceBase
{
public:
	uint8                                         Pad_260[0x58];                                     // 0x0260(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             FrontSideTexture;                                  // 0x02B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     HimituGlowMaterial;                                // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HimituShadowTexture;                               // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             LineMaskTexture;                                   // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialInterface*                     BlueLineMaterial;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void PlayNativeAnim(EJackTokugiPieceAnim AnimType, bool bReverse);
	void SetElements(class UCanvasPanel* InIconRoot, class UCanvasPanel* InIconParts, class UImage* InFace, class UImage* InFrontSide, class UImage* InHimituGlow, class UImage* InHimituShadow, class UImage* InBackSide, class UImage* InSideSide, class UImage* InLineMask1, class UImage* InLineMask2, class UImage* InLineMask3, class UImage* InBlueLine, class UImage* InCircle, class UImage* InCircle1);
	void SetFrontSideTexture(class UTexture2D* Texture);
	void SetHimituVisible(bool bIsVisible);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPiece">();
	}
	static class UJackUMGTokugiPiece* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPiece>();
	}
};
static_assert(alignof(UJackUMGTokugiPiece) == 0x000008, "Wrong alignment on UJackUMGTokugiPiece");
static_assert(sizeof(UJackUMGTokugiPiece) == 0x0002E0, "Wrong size on UJackUMGTokugiPiece");
static_assert(offsetof(UJackUMGTokugiPiece, FrontSideTexture) == 0x0002B8, "Member 'UJackUMGTokugiPiece::FrontSideTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPiece, HimituGlowMaterial) == 0x0002C0, "Member 'UJackUMGTokugiPiece::HimituGlowMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPiece, HimituShadowTexture) == 0x0002C8, "Member 'UJackUMGTokugiPiece::HimituShadowTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPiece, LineMaskTexture) == 0x0002D0, "Member 'UJackUMGTokugiPiece::LineMaskTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPiece, BlueLineMaterial) == 0x0002D8, "Member 'UJackUMGTokugiPiece::BlueLineMaterial' has a wrong offset!");

// Class JackGame.JackCollideEffectTable
// 0x0120 (0x0158 - 0x0038)
class UJackCollideEffectTable : public UJackPhysicalCollideBase
{
public:
	TSubclassOf<class UJackCollideEffect>         Default;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Earth;                                             // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         EarthDry;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Mud;                                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Stone;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Wood;                                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         WoodBoard;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         WoodDamaged;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         WoodThick;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         SuspensionBridge;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         SandStone;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Sand;                                              // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Gravel;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         BurntSand;                                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Water;                                             // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Shallow;                                           // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         OceanFloor;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Snow;                                              // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Ice;                                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Grass;                                             // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Leaf;                                              // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Straw;                                             // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         BrownGrass;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Cloth;                                             // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         ClothThick;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Metal;                                             // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Coin;                                              // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Flesh;                                             // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Ladder;                                            // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Rope;                                              // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Poison;                                            // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Lava;                                              // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Ivy;                                               // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         Barrier;                                           // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         ColdLava;                                          // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackCollideEffect>         CleftLava;                                         // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	TSubclassOf<class UJackCollideEffect> GetCollideEffectClassByHitResult(const struct FHitResult& HitResult);
	TSubclassOf<class UJackCollideEffect> GetCollideEffectClassBySurfaceType(EPhysicalSurface SurfaceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCollideEffectTable">();
	}
	static class UJackCollideEffectTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCollideEffectTable>();
	}
};
static_assert(alignof(UJackCollideEffectTable) == 0x000008, "Wrong alignment on UJackCollideEffectTable");
static_assert(sizeof(UJackCollideEffectTable) == 0x000158, "Wrong size on UJackCollideEffectTable");
static_assert(offsetof(UJackCollideEffectTable, Default) == 0x000038, "Member 'UJackCollideEffectTable::Default' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Earth) == 0x000040, "Member 'UJackCollideEffectTable::Earth' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, EarthDry) == 0x000048, "Member 'UJackCollideEffectTable::EarthDry' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Mud) == 0x000050, "Member 'UJackCollideEffectTable::Mud' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Stone) == 0x000058, "Member 'UJackCollideEffectTable::Stone' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Wood) == 0x000060, "Member 'UJackCollideEffectTable::Wood' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, WoodBoard) == 0x000068, "Member 'UJackCollideEffectTable::WoodBoard' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, WoodDamaged) == 0x000070, "Member 'UJackCollideEffectTable::WoodDamaged' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, WoodThick) == 0x000078, "Member 'UJackCollideEffectTable::WoodThick' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, SuspensionBridge) == 0x000080, "Member 'UJackCollideEffectTable::SuspensionBridge' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, SandStone) == 0x000088, "Member 'UJackCollideEffectTable::SandStone' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Sand) == 0x000090, "Member 'UJackCollideEffectTable::Sand' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Gravel) == 0x000098, "Member 'UJackCollideEffectTable::Gravel' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, BurntSand) == 0x0000A0, "Member 'UJackCollideEffectTable::BurntSand' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Water) == 0x0000A8, "Member 'UJackCollideEffectTable::Water' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Shallow) == 0x0000B0, "Member 'UJackCollideEffectTable::Shallow' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, OceanFloor) == 0x0000B8, "Member 'UJackCollideEffectTable::OceanFloor' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Snow) == 0x0000C0, "Member 'UJackCollideEffectTable::Snow' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Ice) == 0x0000C8, "Member 'UJackCollideEffectTable::Ice' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Grass) == 0x0000D0, "Member 'UJackCollideEffectTable::Grass' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Leaf) == 0x0000D8, "Member 'UJackCollideEffectTable::Leaf' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Straw) == 0x0000E0, "Member 'UJackCollideEffectTable::Straw' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, BrownGrass) == 0x0000E8, "Member 'UJackCollideEffectTable::BrownGrass' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Cloth) == 0x0000F0, "Member 'UJackCollideEffectTable::Cloth' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, ClothThick) == 0x0000F8, "Member 'UJackCollideEffectTable::ClothThick' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Metal) == 0x000100, "Member 'UJackCollideEffectTable::Metal' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Coin) == 0x000108, "Member 'UJackCollideEffectTable::Coin' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Flesh) == 0x000110, "Member 'UJackCollideEffectTable::Flesh' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Ladder) == 0x000118, "Member 'UJackCollideEffectTable::Ladder' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Rope) == 0x000120, "Member 'UJackCollideEffectTable::Rope' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Poison) == 0x000128, "Member 'UJackCollideEffectTable::Poison' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Lava) == 0x000130, "Member 'UJackCollideEffectTable::Lava' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Ivy) == 0x000138, "Member 'UJackCollideEffectTable::Ivy' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, Barrier) == 0x000140, "Member 'UJackCollideEffectTable::Barrier' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, ColdLava) == 0x000148, "Member 'UJackCollideEffectTable::ColdLava' has a wrong offset!");
static_assert(offsetof(UJackCollideEffectTable, CleftLava) == 0x000150, "Member 'UJackCollideEffectTable::CleftLava' has a wrong offset!");

// Class JackGame.JackCollideSoundTable
// 0x0120 (0x0158 - 0x0038)
class UJackCollideSoundTable : public UJackPhysicalCollideBase
{
public:
	class USoundBase*                             Default;                                           // 0x0038(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Earth;                                             // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EarthDry;                                          // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Mud;                                               // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Stone;                                             // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Wood;                                              // 0x0060(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WoodBoard;                                         // 0x0068(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WoodDamaged;                                       // 0x0070(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WoodThick;                                         // 0x0078(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SuspensionBridge;                                  // 0x0080(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SandStone;                                         // 0x0088(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sand;                                              // 0x0090(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Gravel;                                            // 0x0098(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BurntSand;                                         // 0x00A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Water;                                             // 0x00A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Shallow;                                           // 0x00B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             OceanFloor;                                        // 0x00B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Snow;                                              // 0x00C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Ice;                                               // 0x00C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Grass;                                             // 0x00D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Leaf;                                              // 0x00D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Straw;                                             // 0x00E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BrownGrass;                                        // 0x00E8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Cloth;                                             // 0x00F0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ClothThick;                                        // 0x00F8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Metal;                                             // 0x0100(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Coin;                                              // 0x0108(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Flesh;                                             // 0x0110(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Ladder;                                            // 0x0118(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Rope;                                              // 0x0120(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Poison;                                            // 0x0128(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Lava;                                              // 0x0130(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Ivy;                                               // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Barrier;                                           // 0x0140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ColdLava;                                          // 0x0148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             CleftLava;                                         // 0x0150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class USoundBase* GetCollideSoundByHitResult(const struct FHitResult& HitResult);
	class USoundBase* GetCollideSoundBySurfaceType(EPhysicalSurface SurfaceType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCollideSoundTable">();
	}
	static class UJackCollideSoundTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCollideSoundTable>();
	}
};
static_assert(alignof(UJackCollideSoundTable) == 0x000008, "Wrong alignment on UJackCollideSoundTable");
static_assert(sizeof(UJackCollideSoundTable) == 0x000158, "Wrong size on UJackCollideSoundTable");
static_assert(offsetof(UJackCollideSoundTable, Default) == 0x000038, "Member 'UJackCollideSoundTable::Default' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Earth) == 0x000040, "Member 'UJackCollideSoundTable::Earth' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, EarthDry) == 0x000048, "Member 'UJackCollideSoundTable::EarthDry' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Mud) == 0x000050, "Member 'UJackCollideSoundTable::Mud' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Stone) == 0x000058, "Member 'UJackCollideSoundTable::Stone' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Wood) == 0x000060, "Member 'UJackCollideSoundTable::Wood' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, WoodBoard) == 0x000068, "Member 'UJackCollideSoundTable::WoodBoard' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, WoodDamaged) == 0x000070, "Member 'UJackCollideSoundTable::WoodDamaged' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, WoodThick) == 0x000078, "Member 'UJackCollideSoundTable::WoodThick' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, SuspensionBridge) == 0x000080, "Member 'UJackCollideSoundTable::SuspensionBridge' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, SandStone) == 0x000088, "Member 'UJackCollideSoundTable::SandStone' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Sand) == 0x000090, "Member 'UJackCollideSoundTable::Sand' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Gravel) == 0x000098, "Member 'UJackCollideSoundTable::Gravel' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, BurntSand) == 0x0000A0, "Member 'UJackCollideSoundTable::BurntSand' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Water) == 0x0000A8, "Member 'UJackCollideSoundTable::Water' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Shallow) == 0x0000B0, "Member 'UJackCollideSoundTable::Shallow' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, OceanFloor) == 0x0000B8, "Member 'UJackCollideSoundTable::OceanFloor' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Snow) == 0x0000C0, "Member 'UJackCollideSoundTable::Snow' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Ice) == 0x0000C8, "Member 'UJackCollideSoundTable::Ice' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Grass) == 0x0000D0, "Member 'UJackCollideSoundTable::Grass' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Leaf) == 0x0000D8, "Member 'UJackCollideSoundTable::Leaf' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Straw) == 0x0000E0, "Member 'UJackCollideSoundTable::Straw' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, BrownGrass) == 0x0000E8, "Member 'UJackCollideSoundTable::BrownGrass' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Cloth) == 0x0000F0, "Member 'UJackCollideSoundTable::Cloth' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, ClothThick) == 0x0000F8, "Member 'UJackCollideSoundTable::ClothThick' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Metal) == 0x000100, "Member 'UJackCollideSoundTable::Metal' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Coin) == 0x000108, "Member 'UJackCollideSoundTable::Coin' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Flesh) == 0x000110, "Member 'UJackCollideSoundTable::Flesh' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Ladder) == 0x000118, "Member 'UJackCollideSoundTable::Ladder' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Rope) == 0x000120, "Member 'UJackCollideSoundTable::Rope' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Poison) == 0x000128, "Member 'UJackCollideSoundTable::Poison' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Lava) == 0x000130, "Member 'UJackCollideSoundTable::Lava' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Ivy) == 0x000138, "Member 'UJackCollideSoundTable::Ivy' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, Barrier) == 0x000140, "Member 'UJackCollideSoundTable::Barrier' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, ColdLava) == 0x000148, "Member 'UJackCollideSoundTable::ColdLava' has a wrong offset!");
static_assert(offsetof(UJackCollideSoundTable, CleftLava) == 0x000150, "Member 'UJackCollideSoundTable::CleftLava' has a wrong offset!");

// Class JackGame.JackCommandDispatcher
// 0x0028 (0x0060 - 0x0038)
class UJackCommandDispatcher final : public UObject
{
public:
	UMulticastDelegateProperty_                   OnJackCommandSample3;                              // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnJackCommandSample4;                              // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackCommandSample3Delegate__DelegateSignature(const struct FJackCommandSample3& InCommand);
	void JackCommandSample4Delegate__DelegateSignature(const struct FJackCommandSample4& InCommand);
	void SendAllBlueprintsFromBrueprint(class UObject* Sender);
	void SendAllCharactersFromBrueprint(class UObject* Sender);
	void SendAllFromBrueprint(class UObject* Sender);
	void SendFromBrueprint(class UObject* Sender, class UObject* Receiver);
	void SetJackCommandSample3(struct FJackCommandSample3& InCommand);
	void SetJackCommandSample4(struct FJackCommandSample4& InCommand);
	void SetJackCommandSample5(struct FJackCommandSample5& InCommand);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCommandDispatcher">();
	}
	static class UJackCommandDispatcher* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCommandDispatcher>();
	}
};
static_assert(alignof(UJackCommandDispatcher) == 0x000008, "Wrong alignment on UJackCommandDispatcher");
static_assert(sizeof(UJackCommandDispatcher) == 0x000060, "Wrong size on UJackCommandDispatcher");
static_assert(offsetof(UJackCommandDispatcher, OnJackCommandSample3) == 0x000038, "Member 'UJackCommandDispatcher::OnJackCommandSample3' has a wrong offset!");
static_assert(offsetof(UJackCommandDispatcher, OnJackCommandSample4) == 0x000048, "Member 'UJackCommandDispatcher::OnJackCommandSample4' has a wrong offset!");

// Class JackGame.JackOLSManager
// 0x0070 (0x00A8 - 0x0038)
class UJackOLSManager final : public UObject
{
public:
	class UOSDK*                                  OSDK;                                              // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UOSDKWebServiceClient*                  WebServiceClient;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x60];                                      // 0x0048(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOLSManager">();
	}
	static class UJackOLSManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOLSManager>();
	}
};
static_assert(alignof(UJackOLSManager) == 0x000008, "Wrong alignment on UJackOLSManager");
static_assert(sizeof(UJackOLSManager) == 0x0000A8, "Wrong size on UJackOLSManager");
static_assert(offsetof(UJackOLSManager, OSDK) == 0x000038, "Member 'UJackOLSManager::OSDK' has a wrong offset!");
static_assert(offsetof(UJackOLSManager, WebServiceClient) == 0x000040, "Member 'UJackOLSManager::WebServiceClient' has a wrong offset!");

// Class JackGame.JackCommandReceiver
// 0x0000 (0x0038 - 0x0038)
class IJackCommandReceiver final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCommandReceiver">();
	}
	static class IJackCommandReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJackCommandReceiver>();
	}
};
static_assert(alignof(IJackCommandReceiver) == 0x000008, "Wrong alignment on IJackCommandReceiver");
static_assert(sizeof(IJackCommandReceiver) == 0x000038, "Wrong size on IJackCommandReceiver");

// Class JackGame.JackCommandTypes
// 0x0000 (0x0038 - 0x0038)
class UJackCommandTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCommandTypes">();
	}
	static class UJackCommandTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCommandTypes>();
	}
};
static_assert(alignof(UJackCommandTypes) == 0x000008, "Wrong alignment on UJackCommandTypes");
static_assert(sizeof(UJackCommandTypes) == 0x000038, "Wrong size on UJackCommandTypes");

// Class JackGame.JackCoordSoundDisableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackCoordSoundDisableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoordSoundDisableTrackInst">();
	}
	static class UJackCoordSoundDisableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCoordSoundDisableTrackInst>();
	}
};
static_assert(alignof(UJackCoordSoundDisableTrackInst) == 0x000008, "Wrong alignment on UJackCoordSoundDisableTrackInst");
static_assert(sizeof(UJackCoordSoundDisableTrackInst) == 0x000040, "Wrong size on UJackCoordSoundDisableTrackInst");

// Class JackGame.JackMusicManager
// 0x02D8 (0x0310 - 0x0038)
class UJackMusicManager final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   BGMFinishedDelegate;                               // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   BGMStartedDelegate;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x70];                                      // 0x0060(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackMusicContext*>              BGMStack;                                          // 0x00D0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class UJackMusicContext*                      WaitingNewBGM;                                     // 0x00E0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMusicContext*                      SavingNewBGM;                                      // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F0[0x68];                                      // 0x00F0(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             BGMIDVolumeOverlapSaveBGMAsset;                    // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x8];                                      // 0x0160(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMusicContext*                      CurrentME;                                         // 0x0168(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMusicContext*                      WaitingNewME;                                      // 0x0170(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_178[0x28];                                     // 0x0178(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackSEADCategory>                     PlayMEFadeCategoryList;                            // 0x01A0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<struct FJackMESaveCategoryVolume>      MESaveCategoryVolume;                              // 0x01B0(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	class USoundBase*                             RegidentBattleBGMObject;                           // 0x01C0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FSoftObjectPath                        RegidentBattleBGMAssetRef;                         // 0x01C8(0x0008)(Transient, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1D0[0x140];                                    // 0x01D0(0x0140)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const class FString GetVolumeTableCSVFilePath();

	void AllClearBGM();
	bool BGMChangeDisableBeginOverlap(const class FName InVolumeID);
	void BGMChangeDisableClearOverlap();
	bool BGMChangeDisableEndOverlap(const class FName InVolumeID);
	EJackBGMVolumeResult BGMVolumeBeginOverlap(const class FName VolumeID);
	void BGMVolumeClearOverlap();
	EJackBGMVolumeResult BGMVolumeEndOverlap(const class FName VolumeID);
	void BPSetEnableInputPlayME(bool IsEnableInput);
	void BPStopMEForEmergency(float FOTime);
	void ClearBGMVolumeOverlapSaveBGMAsset();
	void ClearStakingBGM(int32 NumLeaveBGM);
	void DoBGMStartedDelegate();
	const class FString GetCurrentBGMAssetName();
	bool IsEqualPlayBGMAssetFromBGMID(const class FName InBGMID, bool bNightTime);
	bool IsStopFadeoutBGM();
	void JackBGMFinishedDelegate__DelegateSignature();
	void JackBGMStartedDelegate__DelegateSignature();
	void MusicEventDelegateLogFunc(class UJackMusicManager* InMusicManager, class UJackMusicContext* InMusicContext, EJackMusicEvent InEvent);
	void OnDetectedMusicPauseStateChanged(class UJackMusicContext* Music, bool bJustPaused);
	void OnDetectedMusicStopCompleted(class UJackMusicContext* Music);
	bool OverwriteFadeOut(float InFadeOutTime);
	void SetBGMChanging(bool bIsChanging);
	void SetBGMGapTime(float InPregapTime, float InPostgapTime);
	void SetBGMLanguageType(EJackLanguage InBGMLanguageType);
	void SetBGMVolumeOverlapSaveBGMAsset(class USoundBase* InSoundBase);
	void SetCSCurrentID(const class FName& InCSID, const class FName& InBGMID);
	void SetCurrentBGMId(const class FName& InMapId);
	void SetDisableChangePlayBGM(bool bIsEnable, bool bIsPengind);
	void SetDisableChangePlayBGMByVehicle(bool bIsDisable);
	void SetFadeTimeBGMDuringME(float InFadeOutTime, float InFadeinTime);
	void SetMapCurrentMapId(const class FName InMapId, const class FName InBGMID);
	void SetMEGapTime(float InPregapTime, float InPostgapTime);
	void SetPendingPlayBGMID(const class FName InBGMID);
	void SetPlayingBattle(bool IsBattle);
	void SetPlayingCutScene(bool IsCutScene);
	void SetPrevBGMID(const class FName& InPrevBGMID);
	bool SetResidentBattleBGM(const class FName& InBattleBGMID);
	void SetWaitChangingMEToBGM(bool bIsWait);
	void SkipBGMStartedDelegate(bool bIsSkipLatent);
	void WaitToPlayBGM(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

	int32 GetBGMVolumeOverlapCount() const;
	const class FName GetBGMVolumeOverlapId() const;
	class USoundBase* GetBGMVolumeOverlapSaveBGMAsset() const;
	const class FName GetCSCurrentBGMID() const;
	const class FName GetCSCurrentCSID() const;
	const class FName GetCurrentBGMId() const;
	float GetFadeOutTimeOnResumeBGMAfterPlayME() const;
	float GetFadeOutTimeOnSuspendBGMBeforePlayME() const;
	const class FName GetMapCurrentBGMId() const;
	const class FName GetMapCurrentDefaultBGMId() const;
	const class FName GetMapCurrentMapId() const;
	const class FName GetPendingPlayBGMID() const;
	const class FName GetPrevBGMID() const;
	bool IsBGMChanging() const;
	bool IsBGMVolumeOverlapping() const;
	bool IsDisableChangePlayBGM() const;
	bool IsDisableChangePlayBGMByVehicle() const;
	bool IsMEPlaying() const;
	bool IsNeverPlayedBGM() const;
	bool IsPendingPlayBGM() const;
	bool IsPlayingBattle() const;
	bool IsPlayingCutScene() const;
	bool IsPlayMusic() const;
	bool IsProcessingME() const;
	bool IsWaitChangingMEToBGM() const;
	bool IsWaitChangingMEToBGMDefault() const;
	bool IsWaitingNewBGM() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMusicManager">();
	}
	static class UJackMusicManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMusicManager>();
	}
};
static_assert(alignof(UJackMusicManager) == 0x000008, "Wrong alignment on UJackMusicManager");
static_assert(sizeof(UJackMusicManager) == 0x000310, "Wrong size on UJackMusicManager");
static_assert(offsetof(UJackMusicManager, BGMFinishedDelegate) == 0x000040, "Member 'UJackMusicManager::BGMFinishedDelegate' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, BGMStartedDelegate) == 0x000050, "Member 'UJackMusicManager::BGMStartedDelegate' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, BGMStack) == 0x0000D0, "Member 'UJackMusicManager::BGMStack' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, WaitingNewBGM) == 0x0000E0, "Member 'UJackMusicManager::WaitingNewBGM' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, SavingNewBGM) == 0x0000E8, "Member 'UJackMusicManager::SavingNewBGM' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, BGMIDVolumeOverlapSaveBGMAsset) == 0x000158, "Member 'UJackMusicManager::BGMIDVolumeOverlapSaveBGMAsset' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, CurrentME) == 0x000168, "Member 'UJackMusicManager::CurrentME' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, WaitingNewME) == 0x000170, "Member 'UJackMusicManager::WaitingNewME' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, PlayMEFadeCategoryList) == 0x0001A0, "Member 'UJackMusicManager::PlayMEFadeCategoryList' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, MESaveCategoryVolume) == 0x0001B0, "Member 'UJackMusicManager::MESaveCategoryVolume' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, RegidentBattleBGMObject) == 0x0001C0, "Member 'UJackMusicManager::RegidentBattleBGMObject' has a wrong offset!");
static_assert(offsetof(UJackMusicManager, RegidentBattleBGMAssetRef) == 0x0001C8, "Member 'UJackMusicManager::RegidentBattleBGMAssetRef' has a wrong offset!");

// Class JackGame.JackCoordSoundTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackCoordSoundTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackAnimNotify_CoordSoundType*         Notify;                                            // 0x0040(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCoordSoundTrackInst">();
	}
	static class UJackCoordSoundTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCoordSoundTrackInst>();
	}
};
static_assert(alignof(UJackCoordSoundTrackInst) == 0x000008, "Wrong alignment on UJackCoordSoundTrackInst");
static_assert(sizeof(UJackCoordSoundTrackInst) == 0x000048, "Wrong size on UJackCoordSoundTrackInst");
static_assert(offsetof(UJackCoordSoundTrackInst, Notify) == 0x000040, "Member 'UJackCoordSoundTrackInst::Notify' has a wrong offset!");

// Class JackGame.JackCrossFadeTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackCrossFadeTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCrossFadeTrackInst">();
	}
	static class UJackCrossFadeTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCrossFadeTrackInst>();
	}
};
static_assert(alignof(UJackCrossFadeTrackInst) == 0x000008, "Wrong alignment on UJackCrossFadeTrackInst");
static_assert(sizeof(UJackCrossFadeTrackInst) == 0x000040, "Wrong size on UJackCrossFadeTrackInst");

// Class JackGame.JackNavArea
// 0x0000 (0x0050 - 0x0050)
class UJackNavArea : public UNavArea
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNavArea">();
	}
	static class UJackNavArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackNavArea>();
	}
};
static_assert(alignof(UJackNavArea) == 0x000008, "Wrong alignment on UJackNavArea");
static_assert(sizeof(UJackNavArea) == 0x000050, "Wrong size on UJackNavArea");

// Class JackGame.JackCutSceneTextController
// 0x0018 (0x0050 - 0x0038)
class UJackCutSceneTextController final : public UObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackCutSceneTextController">();
	}
	static class UJackCutSceneTextController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackCutSceneTextController>();
	}
};
static_assert(alignof(UJackCutSceneTextController) == 0x000008, "Wrong alignment on UJackCutSceneTextController");
static_assert(sizeof(UJackCutSceneTextController) == 0x000050, "Wrong size on UJackCutSceneTextController");

// Class JackGame.JackDamageType
// 0x0008 (0x0058 - 0x0050)
class UJackDamageType final : public UDamageType
{
public:
	uint8                                         bDisableDamage : 1;                                // 0x0050(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bBlowOff : 1;                                      // 0x0050(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDamageType">();
	}
	static class UJackDamageType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDamageType>();
	}
};
static_assert(alignof(UJackDamageType) == 0x000008, "Wrong alignment on UJackDamageType");
static_assert(sizeof(UJackDamageType) == 0x000058, "Wrong size on UJackDamageType");

// Class JackGame.JackNavModifierVolume
// 0x0008 (0x03E8 - 0x03E0)
class AJackNavModifierVolume : public ANavModifierVolume
{
public:
	bool                                          bEnableNavModifierOnBeginPlay;                     // 0x03E0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnableNavModifier;                                // 0x03E1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackNavModifierVolume* DuplicateAsBattleVolume();
	void SetNavModifierActive(bool bActive);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNavModifierVolume">();
	}
	static class AJackNavModifierVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackNavModifierVolume>();
	}
};
static_assert(alignof(AJackNavModifierVolume) == 0x000008, "Wrong alignment on AJackNavModifierVolume");
static_assert(sizeof(AJackNavModifierVolume) == 0x0003E8, "Wrong size on AJackNavModifierVolume");
static_assert(offsetof(AJackNavModifierVolume, bEnableNavModifierOnBeginPlay) == 0x0003E0, "Member 'AJackNavModifierVolume::bEnableNavModifierOnBeginPlay' has a wrong offset!");
static_assert(offsetof(AJackNavModifierVolume, bEnableNavModifier) == 0x0003E1, "Member 'AJackNavModifierVolume::bEnableNavModifier' has a wrong offset!");

// Class JackGame.JackDebugCameraController
// 0x0000 (0x0788 - 0x0788)
class AJackDebugCameraController final : public ADebugCameraController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugCameraController">();
	}
	static class AJackDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackDebugCameraController>();
	}
};
static_assert(alignof(AJackDebugCameraController) == 0x000008, "Wrong alignment on AJackDebugCameraController");
static_assert(sizeof(AJackDebugCameraController) == 0x000788, "Wrong size on AJackDebugCameraController");

// Class JackGame.JackDebugCameraHUD
// 0x0000 (0x0480 - 0x0480)
class AJackDebugCameraHUD final : public ADebugCameraHUD
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugCameraHUD">();
	}
	static class AJackDebugCameraHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackDebugCameraHUD>();
	}
};
static_assert(alignof(AJackDebugCameraHUD) == 0x000008, "Wrong alignment on AJackDebugCameraHUD");
static_assert(sizeof(AJackDebugCameraHUD) == 0x000480, "Wrong size on AJackDebugCameraHUD");

// Class JackGame.JackDebugLoggerComponent
// 0x0010 (0x0138 - 0x0128)
class UJackDebugLoggerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x10];                                     // 0x0128(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddReturn();
	void EndLogger();
	void Print(const class FString& String, bool bAddReturn);
	void PrintLogSkeltalMeshArrayCSVRow(const TArray<class USkeletalMeshComponent*>& MeshArray, float DeltaSeconds);
	void ResetLogSkeltalMeshArray();
	void StartLogger(const class FString& Filename, bool bPrefixActorName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugLoggerComponent">();
	}
	static class UJackDebugLoggerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugLoggerComponent>();
	}
};
static_assert(alignof(UJackDebugLoggerComponent) == 0x000008, "Wrong alignment on UJackDebugLoggerComponent");
static_assert(sizeof(UJackDebugLoggerComponent) == 0x000138, "Wrong size on UJackDebugLoggerComponent");

// Class JackGame.JackParticleModuleLocationGround
// 0x0020 (0x0060 - 0x0040)
class UJackParticleModuleLocationGround final : public UParticleModuleLocationBase
{
public:
	float                                         UpperLength;                                       // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LowerLength;                                       // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LimitAngle;                                        // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyRotation;                                    // 0x004C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseLocalZ;                                        // 0x004D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E[0x2];                                       // 0x004E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Radius;                                            // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationMaxAngle;                                  // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationIgnoreAngle;                               // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParticleModuleLocationGround">();
	}
	static class UJackParticleModuleLocationGround* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParticleModuleLocationGround>();
	}
};
static_assert(alignof(UJackParticleModuleLocationGround) == 0x000008, "Wrong alignment on UJackParticleModuleLocationGround");
static_assert(sizeof(UJackParticleModuleLocationGround) == 0x000060, "Wrong size on UJackParticleModuleLocationGround");
static_assert(offsetof(UJackParticleModuleLocationGround, UpperLength) == 0x000040, "Member 'UJackParticleModuleLocationGround::UpperLength' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, LowerLength) == 0x000044, "Member 'UJackParticleModuleLocationGround::LowerLength' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, LimitAngle) == 0x000048, "Member 'UJackParticleModuleLocationGround::LimitAngle' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, bApplyRotation) == 0x00004C, "Member 'UJackParticleModuleLocationGround::bApplyRotation' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, bUseLocalZ) == 0x00004D, "Member 'UJackParticleModuleLocationGround::bUseLocalZ' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, Radius) == 0x000050, "Member 'UJackParticleModuleLocationGround::Radius' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, RotationMaxAngle) == 0x000054, "Member 'UJackParticleModuleLocationGround::RotationMaxAngle' has a wrong offset!");
static_assert(offsetof(UJackParticleModuleLocationGround, RotationIgnoreAngle) == 0x000058, "Member 'UJackParticleModuleLocationGround::RotationIgnoreAngle' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableByte
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableByte final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	uint8 GetByte();
	void SetByte(uint8 NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableByte">();
	}
	static class UJackDebugMenuVariableByte* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableByte>();
	}
};
static_assert(alignof(UJackDebugMenuVariableByte) == 0x000008, "Wrong alignment on UJackDebugMenuVariableByte");
static_assert(sizeof(UJackDebugMenuVariableByte) == 0x000098, "Wrong size on UJackDebugMenuVariableByte");
static_assert(offsetof(UJackDebugMenuVariableByte, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableByte::ValueChanged' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableCommand
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableCommand final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableCommand">();
	}
	static class UJackDebugMenuVariableCommand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableCommand>();
	}
};
static_assert(alignof(UJackDebugMenuVariableCommand) == 0x000008, "Wrong alignment on UJackDebugMenuVariableCommand");
static_assert(sizeof(UJackDebugMenuVariableCommand) == 0x000098, "Wrong size on UJackDebugMenuVariableCommand");
static_assert(offsetof(UJackDebugMenuVariableCommand, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableCommand::ValueChanged' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableFloat
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableFloat final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	float GetFloat();
	void SetFloat(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableFloat">();
	}
	static class UJackDebugMenuVariableFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableFloat>();
	}
};
static_assert(alignof(UJackDebugMenuVariableFloat) == 0x000008, "Wrong alignment on UJackDebugMenuVariableFloat");
static_assert(sizeof(UJackDebugMenuVariableFloat) == 0x000098, "Wrong size on UJackDebugMenuVariableFloat");
static_assert(offsetof(UJackDebugMenuVariableFloat, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableFloat::ValueChanged' has a wrong offset!");

// Class JackGame.JackPauseTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackPauseTrack final : public UInterpTrack
{
public:
	TArray<struct FJackPauseTrackKey>             KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPauseTrack">();
	}
	static class UJackPauseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPauseTrack>();
	}
};
static_assert(alignof(UJackPauseTrack) == 0x000008, "Wrong alignment on UJackPauseTrack");
static_assert(sizeof(UJackPauseTrack) == 0x0000A0, "Wrong size on UJackPauseTrack");
static_assert(offsetof(UJackPauseTrack, KeyArray) == 0x000090, "Member 'UJackPauseTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableLinearColor
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableLinearColor final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FLinearColor GetLinearColor();
	void SetLinearColor(const struct FLinearColor& NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableLinearColor">();
	}
	static class UJackDebugMenuVariableLinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableLinearColor>();
	}
};
static_assert(alignof(UJackDebugMenuVariableLinearColor) == 0x000008, "Wrong alignment on UJackDebugMenuVariableLinearColor");
static_assert(sizeof(UJackDebugMenuVariableLinearColor) == 0x000098, "Wrong size on UJackDebugMenuVariableLinearColor");
static_assert(offsetof(UJackDebugMenuVariableLinearColor, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableLinearColor::ValueChanged' has a wrong offset!");

// Class JackGame.JackDebugMenuVariableRotator
// 0x0010 (0x0098 - 0x0088)
class UJackDebugMenuVariableRotator final : public UJackDebugMenuVariable
{
public:
	UMulticastDelegateProperty_                   ValueChanged;                                      // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	struct FRotator GetRotator();
	void SetRotator(const struct FRotator& NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDebugMenuVariableRotator">();
	}
	static class UJackDebugMenuVariableRotator* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDebugMenuVariableRotator>();
	}
};
static_assert(alignof(UJackDebugMenuVariableRotator) == 0x000008, "Wrong alignment on UJackDebugMenuVariableRotator");
static_assert(sizeof(UJackDebugMenuVariableRotator) == 0x000098, "Wrong size on UJackDebugMenuVariableRotator");
static_assert(offsetof(UJackDebugMenuVariableRotator, ValueChanged) == 0x000088, "Member 'UJackDebugMenuVariableRotator::ValueChanged' has a wrong offset!");

// Class JackGame.JackDofPhotoModeOverrider
// 0x0528 (0x0560 - 0x0038)
class UJackDofPhotoModeOverrider final : public UObject
{
public:
	uint8                                         Pad_38[0x528];                                     // 0x0038(0x0528)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDofPhotoModeOverrider">();
	}
	static class UJackDofPhotoModeOverrider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDofPhotoModeOverrider>();
	}
};
static_assert(alignof(UJackDofPhotoModeOverrider) == 0x000008, "Wrong alignment on UJackDofPhotoModeOverrider");
static_assert(sizeof(UJackDofPhotoModeOverrider) == 0x000560, "Wrong size on UJackDofPhotoModeOverrider");

// Class JackGame.JackDepthOfFieldQualityTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDepthOfFieldQualityTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDepthOfFieldQualityTrack">();
	}
	static class UJackDepthOfFieldQualityTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDepthOfFieldQualityTrack>();
	}
};
static_assert(alignof(UJackDepthOfFieldQualityTrack) == 0x000008, "Wrong alignment on UJackDepthOfFieldQualityTrack");
static_assert(sizeof(UJackDepthOfFieldQualityTrack) == 0x0000B0, "Wrong size on UJackDepthOfFieldQualityTrack");

// Class JackGame.JackDestructibleActor
// 0x0130 (0x04C8 - 0x0398)
#pragma pack(push, 0x1)
class alignas(0x08) AJackDestructibleActor : public AActor
{
public:
	TWeakObjectPtr<class UStaticMeshComponent>    BeforeStaticMeshComponent;                         // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UDestructibleComponent>  DestructibleComponent;                             // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitSkipSec;                                        // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TouchCollideSkipSec;                               // 0x03AC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DestructObjectClearSec;                            // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HitToDestructTimerSec;                             // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitPoint;                                          // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ImpulseStrength;                                   // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageAmount;                                      // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHitCheckAnotherTouch;                             // 0x03C8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         HitImpulseSize;                                    // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NoWakeUpFrameCount;                                // 0x03D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWakeUpStatic;                                     // 0x03D4(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D5[0x3];                                      // 0x03D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AllowPlayerHitSec;                                 // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EmargencyDestructSec;                              // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E0[0xE8];                                     // 0x03E0(0x00E8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHit(float NowDamageAmount, const struct FVector& HitLocation, const struct FVector& ImpulseDir, float NowImpulseStrength, float ForceImpulseDirLength, bool bNoSetSkipTimer);
	void OnDestruct();
	void OnTouchCollide(const struct FHitResult& HitResult);
	void SetDebugKiraId(class FName KiraId);
	void SetDitherHiddenActor(EJackCharacterHiddenPurpose InPurpose, bool bNewHidden, class UCurveBase* Curve, float InRequiredSeconds);
	void SetStatckMeshSleep();
	void SetVisibleDestructibleMesh(bool bOn);
	void TouchCollide(const struct FHitResult& HitResult);
	bool TryStartStaticMeshWakeUp(class AActor* OtherActor, class UPrimitiveComponent* OtherCompo);

	int32 GetStaticMeshWakeupFrame() const;
	bool IsInScreen() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDestructibleActor">();
	}
	static class AJackDestructibleActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackDestructibleActor>();
	}
};
#pragma pack(pop)
static_assert(alignof(AJackDestructibleActor) == 0x000008, "Wrong alignment on AJackDestructibleActor");
static_assert(sizeof(AJackDestructibleActor) == 0x0004C8, "Wrong size on AJackDestructibleActor");
static_assert(offsetof(AJackDestructibleActor, BeforeStaticMeshComponent) == 0x000398, "Member 'AJackDestructibleActor::BeforeStaticMeshComponent' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, DestructibleComponent) == 0x0003A0, "Member 'AJackDestructibleActor::DestructibleComponent' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, HitSkipSec) == 0x0003A8, "Member 'AJackDestructibleActor::HitSkipSec' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, TouchCollideSkipSec) == 0x0003AC, "Member 'AJackDestructibleActor::TouchCollideSkipSec' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, DestructObjectClearSec) == 0x0003B0, "Member 'AJackDestructibleActor::DestructObjectClearSec' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, HitToDestructTimerSec) == 0x0003B4, "Member 'AJackDestructibleActor::HitToDestructTimerSec' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, HitPoint) == 0x0003B8, "Member 'AJackDestructibleActor::HitPoint' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, ImpulseStrength) == 0x0003BC, "Member 'AJackDestructibleActor::ImpulseStrength' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, DamageAmount) == 0x0003C0, "Member 'AJackDestructibleActor::DamageAmount' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, DamageRadius) == 0x0003C4, "Member 'AJackDestructibleActor::DamageRadius' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, bHitCheckAnotherTouch) == 0x0003C8, "Member 'AJackDestructibleActor::bHitCheckAnotherTouch' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, HitImpulseSize) == 0x0003CC, "Member 'AJackDestructibleActor::HitImpulseSize' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, NoWakeUpFrameCount) == 0x0003D0, "Member 'AJackDestructibleActor::NoWakeUpFrameCount' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, bWakeUpStatic) == 0x0003D4, "Member 'AJackDestructibleActor::bWakeUpStatic' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, AllowPlayerHitSec) == 0x0003D8, "Member 'AJackDestructibleActor::AllowPlayerHitSec' has a wrong offset!");
static_assert(offsetof(AJackDestructibleActor, EmargencyDestructSec) == 0x0003DC, "Member 'AJackDestructibleActor::EmargencyDestructSec' has a wrong offset!");

// Class JackGame.JackPhysicsBlendRateTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackPhysicsBlendRateTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsBlendRateTrackInst">();
	}
	static class UJackPhysicsBlendRateTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicsBlendRateTrackInst>();
	}
};
static_assert(alignof(UJackPhysicsBlendRateTrackInst) == 0x000008, "Wrong alignment on UJackPhysicsBlendRateTrackInst");
static_assert(sizeof(UJackPhysicsBlendRateTrackInst) == 0x000038, "Wrong size on UJackPhysicsBlendRateTrackInst");

// Class JackGame.JackItemManager
// 0x0920 (0x0958 - 0x0038)
class UJackItemManager : public UObject
{
public:
	class UDataTable*                             ItemDataTable;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ItemEquipmentDataTable;                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemInnerCountMax_Common;                          // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemInnerCountMax_Equipment;                       // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemInnerCountMax_Character;                       // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemFrameCountMax_Character;                       // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemInnerCountMax_Exchange_Default;                // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         YuukyuuNoKinkoMax;                                 // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackItemGetLinkFlag>           ItemGetLinkFlag;                                   // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackItemInnerCountMax>         ItemInnerCountMax_Exchange_Individual;             // 0x0070(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class FName                                   ChangeEquipmentPossibleFlag_P004;                  // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageConjunctionWordID;                          // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageSpaceWordID;                                // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageRareWordID;                                 // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageStoreHandWordID;                            // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageStoreCommonBagWordID;                       // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MessageStoreEquipmentBagWordID;                    // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           DeleteItemWhenBackToThePast;                       // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TMap<EJackItem_Classification, class UTexture2D*> ClassificationStandardIconList;                    // 0x00C8(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSetYuukyuuNoKinko;                               // 0x0118(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_128[0x830];                                    // 0x0128(0x0830)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AutoEquipmentAttach(EJackCharacter CharacterType, EJackEquipmentRegion RegionType, class FName ItemID);
	bool AutoEquipmentDetach(EJackCharacter CharacterType, class FName ItemID);
	int32 DiscardItem(EJackItem_Bag BagType, class FName ItemID, int32 ItemCount, bool bIgnoreEquippedItem);
	bool IsExistItem(class FName ItemID);
	bool IsForceHideBag();
	void OnSetYuukyuuNoKinko__DelegateSignature();
	void PlayGetSE(class FName ItemID, class FName SEID);
	void SetForceHideBag(bool bFlag);
	void SetItemConsumeInCustomEvent(bool bFlag);
	void SetYuukyuuNoKinko(class FName KinkoID, class FName ItemID);
	int32 StoreItem(class FName ItemID, int32 ItemCount, bool bAcceptOverflow, EJackItem_Bag* OutStoreBag);
	int32 UseSeed(EJackCharacter CharacterType, class FName ItemID);

	bool CorrectItemGetMessageType(class FName ItemID, bool bSimpleText) const;
	class UJackFriendGameCharacter* GetAcquirer(EJackItem_Bag BagType) const;
	const class FString GetAcquirerWord(EJackItem_Bag BagType) const;
	TArray<class FName> GetAcquisitionItemList() const;
	const EJackItem_Classification GetClassification(class FName ItemID) const;
	class UTexture2D* GetClassificationStandardIcon(EJackItem_Classification Classification) const;
	const class FString GetConjunctionWord() const;
	const class FName GetConjunctionWordId() const;
	const class FString GetDescription(class FName ItemID) const;
	const EJackItemGetIcon GetGetIconType(class FName ItemID) const;
	int32 GetItemClassificationMax(EJackItem_Classification Classification) const;
	int32 GetItemCount(class FName ItemID) const;
	int32 GetItemCountInBag(EJackItem_Bag BagType, class FName ItemID) const;
	int32 GetItemGettableCount(class FName ItemID) const;
	int32 GetItemGettableCountInBag(EJackItem_Bag BagType, class FName ItemID) const;
	const class FString GetItemName(class FName ItemID, bool ListFlag) const;
	TArray<class FName> GetPictorialBookItems(int32 PictorialBookNo) const;
	int32 GetPossessionItemCount(const class FName& ItemID) const;
	int32 GetPrice_Buying(class FName ItemID) const;
	int32 GetPrice_Selling(class FName ItemID) const;
	const class FString GetRareWord() const;
	const class FName GetRareWordId() const;
	const int32 GetRarity(class FName ItemID) const;
	const class FString GetSpaceWord() const;
	const class FName GetSpaceWordId() const;
	const class FString GetSpecificAbilityDescription(class FName ItemID) const;
	const class FString GetStorageWord(EJackItem_Bag BagType) const;
	const class FName GetStorageWordId(EJackItem_Bag BagType) const;
	int32 GetTotalAcquisitionItemCount(const class FName& ItemID) const;
	const class FString GetUnitName(class FName ItemID) const;
	const class FName GetUnitNameId(class FName ItemID) const;
	class FName GetYuukyuuNoKinko(class FName KinkoID) const;
	bool IsAcquisitionByClassification(EJackItem_Classification Classification) const;
	TArray<struct FJackMessageArgumentData> MakeGoldGetMessageTag(int32 GoldCount, const class FString& GoldCountTagString) const;
	TArray<struct FJackMessageArgumentData> MakeItemGetMessageTag(class FName ItemID, int32 ItemCount, EJackItem_Bag BagType, const class FString& ItemNameTagString, const class FString& ItemCountTagString, const class FString& ItemUnitNameTagString, const class FString& ConjunctionTagString, const class FString& SpaceTagString, const class FString& HalfSpaceTagString, const class FString& CharacterTagString, const class FString& StoreTargetTagString, const class FString& RareTagString) const;
	class FName MakeItemGetMessageTextID(class FName ItemID, const class FString& Prefix) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackItemManager">();
	}
	static class UJackItemManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackItemManager>();
	}
};
static_assert(alignof(UJackItemManager) == 0x000008, "Wrong alignment on UJackItemManager");
static_assert(sizeof(UJackItemManager) == 0x000958, "Wrong size on UJackItemManager");
static_assert(offsetof(UJackItemManager, ItemDataTable) == 0x000038, "Member 'UJackItemManager::ItemDataTable' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemEquipmentDataTable) == 0x000040, "Member 'UJackItemManager::ItemEquipmentDataTable' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemInnerCountMax_Common) == 0x000048, "Member 'UJackItemManager::ItemInnerCountMax_Common' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemInnerCountMax_Equipment) == 0x00004C, "Member 'UJackItemManager::ItemInnerCountMax_Equipment' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemInnerCountMax_Character) == 0x000050, "Member 'UJackItemManager::ItemInnerCountMax_Character' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemFrameCountMax_Character) == 0x000054, "Member 'UJackItemManager::ItemFrameCountMax_Character' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemInnerCountMax_Exchange_Default) == 0x000058, "Member 'UJackItemManager::ItemInnerCountMax_Exchange_Default' has a wrong offset!");
static_assert(offsetof(UJackItemManager, YuukyuuNoKinkoMax) == 0x00005C, "Member 'UJackItemManager::YuukyuuNoKinkoMax' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemGetLinkFlag) == 0x000060, "Member 'UJackItemManager::ItemGetLinkFlag' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ItemInnerCountMax_Exchange_Individual) == 0x000070, "Member 'UJackItemManager::ItemInnerCountMax_Exchange_Individual' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ChangeEquipmentPossibleFlag_P004) == 0x000080, "Member 'UJackItemManager::ChangeEquipmentPossibleFlag_P004' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageConjunctionWordID) == 0x000088, "Member 'UJackItemManager::MessageConjunctionWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageSpaceWordID) == 0x000090, "Member 'UJackItemManager::MessageSpaceWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageRareWordID) == 0x000098, "Member 'UJackItemManager::MessageRareWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageStoreHandWordID) == 0x0000A0, "Member 'UJackItemManager::MessageStoreHandWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageStoreCommonBagWordID) == 0x0000A8, "Member 'UJackItemManager::MessageStoreCommonBagWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, MessageStoreEquipmentBagWordID) == 0x0000B0, "Member 'UJackItemManager::MessageStoreEquipmentBagWordID' has a wrong offset!");
static_assert(offsetof(UJackItemManager, DeleteItemWhenBackToThePast) == 0x0000B8, "Member 'UJackItemManager::DeleteItemWhenBackToThePast' has a wrong offset!");
static_assert(offsetof(UJackItemManager, ClassificationStandardIconList) == 0x0000C8, "Member 'UJackItemManager::ClassificationStandardIconList' has a wrong offset!");
static_assert(offsetof(UJackItemManager, OnSetYuukyuuNoKinko) == 0x000118, "Member 'UJackItemManager::OnSetYuukyuuNoKinko' has a wrong offset!");

// Class JackGame.JackDestructibleVehicleMonster
// 0x0048 (0x0400 - 0x03B8)
class AJackDestructibleVehicleMonster final : public ADestructibleActor
{
public:
	EJackVehicle                                  VehicleType;                                       // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DestructDegree;                                    // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAdditionalRadialForce;                            // 0x03C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C1[0x3];                                      // 0x03C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdditionalRadialForceStrength;                     // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalRadialForceRadius;                       // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AdditionalRadialForceSec;                          // 0x03CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x30];                                     // 0x03D0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOverlappedComponent(class UPrimitiveComponent* OtherComp);
	void ForceDestruct(class AActor* Actor);
	void OnDestruct(const struct FVector& HitLocation, const struct FVector& ImpluseDir);
	void OnHitStaticMesh(class AActor* InActor, const struct FVector& HitLocation, bool bForceHit);
	void RemoveOverlappedComponent(class UPrimitiveComponent* OtherComp);

	struct FVector GetHitDir(const class AActor* Actor) const;
	struct FVector GetHitLocation(const class AActor* Actor) const;
	struct FVector GetImpactLocation(const struct FVector& StartLocation) const;
	bool IsDestructibleVelocity(const class AActor* Actor) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDestructibleVehicleMonster">();
	}
	static class AJackDestructibleVehicleMonster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackDestructibleVehicleMonster>();
	}
};
static_assert(alignof(AJackDestructibleVehicleMonster) == 0x000008, "Wrong alignment on AJackDestructibleVehicleMonster");
static_assert(sizeof(AJackDestructibleVehicleMonster) == 0x000400, "Wrong size on AJackDestructibleVehicleMonster");
static_assert(offsetof(AJackDestructibleVehicleMonster, VehicleType) == 0x0003B8, "Member 'AJackDestructibleVehicleMonster::VehicleType' has a wrong offset!");
static_assert(offsetof(AJackDestructibleVehicleMonster, DestructDegree) == 0x0003BC, "Member 'AJackDestructibleVehicleMonster::DestructDegree' has a wrong offset!");
static_assert(offsetof(AJackDestructibleVehicleMonster, bAdditionalRadialForce) == 0x0003C0, "Member 'AJackDestructibleVehicleMonster::bAdditionalRadialForce' has a wrong offset!");
static_assert(offsetof(AJackDestructibleVehicleMonster, AdditionalRadialForceStrength) == 0x0003C4, "Member 'AJackDestructibleVehicleMonster::AdditionalRadialForceStrength' has a wrong offset!");
static_assert(offsetof(AJackDestructibleVehicleMonster, AdditionalRadialForceRadius) == 0x0003C8, "Member 'AJackDestructibleVehicleMonster::AdditionalRadialForceRadius' has a wrong offset!");
static_assert(offsetof(AJackDestructibleVehicleMonster, AdditionalRadialForceSec) == 0x0003CC, "Member 'AJackDestructibleVehicleMonster::AdditionalRadialForceSec' has a wrong offset!");

// Class JackGame.JackImeManager
// 0x0008 (0x0040 - 0x0038)
class UJackImeManager final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString GetEntryString();
	bool IsOpenDialog();
	void OpenNameEntry(class FString* EntryStr);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackImeManager">();
	}
	static class UJackImeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackImeManager>();
	}
};
static_assert(alignof(UJackImeManager) == 0x000008, "Wrong alignment on UJackImeManager");
static_assert(sizeof(UJackImeManager) == 0x000040, "Wrong size on UJackImeManager");

// Class JackGame.JackDisableDesiredMaxDrawDistanceTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackDisableDesiredMaxDrawDistanceTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDisableDesiredMaxDrawDistanceTrackInst">();
	}
	static class UJackDisableDesiredMaxDrawDistanceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDisableDesiredMaxDrawDistanceTrackInst>();
	}
};
static_assert(alignof(UJackDisableDesiredMaxDrawDistanceTrackInst) == 0x000008, "Wrong alignment on UJackDisableDesiredMaxDrawDistanceTrackInst");
static_assert(sizeof(UJackDisableDesiredMaxDrawDistanceTrackInst) == 0x000050, "Wrong size on UJackDisableDesiredMaxDrawDistanceTrackInst");

// Class JackGame.JackUMGSoubiList
// 0x02C0 (0x02F8 - 0x0038)
class UJackUMGSoubiList final : public UObject
{
public:
	struct FJackUMGSoubiData                      Handedness;                                        // 0x0038(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      Hand;                                              // 0x00A8(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      Head;                                              // 0x0118(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      Body;                                              // 0x0188(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      Accessory1;                                        // 0x01F8(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      Accessory2;                                        // 0x0268(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D8[0x20];                                     // 0x02D8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJackUMGSoubiData GetSoubiDataFromIndex(int32 InIndex);
	struct FJackUMGSoubiData GetSoubiDataFromRegion(EJackEquipmentRegion RegionType);
	const struct FJackUMGSoubiData GetSoubiDataRefFromIndex(int32 InIndex);
	const struct FJackUMGSoubiData GetSoubiDataRefFromRegion(EJackEquipmentRegion RegionType);
	void SetIsChange(EJackEquipmentRegion RegionType, bool InFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSoubiList">();
	}
	static class UJackUMGSoubiList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSoubiList>();
	}
};
static_assert(alignof(UJackUMGSoubiList) == 0x000008, "Wrong alignment on UJackUMGSoubiList");
static_assert(sizeof(UJackUMGSoubiList) == 0x0002F8, "Wrong size on UJackUMGSoubiList");
static_assert(offsetof(UJackUMGSoubiList, Handedness) == 0x000038, "Member 'UJackUMGSoubiList::Handedness' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiList, Hand) == 0x0000A8, "Member 'UJackUMGSoubiList::Hand' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiList, Head) == 0x000118, "Member 'UJackUMGSoubiList::Head' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiList, Body) == 0x000188, "Member 'UJackUMGSoubiList::Body' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiList, Accessory1) == 0x0001F8, "Member 'UJackUMGSoubiList::Accessory1' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiList, Accessory2) == 0x000268, "Member 'UJackUMGSoubiList::Accessory2' has a wrong offset!");

// Class JackGame.JackDisableDynamicResolutionTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackDisableDynamicResolutionTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDisableDynamicResolutionTrack">();
	}
	static class UJackDisableDynamicResolutionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDisableDynamicResolutionTrack>();
	}
};
static_assert(alignof(UJackDisableDynamicResolutionTrack) == 0x000008, "Wrong alignment on UJackDisableDynamicResolutionTrack");
static_assert(sizeof(UJackDisableDynamicResolutionTrack) == 0x0000A8, "Wrong size on UJackDisableDynamicResolutionTrack");

// Class JackGame.JackDisableDynamicResolutionTrackInst
// 0x0008 (0x0048 - 0x0040)
class UJackDisableDynamicResolutionTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDisableDynamicResolutionTrackInst">();
	}
	static class UJackDisableDynamicResolutionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDisableDynamicResolutionTrackInst>();
	}
};
static_assert(alignof(UJackDisableDynamicResolutionTrackInst) == 0x000008, "Wrong alignment on UJackDisableDynamicResolutionTrackInst");
static_assert(sizeof(UJackDisableDynamicResolutionTrackInst) == 0x000048, "Wrong size on UJackDisableDynamicResolutionTrackInst");

// Class JackGame.JackMaterialUpdater
// 0x00C8 (0x0100 - 0x0038)
class UJackMaterialUpdater : public UObject
{
public:
	UMulticastDelegateProperty_                   UpdateFinished;                                    // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xB8];                                      // 0x0048(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetInverseWorldEffectiveTimeDilation(bool bInverse);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdater">();
	}
	static class UJackMaterialUpdater* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdater>();
	}
};
static_assert(alignof(UJackMaterialUpdater) == 0x000008, "Wrong alignment on UJackMaterialUpdater");
static_assert(sizeof(UJackMaterialUpdater) == 0x000100, "Wrong size on UJackMaterialUpdater");
static_assert(offsetof(UJackMaterialUpdater, UpdateFinished) == 0x000038, "Member 'UJackMaterialUpdater::UpdateFinished' has a wrong offset!");

// Class JackGame.JackMaterialUpdaterScalar
// 0x0010 (0x0110 - 0x0100)
class UJackMaterialUpdaterScalar final : public UJackMaterialUpdater
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterScalar">();
	}
	static class UJackMaterialUpdaterScalar* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterScalar>();
	}
};
static_assert(alignof(UJackMaterialUpdaterScalar) == 0x000008, "Wrong alignment on UJackMaterialUpdaterScalar");
static_assert(sizeof(UJackMaterialUpdaterScalar) == 0x000110, "Wrong size on UJackMaterialUpdaterScalar");

// Class JackGame.JackDistributionExponentTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDistributionExponentTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDistributionExponentTrack">();
	}
	static class UJackDistributionExponentTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDistributionExponentTrack>();
	}
};
static_assert(alignof(UJackDistributionExponentTrack) == 0x000008, "Wrong alignment on UJackDistributionExponentTrack");
static_assert(sizeof(UJackDistributionExponentTrack) == 0x0000B0, "Wrong size on UJackDistributionExponentTrack");

// Class JackGame.JackDitherHideComponent
// 0x00C8 (0x01F0 - 0x0128)
class UJackDitherHideComponent final : public UActorComponent
{
public:
	class FString                                 MaterialName;                                      // 0x0128(0x0010)(Edit, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_138[0xB8];                                     // 0x0138(0x00B8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool SetDitherHidden(EJackHideCompoHiddenPurpose InPurpose, bool bInHidden, class UCurveBase* Curve, float InRequiredSeconds, bool bForceApplyParameter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDitherHideComponent">();
	}
	static class UJackDitherHideComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDitherHideComponent>();
	}
};
static_assert(alignof(UJackDitherHideComponent) == 0x000008, "Wrong alignment on UJackDitherHideComponent");
static_assert(sizeof(UJackDitherHideComponent) == 0x0001F0, "Wrong size on UJackDitherHideComponent");
static_assert(offsetof(UJackDitherHideComponent, MaterialName) == 0x000128, "Member 'UJackDitherHideComponent::MaterialName' has a wrong offset!");

// Class JackGame.JackInterruptFootIKEnableTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackInterruptFootIKEnableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInterruptFootIKEnableTrackInst">();
	}
	static class UJackInterruptFootIKEnableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInterruptFootIKEnableTrackInst>();
	}
};
static_assert(alignof(UJackInterruptFootIKEnableTrackInst) == 0x000008, "Wrong alignment on UJackInterruptFootIKEnableTrackInst");
static_assert(sizeof(UJackInterruptFootIKEnableTrackInst) == 0x000050, "Wrong size on UJackInterruptFootIKEnableTrackInst");

// Class JackGame.JackDPICustomScalingRule
// 0x0000 (0x0038 - 0x0038)
class UJackDPICustomScalingRule final : public UDPICustomScalingRule
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDPICustomScalingRule">();
	}
	static class UJackDPICustomScalingRule* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDPICustomScalingRule>();
	}
};
static_assert(alignof(UJackDPICustomScalingRule) == 0x000008, "Wrong alignment on UJackDPICustomScalingRule");
static_assert(sizeof(UJackDPICustomScalingRule) == 0x000038, "Wrong size on UJackDPICustomScalingRule");

// Class JackGame.JackLipSyncEnableTrack
// 0x0018 (0x00C0 - 0x00A8)
class UJackLipSyncEnableTrack final : public UJackToggleBaseTrack
{
public:
	float                                         DefaultLipTime;                                    // 0x00A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AC[0x4];                                       // 0x00AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackLipSyncEnableTrackInfo>    InfoArray;                                         // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLipSyncEnableTrack">();
	}
	static class UJackLipSyncEnableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLipSyncEnableTrack>();
	}
};
static_assert(alignof(UJackLipSyncEnableTrack) == 0x000008, "Wrong alignment on UJackLipSyncEnableTrack");
static_assert(sizeof(UJackLipSyncEnableTrack) == 0x0000C0, "Wrong size on UJackLipSyncEnableTrack");
static_assert(offsetof(UJackLipSyncEnableTrack, DefaultLipTime) == 0x0000A8, "Member 'UJackLipSyncEnableTrack::DefaultLipTime' has a wrong offset!");
static_assert(offsetof(UJackLipSyncEnableTrack, InfoArray) == 0x0000B0, "Member 'UJackLipSyncEnableTrack::InfoArray' has a wrong offset!");

// Class JackGame.JackDR_DecreasesResolutionMaxCountTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_DecreasesResolutionMaxCountTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_DecreasesResolutionMaxCountTrackInst">();
	}
	static class UJackDR_DecreasesResolutionMaxCountTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_DecreasesResolutionMaxCountTrackInst>();
	}
};
static_assert(alignof(UJackDR_DecreasesResolutionMaxCountTrackInst) == 0x000008, "Wrong alignment on UJackDR_DecreasesResolutionMaxCountTrackInst");
static_assert(sizeof(UJackDR_DecreasesResolutionMaxCountTrackInst) == 0x000038, "Wrong size on UJackDR_DecreasesResolutionMaxCountTrackInst");

// Class JackGame.JackHighQualityTextureTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackHighQualityTextureTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHighQualityTextureTrackInst">();
	}
	static class UJackHighQualityTextureTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackHighQualityTextureTrackInst>();
	}
};
static_assert(alignof(UJackHighQualityTextureTrackInst) == 0x000008, "Wrong alignment on UJackHighQualityTextureTrackInst");
static_assert(sizeof(UJackHighQualityTextureTrackInst) == 0x000040, "Wrong size on UJackHighQualityTextureTrackInst");

// Class JackGame.JackDR_DecreasesResolutionTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_DecreasesResolutionTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_DecreasesResolutionTrackInst">();
	}
	static class UJackDR_DecreasesResolutionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_DecreasesResolutionTrackInst>();
	}
};
static_assert(alignof(UJackDR_DecreasesResolutionTrackInst) == 0x000008, "Wrong alignment on UJackDR_DecreasesResolutionTrackInst");
static_assert(sizeof(UJackDR_DecreasesResolutionTrackInst) == 0x000038, "Wrong size on UJackDR_DecreasesResolutionTrackInst");

// Class JackGame.JackDR_MaxTimeBudgetTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_MaxTimeBudgetTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_MaxTimeBudgetTrack">();
	}
	static class UJackDR_MaxTimeBudgetTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_MaxTimeBudgetTrack>();
	}
};
static_assert(alignof(UJackDR_MaxTimeBudgetTrack) == 0x000008, "Wrong alignment on UJackDR_MaxTimeBudgetTrack");
static_assert(sizeof(UJackDR_MaxTimeBudgetTrack) == 0x0000B0, "Wrong size on UJackDR_MaxTimeBudgetTrack");

// Class JackGame.JackDR_MaxTimeBudgetTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_MaxTimeBudgetTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_MaxTimeBudgetTrackInst">();
	}
	static class UJackDR_MaxTimeBudgetTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_MaxTimeBudgetTrackInst>();
	}
};
static_assert(alignof(UJackDR_MaxTimeBudgetTrackInst) == 0x000008, "Wrong alignment on UJackDR_MaxTimeBudgetTrackInst");
static_assert(sizeof(UJackDR_MaxTimeBudgetTrackInst) == 0x000038, "Wrong size on UJackDR_MaxTimeBudgetTrackInst");

// Class JackGame.JackVehicleUma
// 0x00E0 (0x1C10 - 0x1B30)
class AJackVehicleUma : public AJackVehicleMonster
{
public:
	float                                         ForceFallSec;                                      // 0x1B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B34[0x4];                                     // 0x1B34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCheckOffset;                                   // 0x1B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxJumpZ;                                          // 0x1B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinJumpZ;                                          // 0x1B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAttitudeRotationSpeed;                         // 0x1B44(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAddAttitudeRotation;                           // 0x1B50(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         JumpMaxVelocity;                                   // 0x1B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMaxVelocity;                        // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMinAnimationRate;                   // 0x1B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B68[0x1];                                     // 0x1B68(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNoWaiterMontage;                                  // 0x1B69(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B6A[0xA6];                                    // 0x1B6A(0x00A6)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnCallHorse();
	void SetJumpOff(bool bInJumpOff);
	void StartAnimMontageWait();
	void StopAnimMontageWait();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleUma">();
	}
	static class AJackVehicleUma* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleUma>();
	}
};
static_assert(alignof(AJackVehicleUma) == 0x000010, "Wrong alignment on AJackVehicleUma");
static_assert(sizeof(AJackVehicleUma) == 0x001C10, "Wrong size on AJackVehicleUma");
static_assert(offsetof(AJackVehicleUma, ForceFallSec) == 0x001B30, "Member 'AJackVehicleUma::ForceFallSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpCheckOffset) == 0x001B38, "Member 'AJackVehicleUma::JumpCheckOffset' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, MaxJumpZ) == 0x001B3C, "Member 'AJackVehicleUma::MaxJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, MinJumpZ) == 0x001B40, "Member 'AJackVehicleUma::MinJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpAttitudeRotationSpeed) == 0x001B44, "Member 'AJackVehicleUma::JumpAttitudeRotationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpAddAttitudeRotation) == 0x001B50, "Member 'AJackVehicleUma::JumpAddAttitudeRotation' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpMaxVelocity) == 0x001B5C, "Member 'AJackVehicleUma::JumpMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpStartMotionMaxVelocity) == 0x001B60, "Member 'AJackVehicleUma::JumpStartMotionMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, JumpStartMotionMinAnimationRate) == 0x001B64, "Member 'AJackVehicleUma::JumpStartMotionMinAnimationRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleUma, bNoWaiterMontage) == 0x001B69, "Member 'AJackVehicleUma::bNoWaiterMontage' has a wrong offset!");

// Class JackGame.JackVehicleV106
// 0x0010 (0x1C20 - 0x1C10)
class AJackVehicleV106 final : public AJackVehicleUma
{
public:
	bool                                          bSyncOffAdditionalPitch;                           // 0x1C10(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C11[0xF];                                     // 0x1C11(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV106">();
	}
	static class AJackVehicleV106* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV106>();
	}
};
static_assert(alignof(AJackVehicleV106) == 0x000010, "Wrong alignment on AJackVehicleV106");
static_assert(sizeof(AJackVehicleV106) == 0x001C20, "Wrong size on AJackVehicleV106");
static_assert(offsetof(AJackVehicleV106, bSyncOffAdditionalPitch) == 0x001C10, "Member 'AJackVehicleV106::bSyncOffAdditionalPitch' has a wrong offset!");

// Class JackGame.JackDR_MinTimeBudgetTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDR_MinTimeBudgetTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_MinTimeBudgetTrack">();
	}
	static class UJackDR_MinTimeBudgetTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_MinTimeBudgetTrack>();
	}
};
static_assert(alignof(UJackDR_MinTimeBudgetTrack) == 0x000008, "Wrong alignment on UJackDR_MinTimeBudgetTrack");
static_assert(sizeof(UJackDR_MinTimeBudgetTrack) == 0x0000B0, "Wrong size on UJackDR_MinTimeBudgetTrack");

// Class JackGame.JackKiraManager
// 0x0010 (0x0048 - 0x0038)
class UJackKiraManager final : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetRemainRespawnTime(const class FName& SaveFlag, int32 CheckSeconds);
	bool IsAlreadyGotten(const class FName& SaveFlag);
	int32 SaveRespawnBaseSeconds(const class FName& SaveFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackKiraManager">();
	}
	static class UJackKiraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackKiraManager>();
	}
};
static_assert(alignof(UJackKiraManager) == 0x000008, "Wrong alignment on UJackKiraManager");
static_assert(sizeof(UJackKiraManager) == 0x000048, "Wrong size on UJackKiraManager");

// Class JackGame.JackDR_MinTimeBudgetTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_MinTimeBudgetTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_MinTimeBudgetTrackInst">();
	}
	static class UJackDR_MinTimeBudgetTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_MinTimeBudgetTrackInst>();
	}
};
static_assert(alignof(UJackDR_MinTimeBudgetTrackInst) == 0x000008, "Wrong alignment on UJackDR_MinTimeBudgetTrackInst");
static_assert(sizeof(UJackDR_MinTimeBudgetTrackInst) == 0x000038, "Wrong size on UJackDR_MinTimeBudgetTrackInst");

// Class JackGame.JackDR_ScreenPercentageTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_ScreenPercentageTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_ScreenPercentageTrackInst">();
	}
	static class UJackDR_ScreenPercentageTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_ScreenPercentageTrackInst>();
	}
};
static_assert(alignof(UJackDR_ScreenPercentageTrackInst) == 0x000008, "Wrong alignment on UJackDR_ScreenPercentageTrackInst");
static_assert(sizeof(UJackDR_ScreenPercentageTrackInst) == 0x000038, "Wrong size on UJackDR_ScreenPercentageTrackInst");

// Class JackGame.JackMiniGameEffectEmitter
// 0x0080 (0x03F0 - 0x0370)
class UJackMiniGameEffectEmitter : public UJackUMGWidgetBase
{
public:
	float                                         EmitterLifeTime;                                   // 0x0370(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerateNum;                                       // 0x0374(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParticleGenerateTime;                              // 0x0378(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GenerateCount;                                     // 0x037C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTime;                                          // 0x0380(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LifeTimeRange;                                     // 0x0384(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityScale;                                     // 0x0388(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityScaleRange;                                // 0x038C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartScale;                                        // 0x0390(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartScaleRange;                                   // 0x0394(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScale;                                          // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Damping;                                           // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVelocity;                                     // 0x03A0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleVelocityRange;                                // 0x03A4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDamping;                                      // 0x03A8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartAlpha;                                        // 0x03AC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndAlpha;                                          // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSubclassOf<class UJackMiniGameEffectParticle>> Class_0;                                           // 0x03B8(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TWeakObjectPtr<class UJackMiniGameEffectParticle>> ParticleList;                                      // 0x03C8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, UObjectWrapper, NativeAccessSpecifierPublic)
	int32                                         ZOrder;                                            // 0x03D8(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DC[0x14];                                     // 0x03DC(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetParticleGenerateTime(float InParticleGenerateTime);
	void Start();
	void Stop(bool bIsForceDelete);
	void Update(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitter">();
	}
	static class UJackMiniGameEffectEmitter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitter>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitter) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitter");
static_assert(sizeof(UJackMiniGameEffectEmitter) == 0x0003F0, "Wrong size on UJackMiniGameEffectEmitter");
static_assert(offsetof(UJackMiniGameEffectEmitter, EmitterLifeTime) == 0x000370, "Member 'UJackMiniGameEffectEmitter::EmitterLifeTime' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, GenerateNum) == 0x000374, "Member 'UJackMiniGameEffectEmitter::GenerateNum' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, ParticleGenerateTime) == 0x000378, "Member 'UJackMiniGameEffectEmitter::ParticleGenerateTime' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, GenerateCount) == 0x00037C, "Member 'UJackMiniGameEffectEmitter::GenerateCount' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, LifeTime) == 0x000380, "Member 'UJackMiniGameEffectEmitter::LifeTime' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, LifeTimeRange) == 0x000384, "Member 'UJackMiniGameEffectEmitter::LifeTimeRange' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, VelocityScale) == 0x000388, "Member 'UJackMiniGameEffectEmitter::VelocityScale' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, VelocityScaleRange) == 0x00038C, "Member 'UJackMiniGameEffectEmitter::VelocityScaleRange' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, StartScale) == 0x000390, "Member 'UJackMiniGameEffectEmitter::StartScale' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, StartScaleRange) == 0x000394, "Member 'UJackMiniGameEffectEmitter::StartScaleRange' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, EndScale) == 0x000398, "Member 'UJackMiniGameEffectEmitter::EndScale' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, Damping) == 0x00039C, "Member 'UJackMiniGameEffectEmitter::Damping' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, AngleVelocity) == 0x0003A0, "Member 'UJackMiniGameEffectEmitter::AngleVelocity' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, AngleVelocityRange) == 0x0003A4, "Member 'UJackMiniGameEffectEmitter::AngleVelocityRange' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, AngleDamping) == 0x0003A8, "Member 'UJackMiniGameEffectEmitter::AngleDamping' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, StartAlpha) == 0x0003AC, "Member 'UJackMiniGameEffectEmitter::StartAlpha' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, EndAlpha) == 0x0003B0, "Member 'UJackMiniGameEffectEmitter::EndAlpha' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, Class_0) == 0x0003B8, "Member 'UJackMiniGameEffectEmitter::Class_0' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, ParticleList) == 0x0003C8, "Member 'UJackMiniGameEffectEmitter::ParticleList' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitter, ZOrder) == 0x0003D8, "Member 'UJackMiniGameEffectEmitter::ZOrder' has a wrong offset!");

// Class JackGame.JackMiniGameEffectEmitterEllipse
// 0x0028 (0x0418 - 0x03F0)
class UJackMiniGameEffectEmitterEllipse final : public UJackMiniGameEffectEmitter
{
public:
	struct FVector2D                              CenterPosition;                                    // 0x03F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerWidth;                                        // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerHeight;                                       // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterWidth;                                        // 0x0400(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterHeight;                                       // 0x0404(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRange;                                        // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSphereEmitter;                                    // 0x0410(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetCenterPosition(const struct FVector2D& InPosition);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitterEllipse">();
	}
	static class UJackMiniGameEffectEmitterEllipse* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitterEllipse>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitterEllipse) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitterEllipse");
static_assert(sizeof(UJackMiniGameEffectEmitterEllipse) == 0x000418, "Wrong size on UJackMiniGameEffectEmitterEllipse");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, CenterPosition) == 0x0003F0, "Member 'UJackMiniGameEffectEmitterEllipse::CenterPosition' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, InnerWidth) == 0x0003F8, "Member 'UJackMiniGameEffectEmitterEllipse::InnerWidth' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, InnerHeight) == 0x0003FC, "Member 'UJackMiniGameEffectEmitterEllipse::InnerHeight' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, OuterWidth) == 0x000400, "Member 'UJackMiniGameEffectEmitterEllipse::OuterWidth' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, OuterHeight) == 0x000404, "Member 'UJackMiniGameEffectEmitterEllipse::OuterHeight' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, Angle) == 0x000408, "Member 'UJackMiniGameEffectEmitterEllipse::Angle' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, AngleRange) == 0x00040C, "Member 'UJackMiniGameEffectEmitterEllipse::AngleRange' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterEllipse, bSphereEmitter) == 0x000410, "Member 'UJackMiniGameEffectEmitterEllipse::bSphereEmitter' has a wrong offset!");

// Class JackGame.JackInteractiveActorManager
// 0x0028 (0x03C0 - 0x0398)
class AJackInteractiveActorManager final : public AActor
{
public:
	uint8                                         Pad_398[0x28];                                     // 0x0398(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInteractiveActorManager">();
	}
	static class AJackInteractiveActorManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackInteractiveActorManager>();
	}
};
static_assert(alignof(AJackInteractiveActorManager) == 0x000008, "Wrong alignment on AJackInteractiveActorManager");
static_assert(sizeof(AJackInteractiveActorManager) == 0x0003C0, "Wrong size on AJackInteractiveActorManager");

// Class JackGame.JackDR_WaitFramesToLowerResolutionTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_WaitFramesToLowerResolutionTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_WaitFramesToLowerResolutionTrackInst">();
	}
	static class UJackDR_WaitFramesToLowerResolutionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_WaitFramesToLowerResolutionTrackInst>();
	}
};
static_assert(alignof(UJackDR_WaitFramesToLowerResolutionTrackInst) == 0x000008, "Wrong alignment on UJackDR_WaitFramesToLowerResolutionTrackInst");
static_assert(sizeof(UJackDR_WaitFramesToLowerResolutionTrackInst) == 0x000038, "Wrong size on UJackDR_WaitFramesToLowerResolutionTrackInst");

// Class JackGame.JackDR_WaitFramesToUpperResolutionTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackDR_WaitFramesToUpperResolutionTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDR_WaitFramesToUpperResolutionTrackInst">();
	}
	static class UJackDR_WaitFramesToUpperResolutionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDR_WaitFramesToUpperResolutionTrackInst>();
	}
};
static_assert(alignof(UJackDR_WaitFramesToUpperResolutionTrackInst) == 0x000008, "Wrong alignment on UJackDR_WaitFramesToUpperResolutionTrackInst");
static_assert(sizeof(UJackDR_WaitFramesToUpperResolutionTrackInst) == 0x000038, "Wrong size on UJackDR_WaitFramesToUpperResolutionTrackInst");

// Class JackGame.JackMiniGameEffectEmitterSphere
// 0x0010 (0x0400 - 0x03F0)
class UJackMiniGameEffectEmitterSphere final : public UJackMiniGameEffectEmitter
{
public:
	struct FVector2D                              CenterPosition;                                    // 0x03F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitterSphere">();
	}
	static class UJackMiniGameEffectEmitterSphere* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitterSphere>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitterSphere) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitterSphere");
static_assert(sizeof(UJackMiniGameEffectEmitterSphere) == 0x000400, "Wrong size on UJackMiniGameEffectEmitterSphere");
static_assert(offsetof(UJackMiniGameEffectEmitterSphere, CenterPosition) == 0x0003F0, "Member 'UJackMiniGameEffectEmitterSphere::CenterPosition' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterSphere, InnerRadius) == 0x0003F8, "Member 'UJackMiniGameEffectEmitterSphere::InnerRadius' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterSphere, OuterRadius) == 0x0003FC, "Member 'UJackMiniGameEffectEmitterSphere::OuterRadius' has a wrong offset!");

// Class JackGame.JackLoadReductionComponent
// 0x0090 (0x0230 - 0x01A0)
class UJackLoadReductionComponent final : public UJackCharacterComponent
{
public:
	TArray<class UActorComponent*>                ControlComponents;                                 // 0x01A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class USkeletalMeshComponent*>         ControlSkeletalMeshComponents;                     // 0x01B0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x67];                                     // 0x01C0(0x0067)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bReductionInCutScene;                              // 0x0227(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_228[0x8];                                      // 0x0228(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLoadReductionComponent">();
	}
	static class UJackLoadReductionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLoadReductionComponent>();
	}
};
static_assert(alignof(UJackLoadReductionComponent) == 0x000008, "Wrong alignment on UJackLoadReductionComponent");
static_assert(sizeof(UJackLoadReductionComponent) == 0x000230, "Wrong size on UJackLoadReductionComponent");
static_assert(offsetof(UJackLoadReductionComponent, ControlComponents) == 0x0001A0, "Member 'UJackLoadReductionComponent::ControlComponents' has a wrong offset!");
static_assert(offsetof(UJackLoadReductionComponent, ControlSkeletalMeshComponents) == 0x0001B0, "Member 'UJackLoadReductionComponent::ControlSkeletalMeshComponents' has a wrong offset!");
static_assert(offsetof(UJackLoadReductionComponent, bReductionInCutScene) == 0x000227, "Member 'UJackLoadReductionComponent::bReductionInCutScene' has a wrong offset!");

// Class JackGame.JackDynamicShadowDistanceMovableLightTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackDynamicShadowDistanceMovableLightTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDynamicShadowDistanceMovableLightTrack">();
	}
	static class UJackDynamicShadowDistanceMovableLightTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDynamicShadowDistanceMovableLightTrack>();
	}
};
static_assert(alignof(UJackDynamicShadowDistanceMovableLightTrack) == 0x000008, "Wrong alignment on UJackDynamicShadowDistanceMovableLightTrack");
static_assert(sizeof(UJackDynamicShadowDistanceMovableLightTrack) == 0x0000B0, "Wrong size on UJackDynamicShadowDistanceMovableLightTrack");

// Class JackGame.JackEffectManager
// 0x0000 (0x0398 - 0x0398)
class AJackEffectManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEffectManager">();
	}
	static class AJackEffectManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackEffectManager>();
	}
};
static_assert(alignof(AJackEffectManager) == 0x000008, "Wrong alignment on AJackEffectManager");
static_assert(sizeof(AJackEffectManager) == 0x000398, "Wrong size on AJackEffectManager");

// Class JackGame.JackMiniGameManager
// 0x0050 (0x0088 - 0x0038)
class UJackMiniGameManager : public UObject
{
public:
	TSubclassOf<class UJackUmaRaceAccessor>       UmaRaceAccessorClass;                              // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackRouletteAccessor>      RouletteAccessorClass;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackMeosiSlotAccessor>     MeosiSlotAccessorClass;                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackMiniGameJackPotAccessor> JackPotAccessorClass;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsUpdateOneDay;                                   // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUmaRaceAccessor*                   UmaRaceAccessor;                                   // 0x0060(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackRouletteAccessor*                  RouletteAccessor;                                  // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackMeosiSlotAccessor*                 MeosiSlotAccessor;                                 // 0x0070(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackMiniGameJackPotAccessor*           JackPotAccessor;                                   // 0x0078(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_80[0x8];                                       // 0x0080(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDebugMenu();
	void ApplyCasinoArchievement();
	void CreateInstances();
	void DisableUpdateDayFlag();
	class UJackMiniGameJackPotAccessor* GetJackPotAccessor();
	int32 GetJackPotCoinNum();
	EJackMiniGameJackPotLevel GetJackPotLevel();
	class UJackMeosiSlotAccessor* GetMeosiSlotAccessor();
	class UJackRouletteAccessor* GetRouletteAccessor();
	class UJackUmaRaceAccessor* GetUmaRaceAccessor();
	void IncrementJackPotCoinNum(int32 InCoinNum);
	bool IsMamonoCasino();
	bool IsResolutionChange();
	bool IsUpdateDayFlag();
	void RemoveDebugMenu();
	void RequestGarbageCollection(class UObject* WorldContextObject, bool bIsImmidiate);
	void RequestIncrementalGarbageCollection(class UObject* WorldContextObject, bool bImmidiate);
	void ResolutionChange(class UObject* WorldContextObject);
	void RestoreResolutionChange(class UObject* WorldContextObject);
	void SetCasinoCoin(int32 Coin);
	void SetResolutionChange(bool InResolutionChange);
	void SetUpdateOneDay(bool bIsUpdate);
	void UpdateOneDay();

	int32 GetCasinoCoin() const;
	int32 GetCasinoCoinMax() const;
	bool IsMiniGamePlaying() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameManager">();
	}
	static class UJackMiniGameManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameManager>();
	}
};
static_assert(alignof(UJackMiniGameManager) == 0x000008, "Wrong alignment on UJackMiniGameManager");
static_assert(sizeof(UJackMiniGameManager) == 0x000088, "Wrong size on UJackMiniGameManager");
static_assert(offsetof(UJackMiniGameManager, UmaRaceAccessorClass) == 0x000038, "Member 'UJackMiniGameManager::UmaRaceAccessorClass' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, RouletteAccessorClass) == 0x000040, "Member 'UJackMiniGameManager::RouletteAccessorClass' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, MeosiSlotAccessorClass) == 0x000048, "Member 'UJackMiniGameManager::MeosiSlotAccessorClass' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, JackPotAccessorClass) == 0x000050, "Member 'UJackMiniGameManager::JackPotAccessorClass' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, bIsUpdateOneDay) == 0x000058, "Member 'UJackMiniGameManager::bIsUpdateOneDay' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, UmaRaceAccessor) == 0x000060, "Member 'UJackMiniGameManager::UmaRaceAccessor' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, RouletteAccessor) == 0x000068, "Member 'UJackMiniGameManager::RouletteAccessor' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, MeosiSlotAccessor) == 0x000070, "Member 'UJackMiniGameManager::MeosiSlotAccessor' has a wrong offset!");
static_assert(offsetof(UJackMiniGameManager, JackPotAccessor) == 0x000078, "Member 'UJackMiniGameManager::JackPotAccessor' has a wrong offset!");

// Class JackGame.JackInterpTrackNameBase
// 0x0010 (0x00A0 - 0x0090)
class UJackInterpTrackNameBase : public UInterpTrack
{
public:
	TArray<struct FJackNameTrackKey>              NameTrack;                                         // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInterpTrackNameBase">();
	}
	static class UJackInterpTrackNameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInterpTrackNameBase>();
	}
};
static_assert(alignof(UJackInterpTrackNameBase) == 0x000008, "Wrong alignment on UJackInterpTrackNameBase");
static_assert(sizeof(UJackInterpTrackNameBase) == 0x0000A0, "Wrong size on UJackInterpTrackNameBase");
static_assert(offsetof(UJackInterpTrackNameBase, NameTrack) == 0x000090, "Member 'UJackInterpTrackNameBase::NameTrack' has a wrong offset!");

// Class JackGame.JackJumpLabelTrack
// 0x0000 (0x00A0 - 0x00A0)
class UJackJumpLabelTrack final : public UJackInterpTrackNameBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackJumpLabelTrack">();
	}
	static class UJackJumpLabelTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackJumpLabelTrack>();
	}
};
static_assert(alignof(UJackJumpLabelTrack) == 0x000008, "Wrong alignment on UJackJumpLabelTrack");
static_assert(sizeof(UJackJumpLabelTrack) == 0x0000A0, "Wrong size on UJackJumpLabelTrack");

// Class JackGame.JackEquipmentControlComponentSettings
// 0x0060 (0x0098 - 0x0038)
class UJackEquipmentControlComponentSettings : public UObject
{
public:
	struct FJackEquipmentClassificationInfoDict   DefaultEquipmentClassificationInfoDict;            // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FJackEquipmentClassificationInfoDict> EquipmentClassificationInfoDict;                   // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEquipmentControlComponentSettings">();
	}
	static class UJackEquipmentControlComponentSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEquipmentControlComponentSettings>();
	}
};
static_assert(alignof(UJackEquipmentControlComponentSettings) == 0x000008, "Wrong alignment on UJackEquipmentControlComponentSettings");
static_assert(sizeof(UJackEquipmentControlComponentSettings) == 0x000098, "Wrong size on UJackEquipmentControlComponentSettings");
static_assert(offsetof(UJackEquipmentControlComponentSettings, DefaultEquipmentClassificationInfoDict) == 0x000038, "Member 'UJackEquipmentControlComponentSettings::DefaultEquipmentClassificationInfoDict' has a wrong offset!");
static_assert(offsetof(UJackEquipmentControlComponentSettings, EquipmentClassificationInfoDict) == 0x000088, "Member 'UJackEquipmentControlComponentSettings::EquipmentClassificationInfoDict' has a wrong offset!");

// Class JackGame.JackEventBattleInfo
// 0x01E0 (0x0218 - 0x0038)
class UJackEventBattleInfo final : public UObject
{
public:
	class FName                                   EventBattleID;                                     // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadComplete_MonsterMain;                         // 0x0040(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadComplete_MonsterVoice;                        // 0x0041(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoadComplete_MonsterVoiceReload;                  // 0x0042(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               StreamObjectsHolder;                               // 0x0048(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackStreamObjectsHolder*               VoiceStreamObjectsHolder;                          // 0x0050(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackDataTableEventBattle              DataTableRow;                                      // 0x0058(0x0148)(Edit, EditConst, NativeAccessSpecifierPublic)
	bool                                          bBattleField_Valid;                                // 0x01A0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A1[0x3];                                      // 0x01A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                BattleField_Location;                              // 0x01A4(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BattleField_Direction;                             // 0x01B0(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackEventBattlePlayerInfo             PlayerInfo;                                        // 0x01BC(0x001C)(Edit, EditConst, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FJackEventBattleMonsterInfo>    MonsterInfoArray;                                  // 0x01D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x10];                                     // 0x01E8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                MonsterTroopLocation;                              // 0x01F8(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Appear_Direction;                                  // 0x0204(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAppearDirectionUse;                               // 0x0210(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialUnsheathe;                                 // 0x0211(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_212[0x6];                                      // 0x0212(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAppearInfo(const struct FVector& AppearDirection);
	void SetBattleFieldInfo(const struct FVector& BattleFieldLocation, const struct FVector& BattleFieldDirection);
	void SetInitialUnsheathe(bool bUnsheathe);
	void SetMonsterInfo(int32 EventBattleMonsterIndex, const struct FVector& BattleStartLocation, const struct FVector& BattleStartDirection);
	void SetMonsterTroopInfo(const struct FVector& TroopLocation);
	void SetPlayerInfo(const struct FVector& BattleStartLocation, const struct FVector& BattleStartDirection);
	void SetSyuurenjouInfo(class FName SirenID, int32 BattleIndex);

	EJackFadeColor GetEndFadeColor() const;
	EJackFadeColor GetStartFadeColor() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEventBattleInfo">();
	}
	static class UJackEventBattleInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEventBattleInfo>();
	}
};
static_assert(alignof(UJackEventBattleInfo) == 0x000008, "Wrong alignment on UJackEventBattleInfo");
static_assert(sizeof(UJackEventBattleInfo) == 0x000218, "Wrong size on UJackEventBattleInfo");
static_assert(offsetof(UJackEventBattleInfo, EventBattleID) == 0x000038, "Member 'UJackEventBattleInfo::EventBattleID' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bLoadComplete_MonsterMain) == 0x000040, "Member 'UJackEventBattleInfo::bLoadComplete_MonsterMain' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bLoadComplete_MonsterVoice) == 0x000041, "Member 'UJackEventBattleInfo::bLoadComplete_MonsterVoice' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bLoadComplete_MonsterVoiceReload) == 0x000042, "Member 'UJackEventBattleInfo::bLoadComplete_MonsterVoiceReload' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, StreamObjectsHolder) == 0x000048, "Member 'UJackEventBattleInfo::StreamObjectsHolder' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, VoiceStreamObjectsHolder) == 0x000050, "Member 'UJackEventBattleInfo::VoiceStreamObjectsHolder' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, DataTableRow) == 0x000058, "Member 'UJackEventBattleInfo::DataTableRow' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bBattleField_Valid) == 0x0001A0, "Member 'UJackEventBattleInfo::bBattleField_Valid' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, BattleField_Location) == 0x0001A4, "Member 'UJackEventBattleInfo::BattleField_Location' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, BattleField_Direction) == 0x0001B0, "Member 'UJackEventBattleInfo::BattleField_Direction' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, PlayerInfo) == 0x0001BC, "Member 'UJackEventBattleInfo::PlayerInfo' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, MonsterInfoArray) == 0x0001D8, "Member 'UJackEventBattleInfo::MonsterInfoArray' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, MonsterTroopLocation) == 0x0001F8, "Member 'UJackEventBattleInfo::MonsterTroopLocation' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, Appear_Direction) == 0x000204, "Member 'UJackEventBattleInfo::Appear_Direction' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bAppearDirectionUse) == 0x000210, "Member 'UJackEventBattleInfo::bAppearDirectionUse' has a wrong offset!");
static_assert(offsetof(UJackEventBattleInfo, bInitialUnsheathe) == 0x000211, "Member 'UJackEventBattleInfo::bInitialUnsheathe' has a wrong offset!");

// Class JackGame.JackEventBattleManager
// 0x0050 (0x03E8 - 0x0398)
class AJackEventBattleManager final : public AActor
{
public:
	TMap<class FName, class UJackEventBattleInfo*> EventBattleInfoMap;                                // 0x0398(0x0050)(Edit, ExportObject, ZeroConstructor, EditConst, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)

public:
	class UJackEventBattleInfo* GetEventBattleInfo(class FName EventBattleID);
	class UJackEventBattleInfo* LoadEventBattle(class FName EventBattleID, const struct FLatentActionInfo& LatentInfo);
	bool StartEventBattle(const class UJackEventBattleInfo* EventBattleInfo, const struct FLatentActionInfo& LatentInfo);
	bool UnloadEventBattle(class FName EventBattleID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEventBattleManager">();
	}
	static class AJackEventBattleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackEventBattleManager>();
	}
};
static_assert(alignof(AJackEventBattleManager) == 0x000008, "Wrong alignment on AJackEventBattleManager");
static_assert(sizeof(AJackEventBattleManager) == 0x0003E8, "Wrong size on AJackEventBattleManager");
static_assert(offsetof(AJackEventBattleManager, EventBattleInfoMap) == 0x000398, "Member 'AJackEventBattleManager::EventBattleInfoMap' has a wrong offset!");

// Class JackGame.JackUMGTokugiPanelMemberData
// 0x0018 (0x0050 - 0x0038)
class UJackUMGTokugiPanelMemberData final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DefaultPosition;                                   // 0x003C(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsIncreaseHighlight;                              // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackFriendGameCharacter*               Data;                                              // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TArray<class UJackUMGItemData*> ConstructTokugiPanelMemberData(class UObject* WorldContextObject, bool bInBattleResult);
	static class UJackUMGTokugiPanelMemberData* GetTokugiPanelMemberData(const class UJackUMGItemData* ItemData);

	EJackCharacter GetCharacterType();
	class FString GetName();
	int32 GetSkillPoint();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPanelMemberData">();
	}
	static class UJackUMGTokugiPanelMemberData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPanelMemberData>();
	}
};
static_assert(alignof(UJackUMGTokugiPanelMemberData) == 0x000008, "Wrong alignment on UJackUMGTokugiPanelMemberData");
static_assert(sizeof(UJackUMGTokugiPanelMemberData) == 0x000050, "Wrong size on UJackUMGTokugiPanelMemberData");
static_assert(offsetof(UJackUMGTokugiPanelMemberData, Index_0) == 0x000038, "Member 'UJackUMGTokugiPanelMemberData::Index_0' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelMemberData, DefaultPosition) == 0x00003C, "Member 'UJackUMGTokugiPanelMemberData::DefaultPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelMemberData, bIsIncreaseHighlight) == 0x000044, "Member 'UJackUMGTokugiPanelMemberData::bIsIncreaseHighlight' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelMemberData, Data) == 0x000048, "Member 'UJackUMGTokugiPanelMemberData::Data' has a wrong offset!");

// Class JackGame.JackLookAtIKTrackInst
// 0x0018 (0x0058 - 0x0040)
class UJackLookAtIKTrackInst final : public UJackToggleBaseTrackInst
{
public:
	bool                                          bLookAtEnable;                                     // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultAutoLookAt;                                // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultLookAtInterpSpeed;                          // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   DefaultLookAtInterpCurve;                          // 0x0048(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x3];                                       // 0x0049(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntrpSec;                                          // 0x004C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowKeyIndex;                                       // 0x0050(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLookAtIKTrackInst">();
	}
	static class UJackLookAtIKTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLookAtIKTrackInst>();
	}
};
static_assert(alignof(UJackLookAtIKTrackInst) == 0x000008, "Wrong alignment on UJackLookAtIKTrackInst");
static_assert(sizeof(UJackLookAtIKTrackInst) == 0x000058, "Wrong size on UJackLookAtIKTrackInst");
static_assert(offsetof(UJackLookAtIKTrackInst, bLookAtEnable) == 0x000040, "Member 'UJackLookAtIKTrackInst::bLookAtEnable' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrackInst, bDefaultAutoLookAt) == 0x000041, "Member 'UJackLookAtIKTrackInst::bDefaultAutoLookAt' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrackInst, DefaultLookAtInterpSpeed) == 0x000044, "Member 'UJackLookAtIKTrackInst::DefaultLookAtInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrackInst, DefaultLookAtInterpCurve) == 0x000048, "Member 'UJackLookAtIKTrackInst::DefaultLookAtInterpCurve' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrackInst, IntrpSec) == 0x00004C, "Member 'UJackLookAtIKTrackInst::IntrpSec' has a wrong offset!");
static_assert(offsetof(UJackLookAtIKTrackInst, NowKeyIndex) == 0x000050, "Member 'UJackLookAtIKTrackInst::NowKeyIndex' has a wrong offset!");

// Class JackGame.JackExtraNPCCapsuleComponent
// 0x0010 (0x0770 - 0x0760)
class UJackExtraNPCCapsuleComponent : public UCapsuleComponent
{
public:
	class FName                                   AttachSocket;                                      // 0x0760(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_768[0x8];                                      // 0x0768(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void OnHit(class UPrimitiveComponent* HitComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, const struct FVector& NormalImpulse, const struct FHitResult& Hit);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackExtraNPCCapsuleComponent">();
	}
	static class UJackExtraNPCCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackExtraNPCCapsuleComponent>();
	}
};
static_assert(alignof(UJackExtraNPCCapsuleComponent) == 0x000010, "Wrong alignment on UJackExtraNPCCapsuleComponent");
static_assert(sizeof(UJackExtraNPCCapsuleComponent) == 0x000770, "Wrong size on UJackExtraNPCCapsuleComponent");
static_assert(offsetof(UJackExtraNPCCapsuleComponent, AttachSocket) == 0x000760, "Member 'UJackExtraNPCCapsuleComponent::AttachSocket' has a wrong offset!");

// Class JackGame.JackMaterialTextureFolder
// 0x0010 (0x0090 - 0x0080)
class UJackMaterialTextureFolder final : public UMaterialInterface
{
public:
	uint8                                         Pad_80[0x10];                                      // 0x0080(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialTextureFolder">();
	}
	static class UJackMaterialTextureFolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialTextureFolder>();
	}
};
static_assert(alignof(UJackMaterialTextureFolder) == 0x000008, "Wrong alignment on UJackMaterialTextureFolder");
static_assert(sizeof(UJackMaterialTextureFolder) == 0x000090, "Wrong size on UJackMaterialTextureFolder");

// Class JackGame.JackEyeLookAtComponent
// 0x0120 (0x02C0 - 0x01A0)
class UJackEyeLookAtComponent : public UJackCharacterComponent
{
public:
	float                                         CurrentHorizontalValue;                            // 0x01A0(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentVerticalValue;                              // 0x01A4(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalValue;                                   // 0x01A8(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         VerticalValue;                                     // 0x01AC(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   SourceSocket;                                      // 0x01B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TargetSocket;                                      // 0x01B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEyeLookAtEnable;                                  // 0x01C0(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1C1[0x3];                                      // 0x01C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TransitionSpeed;                                   // 0x01C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class ACharacter*                             TargetCharacter;                                   // 0x01C8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USceneComponent*                        TargetSceneComponent;                              // 0x01D0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                TargetLocation;                                    // 0x01D8(0x000C)(Edit, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSynchronizedEyeLookAt;                            // 0x01E4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E5[0xDB];                                     // 0x01E5(0x00DB)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearEyeLookAtParameters();
	void OnEyeLookAtEnableChanged();
	void OnSynchronizedEyeLookAtChanged();
	void SetEyeLookAtEnable(bool bNew);
	void SetSynchronizedEyeLookAt(bool bNew);
	void SetTargetCharacter(class ACharacter* InCharacter, class FName InSocketName);
	void SetTargetLocation(const struct FVector& InLocation);
	void SetTargetSceneComponent(class USceneComponent* InSceneComponent, class FName InSocketName);
	void SetTransitionSpeed(float Speed);

	float GetCurrentHorizontalValue() const;
	float GetCurrentVerticalValue() const;
	bool GetEyeLookAtEnable() const;
	bool GetSynchronizedEyeLookAt() const;
	class ACharacter* GetTargetCharacter() const;
	struct FVector GetTargetLocation() const;
	class USceneComponent* GetTargetSceneComponent() const;
	class FName GetTargetSocketName() const;
	float GetTransitionSpeed() const;
	bool IsEyeLookAtRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEyeLookAtComponent">();
	}
	static class UJackEyeLookAtComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEyeLookAtComponent>();
	}
};
static_assert(alignof(UJackEyeLookAtComponent) == 0x000008, "Wrong alignment on UJackEyeLookAtComponent");
static_assert(sizeof(UJackEyeLookAtComponent) == 0x0002C0, "Wrong size on UJackEyeLookAtComponent");
static_assert(offsetof(UJackEyeLookAtComponent, CurrentHorizontalValue) == 0x0001A0, "Member 'UJackEyeLookAtComponent::CurrentHorizontalValue' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, CurrentVerticalValue) == 0x0001A4, "Member 'UJackEyeLookAtComponent::CurrentVerticalValue' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, HorizontalValue) == 0x0001A8, "Member 'UJackEyeLookAtComponent::HorizontalValue' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, VerticalValue) == 0x0001AC, "Member 'UJackEyeLookAtComponent::VerticalValue' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, SourceSocket) == 0x0001B0, "Member 'UJackEyeLookAtComponent::SourceSocket' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, TargetSocket) == 0x0001B8, "Member 'UJackEyeLookAtComponent::TargetSocket' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, bEyeLookAtEnable) == 0x0001C0, "Member 'UJackEyeLookAtComponent::bEyeLookAtEnable' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, TransitionSpeed) == 0x0001C4, "Member 'UJackEyeLookAtComponent::TransitionSpeed' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, TargetCharacter) == 0x0001C8, "Member 'UJackEyeLookAtComponent::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, TargetSceneComponent) == 0x0001D0, "Member 'UJackEyeLookAtComponent::TargetSceneComponent' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, TargetLocation) == 0x0001D8, "Member 'UJackEyeLookAtComponent::TargetLocation' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtComponent, bSynchronizedEyeLookAt) == 0x0001E4, "Member 'UJackEyeLookAtComponent::bSynchronizedEyeLookAt' has a wrong offset!");

// Class JackGame.JackEyeLookAtTrack
// 0x0028 (0x00D0 - 0x00A8)
class UJackEyeLookAtTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   LookAtGroupName;                                   // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LookAtBoneName;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PositionThreshold;                                 // 0x00B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackEyeLookAtTrackInfo>        LookAtInfos;                                       // 0x00C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEyeLookAtTrack">();
	}
	static class UJackEyeLookAtTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEyeLookAtTrack>();
	}
};
static_assert(alignof(UJackEyeLookAtTrack) == 0x000008, "Wrong alignment on UJackEyeLookAtTrack");
static_assert(sizeof(UJackEyeLookAtTrack) == 0x0000D0, "Wrong size on UJackEyeLookAtTrack");
static_assert(offsetof(UJackEyeLookAtTrack, LookAtGroupName) == 0x0000A8, "Member 'UJackEyeLookAtTrack::LookAtGroupName' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrack, LookAtBoneName) == 0x0000B0, "Member 'UJackEyeLookAtTrack::LookAtBoneName' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrack, PositionThreshold) == 0x0000B8, "Member 'UJackEyeLookAtTrack::PositionThreshold' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrack, LookAtInfos) == 0x0000C0, "Member 'UJackEyeLookAtTrack::LookAtInfos' has a wrong offset!");

// Class JackGame.JackPafuPafuParameter
// 0x00C8 (0x0100 - 0x0038)
class UJackPafuPafuParameter final : public UObject
{
public:
	float                                         Ddz;                                               // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ddz_lpf;                                           // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ddz_hat;                                           // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dz;                                                // 0x0044(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0048(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Ddx;                                               // 0x004C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Dx;                                                // 0x0050(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0054(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x4];                                       // 0x0058(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Dt;                                                // 0x005C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoyAccelToDdzCoeff;                                // 0x0060(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoyDdzLpfCoeff;                                    // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoyDdzThreshold;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoyDzThreshold;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoyZDecay;                                         // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         M;                                                 // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         K;                                                 // 0x0078(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         D;                                                 // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToAmplCoeff;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToAmplMax;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToAmplMin;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToFreqF0;                                       // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToFreqCoeff;                                    // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DdxToFreqMax;                                      // 0x0094(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x68];                                      // 0x0098(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPafuPafuParameter">();
	}
	static class UJackPafuPafuParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPafuPafuParameter>();
	}
};
static_assert(alignof(UJackPafuPafuParameter) == 0x000008, "Wrong alignment on UJackPafuPafuParameter");
static_assert(sizeof(UJackPafuPafuParameter) == 0x000100, "Wrong size on UJackPafuPafuParameter");
static_assert(offsetof(UJackPafuPafuParameter, Ddz) == 0x000038, "Member 'UJackPafuPafuParameter::Ddz' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Ddz_lpf) == 0x00003C, "Member 'UJackPafuPafuParameter::Ddz_lpf' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Ddz_hat) == 0x000040, "Member 'UJackPafuPafuParameter::Ddz_hat' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Dz) == 0x000044, "Member 'UJackPafuPafuParameter::Dz' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Z) == 0x000048, "Member 'UJackPafuPafuParameter::Z' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Ddx) == 0x00004C, "Member 'UJackPafuPafuParameter::Ddx' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Dx) == 0x000050, "Member 'UJackPafuPafuParameter::Dx' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, X) == 0x000054, "Member 'UJackPafuPafuParameter::X' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, Dt) == 0x00005C, "Member 'UJackPafuPafuParameter::Dt' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, JoyAccelToDdzCoeff) == 0x000060, "Member 'UJackPafuPafuParameter::JoyAccelToDdzCoeff' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, JoyDdzLpfCoeff) == 0x000064, "Member 'UJackPafuPafuParameter::JoyDdzLpfCoeff' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, JoyDdzThreshold) == 0x000068, "Member 'UJackPafuPafuParameter::JoyDdzThreshold' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, JoyDzThreshold) == 0x00006C, "Member 'UJackPafuPafuParameter::JoyDzThreshold' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, JoyZDecay) == 0x000070, "Member 'UJackPafuPafuParameter::JoyZDecay' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, M) == 0x000074, "Member 'UJackPafuPafuParameter::M' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, K) == 0x000078, "Member 'UJackPafuPafuParameter::K' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, D) == 0x00007C, "Member 'UJackPafuPafuParameter::D' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToAmplCoeff) == 0x000080, "Member 'UJackPafuPafuParameter::DdxToAmplCoeff' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToAmplMax) == 0x000084, "Member 'UJackPafuPafuParameter::DdxToAmplMax' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToAmplMin) == 0x000088, "Member 'UJackPafuPafuParameter::DdxToAmplMin' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToFreqF0) == 0x00008C, "Member 'UJackPafuPafuParameter::DdxToFreqF0' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToFreqCoeff) == 0x000090, "Member 'UJackPafuPafuParameter::DdxToFreqCoeff' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuParameter, DdxToFreqMax) == 0x000094, "Member 'UJackPafuPafuParameter::DdxToFreqMax' has a wrong offset!");

// Class JackGame.JackEyeLookAtTrackInst
// 0x0010 (0x0050 - 0x0040)
class UJackEyeLookAtTrackInst final : public UJackToggleBaseTrackInst
{
public:
	bool                                          bLookAtEnable;                                     // 0x0040(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultAutoLookAt;                                // 0x0041(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0x2];                                       // 0x0042(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntrpSec;                                          // 0x0044(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NowKeyIndex;                                       // 0x0048(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackEyeLookAtTrackInst">();
	}
	static class UJackEyeLookAtTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackEyeLookAtTrackInst>();
	}
};
static_assert(alignof(UJackEyeLookAtTrackInst) == 0x000008, "Wrong alignment on UJackEyeLookAtTrackInst");
static_assert(sizeof(UJackEyeLookAtTrackInst) == 0x000050, "Wrong size on UJackEyeLookAtTrackInst");
static_assert(offsetof(UJackEyeLookAtTrackInst, bLookAtEnable) == 0x000040, "Member 'UJackEyeLookAtTrackInst::bLookAtEnable' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrackInst, bDefaultAutoLookAt) == 0x000041, "Member 'UJackEyeLookAtTrackInst::bDefaultAutoLookAt' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrackInst, IntrpSec) == 0x000044, "Member 'UJackEyeLookAtTrackInst::IntrpSec' has a wrong offset!");
static_assert(offsetof(UJackEyeLookAtTrackInst, NowKeyIndex) == 0x000048, "Member 'UJackEyeLookAtTrackInst::NowKeyIndex' has a wrong offset!");

// Class JackGame.JackFacialControlComponent
// 0x0B30 (0x0CD0 - 0x01A0)
class UJackFacialControlComponent : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x558];                                    // 0x01A0(0x0558)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FacialModeChangeDuration;                          // 0x06F8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SelectedPoseChangeDuration;                        // 0x06FC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectedUpperFacePose;                             // 0x0700(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectedLowerFacePose;                             // 0x0708(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Tone;                                              // 0x0710(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         Emotion;                                           // 0x0714(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackEyeControl                               EyeControlType;                                    // 0x0718(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_719[0x3];                                      // 0x0719(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyeClosingByBlinkTime;                             // 0x071C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EyeClosingByBlinkRemainingTime;                    // 0x0720(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlinkDurationTimeFromOpenToClose;                  // 0x0724(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlinkDurationTimeFromCloseToOpen;                  // 0x0728(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   EyeCurveFromCloseToOpen;                           // 0x072C(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   EyeCurveFromOpenToClose;                           // 0x072D(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_72E[0xA];                                      // 0x072E(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RandomBlinkRemainingTime;                          // 0x0738(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              RandomBlinkTimeRange;                              // 0x073C(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_744[0x4];                                      // 0x0744(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomBlinkCurveName;                              // 0x0748(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          RandomBlinkTargetAnim;                             // 0x0750(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackVowel                                    LastPhraseVowel;                                   // 0x0758(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_759[0x3];                                      // 0x0759(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TalkingSpeed;                                      // 0x075C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipSyncTime;                                       // 0x0760(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipSyncBlendTime;                                  // 0x0764(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipSyncBlendWeight;                                // 0x0768(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipSyncMasterBlendWeight_UpTime;                   // 0x076C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LipSyncMasterBlendWeight_DownTime;                 // 0x0770(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_774[0x4];                                      // 0x0774(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackVowelSetting                      VowelSettings[0xB];                                // 0x0778(0x0018)(Edit, Protected, NativeAccessSpecifierProtected)
	float                                         VowelElapsedTime;                                  // 0x0880(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomLipSyncRunning;                             // 0x0884(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_885[0x23];                                     // 0x0885(0x0023)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RandomMouthCurveName;                              // 0x08A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimSequence*                          RandomMouthTargetAnim;                             // 0x08B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackRandomLipSyncMode                        RandomLipSyncMode;                                 // 0x08B8(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8B9[0x7];                                      // 0x08B9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             FacePoseSequenceDataTable;                         // 0x08C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             AnimDataTable;                                     // 0x08C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   FadeInEasingFunc;                                  // 0x08D0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   FadeOutEasingFunc;                                 // 0x08D1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8D2[0x6];                                      // 0x08D2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     FaceMaterial;                                      // 0x08D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FaceMaterialIndex;                                 // 0x08E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8E4[0x4];                                      // 0x08E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               MaterialInstanceDynamic;                           // 0x08E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MaxBlendCount;                                     // 0x08F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUpperFacialState                         UpperFacialAnimState;                              // 0x08F4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackLowerFacialState                         LowerFacialAnimState;                              // 0x08F5(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseEyeBallPositionOffset;                         // 0x08F6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8F7[0x1];                                      // 0x08F7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlinkPoseEyeOffset;                                // 0x08F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_8FC[0x4];                                      // 0x08FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackEyeCloseFacialPose>        BlinkFacialPoses;                                  // 0x0900(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_910[0xA0];                                     // 0x0910(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DefaultFacialPoseName;                             // 0x09B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   CurrentFacialPoseName;                             // 0x09B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         R;                                                 // 0x09C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              UVClampRange;                                      // 0x09C4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9CC[0x114];                                    // 0x09CC(0x0114)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bControlEnabled;                                   // 0x0AE0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE1[0x3];                                      // 0x0AE1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ControlEnabledMaxLODLevel;                         // 0x0AE4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_AE8[0xD0];                                     // 0x0AE8(0x00D0)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EyelidLength;                                      // 0x0BB8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BBC[0x4];                                      // 0x0BBC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UMaterialInterface*>             DoubleEyelidMaterials;                             // 0x0BC0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_BD0[0x100];                                    // 0x0BD0(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallOnPredictedLODLevelChanged(class USkinnedMeshComponent* SkinndMeshComponent, int32 NewLODLevel, int32 MaxLODLevel);
	float GetLipSyncBlendWeightScale(EJackFacialControlLayer Layer);
	void OnTalkingSpeedChanged();
	void ResetRandomBlinkRemaingTime();
	void SetBlinkDurationTimeFromCloseToOpen(float Time, EJackFacialControlLayer Layer);
	void SetBlinkDurationTimeFromCloseToOpenEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetBlinkDurationTimeFromOpenToClose(float Time, EJackFacialControlLayer Layer);
	void SetBlinkDurationTimeFromOpenToCloseEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetEmotion(float InEmotion, EJackFacialControlLayer Layer);
	void SetEmotionEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetEyeCloseRate(float Rate, EJackFacialControlLayer Layer);
	void SetEyeCloseRateEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetEyeCurveFromCloseToOpen(EEasingFunc EasingFunc, EJackFacialControlLayer Layer);
	void SetEyeCurveFromCloseToOpenEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetEyeCurveTimeFromOpenToClose(EEasingFunc EasingFunc, EJackFacialControlLayer Layer);
	void SetEyeCurveTimeFromOpenToCloseEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetFacialModeChangeDuration(float InDuration);
	void SetForceClosedEyes(bool bValue, EJackFacialControlLayer Layer);
	void SetForceClosedEyesEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetLastPhraseVowel(EJackVowel InLastPhraseVowel);
	void SetLipSyncBlendTime(float InTime, EJackFacialControlLayer Layer);
	void SetLipSyncBlendTimeEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetLipSyncBlendWeight(float InWeight, EJackFacialControlLayer Layer);
	void SetLipSyncBlendWeightEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetLipSyncBlendWeightScale(float InScale, EJackFacialControlLayer Layer);
	void SetLipSyncBlendWeightScaleEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetLipSyncTime(float InTime);
	void SetLowerFacialAnimState(EJackLowerFacialState NewState, EJackFacialControlLayer Layer);
	void SetLowerFacialAnimStateEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetManualLipSyncModeBlendWeight(float Weight, EJackFacialControlLayer Layer);
	void SetManualLipSyncModeEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetManualLipSyncModeVowelBlendWeight(EJackVowel Vowel, float VowelWeight, EJackFacialControlLayer Layer);
	void SetOverridePhraseVowel(EJackVowel InLastPhraseVowel, EJackFacialControlLayer Layer);
	void SetOverridePhraseVowelEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetRandomBlinkMode(EJackRandomBlinkMode InMode, EJackFacialControlLayer Layer);
	void SetRandomBlinkModeEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetRandomLipSyncMode(EJackRandomLipSyncMode InMode, EJackFacialControlLayer Layer);
	void SetRandomLipSyncModeEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetRandomPhrase();
	void SetSelectedFacePoseChangeDuration(float Value, EJackFacialControlLayer Layer);
	void SetSelectedFacePoseChangeDurationEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetSelectedLowerFacePose(class FName InPoseName, EJackFacialControlLayer Layer, float Weight);
	void SetSelectedLowerFacePoseEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetSelectedUpperFacePose(class FName InPoseName, EJackFacialControlLayer Layer, float Weight);
	void SetSelectedUpperFacePoseEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetTalkingSpeed(float NewTalkingSpeed, EJackFacialControlLayer Layer);
	void SetTalkingSpeedEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetTone(float InTone, EJackFacialControlLayer Layer);
	void SetToneEnable(bool bEnable, EJackFacialControlLayer Layer);
	void SetUpperFacialAnimState(EJackUpperFacialState NewState, EJackFacialControlLayer Layer);
	void SetUpperFacialAnimStateEnable(bool bEnable, EJackFacialControlLayer Layer);

	float GetBlinkDurationTimeFromCloseToOpen() const;
	float GetBlinkDurationTimeFromOpenToClose() const;
	struct FVector GetBlinkPoseEyeOffset() const;
	class UAnimInstance* GetCharacterAnimInstance() const;
	class USkeletalMeshComponent* GetCharacterMesh() const;
	float GetEmotion() const;
	float GetEyeCloseRate() const;
	EEasingFunc GetEyeCurveTimeFromCloseToOpen() const;
	EEasingFunc GetEyeCurveTimeFromOpenToClose() const;
	bool GetFacialAnimCurve(class FName Name_0, struct FJackDataTableFacialAnimCurve* OutCurve) const;
	float GetFacialAnimSequenceFrame(class FName Name_0) const;
	float GetFacialModeChangeDuration() const;
	bool GetForceClosedEyes() const;
	bool GetInterruptFacePoseIndexInCurveNames(EJackFacialAnimCategory InCategory, int32* OutSelectedSequenceIndex, TArray<class FName>* OutCurveNames) const;
	EJackVowel GetLastPhraseVowel() const;
	float GetLeftEyeBlinkPoseWeight() const;
	float GetLipSyncBlendTime() const;
	float GetLipSyncBlendWeight() const;
	float GetLipSyncTime() const;
	void GetLowerBlendInfo(TArray<struct FJackFacialAnimationBlendInfo>* OutBlendInfo) const;
	EJackLowerFacialState GetLowerFacialAnimState() const;
	EJackRandomBlinkMode GetRandomBlinkMode() const;
	EJackRandomLipSyncMode GetRandomLipSyncMode() const;
	float GetRightEyeBlinkPoseWeight() const;
	float GetSelectedFacePoseChangeDuration() const;
	class FName GetSelectedLowerFacePose() const;
	float GetSelectedLowerFacePoseBlendWeight() const;
	class FName GetSelectedLowerFacePoseByLayer(EJackFacialControlLayer Layer) const;
	class FName GetSelectedUpperFacePose() const;
	float GetSelectedUpperFacePoseBlendWeight() const;
	class FName GetSelectedUpperFacePoseByLayer(EJackFacialControlLayer Layer) const;
	float GetTalkingSpeed() const;
	float GetTone() const;
	void GetUpperBlendInfo(TArray<struct FJackFacialAnimationBlendInfo>* OutBlendInfo) const;
	EJackUpperFacialState GetUpperFacialAnimState() const;
	float GetVowelSecondNoteBlendWeight() const;
	bool IsClosedEyes() const;
	bool IsClosedEyesByBlink() const;
	bool IsLowerFacialAnimState(EJackLowerFacialState State) const;
	bool IsOpenedEyesByBlink() const;
	bool IsRandomLipSyncRunning() const;
	bool IsUpperFacialAnimState(EJackUpperFacialState State) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFacialControlComponent">();
	}
	static class UJackFacialControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFacialControlComponent>();
	}
};
static_assert(alignof(UJackFacialControlComponent) == 0x000008, "Wrong alignment on UJackFacialControlComponent");
static_assert(sizeof(UJackFacialControlComponent) == 0x000CD0, "Wrong size on UJackFacialControlComponent");
static_assert(offsetof(UJackFacialControlComponent, FacialModeChangeDuration) == 0x0006F8, "Member 'UJackFacialControlComponent::FacialModeChangeDuration' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, SelectedPoseChangeDuration) == 0x0006FC, "Member 'UJackFacialControlComponent::SelectedPoseChangeDuration' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, SelectedUpperFacePose) == 0x000700, "Member 'UJackFacialControlComponent::SelectedUpperFacePose' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, SelectedLowerFacePose) == 0x000708, "Member 'UJackFacialControlComponent::SelectedLowerFacePose' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, Tone) == 0x000710, "Member 'UJackFacialControlComponent::Tone' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, Emotion) == 0x000714, "Member 'UJackFacialControlComponent::Emotion' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyeControlType) == 0x000718, "Member 'UJackFacialControlComponent::EyeControlType' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyeClosingByBlinkTime) == 0x00071C, "Member 'UJackFacialControlComponent::EyeClosingByBlinkTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyeClosingByBlinkRemainingTime) == 0x000720, "Member 'UJackFacialControlComponent::EyeClosingByBlinkRemainingTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, BlinkDurationTimeFromOpenToClose) == 0x000724, "Member 'UJackFacialControlComponent::BlinkDurationTimeFromOpenToClose' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, BlinkDurationTimeFromCloseToOpen) == 0x000728, "Member 'UJackFacialControlComponent::BlinkDurationTimeFromCloseToOpen' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyeCurveFromCloseToOpen) == 0x00072C, "Member 'UJackFacialControlComponent::EyeCurveFromCloseToOpen' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyeCurveFromOpenToClose) == 0x00072D, "Member 'UJackFacialControlComponent::EyeCurveFromOpenToClose' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomBlinkRemainingTime) == 0x000738, "Member 'UJackFacialControlComponent::RandomBlinkRemainingTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomBlinkTimeRange) == 0x00073C, "Member 'UJackFacialControlComponent::RandomBlinkTimeRange' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomBlinkCurveName) == 0x000748, "Member 'UJackFacialControlComponent::RandomBlinkCurveName' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomBlinkTargetAnim) == 0x000750, "Member 'UJackFacialControlComponent::RandomBlinkTargetAnim' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LastPhraseVowel) == 0x000758, "Member 'UJackFacialControlComponent::LastPhraseVowel' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, TalkingSpeed) == 0x00075C, "Member 'UJackFacialControlComponent::TalkingSpeed' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LipSyncTime) == 0x000760, "Member 'UJackFacialControlComponent::LipSyncTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LipSyncBlendTime) == 0x000764, "Member 'UJackFacialControlComponent::LipSyncBlendTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LipSyncBlendWeight) == 0x000768, "Member 'UJackFacialControlComponent::LipSyncBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LipSyncMasterBlendWeight_UpTime) == 0x00076C, "Member 'UJackFacialControlComponent::LipSyncMasterBlendWeight_UpTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LipSyncMasterBlendWeight_DownTime) == 0x000770, "Member 'UJackFacialControlComponent::LipSyncMasterBlendWeight_DownTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, VowelSettings) == 0x000778, "Member 'UJackFacialControlComponent::VowelSettings' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, VowelElapsedTime) == 0x000880, "Member 'UJackFacialControlComponent::VowelElapsedTime' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, bRandomLipSyncRunning) == 0x000884, "Member 'UJackFacialControlComponent::bRandomLipSyncRunning' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomMouthCurveName) == 0x0008A8, "Member 'UJackFacialControlComponent::RandomMouthCurveName' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomMouthTargetAnim) == 0x0008B0, "Member 'UJackFacialControlComponent::RandomMouthTargetAnim' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, RandomLipSyncMode) == 0x0008B8, "Member 'UJackFacialControlComponent::RandomLipSyncMode' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, FacePoseSequenceDataTable) == 0x0008C0, "Member 'UJackFacialControlComponent::FacePoseSequenceDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, AnimDataTable) == 0x0008C8, "Member 'UJackFacialControlComponent::AnimDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, FadeInEasingFunc) == 0x0008D0, "Member 'UJackFacialControlComponent::FadeInEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, FadeOutEasingFunc) == 0x0008D1, "Member 'UJackFacialControlComponent::FadeOutEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, FaceMaterial) == 0x0008D8, "Member 'UJackFacialControlComponent::FaceMaterial' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, FaceMaterialIndex) == 0x0008E0, "Member 'UJackFacialControlComponent::FaceMaterialIndex' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, MaterialInstanceDynamic) == 0x0008E8, "Member 'UJackFacialControlComponent::MaterialInstanceDynamic' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, MaxBlendCount) == 0x0008F0, "Member 'UJackFacialControlComponent::MaxBlendCount' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, UpperFacialAnimState) == 0x0008F4, "Member 'UJackFacialControlComponent::UpperFacialAnimState' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, LowerFacialAnimState) == 0x0008F5, "Member 'UJackFacialControlComponent::LowerFacialAnimState' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, bUseEyeBallPositionOffset) == 0x0008F6, "Member 'UJackFacialControlComponent::bUseEyeBallPositionOffset' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, BlinkPoseEyeOffset) == 0x0008F8, "Member 'UJackFacialControlComponent::BlinkPoseEyeOffset' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, BlinkFacialPoses) == 0x000900, "Member 'UJackFacialControlComponent::BlinkFacialPoses' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, DefaultFacialPoseName) == 0x0009B0, "Member 'UJackFacialControlComponent::DefaultFacialPoseName' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, CurrentFacialPoseName) == 0x0009B8, "Member 'UJackFacialControlComponent::CurrentFacialPoseName' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, R) == 0x0009C0, "Member 'UJackFacialControlComponent::R' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, UVClampRange) == 0x0009C4, "Member 'UJackFacialControlComponent::UVClampRange' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, bControlEnabled) == 0x000AE0, "Member 'UJackFacialControlComponent::bControlEnabled' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, ControlEnabledMaxLODLevel) == 0x000AE4, "Member 'UJackFacialControlComponent::ControlEnabledMaxLODLevel' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, EyelidLength) == 0x000BB8, "Member 'UJackFacialControlComponent::EyelidLength' has a wrong offset!");
static_assert(offsetof(UJackFacialControlComponent, DoubleEyelidMaterials) == 0x000BC0, "Member 'UJackFacialControlComponent::DoubleEyelidMaterials' has a wrong offset!");

// Class JackGame.JackTokugiPanelUtils
// 0x0000 (0x0038 - 0x0038)
class UJackTokugiPanelUtils final : public UObject
{
public:
	static class UJackUMGTokugiPanelData* FindDataByCursorPos(const TArray<class UJackUMGTokugiPanelData*>& PanelDataList, const struct FVector2D& CursorPos);
	static TArray<int32> GetCrackDirList(const struct FJackUMGTokugiPanelAdjoinData& Data);
	static int32 GetLength(const struct FJackUMGTokugiPanelAdjoinData& Data);
	static void GetMaxNeedCountOfPanelWidget(class UObject* WorldContextObject, int32* PanelWidgetCount, int32* QuestionWidgetCount);
	static struct FVector2D GetNextCursorPosByDir(const struct FVector2D& CursorPos, int32 Direction);
	static TArray<class UJackUMGTokugiPanelData*> GetSelectedSkillLinePanelDataList(const TArray<class UJackUMGTokugiPanelData*>& BaseDataList, EJackSkillLine SkillLineType);
	static class FString GetSkillLineGroupName(const class UObject* WorldContextObject, EJackSkillLine SkillLineType);
	static class FName GetSkillLineGroupTextId(EJackSkillLine SkillLineType);
	static class FString GetSkillLineName(const class UObject* WorldContextObject, EJackSkillLine SkillLineType);
	static class FName GetSkillLineTextId(EJackSkillLine SkillLineType);
	static EJackTokugiPanelAdjoinPieceState GetState(const struct FJackUMGTokugiPanelAdjoinData& Data, int32 Index_0);
	static void GetTokugiPanelScenario(class UObject* WorldContextObject, EJackCharacter CharacterType, bool bSyncLoadTexture, EJackTokugiPanelScenario* TokugiPanelScenario, class UTexture2D** BackgroundTexture, struct FVector2D* PanelPosOffset, struct FVector2D* SkillLineEffectPosOffset, TSoftObjectPtr<class UTexture>* BackgroundTextureAsset);
	static class FString GetWeaponTypeName(const class UObject* WorldContextObject, EJackItem_Classification WeaponType);
	static class FName GetWeaponTypeTextId(EJackItem_Classification WeaponType);
	static bool IsUnlockTokugiPanelCommand(const class UObject* WorldContextObject);
	static EJackSkillLine ToSkillLineType(EJackItem_Classification WeaponType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTokugiPanelUtils">();
	}
	static class UJackTokugiPanelUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTokugiPanelUtils>();
	}
};
static_assert(alignof(UJackTokugiPanelUtils) == 0x000008, "Wrong alignment on UJackTokugiPanelUtils");
static_assert(sizeof(UJackTokugiPanelUtils) == 0x000038, "Wrong size on UJackTokugiPanelUtils");

// Class JackGame.JackMaterialUpdaterLoopedCurve
// 0x0030 (0x0130 - 0x0100)
class UJackMaterialUpdaterLoopedCurve final : public UJackMaterialUpdater
{
public:
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterLoopedCurve">();
	}
	static class UJackMaterialUpdaterLoopedCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterLoopedCurve>();
	}
};
static_assert(alignof(UJackMaterialUpdaterLoopedCurve) == 0x000008, "Wrong alignment on UJackMaterialUpdaterLoopedCurve");
static_assert(sizeof(UJackMaterialUpdaterLoopedCurve) == 0x000130, "Wrong size on UJackMaterialUpdaterLoopedCurve");

// Class JackGame.JackFacialInfo
// 0x0020 (0x0058 - 0x0038)
class UJackFacialInfo final : public UObject
{
public:
	TArray<struct FJackFacialInfo_Eye>            Eye;                                               // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackFacialInfo_Mouth>          Mouth;                                             // 0x0048(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFacialInfo">();
	}
	static class UJackFacialInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFacialInfo>();
	}
};
static_assert(alignof(UJackFacialInfo) == 0x000008, "Wrong alignment on UJackFacialInfo");
static_assert(sizeof(UJackFacialInfo) == 0x000058, "Wrong size on UJackFacialInfo");
static_assert(offsetof(UJackFacialInfo, Eye) == 0x000038, "Member 'UJackFacialInfo::Eye' has a wrong offset!");
static_assert(offsetof(UJackFacialInfo, Mouth) == 0x000048, "Member 'UJackFacialInfo::Mouth' has a wrong offset!");

// Class JackGame.JackMapLocator
// 0x0000 (0x03A0 - 0x03A0)
class AJackMapLocator final : public AJackLocator
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMapLocator">();
	}
	static class AJackMapLocator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMapLocator>();
	}
};
static_assert(alignof(AJackMapLocator) == 0x000008, "Wrong alignment on AJackMapLocator");
static_assert(sizeof(AJackMapLocator) == 0x0003A0, "Wrong size on AJackMapLocator");

// Class JackGame.JackFacialPresetTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackFacialPresetTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFacialPresetTrackInst">();
	}
	static class UJackFacialPresetTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFacialPresetTrackInst>();
	}
};
static_assert(alignof(UJackFacialPresetTrackInst) == 0x000008, "Wrong alignment on UJackFacialPresetTrackInst");
static_assert(sizeof(UJackFacialPresetTrackInst) == 0x000038, "Wrong size on UJackFacialPresetTrackInst");

// Class JackGame.JackFacilityManager
// 0x0038 (0x0070 - 0x0038)
class UJackFacilityManager : public UObject
{
public:
	class UDataTable*                             ShopDataTable;                                     // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             InnDataTable;                                      // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ChurchDataTable;                                   // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             BankDataTable;                                     // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasePrice_Revive;                                  // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasePrice_PoisonTreatment;                         // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasePrice_CurseRelease;                            // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BasePrice_TokugiReset;                             // 0x0064(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetBankDataTable(class FName BankID, struct FJackDataTableBank* OutBankTable) const;
	bool GetChurchDataTable(class FName ChurchId, struct FJackDataTableChurch* OutChurchTable) const;
	bool GetInnDataTable(class FName InnID, struct FJackDataTableInn* OutInnTable) const;
	bool GetShopDataTable(class FName ShopId, struct FJackDataTableShop* OutShopTable) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFacilityManager">();
	}
	static class UJackFacilityManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFacilityManager>();
	}
};
static_assert(alignof(UJackFacilityManager) == 0x000008, "Wrong alignment on UJackFacilityManager");
static_assert(sizeof(UJackFacilityManager) == 0x000070, "Wrong size on UJackFacilityManager");
static_assert(offsetof(UJackFacilityManager, ShopDataTable) == 0x000038, "Member 'UJackFacilityManager::ShopDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, InnDataTable) == 0x000040, "Member 'UJackFacilityManager::InnDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, ChurchDataTable) == 0x000048, "Member 'UJackFacilityManager::ChurchDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, BankDataTable) == 0x000050, "Member 'UJackFacilityManager::BankDataTable' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, BasePrice_Revive) == 0x000058, "Member 'UJackFacilityManager::BasePrice_Revive' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, BasePrice_PoisonTreatment) == 0x00005C, "Member 'UJackFacilityManager::BasePrice_PoisonTreatment' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, BasePrice_CurseRelease) == 0x000060, "Member 'UJackFacilityManager::BasePrice_CurseRelease' has a wrong offset!");
static_assert(offsetof(UJackFacilityManager, BasePrice_TokugiReset) == 0x000064, "Member 'UJackFacilityManager::BasePrice_TokugiReset' has a wrong offset!");

// Class JackGame.JackFieldAttackManager
// 0x0098 (0x00D0 - 0x0038)
class UJackFieldAttackManager : public UObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackCollideEffect>         DamageCollideEffects[0x10];                        // 0x0050(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFieldAttackManager">();
	}
	static class UJackFieldAttackManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFieldAttackManager>();
	}
};
static_assert(alignof(UJackFieldAttackManager) == 0x000008, "Wrong alignment on UJackFieldAttackManager");
static_assert(sizeof(UJackFieldAttackManager) == 0x0000D0, "Wrong size on UJackFieldAttackManager");
static_assert(offsetof(UJackFieldAttackManager, DamageCollideEffects) == 0x000050, "Member 'UJackFieldAttackManager::DamageCollideEffects' has a wrong offset!");

// Class JackGame.JackLocatorAccessComponent
// 0x0080 (0x01A8 - 0x0128)
class UJackLocatorAccessComponent final : public UActorComponent
{
public:
	TArray<struct FJackLocatorCourse>             Courses;                                           // 0x0128(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackLocatorDict>               Locators;                                          // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           ListingTags;                                       // 0x0148(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_158[0x50];                                     // 0x0158(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLocatorAccessComponent">();
	}
	static class UJackLocatorAccessComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLocatorAccessComponent>();
	}
};
static_assert(alignof(UJackLocatorAccessComponent) == 0x000008, "Wrong alignment on UJackLocatorAccessComponent");
static_assert(sizeof(UJackLocatorAccessComponent) == 0x0001A8, "Wrong size on UJackLocatorAccessComponent");
static_assert(offsetof(UJackLocatorAccessComponent, Courses) == 0x000128, "Member 'UJackLocatorAccessComponent::Courses' has a wrong offset!");
static_assert(offsetof(UJackLocatorAccessComponent, Locators) == 0x000138, "Member 'UJackLocatorAccessComponent::Locators' has a wrong offset!");
static_assert(offsetof(UJackLocatorAccessComponent, ListingTags) == 0x000148, "Member 'UJackLocatorAccessComponent::ListingTags' has a wrong offset!");

// Class JackGame.JackFieldPlayerUmaRaceController
// 0x0018 (0x0B40 - 0x0B28)
class AJackFieldPlayerUmaRaceController final : public AJackFieldPlayerController
{
public:
	TWeakObjectPtr<class AJackFieldPlayerController> OriginalPlayerController;                          // 0x0B28(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_B30[0x10];                                     // 0x0B30(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Finalize();
	void Initialize(class AJackPlayableCharacter* PlayableCharacter);
	void OnOpenGiveUpWindowEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFieldPlayerUmaRaceController">();
	}
	static class AJackFieldPlayerUmaRaceController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFieldPlayerUmaRaceController>();
	}
};
static_assert(alignof(AJackFieldPlayerUmaRaceController) == 0x000008, "Wrong alignment on AJackFieldPlayerUmaRaceController");
static_assert(sizeof(AJackFieldPlayerUmaRaceController) == 0x000B40, "Wrong size on AJackFieldPlayerUmaRaceController");
static_assert(offsetof(AJackFieldPlayerUmaRaceController, OriginalPlayerController) == 0x000B28, "Member 'AJackFieldPlayerUmaRaceController::OriginalPlayerController' has a wrong offset!");

// Class JackGame.JackInteractiveActor
// 0x0028 (0x03C0 - 0x0398)
class AJackInteractiveActor : public AActor
{
public:
	bool                                          bNPCReaction;                                      // 0x0398(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNPCAfterMove;                                     // 0x0399(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39A[0x2];                                      // 0x039A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NPCAfterMoveLocation;                              // 0x039C(0x000C)(Edit, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NPCAfterMoveSpeed;                                 // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnReceiveMessage;                                  // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)

public:
	void AddInteractiveActor(class AActor* InActor, class UJackInteractiveActorComponent* InInteractiveActorComponent);
	bool OnEndInteract(class AActor* InActor);
	bool OnInteract(class AActor* InActor);
	void ReceiveMessageDelegate__DelegateSignature(const class FString& Message, class AActor* Sender);
	void RemoveInteractiveActor(class AActor* InActor, class UJackInteractiveActorComponent* InInteractiveActorComponent);

	bool CanInteract() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInteractiveActor">();
	}
	static class AJackInteractiveActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackInteractiveActor>();
	}
};
static_assert(alignof(AJackInteractiveActor) == 0x000008, "Wrong alignment on AJackInteractiveActor");
static_assert(sizeof(AJackInteractiveActor) == 0x0003C0, "Wrong size on AJackInteractiveActor");
static_assert(offsetof(AJackInteractiveActor, bNPCReaction) == 0x000398, "Member 'AJackInteractiveActor::bNPCReaction' has a wrong offset!");
static_assert(offsetof(AJackInteractiveActor, bNPCAfterMove) == 0x000399, "Member 'AJackInteractiveActor::bNPCAfterMove' has a wrong offset!");
static_assert(offsetof(AJackInteractiveActor, NPCAfterMoveLocation) == 0x00039C, "Member 'AJackInteractiveActor::NPCAfterMoveLocation' has a wrong offset!");
static_assert(offsetof(AJackInteractiveActor, NPCAfterMoveSpeed) == 0x0003A8, "Member 'AJackInteractiveActor::NPCAfterMoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackInteractiveActor, OnReceiveMessage) == 0x0003B0, "Member 'AJackInteractiveActor::OnReceiveMessage' has a wrong offset!");

// Class JackGame.JackHaul
// 0x0000 (0x03C0 - 0x03C0)
class AJackHaul final : public AJackInteractiveActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHaul">();
	}
	static class AJackHaul* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackHaul>();
	}
};
static_assert(alignof(AJackHaul) == 0x000008, "Wrong alignment on AJackHaul");
static_assert(sizeof(AJackHaul) == 0x0003C0, "Wrong size on AJackHaul");

// Class JackGame.JackFishPlayerCharacter
// 0x0000 (0x1440 - 0x1440)
class AJackFishPlayerCharacter final : public AJackPlayableCharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFishPlayerCharacter">();
	}
	static class AJackFishPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFishPlayerCharacter>();
	}
};
static_assert(alignof(AJackFishPlayerCharacter) == 0x000010, "Wrong alignment on AJackFishPlayerCharacter");
static_assert(sizeof(AJackFishPlayerCharacter) == 0x001440, "Wrong size on AJackFishPlayerCharacter");

// Class JackGame.JackFloatMaterialParameterTrackInst
// 0x0030 (0x00A0 - 0x0070)
class UJackFloatMaterialParameterTrackInst final : public UInterpTrackInstFloatMaterialParam
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialInstancesToAll;                            // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<float>                                 ResetFloatsToAll;                                  // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimitiveMaterialRef>          PrimitiveMaterialRefsToAll;                        // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFloatMaterialParameterTrackInst">();
	}
	static class UJackFloatMaterialParameterTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFloatMaterialParameterTrackInst>();
	}
};
static_assert(alignof(UJackFloatMaterialParameterTrackInst) == 0x000008, "Wrong alignment on UJackFloatMaterialParameterTrackInst");
static_assert(sizeof(UJackFloatMaterialParameterTrackInst) == 0x0000A0, "Wrong size on UJackFloatMaterialParameterTrackInst");
static_assert(offsetof(UJackFloatMaterialParameterTrackInst, MaterialInstancesToAll) == 0x000070, "Member 'UJackFloatMaterialParameterTrackInst::MaterialInstancesToAll' has a wrong offset!");
static_assert(offsetof(UJackFloatMaterialParameterTrackInst, ResetFloatsToAll) == 0x000080, "Member 'UJackFloatMaterialParameterTrackInst::ResetFloatsToAll' has a wrong offset!");
static_assert(offsetof(UJackFloatMaterialParameterTrackInst, PrimitiveMaterialRefsToAll) == 0x000090, "Member 'UJackFloatMaterialParameterTrackInst::PrimitiveMaterialRefsToAll' has a wrong offset!");

// Class JackGame.JackMapKiraAccessorBase
// 0x0008 (0x0040 - 0x0038)
class UJackMapKiraAccessorBase : public UObject
{
public:
	int32                                         UniqueNo;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CanPickUp() const;
	TArray<class FName> GetCandidateItemIDList() const;
	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	class AActor* GetKiraActor() const;
	class FName GetKiraName() const;
	TArray<EJackMapSymbol> GetTimeZoneIcon() const;
	TArray<EJackMapSymbol> GetWeatherIcon() const;
	bool HasPickedUp() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMapKiraAccessorBase">();
	}
	static class UJackMapKiraAccessorBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMapKiraAccessorBase>();
	}
};
static_assert(alignof(UJackMapKiraAccessorBase) == 0x000008, "Wrong alignment on UJackMapKiraAccessorBase");
static_assert(sizeof(UJackMapKiraAccessorBase) == 0x000040, "Wrong size on UJackMapKiraAccessorBase");
static_assert(offsetof(UJackMapKiraAccessorBase, UniqueNo) == 0x000038, "Member 'UJackMapKiraAccessorBase::UniqueNo' has a wrong offset!");

// Class JackGame.JackMapScheduledKiraAccessor
// 0x0008 (0x0048 - 0x0040)
class UJackMapScheduledKiraAccessor final : public UJackMapKiraAccessorBase
{
public:
	TWeakObjectPtr<class AJackScheduledKira>      KiraActor;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanPickUp() const;
	TArray<class FName> GetCandidateItemIDList() const;
	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	class AActor* GetKiraActor() const;
	class FName GetKiraName() const;
	TArray<EJackMapSymbol> GetTimeZoneIcon() const;
	TArray<EJackMapSymbol> GetWeatherIcon() const;
	bool HasPickedUp() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMapScheduledKiraAccessor">();
	}
	static class UJackMapScheduledKiraAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMapScheduledKiraAccessor>();
	}
};
static_assert(alignof(UJackMapScheduledKiraAccessor) == 0x000008, "Wrong alignment on UJackMapScheduledKiraAccessor");
static_assert(sizeof(UJackMapScheduledKiraAccessor) == 0x000048, "Wrong size on UJackMapScheduledKiraAccessor");
static_assert(offsetof(UJackMapScheduledKiraAccessor, KiraActor) == 0x000040, "Member 'UJackMapScheduledKiraAccessor::KiraActor' has a wrong offset!");

// Class JackGame.JackFootIKComponent
// 0x0300 (0x04A0 - 0x01A0)
class UJackFootIKComponent final : public UJackCharacterComponent
{
public:
	bool                                          bFootIKEnabled;                                    // 0x01A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAdjustHeightEnabled;                              // 0x01A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFitHighestOnAdjuestHeight;                        // 0x01A2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A3[0x1];                                      // 0x01A3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AdjustHeightMin;                                   // 0x01A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustHeightMax;                                   // 0x01A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1AC[0x4];                                      // 0x01AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackFootIKDict>                FootIKs;                                           // 0x01B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         FixMeUpSpeed;                                      // 0x01C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FixMeDownSpeed;                                    // 0x01C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustHeightMoveRateMaxVelocity;                   // 0x01C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IKAlphaMoveRateMaxVelocity;                        // 0x01CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                MeshRootRelativeLocation;                          // 0x01D0(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFourFootIK;                                       // 0x01DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFourFootIKForInterruptIK;                         // 0x01DD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1DE[0x232];                                    // 0x01DE(0x0232)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TraceLocationThreshould;                           // 0x0410(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseHitResultNormal;                               // 0x0414(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_415[0x2];                                      // 0x0415(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bCalcAdjustHeightBlendWeight_ManualSetting;        // 0x0417(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CalcAdjustHeightBlendWeight_MovementSpeedMax;      // 0x0418(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CalcAdjustHeigthBlendWeight_MovementSpeedBlendWeightMax; // 0x041C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   CalcAdjustHeightBlendWeight_MovementSpeedBlendCurve; // 0x0420(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_421[0x3];                                      // 0x0421(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CalcAdjustHeightBlendWeight_GroundDegreeMax;       // 0x0424(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CalcAdjustHeigthBlendWeight_GroundDegreeBlendWeightMax; // 0x0428(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   CalcAdjustHeightBlendWeight_GroundDegreeBlendCurve; // 0x042C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42D[0x5B];                                     // 0x042D(0x005B)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bShowTraceFootIK;                                  // 0x0488(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_489[0x17];                                     // 0x0489(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetRelativeLocationDefault();
	void SetAdjustMeshHeightDisable(bool bDisable, EJackFootIKControlPurpose Purpose);
	void SetAdjustMeshHeightZero(bool bOn);
	void SetFootIKDisable(bool bDisable, EJackFootIKControlPurpose Purpose);

	class USceneComponent* GetMeshRootComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFootIKComponent">();
	}
	static class UJackFootIKComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFootIKComponent>();
	}
};
static_assert(alignof(UJackFootIKComponent) == 0x000008, "Wrong alignment on UJackFootIKComponent");
static_assert(sizeof(UJackFootIKComponent) == 0x0004A0, "Wrong size on UJackFootIKComponent");
static_assert(offsetof(UJackFootIKComponent, bFootIKEnabled) == 0x0001A0, "Member 'UJackFootIKComponent::bFootIKEnabled' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bAdjustHeightEnabled) == 0x0001A1, "Member 'UJackFootIKComponent::bAdjustHeightEnabled' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bFitHighestOnAdjuestHeight) == 0x0001A2, "Member 'UJackFootIKComponent::bFitHighestOnAdjuestHeight' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, AdjustHeightMin) == 0x0001A4, "Member 'UJackFootIKComponent::AdjustHeightMin' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, AdjustHeightMax) == 0x0001A8, "Member 'UJackFootIKComponent::AdjustHeightMax' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, FootIKs) == 0x0001B0, "Member 'UJackFootIKComponent::FootIKs' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, FixMeUpSpeed) == 0x0001C0, "Member 'UJackFootIKComponent::FixMeUpSpeed' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, FixMeDownSpeed) == 0x0001C4, "Member 'UJackFootIKComponent::FixMeDownSpeed' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, AdjustHeightMoveRateMaxVelocity) == 0x0001C8, "Member 'UJackFootIKComponent::AdjustHeightMoveRateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, IKAlphaMoveRateMaxVelocity) == 0x0001CC, "Member 'UJackFootIKComponent::IKAlphaMoveRateMaxVelocity' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, MeshRootRelativeLocation) == 0x0001D0, "Member 'UJackFootIKComponent::MeshRootRelativeLocation' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bFourFootIK) == 0x0001DC, "Member 'UJackFootIKComponent::bFourFootIK' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bFourFootIKForInterruptIK) == 0x0001DD, "Member 'UJackFootIKComponent::bFourFootIKForInterruptIK' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, TraceLocationThreshould) == 0x000410, "Member 'UJackFootIKComponent::TraceLocationThreshould' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bUseHitResultNormal) == 0x000414, "Member 'UJackFootIKComponent::bUseHitResultNormal' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bCalcAdjustHeightBlendWeight_ManualSetting) == 0x000417, "Member 'UJackFootIKComponent::bCalcAdjustHeightBlendWeight_ManualSetting' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeightBlendWeight_MovementSpeedMax) == 0x000418, "Member 'UJackFootIKComponent::CalcAdjustHeightBlendWeight_MovementSpeedMax' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeigthBlendWeight_MovementSpeedBlendWeightMax) == 0x00041C, "Member 'UJackFootIKComponent::CalcAdjustHeigthBlendWeight_MovementSpeedBlendWeightMax' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeightBlendWeight_MovementSpeedBlendCurve) == 0x000420, "Member 'UJackFootIKComponent::CalcAdjustHeightBlendWeight_MovementSpeedBlendCurve' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeightBlendWeight_GroundDegreeMax) == 0x000424, "Member 'UJackFootIKComponent::CalcAdjustHeightBlendWeight_GroundDegreeMax' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeigthBlendWeight_GroundDegreeBlendWeightMax) == 0x000428, "Member 'UJackFootIKComponent::CalcAdjustHeigthBlendWeight_GroundDegreeBlendWeightMax' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, CalcAdjustHeightBlendWeight_GroundDegreeBlendCurve) == 0x00042C, "Member 'UJackFootIKComponent::CalcAdjustHeightBlendWeight_GroundDegreeBlendCurve' has a wrong offset!");
static_assert(offsetof(UJackFootIKComponent, bShowTraceFootIK) == 0x000488, "Member 'UJackFootIKComponent::bShowTraceFootIK' has a wrong offset!");

// Class JackGame.JackInteractiveActorComponent
// 0x02B0 (0x0590 - 0x02E0)
class UJackInteractiveActorComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2E0[0x50];                                     // 0x02E0(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnInteract;                                        // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndInteract;                                     // 0x0340(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropertyChanged;                                 // 0x0350(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInteractionSoundDisable;                          // 0x0360(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSoftObjectPtr<class USoundBase>              InteractionSound;                                  // 0x0368(0x0018)(Edit, BlueprintVisible, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             InteractionSoundConcrete;                          // 0x0380(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bInteractionSound2D;                               // 0x0388(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x7];                                      // 0x0389(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPressButton;                                     // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A0[0x10];                                     // 0x03A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInteractDisable;                                  // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bResponseDisable;                                  // 0x03B1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreTrace;                                      // 0x03B2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreOwnerWhenTrace;                             // 0x03B3(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bPauseWithAllComponentsDefault;                    // 0x03B4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B5[0x1];                                      // 0x03B5(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bInteractDisableWhenInteractorBasedOnOwnerActor;   // 0x03B6(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B7[0x1];                                      // 0x03B7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackInteractor>                       AllowInteractorTypes;                              // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EJackInteractor>                       DenyInteractorTypes;                               // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	bool                                          bNPCReaction;                                      // 0x03D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bNPCAfterMove;                                     // 0x03D9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DA[0x2];                                      // 0x03DA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                NPCAfterMoveLocation;                              // 0x03DC(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NPCAfterMoveSpeed;                                 // 0x03E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimpleCylinderRadius;                              // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SimpleCylinderHalfHeight;                          // 0x03F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0xC];                                      // 0x03F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   DisplayUISocketName;                               // 0x0400(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayUIFukidasiSocketName;                       // 0x0408(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayUINamePlateSocketName;                      // 0x0410(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   DisplayUIEmotionSocketName;                        // 0x0418(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HiddenCheckSocketName;                             // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HiddenCheckRadius;                                 // 0x0428(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateUIDisplayLocationRadius;                     // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         UpdateUIDisplayLocationSpeed;                      // 0x0430(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                UIDisplayLocationOffsetInComponentSpace;           // 0x0434(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_440[0x78];                                     // 0x0440(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	EJackActionCursor                             ActionCursorType;                                  // 0x04B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackActionGuide                              ActionGuideType;                                   // 0x04B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bControlActionGuideVisibility;                     // 0x04BA(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BB[0xC5];                                     // 0x04BB(0x00C5)(Fixing Size After Last Property [ Dumper-7 ])
	class AVolume*                                ActionGuideVolume;                                 // 0x0580(0x0008)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowUsingInpasu;                                 // 0x0588(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bAllowUsingMovementRootMotion;                     // 0x0589(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58A[0x6];                                      // 0x058A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionGuideVolume_OnBeginOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void ActionGuideVolume_OnEndOverlap(class AActor* OverlappedActor, class AActor* OtherActor);
	void CompleteInteraction();
	void ComponentEndInteractSignature__DelegateSignature(class AActor* OtherActor);
	void ComponentInteractInputSignature__DelegateSignature(EJackKeys Key);
	void ComponentInteractSignature__DelegateSignature(class AActor* OtherActor);
	void ComponentPropertyChangedSignature__DelegateSignature();
	bool EndInteract();
	void SetActionCursorVisibliltyWhileInteraction(bool bNewVisibility);
	void SetInteractDisable(bool bDisable);
	void SetPauseWithAllComponents(bool bPause);
	void SetResponseDisable(bool bDisable);

	bool CanInteract() const;
	class UJackInteractorComponent* GetInteractorComponent() const;
	bool HasActionGuideVolume() const;
	bool IsAllowUsingInpasu() const;
	bool IsInInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInteractiveActorComponent">();
	}
	static class UJackInteractiveActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInteractiveActorComponent>();
	}
};
static_assert(alignof(UJackInteractiveActorComponent) == 0x000008, "Wrong alignment on UJackInteractiveActorComponent");
static_assert(sizeof(UJackInteractiveActorComponent) == 0x000590, "Wrong size on UJackInteractiveActorComponent");
static_assert(offsetof(UJackInteractiveActorComponent, OnInteract) == 0x000330, "Member 'UJackInteractiveActorComponent::OnInteract' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, OnEndInteract) == 0x000340, "Member 'UJackInteractiveActorComponent::OnEndInteract' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, OnPropertyChanged) == 0x000350, "Member 'UJackInteractiveActorComponent::OnPropertyChanged' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bInteractionSoundDisable) == 0x000360, "Member 'UJackInteractiveActorComponent::bInteractionSoundDisable' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, InteractionSound) == 0x000368, "Member 'UJackInteractiveActorComponent::InteractionSound' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, InteractionSoundConcrete) == 0x000380, "Member 'UJackInteractiveActorComponent::InteractionSoundConcrete' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bInteractionSound2D) == 0x000388, "Member 'UJackInteractiveActorComponent::bInteractionSound2D' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, OnPressButton) == 0x000390, "Member 'UJackInteractiveActorComponent::OnPressButton' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bInteractDisable) == 0x0003B0, "Member 'UJackInteractiveActorComponent::bInteractDisable' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bResponseDisable) == 0x0003B1, "Member 'UJackInteractiveActorComponent::bResponseDisable' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bIgnoreTrace) == 0x0003B2, "Member 'UJackInteractiveActorComponent::bIgnoreTrace' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bIgnoreOwnerWhenTrace) == 0x0003B3, "Member 'UJackInteractiveActorComponent::bIgnoreOwnerWhenTrace' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bPauseWithAllComponentsDefault) == 0x0003B4, "Member 'UJackInteractiveActorComponent::bPauseWithAllComponentsDefault' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bInteractDisableWhenInteractorBasedOnOwnerActor) == 0x0003B6, "Member 'UJackInteractiveActorComponent::bInteractDisableWhenInteractorBasedOnOwnerActor' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, AllowInteractorTypes) == 0x0003B8, "Member 'UJackInteractiveActorComponent::AllowInteractorTypes' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, DenyInteractorTypes) == 0x0003C8, "Member 'UJackInteractiveActorComponent::DenyInteractorTypes' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bNPCReaction) == 0x0003D8, "Member 'UJackInteractiveActorComponent::bNPCReaction' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bNPCAfterMove) == 0x0003D9, "Member 'UJackInteractiveActorComponent::bNPCAfterMove' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, NPCAfterMoveLocation) == 0x0003DC, "Member 'UJackInteractiveActorComponent::NPCAfterMoveLocation' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, NPCAfterMoveSpeed) == 0x0003E8, "Member 'UJackInteractiveActorComponent::NPCAfterMoveSpeed' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, SimpleCylinderRadius) == 0x0003EC, "Member 'UJackInteractiveActorComponent::SimpleCylinderRadius' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, SimpleCylinderHalfHeight) == 0x0003F0, "Member 'UJackInteractiveActorComponent::SimpleCylinderHalfHeight' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, DisplayUISocketName) == 0x000400, "Member 'UJackInteractiveActorComponent::DisplayUISocketName' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, DisplayUIFukidasiSocketName) == 0x000408, "Member 'UJackInteractiveActorComponent::DisplayUIFukidasiSocketName' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, DisplayUINamePlateSocketName) == 0x000410, "Member 'UJackInteractiveActorComponent::DisplayUINamePlateSocketName' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, DisplayUIEmotionSocketName) == 0x000418, "Member 'UJackInteractiveActorComponent::DisplayUIEmotionSocketName' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, HiddenCheckSocketName) == 0x000420, "Member 'UJackInteractiveActorComponent::HiddenCheckSocketName' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, HiddenCheckRadius) == 0x000428, "Member 'UJackInteractiveActorComponent::HiddenCheckRadius' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, UpdateUIDisplayLocationRadius) == 0x00042C, "Member 'UJackInteractiveActorComponent::UpdateUIDisplayLocationRadius' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, UpdateUIDisplayLocationSpeed) == 0x000430, "Member 'UJackInteractiveActorComponent::UpdateUIDisplayLocationSpeed' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, UIDisplayLocationOffsetInComponentSpace) == 0x000434, "Member 'UJackInteractiveActorComponent::UIDisplayLocationOffsetInComponentSpace' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, ActionCursorType) == 0x0004B8, "Member 'UJackInteractiveActorComponent::ActionCursorType' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, ActionGuideType) == 0x0004B9, "Member 'UJackInteractiveActorComponent::ActionGuideType' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bControlActionGuideVisibility) == 0x0004BA, "Member 'UJackInteractiveActorComponent::bControlActionGuideVisibility' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, ActionGuideVolume) == 0x000580, "Member 'UJackInteractiveActorComponent::ActionGuideVolume' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bAllowUsingInpasu) == 0x000588, "Member 'UJackInteractiveActorComponent::bAllowUsingInpasu' has a wrong offset!");
static_assert(offsetof(UJackInteractiveActorComponent, bAllowUsingMovementRootMotion) == 0x000589, "Member 'UJackInteractiveActorComponent::bAllowUsingMovementRootMotion' has a wrong offset!");

// Class JackGame.JackFootSoundTrack
// 0x0020 (0x00B0 - 0x0090)
class UJackFootSoundTrack final : public UInterpTrack
{
public:
	TArray<struct FJackFootSoundTrackKey>         KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   AttachGroupName;                                   // 0x00A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayOnMASTS;                                      // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFootSoundTrack">();
	}
	static class UJackFootSoundTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFootSoundTrack>();
	}
};
static_assert(alignof(UJackFootSoundTrack) == 0x000008, "Wrong alignment on UJackFootSoundTrack");
static_assert(sizeof(UJackFootSoundTrack) == 0x0000B0, "Wrong size on UJackFootSoundTrack");
static_assert(offsetof(UJackFootSoundTrack, KeyArray) == 0x000090, "Member 'UJackFootSoundTrack::KeyArray' has a wrong offset!");
static_assert(offsetof(UJackFootSoundTrack, AttachGroupName) == 0x0000A0, "Member 'UJackFootSoundTrack::AttachGroupName' has a wrong offset!");
static_assert(offsetof(UJackFootSoundTrack, bPlayOnMASTS) == 0x0000A8, "Member 'UJackFootSoundTrack::bPlayOnMASTS' has a wrong offset!");

// Class JackGame.JackMatineeAnimationCharacter
// 0x0020 (0x07D0 - 0x07B0)
class AJackMatineeAnimationCharacter final : public ACharacter
{
public:
	uint8                                         Pad_7B0[0x8];                                      // 0x07B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMatineeControlComponent*           MatineeControlComponent;                           // 0x07B8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   AutoAttachSocketName;                              // 0x07C0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UCameraComponent>        TargetCamera;                                      // 0x07C8(0x0008)(Edit, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeAnimationCharacter">();
	}
	static class AJackMatineeAnimationCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMatineeAnimationCharacter>();
	}
};
static_assert(alignof(AJackMatineeAnimationCharacter) == 0x000010, "Wrong alignment on AJackMatineeAnimationCharacter");
static_assert(sizeof(AJackMatineeAnimationCharacter) == 0x0007D0, "Wrong size on AJackMatineeAnimationCharacter");
static_assert(offsetof(AJackMatineeAnimationCharacter, MatineeControlComponent) == 0x0007B8, "Member 'AJackMatineeAnimationCharacter::MatineeControlComponent' has a wrong offset!");
static_assert(offsetof(AJackMatineeAnimationCharacter, AutoAttachSocketName) == 0x0007C0, "Member 'AJackMatineeAnimationCharacter::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(AJackMatineeAnimationCharacter, TargetCamera) == 0x0007C8, "Member 'AJackMatineeAnimationCharacter::TargetCamera' has a wrong offset!");

// Class JackGame.JackForcedLODForParticleTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackForcedLODForParticleTrack final : public UInterpTrackFloatBase
{
public:
	class FName                                   TargetActorTag;                                    // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForcedLODForParticleTrack">();
	}
	static class UJackForcedLODForParticleTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForcedLODForParticleTrack>();
	}
};
static_assert(alignof(UJackForcedLODForParticleTrack) == 0x000008, "Wrong alignment on UJackForcedLODForParticleTrack");
static_assert(sizeof(UJackForcedLODForParticleTrack) == 0x0000B8, "Wrong size on UJackForcedLODForParticleTrack");
static_assert(offsetof(UJackForcedLODForParticleTrack, TargetActorTag) == 0x0000B0, "Member 'UJackForcedLODForParticleTrack::TargetActorTag' has a wrong offset!");

// Class JackGame.JackForcedLODTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackForcedLODTrack final : public UInterpTrackFloatBase
{
public:
	bool                                          bApplyToChildren;                                  // 0x00B0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForcedLODTrack">();
	}
	static class UJackForcedLODTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForcedLODTrack>();
	}
};
static_assert(alignof(UJackForcedLODTrack) == 0x000008, "Wrong alignment on UJackForcedLODTrack");
static_assert(sizeof(UJackForcedLODTrack) == 0x0000B8, "Wrong size on UJackForcedLODTrack");
static_assert(offsetof(UJackForcedLODTrack, bApplyToChildren) == 0x0000B0, "Member 'UJackForcedLODTrack::bApplyToChildren' has a wrong offset!");

// Class JackGame.JackForcedLODTrackInst
// 0x0018 (0x0050 - 0x0038)
class UJackForcedLODTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForcedLODTrackInst">();
	}
	static class UJackForcedLODTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForcedLODTrackInst>();
	}
};
static_assert(alignof(UJackForcedLODTrackInst) == 0x000008, "Wrong alignment on UJackForcedLODTrackInst");
static_assert(sizeof(UJackForcedLODTrackInst) == 0x000050, "Wrong size on UJackForcedLODTrackInst");

// Class JackGame.JackMaterialCoordinatorComponent
// 0x0090 (0x0230 - 0x01A0)
class UJackMaterialCoordinatorComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x10];                                     // 0x01A0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackMaterialCoordinateInfo>    MaterialCoordinateInfos;                           // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x70];                                     // 0x01C0(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearMaterialCoordinate();
	void ClearTemporaryMaterialCoordinate();
	void SetMaterialCoordinate(const struct FJackLDT_MaterialCoordinateType& Type);
	void SetMaterialCoordinateApplyRate(float ApplyRate);
	void SetTemporaryMaterialCoordinate(const struct FJackLDT_TemporaryMaterialCoordinate& NewTemporaryMaterialCoordinate);
	void SetTemporaryMaterialCoordinateApplyRate(float ApplyRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialCoordinatorComponent">();
	}
	static class UJackMaterialCoordinatorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialCoordinatorComponent>();
	}
};
static_assert(alignof(UJackMaterialCoordinatorComponent) == 0x000008, "Wrong alignment on UJackMaterialCoordinatorComponent");
static_assert(sizeof(UJackMaterialCoordinatorComponent) == 0x000230, "Wrong size on UJackMaterialCoordinatorComponent");
static_assert(offsetof(UJackMaterialCoordinatorComponent, MaterialCoordinateInfos) == 0x0001B0, "Member 'UJackMaterialCoordinatorComponent::MaterialCoordinateInfos' has a wrong offset!");

// Class JackGame.JackForceLoadReductionDisableForOuterNPCTrack
// 0x0010 (0x00B8 - 0x00A8)
class UJackForceLoadReductionDisableForOuterNPCTrack final : public UJackToggleBaseTrack
{
public:
	TArray<class FName>                           TargetNPCList;                                     // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForceLoadReductionDisableForOuterNPCTrack">();
	}
	static class UJackForceLoadReductionDisableForOuterNPCTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForceLoadReductionDisableForOuterNPCTrack>();
	}
};
static_assert(alignof(UJackForceLoadReductionDisableForOuterNPCTrack) == 0x000008, "Wrong alignment on UJackForceLoadReductionDisableForOuterNPCTrack");
static_assert(sizeof(UJackForceLoadReductionDisableForOuterNPCTrack) == 0x0000B8, "Wrong size on UJackForceLoadReductionDisableForOuterNPCTrack");
static_assert(offsetof(UJackForceLoadReductionDisableForOuterNPCTrack, TargetNPCList) == 0x0000A8, "Member 'UJackForceLoadReductionDisableForOuterNPCTrack::TargetNPCList' has a wrong offset!");

// Class JackGame.JackForceUpdateAnimationInMatineeTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackForceUpdateAnimationInMatineeTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackForceUpdateAnimationInMatineeTrack">();
	}
	static class UJackForceUpdateAnimationInMatineeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackForceUpdateAnimationInMatineeTrack>();
	}
};
static_assert(alignof(UJackForceUpdateAnimationInMatineeTrack) == 0x000008, "Wrong alignment on UJackForceUpdateAnimationInMatineeTrack");
static_assert(sizeof(UJackForceUpdateAnimationInMatineeTrack) == 0x0000A8, "Wrong size on UJackForceUpdateAnimationInMatineeTrack");

// Class JackGame.JackMeosiSlotGameMain
// 0x0058 (0x03F0 - 0x0398)
class AJackMeosiSlotGameMain final : public AActor
{
public:
	class UJackMeosiSlotState*                    MeosiSlotState;                                    // 0x0398(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackMeosiSlotReels*                    MeosiSlotReels;                                    // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugEnabled;                                   // 0x03A8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugAutoPlayEnabled;                           // 0x03A9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsDebugDrawEnabled;                               // 0x03AA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMeosiSlotDebugDraw                       DebugDrawType;                                     // 0x03AB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DebugAutoPlayInterval;                             // 0x03AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x18];                                     // 0x03B0(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMeosiSlotSoundManager*             SoundManager;                                      // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyEndSaveData();
	int32 BetCoin();
	int32 FluctuateCoin(int32 InGain);
	class UJackMeosiSlotSoundManager* GetSoundManager();
	void InitializeReelParam(const struct FJackMeosiSlotReelInitialParam& InParam);
	void InitializeReelReference(class AJackMeosiSlotReels* InReels);
	void InitializeStateParam(const struct FJackMeosiSlotStateInitialParam& InParam);
	bool IsMamonoCasino();
	int32 PayBackBetCoin();
	void RequestClosedNumTotalGame();
	bool RequireReelBrake(EJackMeosiSlotReel InReelIndex);
	bool RequireReelRevolvingStart();
	void ResetAutoPlay();
	void SetAutoPlay();
	void UpdateAutoPlayKeyPressRepeatedly(float DeltaSeconds, const struct FKey& Key);
	void UpdateDebugKeyPressRepeatedly(float DeltaSeconds, const struct FKey& Key);
	struct FJackMeosiSlotGameResult UpdateGameResult();
	void UpdateLeverOn();
	void UpdateState();

	bool IsAutoPlay() const;
	bool IsMessageWindowClosed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotGameMain">();
	}
	static class AJackMeosiSlotGameMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMeosiSlotGameMain>();
	}
};
static_assert(alignof(AJackMeosiSlotGameMain) == 0x000008, "Wrong alignment on AJackMeosiSlotGameMain");
static_assert(sizeof(AJackMeosiSlotGameMain) == 0x0003F0, "Wrong size on AJackMeosiSlotGameMain");
static_assert(offsetof(AJackMeosiSlotGameMain, MeosiSlotState) == 0x000398, "Member 'AJackMeosiSlotGameMain::MeosiSlotState' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, MeosiSlotReels) == 0x0003A0, "Member 'AJackMeosiSlotGameMain::MeosiSlotReels' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, bIsDebugEnabled) == 0x0003A8, "Member 'AJackMeosiSlotGameMain::bIsDebugEnabled' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, bIsDebugAutoPlayEnabled) == 0x0003A9, "Member 'AJackMeosiSlotGameMain::bIsDebugAutoPlayEnabled' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, bIsDebugDrawEnabled) == 0x0003AA, "Member 'AJackMeosiSlotGameMain::bIsDebugDrawEnabled' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, DebugDrawType) == 0x0003AB, "Member 'AJackMeosiSlotGameMain::DebugDrawType' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, DebugAutoPlayInterval) == 0x0003AC, "Member 'AJackMeosiSlotGameMain::DebugAutoPlayInterval' has a wrong offset!");
static_assert(offsetof(AJackMeosiSlotGameMain, SoundManager) == 0x0003C8, "Member 'AJackMeosiSlotGameMain::SoundManager' has a wrong offset!");

// Class JackGame.JackMatineePreviewActor
// 0x0020 (0x03B8 - 0x0398)
class AJackMatineePreviewActor final : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCapsuleComponent*                      RootCapsuleComponent;                              // 0x03A0(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshComponent*                 SkeletalMeshComponent;                             // 0x03A8(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineePreviewActor">();
	}
	static class AJackMatineePreviewActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMatineePreviewActor>();
	}
};
static_assert(alignof(AJackMatineePreviewActor) == 0x000008, "Wrong alignment on AJackMatineePreviewActor");
static_assert(sizeof(AJackMatineePreviewActor) == 0x0003B8, "Wrong size on AJackMatineePreviewActor");
static_assert(offsetof(AJackMatineePreviewActor, RootCapsuleComponent) == 0x0003A0, "Member 'AJackMatineePreviewActor::RootCapsuleComponent' has a wrong offset!");
static_assert(offsetof(AJackMatineePreviewActor, SkeletalMeshComponent) == 0x0003A8, "Member 'AJackMatineePreviewActor::SkeletalMeshComponent' has a wrong offset!");

// Class JackGame.JackFPSCameraData
// 0x0058 (0x0098 - 0x0040)
class UJackFPSCameraData : public UJackCameraData
{
public:
	struct FVector                                CameraStartOffset;                                 // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotationMax;                                 // 0x004C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotationMin;                                 // 0x0058(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MoveLimitRadiusXY;                                 // 0x0064(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLimitZMax;                                     // 0x0068(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveLimitZMin;                                     // 0x006C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveCameraSpeed;                                   // 0x0070(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CameraCollideRadius;                               // 0x0074(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             CameraCollisionChannel;                            // 0x0078(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxZoomFov;                                        // 0x007C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinZoomFov;                                        // 0x0080(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomMaxSpeed;                                      // 0x0084(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomMinSpeed;                                      // 0x0088(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomUpSpeedRate;                                   // 0x008C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoomDownSpeedRate;                                 // 0x0090(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFPSCameraData">();
	}
	static class UJackFPSCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFPSCameraData>();
	}
};
static_assert(alignof(UJackFPSCameraData) == 0x000008, "Wrong alignment on UJackFPSCameraData");
static_assert(sizeof(UJackFPSCameraData) == 0x000098, "Wrong size on UJackFPSCameraData");
static_assert(offsetof(UJackFPSCameraData, CameraStartOffset) == 0x000040, "Member 'UJackFPSCameraData::CameraStartOffset' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, CameraRotationMax) == 0x00004C, "Member 'UJackFPSCameraData::CameraRotationMax' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, CameraRotationMin) == 0x000058, "Member 'UJackFPSCameraData::CameraRotationMin' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MoveLimitRadiusXY) == 0x000064, "Member 'UJackFPSCameraData::MoveLimitRadiusXY' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MoveLimitZMax) == 0x000068, "Member 'UJackFPSCameraData::MoveLimitZMax' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MoveLimitZMin) == 0x00006C, "Member 'UJackFPSCameraData::MoveLimitZMin' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MoveCameraSpeed) == 0x000070, "Member 'UJackFPSCameraData::MoveCameraSpeed' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, CameraCollideRadius) == 0x000074, "Member 'UJackFPSCameraData::CameraCollideRadius' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, CameraCollisionChannel) == 0x000078, "Member 'UJackFPSCameraData::CameraCollisionChannel' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MaxZoomFov) == 0x00007C, "Member 'UJackFPSCameraData::MaxZoomFov' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, MinZoomFov) == 0x000080, "Member 'UJackFPSCameraData::MinZoomFov' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, ZoomMaxSpeed) == 0x000084, "Member 'UJackFPSCameraData::ZoomMaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, ZoomMinSpeed) == 0x000088, "Member 'UJackFPSCameraData::ZoomMinSpeed' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, ZoomUpSpeedRate) == 0x00008C, "Member 'UJackFPSCameraData::ZoomUpSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackFPSCameraData, ZoomDownSpeedRate) == 0x000090, "Member 'UJackFPSCameraData::ZoomDownSpeedRate' has a wrong offset!");

// Class JackGame.JackFriendAnimationSMComponent
// 0x0010 (0x01B0 - 0x01A0)
class UJackFriendAnimationSMComponent final : public UJackCharacterComponent
{
public:
	class UJackFriendAnimationStateMachine*       StateMachine;                                      // 0x01A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UClass*                                 StateMachineClass;                                 // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendAnimationSMComponent">();
	}
	static class UJackFriendAnimationSMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFriendAnimationSMComponent>();
	}
};
static_assert(alignof(UJackFriendAnimationSMComponent) == 0x000008, "Wrong alignment on UJackFriendAnimationSMComponent");
static_assert(sizeof(UJackFriendAnimationSMComponent) == 0x0001B0, "Wrong size on UJackFriendAnimationSMComponent");
static_assert(offsetof(UJackFriendAnimationSMComponent, StateMachine) == 0x0001A0, "Member 'UJackFriendAnimationSMComponent::StateMachine' has a wrong offset!");
static_assert(offsetof(UJackFriendAnimationSMComponent, StateMachineClass) == 0x0001A8, "Member 'UJackFriendAnimationSMComponent::StateMachineClass' has a wrong offset!");

// Class JackGame.JackMeosiSlotMonsterDataManager
// 0x0018 (0x0050 - 0x0038)
class UJackMeosiSlotMonsterDataManager final : public UObject
{
public:
	TArray<struct FJackMeosiSlotMonsterTexture>   MonsterTextures;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotMonsterDataManager">();
	}
	static class UJackMeosiSlotMonsterDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotMonsterDataManager>();
	}
};
static_assert(alignof(UJackMeosiSlotMonsterDataManager) == 0x000008, "Wrong alignment on UJackMeosiSlotMonsterDataManager");
static_assert(sizeof(UJackMeosiSlotMonsterDataManager) == 0x000050, "Wrong size on UJackMeosiSlotMonsterDataManager");
static_assert(offsetof(UJackMeosiSlotMonsterDataManager, MonsterTextures) == 0x000038, "Member 'UJackMeosiSlotMonsterDataManager::MonsterTextures' has a wrong offset!");

// Class JackGame.JackFriendCharacter
// 0x0090 (0x14D0 - 0x1440)
class AJackFriendCharacter final : public AJackPlayableCharacter
{
public:
	class UJackBattleAIComponent*                 BattleAIComponent;                                 // 0x1438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackEquipmentControlComponent*         EquipmentControlComponent;                         // 0x1440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLookAtComponent*                   LookAtComponent;                                   // 0x1448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFriendAnimationSMComponent*        AnimSMComponent;                                   // 0x1450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackCharacter                                CharacterType;                                     // 0x1458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1459[0x7];                                     // 0x1459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   FieldProp;                                         // 0x1460(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1468[0x68];                                    // 0x1468(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinalizePartyTalkControl();
	void InitializePartyTalkControl(class AActor* SayActor, const struct FJackPartyTalkDescription& InDescription);

	struct FJackPartyTalkDescription GetPartyTalkDescription() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFriendCharacter">();
	}
	static class AJackFriendCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFriendCharacter>();
	}
};
static_assert(alignof(AJackFriendCharacter) == 0x000010, "Wrong alignment on AJackFriendCharacter");
static_assert(sizeof(AJackFriendCharacter) == 0x0014D0, "Wrong size on AJackFriendCharacter");
static_assert(offsetof(AJackFriendCharacter, BattleAIComponent) == 0x001438, "Member 'AJackFriendCharacter::BattleAIComponent' has a wrong offset!");
static_assert(offsetof(AJackFriendCharacter, EquipmentControlComponent) == 0x001440, "Member 'AJackFriendCharacter::EquipmentControlComponent' has a wrong offset!");
static_assert(offsetof(AJackFriendCharacter, LookAtComponent) == 0x001448, "Member 'AJackFriendCharacter::LookAtComponent' has a wrong offset!");
static_assert(offsetof(AJackFriendCharacter, AnimSMComponent) == 0x001450, "Member 'AJackFriendCharacter::AnimSMComponent' has a wrong offset!");
static_assert(offsetof(AJackFriendCharacter, CharacterType) == 0x001458, "Member 'AJackFriendCharacter::CharacterType' has a wrong offset!");
static_assert(offsetof(AJackFriendCharacter, FieldProp) == 0x001460, "Member 'AJackFriendCharacter::FieldProp' has a wrong offset!");

// Class JackGame.JackReelUnit
// 0x0010 (0x0048 - 0x0038)
class UJackReelUnit : public UObject
{
public:
	TArray<class UJackReelController*>            ReelControllers;                                   // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackReelUnit">();
	}
	static class UJackReelUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackReelUnit>();
	}
};
static_assert(alignof(UJackReelUnit) == 0x000008, "Wrong alignment on UJackReelUnit");
static_assert(sizeof(UJackReelUnit) == 0x000048, "Wrong size on UJackReelUnit");
static_assert(offsetof(UJackReelUnit, ReelControllers) == 0x000038, "Member 'UJackReelUnit::ReelControllers' has a wrong offset!");

// Class JackGame.JackFukidasiComponent
// 0x0020 (0x01C0 - 0x01A0)
class UJackFukidasiComponent final : public UJackCharacterComponent
{
public:
	class FName                                   FukidasiSocketName;                                // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   HeadSocketName;                                    // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HeadRadius;                                        // 0x01B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B4[0xC];                                      // 0x01B4(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFukidasiComponent">();
	}
	static class UJackFukidasiComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFukidasiComponent>();
	}
};
static_assert(alignof(UJackFukidasiComponent) == 0x000008, "Wrong alignment on UJackFukidasiComponent");
static_assert(sizeof(UJackFukidasiComponent) == 0x0001C0, "Wrong size on UJackFukidasiComponent");
static_assert(offsetof(UJackFukidasiComponent, FukidasiSocketName) == 0x0001A0, "Member 'UJackFukidasiComponent::FukidasiSocketName' has a wrong offset!");
static_assert(offsetof(UJackFukidasiComponent, HeadSocketName) == 0x0001A8, "Member 'UJackFukidasiComponent::HeadSocketName' has a wrong offset!");
static_assert(offsetof(UJackFukidasiComponent, HeadRadius) == 0x0001B0, "Member 'UJackFukidasiComponent::HeadRadius' has a wrong offset!");

// Class JackGame.JackMeosiSlotState
// 0x07A0 (0x07D8 - 0x0038)
class UJackMeosiSlotState final : public UObject
{
public:
	uint8                                         Pad_38[0x6BC];                                     // 0x0038(0x06BC)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDebugHsHandEnabled;                             // 0x06F4(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotHsHand                          DebugSlotHsHand;                                   // 0x06F5(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugInternalProbabilityStatusEnabled;          // 0x06F6(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotInternalProbabilityStatus       DebugInternalProbabilityStatus;                    // 0x06F7(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugLatentEnabled;                             // 0x06F8(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDirectImpact;                                // 0x06F9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6FA[0x2];                                      // 0x06FA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugLatentPeriod;                                 // 0x06FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugBonusRising;                                  // 0x0700(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugBonusGoldSevens;                              // 0x0704(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugBonusBack;                                    // 0x0708(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugChanceCutinStepUpColor_Default;               // 0x070C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugChanceCutinStepUpColor_Left;                  // 0x0710(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugChanceCutinStepUpColor_Center;                // 0x0714(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugChanceCutinStepUpColor_Right;                 // 0x0718(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugMonsterEncounterEnabled;                   // 0x071C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71D[0x3];                                      // 0x071D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugMonsterIndex;                                 // 0x0720(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugTreasureBoxAppearanceEnabled;              // 0x0724(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_725[0x1];                                      // 0x0725(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsDebugRecruitEnabled;                            // 0x0726(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugRecruit;                                     // 0x0727(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugYakumonoFlashEnabled;                      // 0x0728(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugYakumonoFlash;                               // 0x0729(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugDrakeeEffectEnabled;                       // 0x072A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotDrakeeEffect                    DebugDrakeeEffect1;                                // 0x072B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotDrakeeEffect                    DebugDrakeeEffect2;                                // 0x072C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotDrakeeEffect                    DebugDrakeeEffect3;                                // 0x072D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotDrakeeColor                     DebugDrakeeColor;                                  // 0x072E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72F[0x1];                                      // 0x072F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugShimofuriBackGround;                          // 0x0730(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         bIsDebugShimofuriChanceSuper;                      // 0x0734(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugShimofuriChanceSuccess;                    // 0x0738(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugShimofuriChanceBound;                      // 0x0739(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugShimofuriChanceColorRed;                   // 0x073A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugEffectEnabled;                             // 0x073B(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotEffect                          DebugEffect;                                       // 0x073C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugReelLightOffTimes1;                           // 0x073D(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugReelLightOffTimes2;                           // 0x073E(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugReelLightOffTimes3;                           // 0x073F(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMeosiSlotFireLampColor                   DebugFireLampColor;                                // 0x0740(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DebugFireLampLargeSize;                            // 0x0741(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugReelSEEnabled;                             // 0x0742(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_743[0x1];                                      // 0x0743(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackMeosiSlotSoundEffect              DebugReelStartSE;                                  // 0x0744(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackMeosiSlotSoundEffect              DebugReelStopSE1;                                  // 0x074C(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackMeosiSlotSoundEffect              DebugReelStopSE2;                                  // 0x0754(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackMeosiSlotSoundEffect              DebugReelStopSE3;                                  // 0x075C(0x0008)(BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsDebugAssistEnabled;                             // 0x0764(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugAssist;                                    // 0x0765(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugStockClear;                                // 0x0766(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugMamonoCasino;                              // 0x0767(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugNumOrb;                                    // 0x0768(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugPamph;                                     // 0x0769(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_76A[0x2];                                      // 0x076A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugExtraMode;                                    // 0x076C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleProntoEnabled;                   // 0x0770(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleWinningFixEnabled;               // 0x0771(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleWinningIchigeki;                 // 0x0772(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_773[0x1];                                      // 0x0773(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugBossMonster;                                  // 0x0774(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugComebackType;                                 // 0x0778(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBonusGameNum;                              // 0x077C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_77D[0x3];                                      // 0x077D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugBonusGameNum;                                 // 0x0780(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleSlimeMuteki;                     // 0x0784(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleFriendsMuteki;                   // 0x0785(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugBossBattleBossMuteki;                      // 0x0786(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoPlay;                                       // 0x0787(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugAutoPlay;                                  // 0x0788(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsAutoPlayKey;                                    // 0x0789(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugAutoPlayKey;                               // 0x078A(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78B[0x1];                                      // 0x078B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugAutoPlayType;                                 // 0x078C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugAgingType;                                    // 0x0790(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugAutoStop;                                  // 0x0794(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_795[0x3];                                      // 0x0795(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoPlayGameCount;                                 // 0x0798(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugSptCont;                                      // 0x079C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugSptButton;                                    // 0x07A0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugSptMode;                                      // 0x07A4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugUnionSuccess;                                 // 0x07A8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugLevel;                                        // 0x07AC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDebugHintSetting;                               // 0x07B0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7B1[0x3];                                      // 0x07B1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugBonusStock;                                   // 0x07B4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DebugBreakRefundRate;                              // 0x07B8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7BC[0x4];                                      // 0x07BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<float>                                 DebugRandLog;                                      // 0x07C0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	EJackMeosiSlotBattleBackPattern               DebugBattleBackPattern;                            // 0x07D0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7D1[0x7];                                      // 0x07D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EJackMeosiSlotBarBackColor CalcBarChanceExpected();
	int32 GetBaseBreakOffRefund();
	EJackMeosiSlotBattleBack GetBattleBack(EJackMeosiSlotEffectKeyType InKeyType);
	int32 GetBellMaxRate();
	int32 GetBellMinRate();
	int32 GetBellPayOut(int32 InNumOrb);
	EJackMeosiSlotBonusMonsterLevel GetBonusMonsterLevel();
	int32 GetBreakOffRefund();
	int32 GetCurrentBlockGame();
	int32 GetCurrentPatternBlock();
	int32 GetCurrentScenarioPatternNum();
	int32 GetCurrentScenarioRoute();
	int32 GetHandsCount(EJackMeosiSlotHand InNmHand);
	EJackMeosiSlotScenarioHint GetItemHint();
	struct FJackMeosiSlotItem GetItemHintParam();
	class FName GetItemKey(EJackMeosiSlotItemSpec ItemID);
	class FString GetItemName(EJackMeosiSlotItemSpec ItemID);
	EJackMeosiSlotStageState GetLogInvalidStageState1();
	EJackMeosiSlotStageState GetLogInvalidStageState2();
	int32 GetLotteriedHandsCount(EJackMeosiSlotHand InNmHand);
	int32 GetLotteriedHsHandsCount(EJackMeosiSlotHsHand InHsHand);
	class FName GetMonsterKey(EJackMeosiSlotMonsterID MonsterID);
	class FString GetMonsterListName(EJackMeosiSlotMonsterID MonsterID);
	class FString GetMonsterName(EJackMeosiSlotMonsterID MonsterID);
	int32 GetNumTotalFeed();
	int32 GetNumTotalOrb();
	EJackMeosiSlotStageState GetOldStageState();
	int32 GetPreBreakOffRefund();
	EJackMeosiSlotScenarioBranch GetScenarioCondition();
	class FName GetScenarioPatternName();
	int32 GetScenarioPatternNum();
	int32 GetScenarioRoute();
	int32 GetShimohuriMonsterRefund(const class FName& InMonsterKey);
	float GetShimohuriMonsterRefundRate(const class FName& InMonsterKey);
	int32 GetSptPoint();
	bool GetSptResult();
	EJackMeosiSlotStageState GetStageState();
	int32 GetStopedHandsCount(EJackMeosiSlotHand InNmHand);
	int32 GetStopedHsHandsCount(EJackMeosiSlotHsHand InHsHand);
	class FString GetTextFromTextPack(const class FString& InTextId);
	EJackMeosiSlotUnionScenarioID GetUnionScenarioID();
	bool IsChallengeBattle();
	bool IsChallengeBattleResult();
	bool IsChanceZoneNormal();
	bool IsExtraMode();
	bool IsIntroductionChallengeBattle();
	bool IsInvalidStopedHsHand();
	bool IsSpTrainingEntry();
	bool IsStockBGM();
	EJackMeosiSlotBattleBack LotteryBattleBack(EJackMeosiSlotEffectKeyType InKeyType);
	EJackMeosiSlotBattleBackPattern LotteryBattleBackPattern();
	void QuitMeosiSlot();
	void ReqStockClear(bool bIsPrevSim);
	void ResetAutoPlayGameCount();
	void ResetBreakOffRefund();
	void ResetDebugNumOrb();
	void ResetPartyMonsters();
	void RestorePrev();
	void SetClosedNumTotalGame();
	void SetNumOrb(int32 InNumOrb);
	void SimQuitMeosiSlot();
	void StockBgm();

	int32 GetAgingType() const;
	EJackMeosiSlotHsHand GetAsistHsHand() const;
	bool GetAsistHsHandResult() const;
	int32 GetAsistReelPos(EJackMeosiSlotReel IdxReel) const;
	int32 GetAutoPlayGameCount() const;
	float GetAutoPlayInterval() const;
	bool GetAutoPlayKey() const;
	struct FJackMeosiSlotBarChance GetBarChance() const;
	struct FJackMeosiSlotBattle GetBattle() const;
	int32 GetBetMax() const;
	float GetBonusAverage() const;
	int32 GetCeilingValue() const;
	struct FJackMeosiSlotChanceCutinDefault GetChanceCutinDefault() const;
	struct FJackMeosiSlotChanceCutinStepUp GetChanceCutinStepUp() const;
	EJackMeosiSlotScenarioActNo GetCurrentScenarioActNo() const;
	EJackMeosiSlotScenarioActType GetCurrentScenarioActType() const;
	EJackMeosiSlotKeySeType GetCurrentScenarioKeySe() const;
	EJackMeosiSlotScenarioSubAct GetCurrentScenarioSubAct() const;
	EJackMeosiSlotStage GetCurrentStage() const;
	int32 GetDebugAgingType() const;
	bool GetDebugAutoPlayKey() const;
	EJackMeosiSlotInternalProbabilityStatus GetDispInternalProbabilityStatus() const;
	struct FJackMeosiSlotDoorEmission GetDoorEmission() const;
	struct FJackMeosiSlotDrakeeEffect GetDrakeeEffect() const;
	EJackMeosiSlotEffect GetEffect() const;
	EJackMeosiSlotEvent GetEvent() const;
	struct FJackMeosiSlotFireLamp GetFireLamp() const;
	struct FJackMeosiSlotFrameLamp GetFrameLamp() const;
	int32 GetGamesToParadiseRemaining() const;
	EJackMeosiSlotHand GetHand() const;
	struct FJackMeosiSlotMonster GetHeroMonster() const;
	EJackMeosiSlotHsHand GetHsHand() const;
	EJackMeosiSlotInternalProbabilityStatus GetInternalProbabilityStatus() const;
	int32 GetLatentPeriod() const;
	int32 GetLevel() const;
	EJackMeosiSlotHsHand GetLotteriedHsHand() const;
	float GetMachineRates() const;
	EJackMeosiSlotStage GetNextStage() const;
	int32 GetNumAdvantage() const;
	int32 GetNumATAdvantage() const;
	int32 GetNumATBonusTimes() const;
	int32 GetNumATContinuedTimes() const;
	int32 GetNumBigBonusTimes() const;
	int32 GetNumBonusStock() const;
	int32 GetNumBonusTimes() const;
	int32 GetNumCoin() const;
	int32 GetNumElapsedGameLastBattle() const;
	int32 GetNumElapsedGameLastEvent() const;
	int32 GetNumEnemyRemaining() const;
	int32 GetNumFeed() const;
	int32 GetNumGame() const;
	int32 GetNumGamesRemaining() const;
	int32 GetNumGamesRemainingUntilBossBattle() const;
	int32 GetNumKilledEnemy() const;
	int32 GetNumLastPayOut() const;
	int32 GetNumOrb() const;
	int32 GetNumPartyMonsters() const;
	int32 GetNumSpecialBonusTimes() const;
	int32 GetNumTotalBet() const;
	int32 GetNumTotalGame() const;
	int32 GetParadiseModeType() const;
	TArray<struct FJackMeosiSlotMonster> GetPartyMonsters() const;
	int32 GetPeriodUntilPseudoContinuation() const;
	float GetPrevBreakRefundRate() const;
	struct FJackMeosiSlotPseudoContinuation GetPseudoContinuation() const;
	struct FJackMeosiSlotPseudoContinuation_Dev GetPseudoContinuation_Dev() const;
	int32 GetPseudoContinuationCount() const;
	EJackMeosiSlotCutinColor GetPseudoContinuationDevelopmentColor() const;
	EJackMeosiSlotMonsterRank GetRank() const;
	struct FJackMeosiSlotMonster GetRecruitMonster() const;
	struct FJackMeosiSlotReelLightOff GetReelLightOff() const;
	struct FJackMeosiSlotReelSoundEffectSet GetReelSoundEffect() const;
	EJackMeosiSlotScenarioActNo GetScenarioActNo() const;
	EJackMeosiSlotScenarioActType GetScenarioActType() const;
	EJackMeosiSlotScenarioLotteryResult GetScenarioLotteryResult() const;
	EJackMeosiSlotUnionSlime GetScenarioSlimeID() const;
	int32 GetSetGameNum() const;
	int32 GetSettingAskGames() const;
	EJackMeosiSlotSettingValue GetSettingValue() const;
	struct FJackMeosiSlotShimofuriChance GetShimofuriChance() const;
	struct FJackMeosiSlotSpecialTrainingState GetSpecialTrainingInfo() const;
	EJackMeosiSlotTimeZone GetStageTimeZone() const;
	EJackMeosiSlotHsHand GetStopedHsHand() const;
	EJackMiniGameTableCoinType GetTableType() const;
	struct FJackMeosiSlotTreasureBox GetTreasureBox() const;
	struct FJackMeosiSlotUnionChallengeState GetUnionChallengeInfo() const;
	struct FJackMeosiSlotVariableStateParam GetVariableParam() const;
	struct FJackMeosiSlotYakumonoFlash GetYakumonoFlash() const;
	bool HasChangedToChanceZone() const;
	bool HasReachedMaxCoin() const;
	bool HasReachedMaxOrb() const;
	bool HasReachedMaxTotalGame() const;
	bool IsAdvanceDirectImpact() const;
	bool IsAfterResultWithStock() const;
	bool IsAsist() const;
	bool IsAssistEnable() const;
	bool IsBetPossible(int32 InBet) const;
	bool IsBonusEstablished() const;
	bool IsBonusFixing() const;
	bool IsBonusGame() const;
	bool IsBonusRelief() const;
	bool IsBonusStock() const;
	bool IsBossBattleBGMSpecial() const;
	bool IsBossBattleWinFixed() const;
	bool IsChanceZone() const;
	bool IsContGame() const;
	bool IsContScenario() const;
	bool IsDebugNumOrb() const;
	bool IsDefaultStage() const;
	bool IsDirectImpact() const;
	bool IsEffectHappened() const;
	bool IsEnemyKilledAtOneGame(const struct FJackMeosiSlotMonster& InEnemyMonster) const;
	bool IsEventBossBattle() const;
	bool IsEventHappened() const;
	bool IsEventLocked() const;
	bool IsEventShimofuriChance() const;
	bool IsEventSuperShimofuriChance() const;
	bool IsFakeBattle() const;
	bool IsHandFailure() const;
	bool IsHazureScenario() const;
	bool IsHsHandFailure() const;
	bool IsIchigekiWinFixed() const;
	bool IsInBonusGame() const;
	bool IsInternalProbabilityStatusChanged() const;
	bool IsLatent() const;
	bool IsMamonoScenario() const;
	bool IsPartyMonsterFull() const;
	bool IsPseudoContinuation() const;
	bool IsPseudoContinuationDevelopmentDecided() const;
	bool IsPseudoContinuationDevelopmentEnabled() const;
	bool IsReachSpot() const;
	bool IsSlimeScenario() const;
	bool IsSpecialBonusRising() const;
	bool IsStageChanged() const;
	bool IsStageInitializeRequested() const;
	bool IsTakePamph() const;
	bool IsTBoxScenario() const;
	bool IsZakoCont() const;
	bool WasBonusGameBegun() const;
	bool WasBonusStocked() const;
	bool WasGoldSevens() const;
	bool WasLatentHappened() const;
	bool WasLongFreezeHappened() const;
	bool WasPseudoContinuationEffectHappened() const;
	bool WasReachedCeiling() const;
	bool WasReachedParadise() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotState">();
	}
	static class UJackMeosiSlotState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotState>();
	}
};
static_assert(alignof(UJackMeosiSlotState) == 0x000008, "Wrong alignment on UJackMeosiSlotState");
static_assert(sizeof(UJackMeosiSlotState) == 0x0007D8, "Wrong size on UJackMeosiSlotState");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugHsHandEnabled) == 0x0006F4, "Member 'UJackMeosiSlotState::bIsDebugHsHandEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugSlotHsHand) == 0x0006F5, "Member 'UJackMeosiSlotState::DebugSlotHsHand' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugInternalProbabilityStatusEnabled) == 0x0006F6, "Member 'UJackMeosiSlotState::bIsDebugInternalProbabilityStatusEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugInternalProbabilityStatus) == 0x0006F7, "Member 'UJackMeosiSlotState::DebugInternalProbabilityStatus' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugLatentEnabled) == 0x0006F8, "Member 'UJackMeosiSlotState::bIsDebugLatentEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bDebugDirectImpact) == 0x0006F9, "Member 'UJackMeosiSlotState::bDebugDirectImpact' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugLatentPeriod) == 0x0006FC, "Member 'UJackMeosiSlotState::DebugLatentPeriod' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBonusRising) == 0x000700, "Member 'UJackMeosiSlotState::DebugBonusRising' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBonusGoldSevens) == 0x000704, "Member 'UJackMeosiSlotState::DebugBonusGoldSevens' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBonusBack) == 0x000708, "Member 'UJackMeosiSlotState::DebugBonusBack' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugChanceCutinStepUpColor_Default) == 0x00070C, "Member 'UJackMeosiSlotState::DebugChanceCutinStepUpColor_Default' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugChanceCutinStepUpColor_Left) == 0x000710, "Member 'UJackMeosiSlotState::DebugChanceCutinStepUpColor_Left' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugChanceCutinStepUpColor_Center) == 0x000714, "Member 'UJackMeosiSlotState::DebugChanceCutinStepUpColor_Center' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugChanceCutinStepUpColor_Right) == 0x000718, "Member 'UJackMeosiSlotState::DebugChanceCutinStepUpColor_Right' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugMonsterEncounterEnabled) == 0x00071C, "Member 'UJackMeosiSlotState::bIsDebugMonsterEncounterEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugMonsterIndex) == 0x000720, "Member 'UJackMeosiSlotState::DebugMonsterIndex' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugTreasureBoxAppearanceEnabled) == 0x000724, "Member 'UJackMeosiSlotState::bIsDebugTreasureBoxAppearanceEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugRecruitEnabled) == 0x000726, "Member 'UJackMeosiSlotState::bIsDebugRecruitEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bDebugRecruit) == 0x000727, "Member 'UJackMeosiSlotState::bDebugRecruit' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugYakumonoFlashEnabled) == 0x000728, "Member 'UJackMeosiSlotState::bIsDebugYakumonoFlashEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bDebugYakumonoFlash) == 0x000729, "Member 'UJackMeosiSlotState::bDebugYakumonoFlash' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugDrakeeEffectEnabled) == 0x00072A, "Member 'UJackMeosiSlotState::bIsDebugDrakeeEffectEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugDrakeeEffect1) == 0x00072B, "Member 'UJackMeosiSlotState::DebugDrakeeEffect1' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugDrakeeEffect2) == 0x00072C, "Member 'UJackMeosiSlotState::DebugDrakeeEffect2' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugDrakeeEffect3) == 0x00072D, "Member 'UJackMeosiSlotState::DebugDrakeeEffect3' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugDrakeeColor) == 0x00072E, "Member 'UJackMeosiSlotState::DebugDrakeeColor' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugShimofuriBackGround) == 0x000730, "Member 'UJackMeosiSlotState::DebugShimofuriBackGround' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugShimofuriChanceSuper) == 0x000734, "Member 'UJackMeosiSlotState::bIsDebugShimofuriChanceSuper' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugShimofuriChanceSuccess) == 0x000738, "Member 'UJackMeosiSlotState::bIsDebugShimofuriChanceSuccess' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugShimofuriChanceBound) == 0x000739, "Member 'UJackMeosiSlotState::bIsDebugShimofuriChanceBound' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugShimofuriChanceColorRed) == 0x00073A, "Member 'UJackMeosiSlotState::bIsDebugShimofuriChanceColorRed' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugEffectEnabled) == 0x00073B, "Member 'UJackMeosiSlotState::bIsDebugEffectEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugEffect) == 0x00073C, "Member 'UJackMeosiSlotState::DebugEffect' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelLightOffTimes1) == 0x00073D, "Member 'UJackMeosiSlotState::DebugReelLightOffTimes1' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelLightOffTimes2) == 0x00073E, "Member 'UJackMeosiSlotState::DebugReelLightOffTimes2' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelLightOffTimes3) == 0x00073F, "Member 'UJackMeosiSlotState::DebugReelLightOffTimes3' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugFireLampColor) == 0x000740, "Member 'UJackMeosiSlotState::DebugFireLampColor' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugFireLampLargeSize) == 0x000741, "Member 'UJackMeosiSlotState::DebugFireLampLargeSize' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugReelSEEnabled) == 0x000742, "Member 'UJackMeosiSlotState::bIsDebugReelSEEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelStartSE) == 0x000744, "Member 'UJackMeosiSlotState::DebugReelStartSE' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelStopSE1) == 0x00074C, "Member 'UJackMeosiSlotState::DebugReelStopSE1' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelStopSE2) == 0x000754, "Member 'UJackMeosiSlotState::DebugReelStopSE2' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugReelStopSE3) == 0x00075C, "Member 'UJackMeosiSlotState::DebugReelStopSE3' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugAssistEnabled) == 0x000764, "Member 'UJackMeosiSlotState::bIsDebugAssistEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugAssist) == 0x000765, "Member 'UJackMeosiSlotState::bIsDebugAssist' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugStockClear) == 0x000766, "Member 'UJackMeosiSlotState::bIsDebugStockClear' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugMamonoCasino) == 0x000767, "Member 'UJackMeosiSlotState::bIsDebugMamonoCasino' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugNumOrb) == 0x000768, "Member 'UJackMeosiSlotState::bIsDebugNumOrb' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugPamph) == 0x000769, "Member 'UJackMeosiSlotState::bIsDebugPamph' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugExtraMode) == 0x00076C, "Member 'UJackMeosiSlotState::DebugExtraMode' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleProntoEnabled) == 0x000770, "Member 'UJackMeosiSlotState::bIsDebugBossBattleProntoEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleWinningFixEnabled) == 0x000771, "Member 'UJackMeosiSlotState::bIsDebugBossBattleWinningFixEnabled' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleWinningIchigeki) == 0x000772, "Member 'UJackMeosiSlotState::bIsDebugBossBattleWinningIchigeki' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBossMonster) == 0x000774, "Member 'UJackMeosiSlotState::DebugBossMonster' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugComebackType) == 0x000778, "Member 'UJackMeosiSlotState::DebugComebackType' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBonusGameNum) == 0x00077C, "Member 'UJackMeosiSlotState::bIsDebugBonusGameNum' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBonusGameNum) == 0x000780, "Member 'UJackMeosiSlotState::DebugBonusGameNum' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleSlimeMuteki) == 0x000784, "Member 'UJackMeosiSlotState::bIsDebugBossBattleSlimeMuteki' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleFriendsMuteki) == 0x000785, "Member 'UJackMeosiSlotState::bIsDebugBossBattleFriendsMuteki' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugBossBattleBossMuteki) == 0x000786, "Member 'UJackMeosiSlotState::bIsDebugBossBattleBossMuteki' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsAutoPlay) == 0x000787, "Member 'UJackMeosiSlotState::bIsAutoPlay' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugAutoPlay) == 0x000788, "Member 'UJackMeosiSlotState::bIsDebugAutoPlay' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsAutoPlayKey) == 0x000789, "Member 'UJackMeosiSlotState::bIsAutoPlayKey' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugAutoPlayKey) == 0x00078A, "Member 'UJackMeosiSlotState::bIsDebugAutoPlayKey' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugAutoPlayType) == 0x00078C, "Member 'UJackMeosiSlotState::DebugAutoPlayType' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugAgingType) == 0x000790, "Member 'UJackMeosiSlotState::DebugAgingType' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugAutoStop) == 0x000794, "Member 'UJackMeosiSlotState::bIsDebugAutoStop' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, AutoPlayGameCount) == 0x000798, "Member 'UJackMeosiSlotState::AutoPlayGameCount' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugSptCont) == 0x00079C, "Member 'UJackMeosiSlotState::DebugSptCont' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugSptButton) == 0x0007A0, "Member 'UJackMeosiSlotState::DebugSptButton' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugSptMode) == 0x0007A4, "Member 'UJackMeosiSlotState::DebugSptMode' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugUnionSuccess) == 0x0007A8, "Member 'UJackMeosiSlotState::DebugUnionSuccess' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugLevel) == 0x0007AC, "Member 'UJackMeosiSlotState::DebugLevel' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, bIsDebugHintSetting) == 0x0007B0, "Member 'UJackMeosiSlotState::bIsDebugHintSetting' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBonusStock) == 0x0007B4, "Member 'UJackMeosiSlotState::DebugBonusStock' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBreakRefundRate) == 0x0007B8, "Member 'UJackMeosiSlotState::DebugBreakRefundRate' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugRandLog) == 0x0007C0, "Member 'UJackMeosiSlotState::DebugRandLog' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotState, DebugBattleBackPattern) == 0x0007D0, "Member 'UJackMeosiSlotState::DebugBattleBackPattern' has a wrong offset!");

// Class JackGame.JackMatineeCaptureCommandlet
// 0x0000 (0x0090 - 0x0090)
class UJackMatineeCaptureCommandlet final : public UCommandlet
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeCaptureCommandlet">();
	}
	static class UJackMatineeCaptureCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMatineeCaptureCommandlet>();
	}
};
static_assert(alignof(UJackMatineeCaptureCommandlet) == 0x000008, "Wrong alignment on UJackMatineeCaptureCommandlet");
static_assert(sizeof(UJackMatineeCaptureCommandlet) == 0x000090, "Wrong size on UJackMatineeCaptureCommandlet");

// Class JackGame.JackFusigiKaziGameAction
// 0x00F8 (0x0130 - 0x0038)
class UJackFusigiKaziGameAction final : public UObject
{
public:
	TWeakObjectPtr<class UJackUMGAccessorFusigiKazi> KaziAccessor;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FrameSize;                                         // 0x0040(0x0008)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CursorPos;                                         // 0x0048(0x0008)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MoveLimit;                                         // 0x0050(0x0008)(Edit, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionCategory;                                    // 0x0058(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectActionName;                                  // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackDataTableKaziAction               SelectActionDataRow;                               // 0x0068(0x0060)(Edit, EditConst, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x28];                                      // 0x00C8(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemData*>               KaziActionList;                                    // 0x00F0(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGItemData*>               KaziHissatuList;                                   // 0x0100(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           ActionDataNameList;                                // 0x0110(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class FName>                           HissatuDataNameList;                               // 0x0120(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)

public:
	class FName GetActionCategoryName(class FName ItemID);
	class FName GetActionDataNameForIndex(int32 Index_0);
	class FName GetActionID(EJackFusigiKaziGameTokugi TokugiType);
	struct FVector2D GetKaziActionCursorGaugePos(class FName ActionName, int32 CursorIndex, const struct FVector2D& BasePos);
	struct FVector2D GetKaziActionCursorPos(class FName ActionName, int32 CursorIndex, const struct FVector2D& BasePos);
	int32 GetKaziActionKnockNum(class FName ActionName);
	struct FVector2D GetMoveLimit();
	void InitActionData(class UJackUMGManager* InUMGManager, EJackFusigiKaziKanagata KanagataType);
	bool MoveCursorInfo(int32 MoveX, int32 MoveY);
	void SetSelectActionCategoryName(class FName CategoryName);
	void SettingSelectActionInfo(class FName ActionName);
	class FName UpdateCursorInput(class UJackUMGAccessorFusigiKazi* Accessor, EJackKeys KeyType);

	const TArray<class UJackUMGItemData*> GetKaziActionList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziGameAction">();
	}
	static class UJackFusigiKaziGameAction* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFusigiKaziGameAction>();
	}
};
static_assert(alignof(UJackFusigiKaziGameAction) == 0x000008, "Wrong alignment on UJackFusigiKaziGameAction");
static_assert(sizeof(UJackFusigiKaziGameAction) == 0x000130, "Wrong size on UJackFusigiKaziGameAction");
static_assert(offsetof(UJackFusigiKaziGameAction, KaziAccessor) == 0x000038, "Member 'UJackFusigiKaziGameAction::KaziAccessor' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, FrameSize) == 0x000040, "Member 'UJackFusigiKaziGameAction::FrameSize' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, CursorPos) == 0x000048, "Member 'UJackFusigiKaziGameAction::CursorPos' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, MoveLimit) == 0x000050, "Member 'UJackFusigiKaziGameAction::MoveLimit' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, ActionCategory) == 0x000058, "Member 'UJackFusigiKaziGameAction::ActionCategory' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, SelectActionName) == 0x000060, "Member 'UJackFusigiKaziGameAction::SelectActionName' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, SelectActionDataRow) == 0x000068, "Member 'UJackFusigiKaziGameAction::SelectActionDataRow' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, KaziActionList) == 0x0000F0, "Member 'UJackFusigiKaziGameAction::KaziActionList' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, KaziHissatuList) == 0x000100, "Member 'UJackFusigiKaziGameAction::KaziHissatuList' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, ActionDataNameList) == 0x000110, "Member 'UJackFusigiKaziGameAction::ActionDataNameList' has a wrong offset!");
static_assert(offsetof(UJackFusigiKaziGameAction, HissatuDataNameList) == 0x000120, "Member 'UJackFusigiKaziGameAction::HissatuDataNameList' has a wrong offset!");

// Class JackGame.JackFusigiKaziGameMain
// 0x0238 (0x05D0 - 0x0398)
class AJackFusigiKaziGameMain final : public AActor
{
public:
	uint8                                         Pad_398[0x238];                                    // 0x0398(0x0238)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJackFusigiKaziMaterialParameter GetMaterialParameter();
	float RequestChangeMaterialParameter(const struct FJackFusigiKaziMaterialParameter& Param, float ChangeTime);
	void SetMaterialParameter(const struct FJackFusigiKaziMaterialParameter& Param);
	bool UpdateChangeMaterialParameter(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziGameMain">();
	}
	static class AJackFusigiKaziGameMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFusigiKaziGameMain>();
	}
};
static_assert(alignof(AJackFusigiKaziGameMain) == 0x000008, "Wrong alignment on AJackFusigiKaziGameMain");
static_assert(sizeof(AJackFusigiKaziGameMain) == 0x0005D0, "Wrong size on AJackFusigiKaziGameMain");

// Class JackGame.JackVehicleShip
// 0x0070 (0x14B0 - 0x1440)
class AJackVehicleShip final : public AJackPlayableCharacter
{
public:
	float                                         SteeringRate;                                      // 0x1438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SteeringTurn;                                      // 0x143C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusMin;                                   // 0x1440(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusMax;                                   // 0x1444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusChangeSpeedStart;                      // 0x1448(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotateRadiusChangeSpeedEnd;                        // 0x144C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsShipMove;                                        // 0x1450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1451[0x3];                                     // 0x1451(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ShipCameraYawLerpRate;                             // 0x1454(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1458[0x38];                                    // 0x1458(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnShipPartyTalkStart;                              // 0x1490(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnShipPartyTalkEnd;                                // 0x14A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CancelDash();
	void Latent_StartSinkLeapAnimetion(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EJackVehicleShipAnim AnimType, bool InFast);
	void OnShipDashEndBp();
	void OnShipDashStartBp();
	void OnShipExceptStopBp();
	void OnShipStopBp();
	void ShipPartyTalkEndDelegate__DelegateSignature();
	void ShipPartyTalkStartDelegate__DelegateSignature();
	void StartShipRun();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleShip">();
	}
	static class AJackVehicleShip* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleShip>();
	}
};
static_assert(alignof(AJackVehicleShip) == 0x000010, "Wrong alignment on AJackVehicleShip");
static_assert(sizeof(AJackVehicleShip) == 0x0014B0, "Wrong size on AJackVehicleShip");
static_assert(offsetof(AJackVehicleShip, SteeringRate) == 0x001438, "Member 'AJackVehicleShip::SteeringRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, SteeringTurn) == 0x00143C, "Member 'AJackVehicleShip::SteeringTurn' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, RotateRadiusMin) == 0x001440, "Member 'AJackVehicleShip::RotateRadiusMin' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, RotateRadiusMax) == 0x001444, "Member 'AJackVehicleShip::RotateRadiusMax' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, RotateRadiusChangeSpeedStart) == 0x001448, "Member 'AJackVehicleShip::RotateRadiusChangeSpeedStart' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, RotateRadiusChangeSpeedEnd) == 0x00144C, "Member 'AJackVehicleShip::RotateRadiusChangeSpeedEnd' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, IsShipMove) == 0x001450, "Member 'AJackVehicleShip::IsShipMove' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, ShipCameraYawLerpRate) == 0x001454, "Member 'AJackVehicleShip::ShipCameraYawLerpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, OnShipPartyTalkStart) == 0x001490, "Member 'AJackVehicleShip::OnShipPartyTalkStart' has a wrong offset!");
static_assert(offsetof(AJackVehicleShip, OnShipPartyTalkEnd) == 0x0014A0, "Member 'AJackVehicleShip::OnShipPartyTalkEnd' has a wrong offset!");

// Class JackGame.JackFusigiKaziItemController
// 0x0000 (0x0398 - 0x0398)
class AJackFusigiKaziItemController final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziItemController">();
	}
	static class AJackFusigiKaziItemController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFusigiKaziItemController>();
	}
};
static_assert(alignof(AJackFusigiKaziItemController) == 0x000008, "Wrong alignment on AJackFusigiKaziItemController");
static_assert(sizeof(AJackFusigiKaziItemController) == 0x000398, "Wrong size on AJackFusigiKaziItemController");

// Class JackGame.JackOddEffectExec_Hot_GetExp
// 0x0000 (0x0108 - 0x0108)
class UJackOddEffectExec_Hot_GetExp final : public UJackOddEffectExec_Hot
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Hot_GetExp">();
	}
	static class UJackOddEffectExec_Hot_GetExp* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Hot_GetExp>();
	}
};
static_assert(alignof(UJackOddEffectExec_Hot_GetExp) == 0x000008, "Wrong alignment on UJackOddEffectExec_Hot_GetExp");
static_assert(sizeof(UJackOddEffectExec_Hot_GetExp) == 0x000108, "Wrong size on UJackOddEffectExec_Hot_GetExp");

// Class JackGame.JackFusigiKaziManager
// 0x0000 (0x0398 - 0x0398)
class AJackFusigiKaziManager final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziManager">();
	}
	static class AJackFusigiKaziManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFusigiKaziManager>();
	}
};
static_assert(alignof(AJackFusigiKaziManager) == 0x000008, "Wrong alignment on AJackFusigiKaziManager");
static_assert(sizeof(AJackFusigiKaziManager) == 0x000398, "Wrong size on AJackFusigiKaziManager");

// Class JackGame.JackFusigiKaziQualityAnalysis
// 0x0008 (0x0040 - 0x0038)
class UJackFusigiKaziQualityAnalysis final : public UObject
{
public:
	TWeakObjectPtr<class UJackUMGAccessorFusigiKazi> KaziAccessor;                                      // 0x0038(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFusigiKaziQualityAnalysis">();
	}
	static class UJackFusigiKaziQualityAnalysis* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackFusigiKaziQualityAnalysis>();
	}
};
static_assert(alignof(UJackFusigiKaziQualityAnalysis) == 0x000008, "Wrong alignment on UJackFusigiKaziQualityAnalysis");
static_assert(sizeof(UJackFusigiKaziQualityAnalysis) == 0x000040, "Wrong size on UJackFusigiKaziQualityAnalysis");
static_assert(offsetof(UJackFusigiKaziQualityAnalysis, KaziAccessor) == 0x000038, "Member 'UJackFusigiKaziQualityAnalysis::KaziAccessor' has a wrong offset!");

// Class JackGame.JackGameCharacterManager
// 0x0010 (0x0048 - 0x0038)
class UJackGameCharacterManager final : public UObject
{
public:
	TArray<class UJackGameCharacter*>             GameCharacters;                                    // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameCharacterManager">();
	}
	static class UJackGameCharacterManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameCharacterManager>();
	}
};
static_assert(alignof(UJackGameCharacterManager) == 0x000008, "Wrong alignment on UJackGameCharacterManager");
static_assert(sizeof(UJackGameCharacterManager) == 0x000048, "Wrong size on UJackGameCharacterManager");
static_assert(offsetof(UJackGameCharacterManager, GameCharacters) == 0x000038, "Member 'UJackGameCharacterManager::GameCharacters' has a wrong offset!");

// Class JackGame.JackOddEffectExec_NoroiYasumi
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_NoroiYasumi final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_NoroiYasumi">();
	}
	static class UJackOddEffectExec_NoroiYasumi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_NoroiYasumi>();
	}
};
static_assert(alignof(UJackOddEffectExec_NoroiYasumi) == 0x000008, "Wrong alignment on UJackOddEffectExec_NoroiYasumi");
static_assert(sizeof(UJackOddEffectExec_NoroiYasumi) == 0x000100, "Wrong size on UJackOddEffectExec_NoroiYasumi");

// Class JackGame.JackGameEngine
// 0x0010 (0x0CF0 - 0x0CE0)
class UJackGameEngine final : public UGameEngine
{
public:
	uint8                                         Pad_CE0[0x10];                                     // 0x0CE0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameEngine">();
	}
	static class UJackGameEngine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameEngine>();
	}
};
static_assert(alignof(UJackGameEngine) == 0x000008, "Wrong alignment on UJackGameEngine");
static_assert(sizeof(UJackGameEngine) == 0x000CF0, "Wrong size on UJackGameEngine");

// Class JackGame.JackOddEffectExec_SokusiMukou
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_SokusiMukou final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_SokusiMukou">();
	}
	static class UJackOddEffectExec_SokusiMukou* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_SokusiMukou>();
	}
};
static_assert(alignof(UJackOddEffectExec_SokusiMukou) == 0x000008, "Wrong alignment on UJackOddEffectExec_SokusiMukou");
static_assert(sizeof(UJackOddEffectExec_SokusiMukou) == 0x000108, "Wrong size on UJackOddEffectExec_SokusiMukou");

// Class JackGame.JackGameEvent
// 0x0000 (0x0398 - 0x0398)
class AJackGameEvent : public AActor
{
public:
	void AllDead();
	void SetMonsterGeneratorDisabled(bool bDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameEvent">();
	}
	static class AJackGameEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackGameEvent>();
	}
};
static_assert(alignof(AJackGameEvent) == 0x000008, "Wrong alignment on AJackGameEvent");
static_assert(sizeof(AJackGameEvent) == 0x000398, "Wrong size on AJackGameEvent");

// Class JackGame.JackGameFlag
// 0x0040 (0x0078 - 0x0038)
class UJackGameFlag : public UObject
{
public:
	TArray<struct FJackGameFlagDefinitionTableDic> FlagDefinitionList;                                // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             RelationalGameFlagConfig;                          // 0x0048(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             ScenarioFlagInfo;                                  // 0x0050(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssertNonExistentFlag;                            // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bAssertNonExistentFlagOnlyFirstTime;               // 0x0059(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTypeCheckingEnabled;                              // 0x005A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_5B[0x5];                                       // 0x005B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackGameFlagDataBase*>          FlagDataList;                                      // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackGameFlagDebugger*                  Debugger;                                          // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void InitAllFlagDataToSecondPlaythrough();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlag">();
	}
	static class UJackGameFlag* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlag>();
	}
};
static_assert(alignof(UJackGameFlag) == 0x000008, "Wrong alignment on UJackGameFlag");
static_assert(sizeof(UJackGameFlag) == 0x000078, "Wrong size on UJackGameFlag");
static_assert(offsetof(UJackGameFlag, FlagDefinitionList) == 0x000038, "Member 'UJackGameFlag::FlagDefinitionList' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, RelationalGameFlagConfig) == 0x000048, "Member 'UJackGameFlag::RelationalGameFlagConfig' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, ScenarioFlagInfo) == 0x000050, "Member 'UJackGameFlag::ScenarioFlagInfo' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, bAssertNonExistentFlag) == 0x000058, "Member 'UJackGameFlag::bAssertNonExistentFlag' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, bAssertNonExistentFlagOnlyFirstTime) == 0x000059, "Member 'UJackGameFlag::bAssertNonExistentFlagOnlyFirstTime' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, bTypeCheckingEnabled) == 0x00005A, "Member 'UJackGameFlag::bTypeCheckingEnabled' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, FlagDataList) == 0x000060, "Member 'UJackGameFlag::FlagDataList' has a wrong offset!");
static_assert(offsetof(UJackGameFlag, Debugger) == 0x000070, "Member 'UJackGameFlag::Debugger' has a wrong offset!");

// Class JackGame.JackGameFlagDataBoukenGuide
// 0x0050 (0x0190 - 0x0140)
class UJackGameFlagDataBoukenGuide final : public UJackGameFlagDataBase
{
public:
	uint8                                         Pad_140[0x50];                                     // 0x0140(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataBoukenGuide">();
	}
	static class UJackGameFlagDataBoukenGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataBoukenGuide>();
	}
};
static_assert(alignof(UJackGameFlagDataBoukenGuide) == 0x000008, "Wrong alignment on UJackGameFlagDataBoukenGuide");
static_assert(sizeof(UJackGameFlagDataBoukenGuide) == 0x000190, "Wrong size on UJackGameFlagDataBoukenGuide");

// Class JackGame.JackOddEffectExec_SyourijiKaifuku_MP
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_SyourijiKaifuku_MP final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_SyourijiKaifuku_MP">();
	}
	static class UJackOddEffectExec_SyourijiKaifuku_MP* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_SyourijiKaifuku_MP>();
	}
};
static_assert(alignof(UJackOddEffectExec_SyourijiKaifuku_MP) == 0x000008, "Wrong alignment on UJackOddEffectExec_SyourijiKaifuku_MP");
static_assert(sizeof(UJackOddEffectExec_SyourijiKaifuku_MP) == 0x000100, "Wrong size on UJackOddEffectExec_SyourijiKaifuku_MP");

// Class JackGame.JackGameFlagDataCutScene
// 0x0000 (0x0140 - 0x0140)
class UJackGameFlagDataCutScene final : public UJackGameFlagDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataCutScene">();
	}
	static class UJackGameFlagDataCutScene* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataCutScene>();
	}
};
static_assert(alignof(UJackGameFlagDataCutScene) == 0x000008, "Wrong alignment on UJackGameFlagDataCutScene");
static_assert(sizeof(UJackGameFlagDataCutScene) == 0x000140, "Wrong size on UJackGameFlagDataCutScene");

// Class JackGame.JackGameFlagDataMapVisit
// 0x0000 (0x0140 - 0x0140)
class UJackGameFlagDataMapVisit final : public UJackGameFlagDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataMapVisit">();
	}
	static class UJackGameFlagDataMapVisit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataMapVisit>();
	}
};
static_assert(alignof(UJackGameFlagDataMapVisit) == 0x000008, "Wrong alignment on UJackGameFlagDataMapVisit");
static_assert(sizeof(UJackGameFlagDataMapVisit) == 0x000140, "Wrong size on UJackGameFlagDataMapVisit");

// Class JackGame.JackGameFlagDataTalkCounter
// 0x0000 (0x0140 - 0x0140)
class UJackGameFlagDataTalkCounter final : public UJackGameFlagDataBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagDataTalkCounter">();
	}
	static class UJackGameFlagDataTalkCounter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagDataTalkCounter>();
	}
};
static_assert(alignof(UJackGameFlagDataTalkCounter) == 0x000008, "Wrong alignment on UJackGameFlagDataTalkCounter");
static_assert(sizeof(UJackGameFlagDataTalkCounter) == 0x000140, "Wrong size on UJackGameFlagDataTalkCounter");

// Class JackGame.JackMiniGameInputActor
// 0x0020 (0x03B8 - 0x0398)
class AJackMiniGameInputActor : public AActor
{
public:
	TSubclassOf<class UJackUIInputSettings>       UIInputSettingsClass;                              // 0x0398(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUIInputSettings*                   UIInputSettings;                                   // 0x03A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUIInputManager*                    InputManager;                                      // 0x03A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindKeyMeosiSlot(class APlayerController* PlayerController);
	void BindKeyMiniGameDefault(class APlayerController* PlayerController);
	void BindKeyRoulette(class APlayerController* PlayerController);
	void ClearKeyEventQueue();
	void UnbindKeys(class APlayerController* PlayerController);

	bool IsKeyDown(EJackKeys InKey) const;
	bool IsKeyPressed(EJackKeys InKey) const;
	bool IsKeyReleased(EJackKeys InKey) const;
	bool IsKeyRepeated(EJackKeys InKey) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameInputActor">();
	}
	static class AJackMiniGameInputActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameInputActor>();
	}
};
static_assert(alignof(AJackMiniGameInputActor) == 0x000008, "Wrong alignment on AJackMiniGameInputActor");
static_assert(sizeof(AJackMiniGameInputActor) == 0x0003B8, "Wrong size on AJackMiniGameInputActor");
static_assert(offsetof(AJackMiniGameInputActor, UIInputSettingsClass) == 0x000398, "Member 'AJackMiniGameInputActor::UIInputSettingsClass' has a wrong offset!");
static_assert(offsetof(AJackMiniGameInputActor, UIInputSettings) == 0x0003A0, "Member 'AJackMiniGameInputActor::UIInputSettings' has a wrong offset!");
static_assert(offsetof(AJackMiniGameInputActor, InputManager) == 0x0003A8, "Member 'AJackMiniGameInputActor::InputManager' has a wrong offset!");

// Class JackGame.JackMiniGameRouletteMainMenu
// 0x00B0 (0x0468 - 0x03B8)
class AJackMiniGameRouletteMainMenu final : public AJackMiniGameInputActor
{
public:
	int32                                         CursorX;                                           // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CursorY;                                           // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         Coin;                                              // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ResultNumberHistory;                               // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	int32                                         ResultNumber;                                      // 0x03D8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DevideCoin;                                        // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         JackPotDevideCoin;                                 // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TotalDevideCoin;                                   // 0x03E4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsStateChanged;                                   // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x3];                                      // 0x03E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              CoinMoveTargetPos;                                 // 0x03EC(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsResultJackPot;                                  // 0x03F4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMiniGameTableCoinType                    CoinTableType;                                     // 0x03F5(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F6[0x2];                                      // 0x03F6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EaseSpeed;                                         // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundCoinUp2;                                      // 0x0400(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundCoinMoved;                                    // 0x0408(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundGetCoin;                                      // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoinUpSoundTime;                                   // 0x0418(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoinUpCurrentRatio;                                // 0x041C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoinMoveSpeed;                                     // 0x0420(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         KeyRepeatTime;                                     // 0x0424(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CoinRepeatTime;                                    // 0x0428(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_42C[0x14];                                     // 0x042C(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DT_Roulette;                                       // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x20];                                     // 0x0448(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyDevideCoin();
	void ApplyJackPotPayoutNum();
	bool CalcJackPotLottey(int32* OutResultNumber);
	void EventDebugBetCoin(const TArray<struct FJackMiniGameRouletteDebugBetCoinInfo>& BetCoinInfo);
	TArray<struct FJackRouletteBetCoinSaveData> GetMenuSaveData();
	int32 GetOneBetCoinNum();
	TArray<class UJackUMGWidgetBase*> GetRemoveCoinWidgetArray();
	EJackMiniGameRouletteMenuSequenceEnum GetState();
	int32 GetTotalRestCoin();
	int32 GetTotalWinCoin();
	const class FName GetWinMEID(int32 InCoin);
	void InitializeInstance(class AJackRouletteMenu* Menu);
	bool IsCasinoCoinMax();
	bool IsCoinRepeat();
	bool IsJackPotOnlyLottey();
	void JackMiniGameRouletteInputDelegate__DelegateSignature(const class FName InEventTag);
	void NativeEventResultCoinUp();
	void NativeEventResultCoinUpUpdate(float DeltaTime);
	void RemoveResultCoin();
	void SetCoinTableType(EJackMiniGameTableCoinType InType);
	void SetGameData(int32 ResultNumber_0, bool bIsJackPot);
	void SetState(EJackMiniGameRouletteMenuSequenceEnum InState);
	void StartPlay();
	void UpdateInput(TDelegate<void(class FName InEventTag)> InDelegate, float DeltaTime);

	TArray<int32> GetHistoryArray() const;
	bool IsIncludeBetNumber() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameRouletteMainMenu">();
	}
	static class AJackMiniGameRouletteMainMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameRouletteMainMenu>();
	}
};
static_assert(alignof(AJackMiniGameRouletteMainMenu) == 0x000008, "Wrong alignment on AJackMiniGameRouletteMainMenu");
static_assert(sizeof(AJackMiniGameRouletteMainMenu) == 0x000468, "Wrong size on AJackMiniGameRouletteMainMenu");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CursorX) == 0x0003B8, "Member 'AJackMiniGameRouletteMainMenu::CursorX' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CursorY) == 0x0003BC, "Member 'AJackMiniGameRouletteMainMenu::CursorY' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, Coin) == 0x0003C0, "Member 'AJackMiniGameRouletteMainMenu::Coin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, ResultNumberHistory) == 0x0003C8, "Member 'AJackMiniGameRouletteMainMenu::ResultNumberHistory' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, ResultNumber) == 0x0003D8, "Member 'AJackMiniGameRouletteMainMenu::ResultNumber' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, DevideCoin) == 0x0003DC, "Member 'AJackMiniGameRouletteMainMenu::DevideCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, JackPotDevideCoin) == 0x0003E0, "Member 'AJackMiniGameRouletteMainMenu::JackPotDevideCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, TotalDevideCoin) == 0x0003E4, "Member 'AJackMiniGameRouletteMainMenu::TotalDevideCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, bIsStateChanged) == 0x0003E8, "Member 'AJackMiniGameRouletteMainMenu::bIsStateChanged' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinMoveTargetPos) == 0x0003EC, "Member 'AJackMiniGameRouletteMainMenu::CoinMoveTargetPos' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, bIsResultJackPot) == 0x0003F4, "Member 'AJackMiniGameRouletteMainMenu::bIsResultJackPot' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinTableType) == 0x0003F5, "Member 'AJackMiniGameRouletteMainMenu::CoinTableType' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, EaseSpeed) == 0x0003F8, "Member 'AJackMiniGameRouletteMainMenu::EaseSpeed' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, SoundCoinUp2) == 0x000400, "Member 'AJackMiniGameRouletteMainMenu::SoundCoinUp2' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, SoundCoinMoved) == 0x000408, "Member 'AJackMiniGameRouletteMainMenu::SoundCoinMoved' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, SoundGetCoin) == 0x000410, "Member 'AJackMiniGameRouletteMainMenu::SoundGetCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinUpSoundTime) == 0x000418, "Member 'AJackMiniGameRouletteMainMenu::CoinUpSoundTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinUpCurrentRatio) == 0x00041C, "Member 'AJackMiniGameRouletteMainMenu::CoinUpCurrentRatio' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinMoveSpeed) == 0x000420, "Member 'AJackMiniGameRouletteMainMenu::CoinMoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, KeyRepeatTime) == 0x000424, "Member 'AJackMiniGameRouletteMainMenu::KeyRepeatTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, CoinRepeatTime) == 0x000428, "Member 'AJackMiniGameRouletteMainMenu::CoinRepeatTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainMenu, DT_Roulette) == 0x000440, "Member 'AJackMiniGameRouletteMainMenu::DT_Roulette' has a wrong offset!");

// Class JackGame.JackGameFlagListByDataTable
// 0x00A8 (0x00E0 - 0x0038)
class UJackGameFlagListByDataTable final : public UJackGameFlagListBase
{
public:
	class UDataTable*                             DataTable;                                         // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0xA0];                                      // 0x0040(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagListByDataTable">();
	}
	static class UJackGameFlagListByDataTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagListByDataTable>();
	}
};
static_assert(alignof(UJackGameFlagListByDataTable) == 0x000008, "Wrong alignment on UJackGameFlagListByDataTable");
static_assert(sizeof(UJackGameFlagListByDataTable) == 0x0000E0, "Wrong size on UJackGameFlagListByDataTable");
static_assert(offsetof(UJackGameFlagListByDataTable, DataTable) == 0x000038, "Member 'UJackGameFlagListByDataTable::DataTable' has a wrong offset!");

// Class JackGame.JackMiniGameSlotReel
// 0x00A8 (0x0440 - 0x0398)
class AJackMiniGameSlotReel final : public AActor
{
public:
	int32                                         ReelNumber;                                        // 0x0398(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OnePictureSize;                                    // 0x039C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReelOffset;                                        // 0x03A0(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            RollInCurve;                                       // 0x03B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UCurveFloat*>                    RollOutCurves;                                     // 0x03B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         FreeRollTimeMax;                                   // 0x03C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FreeRollTime2ndMax;                                // 0x03CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddOverFreeRollTime;                               // 0x03D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxVelocity;                                       // 0x03D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReelAnimIndexOffset;                               // 0x03D8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SpawnLocationY;                                    // 0x03DC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RollEndInterpolationSpeed;                         // 0x03E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x5C];                                     // 0x03E4(0x005C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class AJackMiniGameSlotPicture*> GetReelArray();
	void Initialize(TSubclassOf<class AJackMiniGameSlotPicture> Class_0, int32 InReelNumber);
	void SetReelManager(class AJackMiniGameSlotReels* InReelManager);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameSlotReel">();
	}
	static class AJackMiniGameSlotReel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameSlotReel>();
	}
};
static_assert(alignof(AJackMiniGameSlotReel) == 0x000008, "Wrong alignment on AJackMiniGameSlotReel");
static_assert(sizeof(AJackMiniGameSlotReel) == 0x000440, "Wrong size on AJackMiniGameSlotReel");
static_assert(offsetof(AJackMiniGameSlotReel, ReelNumber) == 0x000398, "Member 'AJackMiniGameSlotReel::ReelNumber' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, OnePictureSize) == 0x00039C, "Member 'AJackMiniGameSlotReel::OnePictureSize' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, ReelOffset) == 0x0003A0, "Member 'AJackMiniGameSlotReel::ReelOffset' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, RollInCurve) == 0x0003B0, "Member 'AJackMiniGameSlotReel::RollInCurve' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, RollOutCurves) == 0x0003B8, "Member 'AJackMiniGameSlotReel::RollOutCurves' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, FreeRollTimeMax) == 0x0003C8, "Member 'AJackMiniGameSlotReel::FreeRollTimeMax' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, FreeRollTime2ndMax) == 0x0003CC, "Member 'AJackMiniGameSlotReel::FreeRollTime2ndMax' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, AddOverFreeRollTime) == 0x0003D0, "Member 'AJackMiniGameSlotReel::AddOverFreeRollTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, MaxVelocity) == 0x0003D4, "Member 'AJackMiniGameSlotReel::MaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, ReelAnimIndexOffset) == 0x0003D8, "Member 'AJackMiniGameSlotReel::ReelAnimIndexOffset' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, SpawnLocationY) == 0x0003DC, "Member 'AJackMiniGameSlotReel::SpawnLocationY' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReel, RollEndInterpolationSpeed) == 0x0003E0, "Member 'AJackMiniGameSlotReel::RollEndInterpolationSpeed' has a wrong offset!");

// Class JackGame.JackLightIntensityTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackLightIntensityTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLightIntensityTrack">();
	}
	static class UJackLightIntensityTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLightIntensityTrack>();
	}
};
static_assert(alignof(UJackLightIntensityTrack) == 0x000008, "Wrong alignment on UJackLightIntensityTrack");
static_assert(sizeof(UJackLightIntensityTrack) == 0x0000B0, "Wrong size on UJackLightIntensityTrack");

// Class JackGame.JackGameFlagListBySerifuData
// 0x0000 (0x0038 - 0x0038)
class UJackGameFlagListBySerifuData final : public UJackGameFlagListBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameFlagListBySerifuData">();
	}
	static class UJackGameFlagListBySerifuData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameFlagListBySerifuData>();
	}
};
static_assert(alignof(UJackGameFlagListBySerifuData) == 0x000008, "Wrong alignment on UJackGameFlagListBySerifuData");
static_assert(sizeof(UJackGameFlagListBySerifuData) == 0x000038, "Wrong size on UJackGameFlagListBySerifuData");

// Class JackGame.JackGameInstance
// 0x0778 (0x0870 - 0x00F8)
class UJackGameInstance : public UGameInstance
{
public:
	uint8                                         Pad_F8[0x8];                                       // 0x00F8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackSaveData*                          SaveData;                                          // 0x0100(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGameFlag*                          GameFlag;                                          // 0x0108(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackSystemData*                        SystemData;                                        // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGameDatabase*                      GameDatabase;                                      // 0x0118(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackCharacterSystem*                   CharacterSystem;                                   // 0x0120(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGamePlayer*                        GamePlayer;                                        // 0x0128(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackItemManager*                       ItemManager;                                       // 0x0130(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackItemPresentManager*                ItemPresentManager;                                // 0x0138(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackRecipeBookManager*                 RecipeBookManager;                                 // 0x0140(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMedalManager*                      MedalManager;                                      // 0x0148(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackCoinManager*                       CoinManager;                                       // 0x0150(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFacilityManager*                   FacilityManager;                                   // 0x0158(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackTokugiManager*                     TokugiManager;                                     // 0x0160(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackAchievementManager*                AchievementManager;                                // 0x0168(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackSibariManager*                     SibariManager;                                     // 0x0170(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFukkatunojumonManager*             FukkatunojumonManager;                             // 0x0178(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackSQEXNGWordManager*                 SQEXNGWordManager;                                 // 0x0180(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackOddEffectManager*                  OddEffectManager;                                  // 0x0188(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackWorldTime*                         WorldTime;                                         // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackWorldWeather*                      WorldWeather;                                      // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackKiraManager*                       KiraManager;                                       // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackDispersionManager*                 DispersionManager;                                 // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackTextManager*                       TextManager;                                       // 0x01B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackStreamableManager*                 StreamableManager;                                 // 0x01B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackPreloadMapManager*                 PreloadMapManager;                                 // 0x01C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackSoundManager*                      SoundManager;                                      // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMusicManager*                      MusicManager;                                      // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMiniGameManager*                   MiniGameManager;                                   // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackSaveLoadManager*                   SaveLoadManager;                                   // 0x01E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackShareManager*                      ShareManager;                                      // 0x01E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackInstallManager*                    InstallManager;                                    // 0x01F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGarbageCollectionManager*          GarbageCollectionManager;                          // 0x01F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUIMapManager*                      UIMapManager;                                      // 0x0200(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLocalizationManager*               LocalizationManager;                               // 0x0208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackStoreManager*                      StoreManager;                                      // 0x0210(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackImeManager*                        ImeManager;                                        // 0x0218(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackTextMacroReplaceManager*           TextMacroReplaceManager;                           // 0x0220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackCharacterCaptureCameraCharacterClassLoadManager* CharacterCaptureCameraCharacterClassLoadManager;   // 0x0228(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackModeChangeManager*                 ModeChangeManager;                                 // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackOLSManager*                        OLSManager;                                        // 0x0238(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackPairingManager*                    PairingManager;                                    // 0x0240(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TSoftClassPtr<class UClass>                   SaveDataClass;                                     // 0x0248(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GameFlagClass;                                     // 0x0260(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SystemDataClass;                                   // 0x0278(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GameDatabaseClass;                                 // 0x0290(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CharacterSystemClass;                              // 0x02A8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GamePlayerClass;                                   // 0x02C0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ItemManagerClass;                                  // 0x02D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ItemPresentManagerClass;                           // 0x02F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   RecipeBookManagerClass;                            // 0x0308(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MedalManagerClass;                                 // 0x0320(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   CoinManagerClass;                                  // 0x0338(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FacilityManagerClass;                              // 0x0350(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TokugiManagerClass;                                // 0x0368(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   AchievementManagerClass;                           // 0x0380(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SibariManagerClass;                                // 0x0398(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   FukkatunojumonManagerClass;                        // 0x03B0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SQEXNGWordManagerClass;                            // 0x03C8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   OddEffectManagerClass;                             // 0x03E0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   WorldTimeClass;                                    // 0x03F8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   WorldWeatherClass;                                 // 0x0410(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   KiraManagerClass;                                  // 0x0428(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TextManagerClass;                                  // 0x0440(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SoundManagerClass;                                 // 0x0458(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   MiniGameManagerClass;                              // 0x0470(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   SaveLoadManagerClass;                              // 0x0488(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ShareManagerClass;                                 // 0x04A0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   InstallManagerClass;                               // 0x04B8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   GarbageCollectionManagerClass;                     // 0x04D0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   UIMapManagerClass;                                 // 0x04E8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   LocalizationManagerClass;                          // 0x0500(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   StoreManagerClass;                                 // 0x0518(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   ImeManagerClass;                                   // 0x0530(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   TextMacroReplaceManagerClass;                      // 0x0548(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSoftClassPtr<class UClass>                   PairingManagerClass;                               // 0x0560(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class FString>                         DebugBatchCSSceneName;                             // 0x0578(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	bool                                          bDebugBatchCSMode;                                 // 0x0588(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_589[0x7];                                      // 0x0589(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        ResidentObjects;                                   // 0x0590(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UClass*>                         ResidentClasses;                                   // 0x05A0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class UObjectLibrary*>                 ResidentObjectLibraries;                           // 0x05B0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_5C0[0x1A0];                                    // 0x05C0(0x01A0)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIgnoreReturnToAutoSaveVolume;                     // 0x0760(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnorePlayerMakerUpdateOnTeleport;                // 0x0761(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_762[0x86];                                     // 0x0762(0x0086)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackScreenPercentageSetting>   ScreenPercentageSettings;                          // 0x07E8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	TArray<struct FJackScreenPercentageSetting>   DynamicResolutionScreenPercentageSettings;         // 0x07F8(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPrivate)
	uint8                                         Pad_808[0x68];                                     // 0x0808(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString CheckEndBatchLoop();
	bool HasDebugBatchCSSceneName();
	void JackGameInstanceDelegateCameraAndPlayerMarkerCollisionIgnored__DelegateSignature(bool bIgnored);
	void JackGameModeDelegate__DelegateSignature();
	class FString PollingBatchCheck();
	class FString PopDebugBatchCSSceneName();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameInstance">();
	}
	static class UJackGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameInstance>();
	}
};
static_assert(alignof(UJackGameInstance) == 0x000008, "Wrong alignment on UJackGameInstance");
static_assert(sizeof(UJackGameInstance) == 0x000870, "Wrong size on UJackGameInstance");
static_assert(offsetof(UJackGameInstance, SaveData) == 0x000100, "Member 'UJackGameInstance::SaveData' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GameFlag) == 0x000108, "Member 'UJackGameInstance::GameFlag' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SystemData) == 0x000110, "Member 'UJackGameInstance::SystemData' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GameDatabase) == 0x000118, "Member 'UJackGameInstance::GameDatabase' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, CharacterSystem) == 0x000120, "Member 'UJackGameInstance::CharacterSystem' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GamePlayer) == 0x000128, "Member 'UJackGameInstance::GamePlayer' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ItemManager) == 0x000130, "Member 'UJackGameInstance::ItemManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ItemPresentManager) == 0x000138, "Member 'UJackGameInstance::ItemPresentManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, RecipeBookManager) == 0x000140, "Member 'UJackGameInstance::RecipeBookManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, MedalManager) == 0x000148, "Member 'UJackGameInstance::MedalManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, CoinManager) == 0x000150, "Member 'UJackGameInstance::CoinManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, FacilityManager) == 0x000158, "Member 'UJackGameInstance::FacilityManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TokugiManager) == 0x000160, "Member 'UJackGameInstance::TokugiManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, AchievementManager) == 0x000168, "Member 'UJackGameInstance::AchievementManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SibariManager) == 0x000170, "Member 'UJackGameInstance::SibariManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, FukkatunojumonManager) == 0x000178, "Member 'UJackGameInstance::FukkatunojumonManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SQEXNGWordManager) == 0x000180, "Member 'UJackGameInstance::SQEXNGWordManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, OddEffectManager) == 0x000188, "Member 'UJackGameInstance::OddEffectManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, WorldTime) == 0x000190, "Member 'UJackGameInstance::WorldTime' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, WorldWeather) == 0x000198, "Member 'UJackGameInstance::WorldWeather' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, KiraManager) == 0x0001A0, "Member 'UJackGameInstance::KiraManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, DispersionManager) == 0x0001A8, "Member 'UJackGameInstance::DispersionManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TextManager) == 0x0001B0, "Member 'UJackGameInstance::TextManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, StreamableManager) == 0x0001B8, "Member 'UJackGameInstance::StreamableManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, PreloadMapManager) == 0x0001C0, "Member 'UJackGameInstance::PreloadMapManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SoundManager) == 0x0001C8, "Member 'UJackGameInstance::SoundManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, MusicManager) == 0x0001D0, "Member 'UJackGameInstance::MusicManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, MiniGameManager) == 0x0001D8, "Member 'UJackGameInstance::MiniGameManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SaveLoadManager) == 0x0001E0, "Member 'UJackGameInstance::SaveLoadManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ShareManager) == 0x0001E8, "Member 'UJackGameInstance::ShareManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, InstallManager) == 0x0001F0, "Member 'UJackGameInstance::InstallManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GarbageCollectionManager) == 0x0001F8, "Member 'UJackGameInstance::GarbageCollectionManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, UIMapManager) == 0x000200, "Member 'UJackGameInstance::UIMapManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, LocalizationManager) == 0x000208, "Member 'UJackGameInstance::LocalizationManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, StoreManager) == 0x000210, "Member 'UJackGameInstance::StoreManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ImeManager) == 0x000218, "Member 'UJackGameInstance::ImeManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TextMacroReplaceManager) == 0x000220, "Member 'UJackGameInstance::TextMacroReplaceManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, CharacterCaptureCameraCharacterClassLoadManager) == 0x000228, "Member 'UJackGameInstance::CharacterCaptureCameraCharacterClassLoadManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ModeChangeManager) == 0x000230, "Member 'UJackGameInstance::ModeChangeManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, OLSManager) == 0x000238, "Member 'UJackGameInstance::OLSManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, PairingManager) == 0x000240, "Member 'UJackGameInstance::PairingManager' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SaveDataClass) == 0x000248, "Member 'UJackGameInstance::SaveDataClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GameFlagClass) == 0x000260, "Member 'UJackGameInstance::GameFlagClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SystemDataClass) == 0x000278, "Member 'UJackGameInstance::SystemDataClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GameDatabaseClass) == 0x000290, "Member 'UJackGameInstance::GameDatabaseClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, CharacterSystemClass) == 0x0002A8, "Member 'UJackGameInstance::CharacterSystemClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GamePlayerClass) == 0x0002C0, "Member 'UJackGameInstance::GamePlayerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ItemManagerClass) == 0x0002D8, "Member 'UJackGameInstance::ItemManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ItemPresentManagerClass) == 0x0002F0, "Member 'UJackGameInstance::ItemPresentManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, RecipeBookManagerClass) == 0x000308, "Member 'UJackGameInstance::RecipeBookManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, MedalManagerClass) == 0x000320, "Member 'UJackGameInstance::MedalManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, CoinManagerClass) == 0x000338, "Member 'UJackGameInstance::CoinManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, FacilityManagerClass) == 0x000350, "Member 'UJackGameInstance::FacilityManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TokugiManagerClass) == 0x000368, "Member 'UJackGameInstance::TokugiManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, AchievementManagerClass) == 0x000380, "Member 'UJackGameInstance::AchievementManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SibariManagerClass) == 0x000398, "Member 'UJackGameInstance::SibariManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, FukkatunojumonManagerClass) == 0x0003B0, "Member 'UJackGameInstance::FukkatunojumonManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SQEXNGWordManagerClass) == 0x0003C8, "Member 'UJackGameInstance::SQEXNGWordManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, OddEffectManagerClass) == 0x0003E0, "Member 'UJackGameInstance::OddEffectManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, WorldTimeClass) == 0x0003F8, "Member 'UJackGameInstance::WorldTimeClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, WorldWeatherClass) == 0x000410, "Member 'UJackGameInstance::WorldWeatherClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, KiraManagerClass) == 0x000428, "Member 'UJackGameInstance::KiraManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TextManagerClass) == 0x000440, "Member 'UJackGameInstance::TextManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SoundManagerClass) == 0x000458, "Member 'UJackGameInstance::SoundManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, MiniGameManagerClass) == 0x000470, "Member 'UJackGameInstance::MiniGameManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, SaveLoadManagerClass) == 0x000488, "Member 'UJackGameInstance::SaveLoadManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ShareManagerClass) == 0x0004A0, "Member 'UJackGameInstance::ShareManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, InstallManagerClass) == 0x0004B8, "Member 'UJackGameInstance::InstallManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, GarbageCollectionManagerClass) == 0x0004D0, "Member 'UJackGameInstance::GarbageCollectionManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, UIMapManagerClass) == 0x0004E8, "Member 'UJackGameInstance::UIMapManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, LocalizationManagerClass) == 0x000500, "Member 'UJackGameInstance::LocalizationManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, StoreManagerClass) == 0x000518, "Member 'UJackGameInstance::StoreManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ImeManagerClass) == 0x000530, "Member 'UJackGameInstance::ImeManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, TextMacroReplaceManagerClass) == 0x000548, "Member 'UJackGameInstance::TextMacroReplaceManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, PairingManagerClass) == 0x000560, "Member 'UJackGameInstance::PairingManagerClass' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, DebugBatchCSSceneName) == 0x000578, "Member 'UJackGameInstance::DebugBatchCSSceneName' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, bDebugBatchCSMode) == 0x000588, "Member 'UJackGameInstance::bDebugBatchCSMode' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ResidentObjects) == 0x000590, "Member 'UJackGameInstance::ResidentObjects' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ResidentClasses) == 0x0005A0, "Member 'UJackGameInstance::ResidentClasses' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ResidentObjectLibraries) == 0x0005B0, "Member 'UJackGameInstance::ResidentObjectLibraries' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, bIgnoreReturnToAutoSaveVolume) == 0x000760, "Member 'UJackGameInstance::bIgnoreReturnToAutoSaveVolume' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, bIgnorePlayerMakerUpdateOnTeleport) == 0x000761, "Member 'UJackGameInstance::bIgnorePlayerMakerUpdateOnTeleport' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, ScreenPercentageSettings) == 0x0007E8, "Member 'UJackGameInstance::ScreenPercentageSettings' has a wrong offset!");
static_assert(offsetof(UJackGameInstance, DynamicResolutionScreenPercentageSettings) == 0x0007F8, "Member 'UJackGameInstance::DynamicResolutionScreenPercentageSettings' has a wrong offset!");

// Class JackGame.JackMiniMapTargetComponent
// 0x0020 (0x0148 - 0x0128)
class UJackMiniMapTargetComponent final : public UActorComponent
{
public:
	EJackFloorLevel                               FloorLevel;                                        // 0x0128(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFloorArea                                FloorArea;                                         // 0x0129(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapSymbol                                MapSymbol;                                         // 0x012A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMapSymbolVisible;                                 // 0x012B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              WorldMapDrawOffset;                                // 0x012C(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WorldMapDrawScale;                                 // 0x0134(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              MiniMapDrawOffset;                                 // 0x0138(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MiniMapDrawScale;                                  // 0x0140(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniMapTargetComponent">();
	}
	static class UJackMiniMapTargetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniMapTargetComponent>();
	}
};
static_assert(alignof(UJackMiniMapTargetComponent) == 0x000008, "Wrong alignment on UJackMiniMapTargetComponent");
static_assert(sizeof(UJackMiniMapTargetComponent) == 0x000148, "Wrong size on UJackMiniMapTargetComponent");
static_assert(offsetof(UJackMiniMapTargetComponent, FloorLevel) == 0x000128, "Member 'UJackMiniMapTargetComponent::FloorLevel' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, FloorArea) == 0x000129, "Member 'UJackMiniMapTargetComponent::FloorArea' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, MapSymbol) == 0x00012A, "Member 'UJackMiniMapTargetComponent::MapSymbol' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, bMapSymbolVisible) == 0x00012B, "Member 'UJackMiniMapTargetComponent::bMapSymbolVisible' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, WorldMapDrawOffset) == 0x00012C, "Member 'UJackMiniMapTargetComponent::WorldMapDrawOffset' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, WorldMapDrawScale) == 0x000134, "Member 'UJackMiniMapTargetComponent::WorldMapDrawScale' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, MiniMapDrawOffset) == 0x000138, "Member 'UJackMiniMapTargetComponent::MiniMapDrawOffset' has a wrong offset!");
static_assert(offsetof(UJackMiniMapTargetComponent, MiniMapDrawScale) == 0x000140, "Member 'UJackMiniMapTargetComponent::MiniMapDrawScale' has a wrong offset!");

// Class JackGame.JackMonsterAnimationStateMachine
// 0x00B8 (0x00F0 - 0x0038)
class UJackMonsterAnimationStateMachine final : public UObject
{
public:
	class FName                                   DefaultState;                                      // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   DamageState;                                       // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DamageBlendRate;                                   // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDead;                                             // 0x004C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDamaging;                                         // 0x004D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSpecialMove;                                      // 0x004E(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4F[0x11];                                      // 0x004F(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   OddEffectMotionID;                                 // 0x0060(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x88];                                      // 0x0068(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterAnimationStateMachine">();
	}
	static class UJackMonsterAnimationStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterAnimationStateMachine>();
	}
};
static_assert(alignof(UJackMonsterAnimationStateMachine) == 0x000008, "Wrong alignment on UJackMonsterAnimationStateMachine");
static_assert(sizeof(UJackMonsterAnimationStateMachine) == 0x0000F0, "Wrong size on UJackMonsterAnimationStateMachine");
static_assert(offsetof(UJackMonsterAnimationStateMachine, DefaultState) == 0x000038, "Member 'UJackMonsterAnimationStateMachine::DefaultState' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, DamageState) == 0x000040, "Member 'UJackMonsterAnimationStateMachine::DamageState' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, DamageBlendRate) == 0x000048, "Member 'UJackMonsterAnimationStateMachine::DamageBlendRate' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, bDead) == 0x00004C, "Member 'UJackMonsterAnimationStateMachine::bDead' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, bDamaging) == 0x00004D, "Member 'UJackMonsterAnimationStateMachine::bDamaging' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, bSpecialMove) == 0x00004E, "Member 'UJackMonsterAnimationStateMachine::bSpecialMove' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimationStateMachine, OddEffectMotionID) == 0x000060, "Member 'UJackMonsterAnimationStateMachine::OddEffectMotionID' has a wrong offset!");

// Class JackGame.JackGamePlayer
// 0x0278 (0x02B0 - 0x0038)
class UJackGamePlayer : public UObject
{
public:
	uint8                                         Pad_38[0x68];                                      // 0x0038(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackGamePlayerCondition*               GamePlayerCondition;                               // 0x00A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_A8[0x48];                                      // 0x00A8(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackFriendGameCharacter*>       GameCharacters;                                    // 0x00F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackGuestNpcGameCharacter*>     GuestNpcCharacters;                                // 0x0130(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_140[0x70];                                     // 0x0140(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<EJackCharacter, struct FJackGuestNPCLoadedResourceInfo> GuestNPCLoadedResourceInfos;                       // 0x01B0(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPublic)
	uint8                                         Pad_200[0x10];                                     // 0x0200(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AJackRuraBase>              GimmickRuraActor;                                  // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackRuraPurpose                              RuraMapJumpPurpose;                                // 0x0218(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RuraJumpTag;                                       // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraRiremitoJumpTag;                               // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRuraRiremitoJumpNonPlayer;                        // 0x0230(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                RuraRiremitoJumpStartCharacter;                    // 0x0231(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x7E];                                     // 0x0232(0x007E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 DecreaseGold(int32 InGold);
	void DepositGold(int32 InGold);
	int32 IncreaseGold(int32 InGold, bool bReflectTotalGold);
	bool IsPartyTalking();
	void OnGameModeBeginPlay();
	void WithdrawGold(int32 InGold);

	class UJackFriendGameCharacter* GetControlledGameCharacter() const;
	int32 GetDeposit() const;
	TArray<class UJackFriendGameCharacter*> GetFriendGameCharacters() const;
	int32 GetGold() const;
	TArray<class UJackFriendGameCharacter*> GetPartyMembers(bool bIncludeStandbyMember, EJackFriendCharacterQueryFilter QueryFilter) const;
	class UJackFriendGameCharacter* GetPlayerGameCharacter() const;
	bool IsAllDead() const;
	bool IsSufficientGold(int32 InGold) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGamePlayer">();
	}
	static class UJackGamePlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGamePlayer>();
	}
};
static_assert(alignof(UJackGamePlayer) == 0x000008, "Wrong alignment on UJackGamePlayer");
static_assert(sizeof(UJackGamePlayer) == 0x0002B0, "Wrong size on UJackGamePlayer");
static_assert(offsetof(UJackGamePlayer, GamePlayerCondition) == 0x0000A0, "Member 'UJackGamePlayer::GamePlayerCondition' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, GameCharacters) == 0x0000F0, "Member 'UJackGamePlayer::GameCharacters' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, GuestNpcCharacters) == 0x000130, "Member 'UJackGamePlayer::GuestNpcCharacters' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, GuestNPCLoadedResourceInfos) == 0x0001B0, "Member 'UJackGamePlayer::GuestNPCLoadedResourceInfos' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, GimmickRuraActor) == 0x000210, "Member 'UJackGamePlayer::GimmickRuraActor' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, RuraMapJumpPurpose) == 0x000218, "Member 'UJackGamePlayer::RuraMapJumpPurpose' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, RuraJumpTag) == 0x000220, "Member 'UJackGamePlayer::RuraJumpTag' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, RuraRiremitoJumpTag) == 0x000228, "Member 'UJackGamePlayer::RuraRiremitoJumpTag' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, bRuraRiremitoJumpNonPlayer) == 0x000230, "Member 'UJackGamePlayer::bRuraRiremitoJumpNonPlayer' has a wrong offset!");
static_assert(offsetof(UJackGamePlayer, RuraRiremitoJumpStartCharacter) == 0x000231, "Member 'UJackGamePlayer::RuraRiremitoJumpStartCharacter' has a wrong offset!");

// Class JackGame.JackGameSingleton
// 0x0000 (0x0038 - 0x0038)
class UJackGameSingleton final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameSingleton">();
	}
	static class UJackGameSingleton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameSingleton>();
	}
};
static_assert(alignof(UJackGameSingleton) == 0x000008, "Wrong alignment on UJackGameSingleton");
static_assert(sizeof(UJackGameSingleton) == 0x000038, "Wrong size on UJackGameSingleton");

// Class JackGame.JackGameViewportClient
// 0x00D0 (0x06F0 - 0x0620)
class UJackGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_620[0xD0];                                     // 0x0620(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGameViewportClient">();
	}
	static class UJackGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGameViewportClient>();
	}
};
static_assert(alignof(UJackGameViewportClient) == 0x000008, "Wrong alignment on UJackGameViewportClient");
static_assert(sizeof(UJackGameViewportClient) == 0x0006F0, "Wrong size on UJackGameViewportClient");

// Class JackGame.JackMeosiSlotBattleDef
// 0x0000 (0x0038 - 0x0038)
class UJackMeosiSlotBattleDef final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotBattleDef">();
	}
	static class UJackMeosiSlotBattleDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotBattleDef>();
	}
};
static_assert(alignof(UJackMeosiSlotBattleDef) == 0x000008, "Wrong alignment on UJackMeosiSlotBattleDef");
static_assert(sizeof(UJackMeosiSlotBattleDef) == 0x000038, "Wrong size on UJackMeosiSlotBattleDef");

// Class JackGame.JackGroundAffectComponent
// 0x0000 (0x02E0 - 0x02E0)
class UJackGroundAffectComponent final : public USceneComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGroundAffectComponent">();
	}
	static class UJackGroundAffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGroundAffectComponent>();
	}
};
static_assert(alignof(UJackGroundAffectComponent) == 0x000008, "Wrong alignment on UJackGroundAffectComponent");
static_assert(sizeof(UJackGroundAffectComponent) == 0x0002E0, "Wrong size on UJackGroundAffectComponent");

// Class JackGame.JackHighQualityTextureTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackHighQualityTextureTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHighQualityTextureTrack">();
	}
	static class UJackHighQualityTextureTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackHighQualityTextureTrack>();
	}
};
static_assert(alignof(UJackHighQualityTextureTrack) == 0x000008, "Wrong alignment on UJackHighQualityTextureTrack");
static_assert(sizeof(UJackHighQualityTextureTrack) == 0x0000A8, "Wrong size on UJackHighQualityTextureTrack");

// Class JackGame.JackHitStop
// 0x0098 (0x00D0 - 0x0038)
class UJackHitStop : public UObject
{
public:
	EJackWorldTimeDilation                        WorldTimeDilationType;                             // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackHitStopData                       HitStopDatas[0x8];                                 // 0x0040(0x0010)(Edit, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	EJackHitStopType                              PlayingHitStopType;                                // 0x00C0(0x0001)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1[0x3];                                       // 0x00C1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         PlayingTime;                                       // 0x00C4(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurveMaxTime;                                      // 0x00C8(0x0004)(Edit, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHitStop">();
	}
	static class UJackHitStop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackHitStop>();
	}
};
static_assert(alignof(UJackHitStop) == 0x000008, "Wrong alignment on UJackHitStop");
static_assert(sizeof(UJackHitStop) == 0x0000D0, "Wrong size on UJackHitStop");
static_assert(offsetof(UJackHitStop, WorldTimeDilationType) == 0x000038, "Member 'UJackHitStop::WorldTimeDilationType' has a wrong offset!");
static_assert(offsetof(UJackHitStop, HitStopDatas) == 0x000040, "Member 'UJackHitStop::HitStopDatas' has a wrong offset!");
static_assert(offsetof(UJackHitStop, PlayingHitStopType) == 0x0000C0, "Member 'UJackHitStop::PlayingHitStopType' has a wrong offset!");
static_assert(offsetof(UJackHitStop, PlayingTime) == 0x0000C4, "Member 'UJackHitStop::PlayingTime' has a wrong offset!");
static_assert(offsetof(UJackHitStop, CurveMaxTime) == 0x0000C8, "Member 'UJackHitStop::CurveMaxTime' has a wrong offset!");

// Class JackGame.JackHorseCharacter
// 0x0000 (0x1440 - 0x1440)
class AJackHorseCharacter final : public AJackPlayableCharacter
{
public:
	float                                         SteeringRate;                                      // 0x1438(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurnRate;                                          // 0x143C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHorseCharacter">();
	}
	static class AJackHorseCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackHorseCharacter>();
	}
};
static_assert(alignof(AJackHorseCharacter) == 0x000010, "Wrong alignment on AJackHorseCharacter");
static_assert(sizeof(AJackHorseCharacter) == 0x001440, "Wrong size on AJackHorseCharacter");
static_assert(offsetof(AJackHorseCharacter, SteeringRate) == 0x001438, "Member 'AJackHorseCharacter::SteeringRate' has a wrong offset!");
static_assert(offsetof(AJackHorseCharacter, TurnRate) == 0x00143C, "Member 'AJackHorseCharacter::TurnRate' has a wrong offset!");

// Class JackGame.JackHUD
// 0x01F0 (0x0670 - 0x0480)
class AJackHUD : public AHUD
{
public:
	bool                                          bIsTitleMode;                                      // 0x0480(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIs2DMode;                                         // 0x0481(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_482[0x26];                                     // 0x0482(0x0026)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackUIInputSettings>       UIInputSettingsClass;                              // 0x04A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUIInputSettings*                   UIInputSettings;                                   // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector2D& InVector2D)> LeftAxisDelegate;                                  // 0x04B8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector2D& InVector2D)> RightAxisDelegate;                                 // 0x04C8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(const struct FVector2D& InVector2D)> RightAxisWithButtonDelegate;                       // 0x04D8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4E8[0xE8];                                     // 0x04E8(0x00E8)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUIInputManager*                    InputManager;                                      // 0x05D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5D8[0x30];                                     // 0x05D8(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackUMGManager>            UMGManagerClass;                                   // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGManager*                        UMGManager;                                        // 0x0610(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_618[0x38];                                     // 0x0618(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDrawHUD;                                         // 0x0650(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_660[0x10];                                     // 0x0660(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AllocLeftStickToButtonBindState(struct FJackUIStickToButtonBindState* OutStickToButtonState, bool bIsNoBind);
	void BindL3Button();
	void BindL3R3Button();
	void BindLeftAxis(TDelegate<void(const struct FVector2D& InVector2D)> InDelegate);
	void JackHudInputAxisDelegate__DelegateSignature(const struct FVector2D& InVector2D);
	void BindLeftAxisToButton();
	void BindR3Button();
	void BindRightAxis(TDelegate<void(const struct FVector2D& InVector2D)> InDelegate);
	void BindRightAxisWithButton(TDelegate<void(const struct FVector2D& InVector2D)> InDelegate);
	void ClearKeyStatus();
	void DisplayUIEventLog(bool IsShow);
	void DisplayUIStickToButtonInfo();
	void EnterKeyReverse();
	void ForceUIMapVisit(bool bIsForceMapVisit);
	void MenuForceClose();
	void OnBeginPreloadMap();
	void OnDontRunWhileLoadingChanged(bool bDisable);
	void OnEndPreloadMap();
	void OutputWidgetLoadTimeLog();
	void RestoreLeftStickToButtonBindState(const struct FJackUIStickToButtonBindState& InStickToButtonState, bool bIsUnbind);
	void RuraShowAll();
	void SetBattleTopMenuOpenFlag(bool InFlag);
	void SetCacheInvalidationBox(bool bIsCache);
	void SetEnableExternalLeftAxisToButton(bool bIsEnable);
	void SetExternalLeftAxisXToButton(float InLeftAxisX);
	void SetExternalLeftAxisYToButton(float InLeftAxisY);
	void SetLeftAxisStickMode(EJackUIStickMode InStickMode);
	void SetLeftAxisToButtonDisable(bool bInDisable);
	void SetMapScrollAdjustByFrameRate(bool IsAdjust);
	void SetMapZoomMapScrollVelocityScale(float InVelocityScale);
	void SetUIASyncLoadMenuDebug();
	void SetUIDepthMask(bool bEnabled, float Width, float Height);
	void SetUIGetListOptimize(bool bIsOptimize);
	void SetUIListDebug(bool bIsDebug);
	void SetUIPlatformType(EJackUIPlatformType InUIPlatformType);
	void SetUIStickToButtonAngle(float InAngle);
	void SetUIStickToButtonThreshold(float InThreshold);
	void SetUpdateInvalidationBox(bool bIsUpdate);
	void ShowDebugKeyStatus();
	void ShowRestartLocationWindow(class FName InModeName);
	void SpawnPopupBalloon(const struct FVector& InWorldLocation, EJackPopupBalloon InPopupBalloon, int32 InNumber, class UJackGameCharacter* InGameCharacter, class USkeletalMeshComponent* InLocalMesh, class FName InSocketName);
	void TokugiForceActive(bool IsActive);
	void UnbindL3Button();
	void UnbindL3R3Button();
	void UnbindLeftAxis();
	void UnbindLeftAxisToButton();
	void UnbindR3Button();
	void UnbindRightAxis();
	void UnbindRightAxisWithButton();

	class UJackUIInputManager* GetInputManager() const;
	const struct FVector2D GetLeftStick() const;
	const struct FVector2D GetRightStick() const;
	EJackUIPlatformType GetUIPlatformType() const;
	const class UJackUMGManager* GetUMGManager() const;
	bool IsASyncLoadMenuDebug() const;
	bool IsCacheInvalidationBox() const;
	bool IsEnabledUIDepthMask() const;
	bool IsEnterButtonReverse() const;
	bool IsUIGetListOptimize() const;
	bool IsUpdateInvalidationBox() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackHUD">();
	}
	static class AJackHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackHUD>();
	}
};
static_assert(alignof(AJackHUD) == 0x000008, "Wrong alignment on AJackHUD");
static_assert(sizeof(AJackHUD) == 0x000670, "Wrong size on AJackHUD");
static_assert(offsetof(AJackHUD, bIsTitleMode) == 0x000480, "Member 'AJackHUD::bIsTitleMode' has a wrong offset!");
static_assert(offsetof(AJackHUD, bIs2DMode) == 0x000481, "Member 'AJackHUD::bIs2DMode' has a wrong offset!");
static_assert(offsetof(AJackHUD, UIInputSettingsClass) == 0x0004A8, "Member 'AJackHUD::UIInputSettingsClass' has a wrong offset!");
static_assert(offsetof(AJackHUD, UIInputSettings) == 0x0004B0, "Member 'AJackHUD::UIInputSettings' has a wrong offset!");
static_assert(offsetof(AJackHUD, LeftAxisDelegate) == 0x0004B8, "Member 'AJackHUD::LeftAxisDelegate' has a wrong offset!");
static_assert(offsetof(AJackHUD, RightAxisDelegate) == 0x0004C8, "Member 'AJackHUD::RightAxisDelegate' has a wrong offset!");
static_assert(offsetof(AJackHUD, RightAxisWithButtonDelegate) == 0x0004D8, "Member 'AJackHUD::RightAxisWithButtonDelegate' has a wrong offset!");
static_assert(offsetof(AJackHUD, InputManager) == 0x0005D0, "Member 'AJackHUD::InputManager' has a wrong offset!");
static_assert(offsetof(AJackHUD, UMGManagerClass) == 0x000608, "Member 'AJackHUD::UMGManagerClass' has a wrong offset!");
static_assert(offsetof(AJackHUD, UMGManager) == 0x000610, "Member 'AJackHUD::UMGManager' has a wrong offset!");
static_assert(offsetof(AJackHUD, OnDrawHUD) == 0x000650, "Member 'AJackHUD::OnDrawHUD' has a wrong offset!");

// Class JackGame.JackInstallManager
// 0x0108 (0x0140 - 0x0038)
class UJackInstallManager final : public UObject
{
public:
	uint8                                         Pad_38[0x108];                                     // 0x0038(0x0108)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInstallManager">();
	}
	static class UJackInstallManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInstallManager>();
	}
};
static_assert(alignof(UJackInstallManager) == 0x000008, "Wrong alignment on UJackInstallManager");
static_assert(sizeof(UJackInstallManager) == 0x000140, "Wrong size on UJackInstallManager");

// Class JackGame.JackInteractiveActorGroup
// 0x0020 (0x03B8 - 0x0398)
class AJackInteractiveActorGroup final : public AActor
{
public:
	TArray<TWeakObjectPtr<class AActor>>          GroupedActors;                                     // 0x0398(0x0010)(Edit, ZeroConstructor, DisableEditOnTemplate, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3A8[0x10];                                     // 0x03A8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInteractiveActorGroup">();
	}
	static class AJackInteractiveActorGroup* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackInteractiveActorGroup>();
	}
};
static_assert(alignof(AJackInteractiveActorGroup) == 0x000008, "Wrong alignment on AJackInteractiveActorGroup");
static_assert(sizeof(AJackInteractiveActorGroup) == 0x0003B8, "Wrong size on AJackInteractiveActorGroup");
static_assert(offsetof(AJackInteractiveActorGroup, GroupedActors) == 0x000398, "Member 'AJackInteractiveActorGroup::GroupedActors' has a wrong offset!");

// Class JackGame.JackInteractorComponent
// 0x0060 (0x0200 - 0x01A0)
class UJackInteractorComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x28];                                     // 0x01A0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackInteractorRange>           AccessibleRanges;                                  // 0x01C8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)
	EJackInteractor                               InteractorType;                                    // 0x01D8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bCanInteractInTheAir;                              // 0x01D9(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1DA[0x6];                                      // 0x01DA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TraceStartBoneName;                                // 0x01E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x18];                                     // 0x01E8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInteractiveActorComponent(class UJackInteractiveActorComponent* InInteractiveActorComponent);
	void OnInteractionCompleted__DelegateSignature(class UJackInteractorComponent* InInteractor, class UJackInteractiveActorComponent* InInteractiveActorComponent);
	void RemoveInteractiveActorComponent(class UJackInteractiveActorComponent* InInteractiveActorComponent);

	EJackInteractor GetInteractorType() const;
	bool IsInInteraction() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInteractorComponent">();
	}
	static class UJackInteractorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInteractorComponent>();
	}
};
static_assert(alignof(UJackInteractorComponent) == 0x000008, "Wrong alignment on UJackInteractorComponent");
static_assert(sizeof(UJackInteractorComponent) == 0x000200, "Wrong size on UJackInteractorComponent");
static_assert(offsetof(UJackInteractorComponent, AccessibleRanges) == 0x0001C8, "Member 'UJackInteractorComponent::AccessibleRanges' has a wrong offset!");
static_assert(offsetof(UJackInteractorComponent, InteractorType) == 0x0001D8, "Member 'UJackInteractorComponent::InteractorType' has a wrong offset!");
static_assert(offsetof(UJackInteractorComponent, bCanInteractInTheAir) == 0x0001D9, "Member 'UJackInteractorComponent::bCanInteractInTheAir' has a wrong offset!");
static_assert(offsetof(UJackInteractorComponent, TraceStartBoneName) == 0x0001E0, "Member 'UJackInteractorComponent::TraceStartBoneName' has a wrong offset!");

// Class JackGame.JackInterruptFootIKEnableTrack
// 0x0010 (0x00B8 - 0x00A8)
class UJackInterruptFootIKEnableTrack final : public UJackToggleBaseTrack
{
public:
	TArray<class FName>                           TargetSocketNameList;                              // 0x00A8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackInterruptFootIKEnableTrack">();
	}
	static class UJackInterruptFootIKEnableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackInterruptFootIKEnableTrack>();
	}
};
static_assert(alignof(UJackInterruptFootIKEnableTrack) == 0x000008, "Wrong alignment on UJackInterruptFootIKEnableTrack");
static_assert(sizeof(UJackInterruptFootIKEnableTrack) == 0x0000B8, "Wrong size on UJackInterruptFootIKEnableTrack");
static_assert(offsetof(UJackInterruptFootIKEnableTrack, TargetSocketNameList) == 0x0000A8, "Member 'UJackInterruptFootIKEnableTrack::TargetSocketNameList' has a wrong offset!");

// Class JackGame.JackItemGettableObjectBase
// 0x0020 (0x03B8 - 0x0398)
class AJackItemGettableObjectBase : public AActor
{
public:
	class FName                                   RefreshEventName;                                  // 0x0398(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReceiveMessage;                                  // 0x03A0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bEnabledDisplayDebugInfo;                          // 0x03B0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString OnGenerateDebugInfoString();
	void ReceiveMessageDelegate__DelegateSignature(const class FString& Message, class AActor* Sender);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackItemGettableObjectBase">();
	}
	static class AJackItemGettableObjectBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackItemGettableObjectBase>();
	}
};
static_assert(alignof(AJackItemGettableObjectBase) == 0x000008, "Wrong alignment on AJackItemGettableObjectBase");
static_assert(sizeof(AJackItemGettableObjectBase) == 0x0003B8, "Wrong size on AJackItemGettableObjectBase");
static_assert(offsetof(AJackItemGettableObjectBase, RefreshEventName) == 0x000398, "Member 'AJackItemGettableObjectBase::RefreshEventName' has a wrong offset!");
static_assert(offsetof(AJackItemGettableObjectBase, OnReceiveMessage) == 0x0003A0, "Member 'AJackItemGettableObjectBase::OnReceiveMessage' has a wrong offset!");
static_assert(offsetof(AJackItemGettableObjectBase, bEnabledDisplayDebugInfo) == 0x0003B0, "Member 'AJackItemGettableObjectBase::bEnabledDisplayDebugInfo' has a wrong offset!");

// Class JackGame.JackItemPresentManager
// 0x0120 (0x0170 - 0x0050)
class UJackItemPresentManager : public UJackTickableGameObject
{
public:
	uint8                                         Pad_50[0x8];                                       // 0x0050(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnVestedFlagDelegate;                              // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x50];                                      // 0x0068(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UDataTable*>                     DLCDataTables;                                     // 0x00B8(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_C8[0xA8];                                      // 0x00C8(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DlcDataUpdateStart();
	TArray<struct FJackItemPresentTitle> GetItemPresentTitleList();
	bool IsCheckDlcDataUpdateEnd();
	bool IsVestedFlag(class FName DlcId);
	void OnVestedFlag(class FName DlcId);
	void OnVestedFlagDelegate__DelegateSignature();
	void ReceiveItemPresent(class FName DlcId);

	bool CheckExcessItem(const struct FJackItemPresentPackage& InPackage) const;
	bool GetItemPresentPackage(class FName DlcId, struct FJackItemPresentPackage* OutPackage) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackItemPresentManager">();
	}
	static class UJackItemPresentManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackItemPresentManager>();
	}
};
static_assert(alignof(UJackItemPresentManager) == 0x000008, "Wrong alignment on UJackItemPresentManager");
static_assert(sizeof(UJackItemPresentManager) == 0x000170, "Wrong size on UJackItemPresentManager");
static_assert(offsetof(UJackItemPresentManager, OnVestedFlagDelegate) == 0x000058, "Member 'UJackItemPresentManager::OnVestedFlagDelegate' has a wrong offset!");
static_assert(offsetof(UJackItemPresentManager, DLCDataTables) == 0x0000B8, "Member 'UJackItemPresentManager::DLCDataTables' has a wrong offset!");

// Class JackGame.JackJumpLabelTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackJumpLabelTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackJumpLabelTrackInst">();
	}
	static class UJackJumpLabelTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackJumpLabelTrackInst>();
	}
};
static_assert(alignof(UJackJumpLabelTrackInst) == 0x000008, "Wrong alignment on UJackJumpLabelTrackInst");
static_assert(sizeof(UJackJumpLabelTrackInst) == 0x000038, "Wrong size on UJackJumpLabelTrackInst");

// Class JackGame.JackJumpPlayerCameraData
// 0x0010 (0x0368 - 0x0358)
class UJackJumpPlayerCameraData final : public UJackPlayerCameraData
{
public:
	float                                         FallingCameraAngleTargetPitch;                     // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingCameraInterpSpeed;                          // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingEndCenterdPitch;                            // 0x0360(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FallingEndInterpSpeed;                             // 0x0364(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackJumpPlayerCameraData">();
	}
	static class UJackJumpPlayerCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackJumpPlayerCameraData>();
	}
};
static_assert(alignof(UJackJumpPlayerCameraData) == 0x000008, "Wrong alignment on UJackJumpPlayerCameraData");
static_assert(sizeof(UJackJumpPlayerCameraData) == 0x000368, "Wrong size on UJackJumpPlayerCameraData");
static_assert(offsetof(UJackJumpPlayerCameraData, FallingCameraAngleTargetPitch) == 0x000358, "Member 'UJackJumpPlayerCameraData::FallingCameraAngleTargetPitch' has a wrong offset!");
static_assert(offsetof(UJackJumpPlayerCameraData, FallingCameraInterpSpeed) == 0x00035C, "Member 'UJackJumpPlayerCameraData::FallingCameraInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackJumpPlayerCameraData, FallingEndCenterdPitch) == 0x000360, "Member 'UJackJumpPlayerCameraData::FallingEndCenterdPitch' has a wrong offset!");
static_assert(offsetof(UJackJumpPlayerCameraData, FallingEndInterpSpeed) == 0x000364, "Member 'UJackJumpPlayerCameraData::FallingEndInterpSpeed' has a wrong offset!");

// Class JackGame.JackKnockBackComponent
// 0x0020 (0x01C0 - 0x01A0)
class UJackKnockBackComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackKnockBackComponent">();
	}
	static class UJackKnockBackComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackKnockBackComponent>();
	}
};
static_assert(alignof(UJackKnockBackComponent) == 0x000008, "Wrong alignment on UJackKnockBackComponent");
static_assert(sizeof(UJackKnockBackComponent) == 0x0001C0, "Wrong size on UJackKnockBackComponent");

// Class JackGame.JackLazyMessageManager
// 0x0018 (0x03B0 - 0x0398)
class AJackLazyMessageManager : public AActor
{
public:
	uint8                                         Pad_398[0x18];                                     // 0x0398(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallTryPossessControll();
	bool HasAchievement();
	bool HasMessage();
	bool IsDrawing();
	bool IsDrawingWait();
	bool IsTaughtTabiNoKokoroe(class FName RowName);
	void OnLazyMessageConditionChanged(bool bDisabled);
	void OnTryPossessControll();
	void OnViewAllEnd();
	void OnViewStartAchievement(class FName AchieveId);
	void OnViewStartMessage(class FName TextID, const TArray<struct FJackMessageArgumentData>& Args);
	void OnViewTabiNoKokoroe(class FName RowName);
	void SetEmptyEnd();
	void SetMessage(EJackLazyMessageQueueId TypeId, class FName TextID, const TArray<struct FJackMessageArgumentData>& Args);
	void SetOffAchievementMessage(bool bOn);
	void SetOffTutorialMessage(bool bOn);
	void SetPartyConditionOffMessage(class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	void SetPossessControlGet();
	void SetQuestMessage(class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	void SetTabiNoKokoroe(class FName KeyRowName);
	void SetTokugiOkMessage(class FName TextID, const TArray<struct FJackMessageArgumentData>& InArgs);
	void SetViewEnd();
	class UJackUMGAccessorCommon* ViewTabiNoKokoroe(class FName RowName);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLazyMessageManager">();
	}
	static class AJackLazyMessageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackLazyMessageManager>();
	}
};
static_assert(alignof(AJackLazyMessageManager) == 0x000008, "Wrong alignment on AJackLazyMessageManager");
static_assert(sizeof(AJackLazyMessageManager) == 0x0003B0, "Wrong size on AJackLazyMessageManager");

// Class JackGame.JackLightIntensityTrackInst
// 0x0010 (0x0048 - 0x0038)
class UJackLightIntensityTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLightIntensityTrackInst">();
	}
	static class UJackLightIntensityTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLightIntensityTrackInst>();
	}
};
static_assert(alignof(UJackLightIntensityTrackInst) == 0x000008, "Wrong alignment on UJackLightIntensityTrackInst");
static_assert(sizeof(UJackLightIntensityTrackInst) == 0x000048, "Wrong size on UJackLightIntensityTrackInst");

// Class JackGame.JackLipSyncEnableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackLipSyncEnableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLipSyncEnableTrackInst">();
	}
	static class UJackLipSyncEnableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLipSyncEnableTrackInst>();
	}
};
static_assert(alignof(UJackLipSyncEnableTrackInst) == 0x000008, "Wrong alignment on UJackLipSyncEnableTrackInst");
static_assert(sizeof(UJackLipSyncEnableTrackInst) == 0x000040, "Wrong size on UJackLipSyncEnableTrackInst");

// Class JackGame.JackLoadReductionEnableTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackLoadReductionEnableTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLoadReductionEnableTrack">();
	}
	static class UJackLoadReductionEnableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackLoadReductionEnableTrack>();
	}
};
static_assert(alignof(UJackLoadReductionEnableTrack) == 0x000008, "Wrong alignment on UJackLoadReductionEnableTrack");
static_assert(sizeof(UJackLoadReductionEnableTrack) == 0x0000A8, "Wrong size on UJackLoadReductionEnableTrack");

// Class JackGame.JackLocatorContainer
// 0x0008 (0x03A0 - 0x0398)
class AJackLocatorContainer final : public AActor
{
public:
	class UJackLocatorAccessComponent*            LocatorAccess;                                     // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackLocatorContainer">();
	}
	static class AJackLocatorContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackLocatorContainer>();
	}
};
static_assert(alignof(AJackLocatorContainer) == 0x000008, "Wrong alignment on AJackLocatorContainer");
static_assert(sizeof(AJackLocatorContainer) == 0x0003A0, "Wrong size on AJackLocatorContainer");
static_assert(offsetof(AJackLocatorContainer, LocatorAccess) == 0x000398, "Member 'AJackLocatorContainer::LocatorAccess' has a wrong offset!");

// Class JackGame.JackMap3StepAnimKiraAccessor
// 0x0008 (0x0048 - 0x0040)
class UJackMap3StepAnimKiraAccessor final : public UJackMapKiraAccessorBase
{
public:
	TWeakObjectPtr<class AJack3StepAnimActor>     KiraActor;                                         // 0x0040(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool CanPickUp() const;
	TArray<class FName> GetCandidateItemIDList() const;
	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	class AActor* GetKiraActor() const;
	class FName GetKiraName() const;
	bool HasPickedUp() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMap3StepAnimKiraAccessor">();
	}
	static class UJackMap3StepAnimKiraAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMap3StepAnimKiraAccessor>();
	}
};
static_assert(alignof(UJackMap3StepAnimKiraAccessor) == 0x000008, "Wrong alignment on UJackMap3StepAnimKiraAccessor");
static_assert(sizeof(UJackMap3StepAnimKiraAccessor) == 0x000048, "Wrong size on UJackMap3StepAnimKiraAccessor");
static_assert(offsetof(UJackMap3StepAnimKiraAccessor, KiraActor) == 0x000040, "Member 'UJackMap3StepAnimKiraAccessor::KiraActor' has a wrong offset!");

// Class JackGame.JackUMGKiraItemSyousai
// 0x0010 (0x0128 - 0x0118)
class UJackUMGKiraItemSyousai final : public UJackUMGItemSyousai
{
public:
	TArray<int32>                                 KiraAccessorNoList;                                // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGKiraItemSyousai">();
	}
	static class UJackUMGKiraItemSyousai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGKiraItemSyousai>();
	}
};
static_assert(alignof(UJackUMGKiraItemSyousai) == 0x000008, "Wrong alignment on UJackUMGKiraItemSyousai");
static_assert(sizeof(UJackUMGKiraItemSyousai) == 0x000128, "Wrong size on UJackUMGKiraItemSyousai");
static_assert(offsetof(UJackUMGKiraItemSyousai, KiraAccessorNoList) == 0x000118, "Member 'UJackUMGKiraItemSyousai::KiraAccessorNoList' has a wrong offset!");

// Class JackGame.JackMapStart
// 0x0038 (0x0400 - 0x03C8)
class AJackMapStart final : public APlayerStart
{
public:
	uint8                                         Pad_3C8[0x10];                                     // 0x03C8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLDT_MapStart                      MapStart;                                          // 0x03D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	class UCapsuleComponent*                      Follower0CapsuleComponent;                         // 0x03E8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      Follower1CapsuleComponent;                         // 0x03F0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      Follower2CapsuleComponent;                         // 0x03F8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class UTextRenderComponent* GetDebugTextComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMapStart">();
	}
	static class AJackMapStart* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMapStart>();
	}
};
static_assert(alignof(AJackMapStart) == 0x000008, "Wrong alignment on AJackMapStart");
static_assert(sizeof(AJackMapStart) == 0x000400, "Wrong size on AJackMapStart");
static_assert(offsetof(AJackMapStart, MapStart) == 0x0003D8, "Member 'AJackMapStart::MapStart' has a wrong offset!");
static_assert(offsetof(AJackMapStart, Follower0CapsuleComponent) == 0x0003E8, "Member 'AJackMapStart::Follower0CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AJackMapStart, Follower1CapsuleComponent) == 0x0003F0, "Member 'AJackMapStart::Follower1CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AJackMapStart, Follower2CapsuleComponent) == 0x0003F8, "Member 'AJackMapStart::Follower2CapsuleComponent' has a wrong offset!");

// Class JackGame.JackMaterialUpdaterCurve
// 0x0030 (0x0130 - 0x0100)
class UJackMaterialUpdaterCurve final : public UJackMaterialUpdater
{
public:
	uint8                                         Pad_100[0x30];                                     // 0x0100(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterCurve">();
	}
	static class UJackMaterialUpdaterCurve* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterCurve>();
	}
};
static_assert(alignof(UJackMaterialUpdaterCurve) == 0x000008, "Wrong alignment on UJackMaterialUpdaterCurve");
static_assert(sizeof(UJackMaterialUpdaterCurve) == 0x000130, "Wrong size on UJackMaterialUpdaterCurve");

// Class JackGame.JackMaterialUpdaterDT
// 0x0040 (0x0140 - 0x0100)
class UJackMaterialUpdaterDT final : public UJackMaterialUpdater
{
public:
	uint8                                         Pad_100[0x18];                                     // 0x0100(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveBase*                             StartCurve;                                        // 0x0118(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveBase*                             LoopCurve;                                         // 0x0120(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UCurveBase*                             EndCurve;                                          // 0x0128(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_130[0x10];                                     // 0x0130(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterDT">();
	}
	static class UJackMaterialUpdaterDT* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterDT>();
	}
};
static_assert(alignof(UJackMaterialUpdaterDT) == 0x000008, "Wrong alignment on UJackMaterialUpdaterDT");
static_assert(sizeof(UJackMaterialUpdaterDT) == 0x000140, "Wrong size on UJackMaterialUpdaterDT");
static_assert(offsetof(UJackMaterialUpdaterDT, StartCurve) == 0x000118, "Member 'UJackMaterialUpdaterDT::StartCurve' has a wrong offset!");
static_assert(offsetof(UJackMaterialUpdaterDT, LoopCurve) == 0x000120, "Member 'UJackMaterialUpdaterDT::LoopCurve' has a wrong offset!");
static_assert(offsetof(UJackMaterialUpdaterDT, EndCurve) == 0x000128, "Member 'UJackMaterialUpdaterDT::EndCurve' has a wrong offset!");

// Class JackGame.JackMaterialUpdaterHandle
// 0x0000 (0x0038 - 0x0038)
class UJackMaterialUpdaterHandle final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterHandle">();
	}
	static class UJackMaterialUpdaterHandle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterHandle>();
	}
};
static_assert(alignof(UJackMaterialUpdaterHandle) == 0x000008, "Wrong alignment on UJackMaterialUpdaterHandle");
static_assert(sizeof(UJackMaterialUpdaterHandle) == 0x000038, "Wrong size on UJackMaterialUpdaterHandle");

// Class JackGame.JackMaterialUpdaterVector
// 0x0040 (0x0140 - 0x0100)
class UJackMaterialUpdaterVector final : public UJackMaterialUpdater
{
public:
	uint8                                         Pad_100[0x40];                                     // 0x0100(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMaterialUpdaterVector">();
	}
	static class UJackMaterialUpdaterVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMaterialUpdaterVector>();
	}
};
static_assert(alignof(UJackMaterialUpdaterVector) == 0x000008, "Wrong alignment on UJackMaterialUpdaterVector");
static_assert(sizeof(UJackMaterialUpdaterVector) == 0x000140, "Wrong size on UJackMaterialUpdaterVector");

// Class JackGame.JackMatineeActorEventReceiver
// 0x0000 (0x0038 - 0x0038)
class UJackMatineeActorEventReceiver final : public UMatineeActorEventReceiver
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeActorEventReceiver">();
	}
	static class UJackMatineeActorEventReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMatineeActorEventReceiver>();
	}
};
static_assert(alignof(UJackMatineeActorEventReceiver) == 0x000008, "Wrong alignment on UJackMatineeActorEventReceiver");
static_assert(sizeof(UJackMatineeActorEventReceiver) == 0x000038, "Wrong size on UJackMatineeActorEventReceiver");

// Class JackGame.JackMatineeCameraActor
// 0x0030 (0x0900 - 0x08D0)
class AJackMatineeCameraActor final : public ACameraActor
{
public:
	TWeakObjectPtr<class AMatineeActor>           MatineeActor;                                      // 0x08D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MatineeRotation;                                   // 0x08D8(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         MobileRegionX;                                     // 0x08E4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MobileRegionY;                                     // 0x08E8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x08EC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOperationUpdate;                                  // 0x08F0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F1[0xF];                                      // 0x08F1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayMatinee(class AMatineeActor* Matinee);

	bool DoesInvertHorizontalCameraControl() const;
	bool DoesInvertVerticalCameraControl() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeCameraActor">();
	}
	static class AJackMatineeCameraActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMatineeCameraActor>();
	}
};
static_assert(alignof(AJackMatineeCameraActor) == 0x000010, "Wrong alignment on AJackMatineeCameraActor");
static_assert(sizeof(AJackMatineeCameraActor) == 0x000900, "Wrong size on AJackMatineeCameraActor");
static_assert(offsetof(AJackMatineeCameraActor, MatineeActor) == 0x0008D0, "Member 'AJackMatineeCameraActor::MatineeActor' has a wrong offset!");
static_assert(offsetof(AJackMatineeCameraActor, MatineeRotation) == 0x0008D8, "Member 'AJackMatineeCameraActor::MatineeRotation' has a wrong offset!");
static_assert(offsetof(AJackMatineeCameraActor, MobileRegionX) == 0x0008E4, "Member 'AJackMatineeCameraActor::MobileRegionX' has a wrong offset!");
static_assert(offsetof(AJackMatineeCameraActor, MobileRegionY) == 0x0008E8, "Member 'AJackMatineeCameraActor::MobileRegionY' has a wrong offset!");
static_assert(offsetof(AJackMatineeCameraActor, MoveSpeed) == 0x0008EC, "Member 'AJackMatineeCameraActor::MoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackMatineeCameraActor, bOperationUpdate) == 0x0008F0, "Member 'AJackMatineeCameraActor::bOperationUpdate' has a wrong offset!");

// Class JackGame.JackMatineeClassOverrider
// 0x0020 (0x0058 - 0x0038)
class UJackMatineeClassOverrider final : public UMatineeClassOverrider
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeClassOverrider">();
	}
	static class UJackMatineeClassOverrider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMatineeClassOverrider>();
	}
};
static_assert(alignof(UJackMatineeClassOverrider) == 0x000008, "Wrong alignment on UJackMatineeClassOverrider");
static_assert(sizeof(UJackMatineeClassOverrider) == 0x000058, "Wrong size on UJackMatineeClassOverrider");

// Class JackGame.JackMatineeControlComponent
// 0x0410 (0x05B0 - 0x01A0)
class UJackMatineeControlComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x60];                                     // 0x01A0(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDeclarationUseInMatinee;                          // 0x0200(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_201[0x3];                                      // 0x0201(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatineeAnimationBlendTime;                         // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequence*                          MatineeCaptionBlendAnimation;                      // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UBlendSpace1D*                          MovementBlendSpace;                                // 0x0210(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AutoMovementInterpSec;                             // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21C[0x4];                                      // 0x021C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLDT_NPCList                       MatineeUNID;                                       // 0x0220(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EJackPipipiType                               MatineePipipiType;                                 // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bResetAnimationByTimelineJump;                     // 0x0231(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_232[0x2];                                      // 0x0232(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NodAnimationDefaultApplyRate;                      // 0x0234(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseHighQualityTexture;                            // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWaitTextureLoadCSBefore;                          // 0x0239(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceSenaShortHairFlag;                           // 0x023A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23B[0x5];                                      // 0x023B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             AnimationRateDataTable;                            // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayCoordSoundInCutScene;                         // 0x0248(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOptimizeForCrowd;                               // 0x0249(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOptimizeForCrowdMasterpose;                     // 0x024A(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24B[0x25D];                                    // 0x024B(0x025D)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimSequence*                          LastAdditiveAnimSequence;                          // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimSequence*                          LastNodAnimSequence;                               // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4B8[0x1];                                      // 0x04B8(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIsMatineeControlled;                              // 0x04B9(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4BA[0x2];                                      // 0x04BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MatineeApplyRate;                                  // 0x04BC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BlendApplyRate;                                    // 0x04C0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         InitializeBlendApplyRate;                          // 0x04C4(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         PrevFrameBlendApplyRate;                           // 0x04C8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MoveLength;                                        // 0x04CC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoMovementApplyRateLinear;                       // 0x04D0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOverrideAutoMovementApplyRate;                  // 0x04D4(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4D5[0x3];                                      // 0x04D5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverrideAutoMovementApplyRate;                     // 0x04D8(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         TonePowerByTrack;                                  // 0x04DC(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         AnimationIntervalCount;                            // 0x04E0(0x0004)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_4E4[0xCC];                                     // 0x04E4(0x00CC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetMatineeAdditiveAnimationApplyRate() const;
	float GetMatineeAnimationApplyRate() const;
	float GetMatineeBlendAnimationApplyRate() const;
	float GetMatineeCaptionBlendAnimationApplyRate() const;
	float GetMatineeNodAnimationApplyRate() const;
	bool IsDeclarationToUseMatinee() const;
	bool IsMatineeControlled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMatineeControlComponent">();
	}
	static class UJackMatineeControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMatineeControlComponent>();
	}
};
static_assert(alignof(UJackMatineeControlComponent) == 0x000008, "Wrong alignment on UJackMatineeControlComponent");
static_assert(sizeof(UJackMatineeControlComponent) == 0x0005B0, "Wrong size on UJackMatineeControlComponent");
static_assert(offsetof(UJackMatineeControlComponent, bDeclarationUseInMatinee) == 0x000200, "Member 'UJackMatineeControlComponent::bDeclarationUseInMatinee' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MatineeAnimationBlendTime) == 0x000204, "Member 'UJackMatineeControlComponent::MatineeAnimationBlendTime' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MatineeCaptionBlendAnimation) == 0x000208, "Member 'UJackMatineeControlComponent::MatineeCaptionBlendAnimation' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MovementBlendSpace) == 0x000210, "Member 'UJackMatineeControlComponent::MovementBlendSpace' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, AutoMovementInterpSec) == 0x000218, "Member 'UJackMatineeControlComponent::AutoMovementInterpSec' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MatineeUNID) == 0x000220, "Member 'UJackMatineeControlComponent::MatineeUNID' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MatineePipipiType) == 0x000230, "Member 'UJackMatineeControlComponent::MatineePipipiType' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bResetAnimationByTimelineJump) == 0x000231, "Member 'UJackMatineeControlComponent::bResetAnimationByTimelineJump' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, NodAnimationDefaultApplyRate) == 0x000234, "Member 'UJackMatineeControlComponent::NodAnimationDefaultApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bUseHighQualityTexture) == 0x000238, "Member 'UJackMatineeControlComponent::bUseHighQualityTexture' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bWaitTextureLoadCSBefore) == 0x000239, "Member 'UJackMatineeControlComponent::bWaitTextureLoadCSBefore' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bForceSenaShortHairFlag) == 0x00023A, "Member 'UJackMatineeControlComponent::bForceSenaShortHairFlag' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, AnimationRateDataTable) == 0x000240, "Member 'UJackMatineeControlComponent::AnimationRateDataTable' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bPlayCoordSoundInCutScene) == 0x000248, "Member 'UJackMatineeControlComponent::bPlayCoordSoundInCutScene' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bIsOptimizeForCrowd) == 0x000249, "Member 'UJackMatineeControlComponent::bIsOptimizeForCrowd' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bIsOptimizeForCrowdMasterpose) == 0x00024A, "Member 'UJackMatineeControlComponent::bIsOptimizeForCrowdMasterpose' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, LastAdditiveAnimSequence) == 0x0004A8, "Member 'UJackMatineeControlComponent::LastAdditiveAnimSequence' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, LastNodAnimSequence) == 0x0004B0, "Member 'UJackMatineeControlComponent::LastNodAnimSequence' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bIsMatineeControlled) == 0x0004B9, "Member 'UJackMatineeControlComponent::bIsMatineeControlled' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MatineeApplyRate) == 0x0004BC, "Member 'UJackMatineeControlComponent::MatineeApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, BlendApplyRate) == 0x0004C0, "Member 'UJackMatineeControlComponent::BlendApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, InitializeBlendApplyRate) == 0x0004C4, "Member 'UJackMatineeControlComponent::InitializeBlendApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, PrevFrameBlendApplyRate) == 0x0004C8, "Member 'UJackMatineeControlComponent::PrevFrameBlendApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, MoveLength) == 0x0004CC, "Member 'UJackMatineeControlComponent::MoveLength' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, AutoMovementApplyRateLinear) == 0x0004D0, "Member 'UJackMatineeControlComponent::AutoMovementApplyRateLinear' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, bIsOverrideAutoMovementApplyRate) == 0x0004D4, "Member 'UJackMatineeControlComponent::bIsOverrideAutoMovementApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, OverrideAutoMovementApplyRate) == 0x0004D8, "Member 'UJackMatineeControlComponent::OverrideAutoMovementApplyRate' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, TonePowerByTrack) == 0x0004DC, "Member 'UJackMatineeControlComponent::TonePowerByTrack' has a wrong offset!");
static_assert(offsetof(UJackMatineeControlComponent, AnimationIntervalCount) == 0x0004E0, "Member 'UJackMatineeControlComponent::AnimationIntervalCount' has a wrong offset!");

// Class JackGame.JackMEControlTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackMEControlTrack final : public UInterpTrack
{
public:
	class UDataTable*                             MEDataTable;                                       // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackMEControlTrackKey>         KeyArray;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMEControlTrack">();
	}
	static class UJackMEControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMEControlTrack>();
	}
};
static_assert(alignof(UJackMEControlTrack) == 0x000008, "Wrong alignment on UJackMEControlTrack");
static_assert(sizeof(UJackMEControlTrack) == 0x0000A8, "Wrong size on UJackMEControlTrack");
static_assert(offsetof(UJackMEControlTrack, MEDataTable) == 0x000090, "Member 'UJackMEControlTrack::MEDataTable' has a wrong offset!");
static_assert(offsetof(UJackMEControlTrack, KeyArray) == 0x000098, "Member 'UJackMEControlTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackMEControlTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackMEControlTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMEControlTrackInst">();
	}
	static class UJackMEControlTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMEControlTrackInst>();
	}
};
static_assert(alignof(UJackMEControlTrackInst) == 0x000008, "Wrong alignment on UJackMEControlTrackInst");
static_assert(sizeof(UJackMEControlTrackInst) == 0x000040, "Wrong size on UJackMEControlTrackInst");

// Class JackGame.JackMedalManager
// 0x0030 (0x0068 - 0x0038)
class UJackMedalManager : public UObject
{
public:
	class UDataTable*                             MedalStampDataTable;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             MedalExchangeDataTable;                            // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x20];                                      // 0x0048(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ExchangeItem(class FName ExchangeId, int32 ExchangeCount);
	void GetMedalStampBook();
	int32 StampPress(EJackMedal_Shop ShopType);
	int32 StampPressFromStampPressInfo(EJackMedal_Shop ShopType, const struct FJackMedal_StampPress& StampPressInfo);
	int32 StampPressFromStampPressPageInfo(EJackMedal_Shop ShopType, const struct FJackMedal_StampPressPage& StampPressPageInfo);

	EJackMedal_StampPage GetCurrentPageType() const;
	EJackMedal_Event GetEventType(EJackMedal_Shop ShopType) const;
	TArray<struct FJackMedal_ExchageItem> GetExchangeItemList() const;
	int32 GetHaveMedalNumber() const;
	int32 GetLimitStampNumber() const;
	EJackMedal_Trade GetMedalTradeType(EJackMedal_Shop ShopType) const;
	void GetNextStampItem(class FName* OutItemId, int32* OutStampNumber) const;
	EJackMedal_StampPage GetStampCompletePageType() const;
	int32 GetStampNumber() const;
	int32 GetStampNumberAtPage(EJackMedal_StampPage PageType) const;
	TArray<struct FJackMedal_StampPressPage> GetStampPreessPageInfo(EJackMedal_Shop ShopType) const;
	TArray<struct FJackMedal_StampPress> GetStampPressInfo(EJackMedal_Shop ShopType) const;
	int32 GetStampPressItem(EJackMedal_Shop ShopType, TArray<class FName>* OutItemIdList, TArray<EJackMedal_StampPage>* OutCompletePageTypeList) const;
	bool GetUnlockMedalStampFlag() const;
	bool GetUnlockTiisanaMedalFlag() const;
	bool HasMedalStampBook() const;
	bool IsComplatedPage(EJackMedal_StampPage PageType) const;
	bool IsHaveStampPage2() const;
	bool IsHaveStampPage4() const;
	bool IsShowableNextStampItem(int32 NextItemStampNumber) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMedalManager">();
	}
	static class UJackMedalManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMedalManager>();
	}
};
static_assert(alignof(UJackMedalManager) == 0x000008, "Wrong alignment on UJackMedalManager");
static_assert(sizeof(UJackMedalManager) == 0x000068, "Wrong size on UJackMedalManager");
static_assert(offsetof(UJackMedalManager, MedalStampDataTable) == 0x000038, "Member 'UJackMedalManager::MedalStampDataTable' has a wrong offset!");
static_assert(offsetof(UJackMedalManager, MedalExchangeDataTable) == 0x000040, "Member 'UJackMedalManager::MedalExchangeDataTable' has a wrong offset!");

// Class JackGame.JackMenuCharacter
// 0x0010 (0x1100 - 0x10F0)
class AJackMenuCharacter final : public AJackCharacter
{
public:
	class UJackEquipmentControlComponent*         EquipmentControlComponent;                         // 0x10F0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_10F8[0x8];                                     // 0x10F8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMenuCharacter">();
	}
	static class AJackMenuCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMenuCharacter>();
	}
};
static_assert(alignof(AJackMenuCharacter) == 0x000010, "Wrong alignment on AJackMenuCharacter");
static_assert(sizeof(AJackMenuCharacter) == 0x001100, "Wrong size on AJackMenuCharacter");
static_assert(offsetof(AJackMenuCharacter, EquipmentControlComponent) == 0x0010F0, "Member 'AJackMenuCharacter::EquipmentControlComponent' has a wrong offset!");

// Class JackGame.JackMeosiSlotAccessor
// 0x0010 (0x0048 - 0x0038)
class UJackMeosiSlotAccessor final : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyLocationTime(EJackMiniGameMeosiSlotPoint Locale, int32 NowTime);
	int32 CalcAddGameCount(EJackMiniGameMeosiSlotPoint Locale, int32 NowTime);
	TArray<struct FJackMeosiSlotDataRoboHighlight> GetDataRoboHighlight(const TArray<struct FJackMeosiSlotVariableStateParam>& InParams);
	class FName GetFriendMonsterCommentTextID(int32 FriendMonsterNum);
	EJackMeosiSlotMachineCondition GetMachineCondition(const struct FJackMeosiSlotVariableStateParam& InParam);
	class FName GetMonsterKilledCommentTextID(int32 MonsterKilledNum, int32 CeilingValue);
	class FName GetOrbCommentTextID(int32 OrbNum);
	bool HaveSmaleRoleCounter();
	void ResetSettingValue();
	void SetGamePlayCount(int32 InPlayCount);
	void SetNowTotalGame(int32 InTotalGame);
	void SetUniqueID(int32 InUniqueId);
	void SetupMachineDataFromID(EJackMiniGameMeosiSlotPoint Point, int32 ID, const struct FJackMeosiSlotVariable& Variable);
	void SetupMachineDataFromIndex(int32 Index_0, const struct FJackMeosiSlotVariable& Variable);
	void UpdateMamonoSettingValue();
	void UpdateSettingValue();

	int32 GetCellingValueMaxNum() const;
	int32 GetGamePlayCount() const;
	int32 GetMaxGame() const;
	int32 GetNowTotalGame() const;
	int32 GetNumOrb(EJackMiniGameMeosiSlotPoint Point, int32 ID) const;
	int32 GetSimCountOneGame() const;
	int32 GetUniqueID() const;
	struct FJackMeosiSlotVariable GetVaribaleFromID(EJackMiniGameMeosiSlotPoint Point, int32 ID) const;
	struct FJackMeosiSlotVariable GetVaribaleFromIndex(int32 Index_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotAccessor">();
	}
	static class UJackMeosiSlotAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotAccessor>();
	}
};
static_assert(alignof(UJackMeosiSlotAccessor) == 0x000008, "Wrong alignment on UJackMeosiSlotAccessor");
static_assert(sizeof(UJackMeosiSlotAccessor) == 0x000048, "Wrong size on UJackMeosiSlotAccessor");

// Class JackGame.JackMeosiSlotConfigurationDataManager
// 0x0000 (0x0038 - 0x0038)
class UJackMeosiSlotConfigurationDataManager final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotConfigurationDataManager">();
	}
	static class UJackMeosiSlotConfigurationDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotConfigurationDataManager>();
	}
};
static_assert(alignof(UJackMeosiSlotConfigurationDataManager) == 0x000008, "Wrong alignment on UJackMeosiSlotConfigurationDataManager");
static_assert(sizeof(UJackMeosiSlotConfigurationDataManager) == 0x000038, "Wrong size on UJackMeosiSlotConfigurationDataManager");

// Class JackGame.JackMeosiSlotDataManagers
// 0x0038 (0x0070 - 0x0038)
class UJackMeosiSlotDataManagers final : public UObject
{
public:
	class UJackMeosiSlotConfigurationDataManager* ConfigurationDataManager;                          // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMeosiSlotMonsterDataManager*       MonsterDataManager;                                // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackMeosiSlotItemDataManager*          ItemDataManager;                                   // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     PamphletTextures;                                  // 0x0050(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UTexture2D*>                     AnyTextures;                                       // 0x0060(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotDataManagers">();
	}
	static class UJackMeosiSlotDataManagers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotDataManagers>();
	}
};
static_assert(alignof(UJackMeosiSlotDataManagers) == 0x000008, "Wrong alignment on UJackMeosiSlotDataManagers");
static_assert(sizeof(UJackMeosiSlotDataManagers) == 0x000070, "Wrong size on UJackMeosiSlotDataManagers");
static_assert(offsetof(UJackMeosiSlotDataManagers, ConfigurationDataManager) == 0x000038, "Member 'UJackMeosiSlotDataManagers::ConfigurationDataManager' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotDataManagers, MonsterDataManager) == 0x000040, "Member 'UJackMeosiSlotDataManagers::MonsterDataManager' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotDataManagers, ItemDataManager) == 0x000048, "Member 'UJackMeosiSlotDataManagers::ItemDataManager' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotDataManagers, PamphletTextures) == 0x000050, "Member 'UJackMeosiSlotDataManagers::PamphletTextures' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotDataManagers, AnyTextures) == 0x000060, "Member 'UJackMeosiSlotDataManagers::AnyTextures' has a wrong offset!");

// Class JackGame.JackMeosiSlotEffectDef
// 0x0000 (0x0038 - 0x0038)
class UJackMeosiSlotEffectDef final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotEffectDef">();
	}
	static class UJackMeosiSlotEffectDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotEffectDef>();
	}
};
static_assert(alignof(UJackMeosiSlotEffectDef) == 0x000008, "Wrong alignment on UJackMeosiSlotEffectDef");
static_assert(sizeof(UJackMeosiSlotEffectDef) == 0x000038, "Wrong size on UJackMeosiSlotEffectDef");

// Class JackGame.JackMeosiSlotGameResultDef
// 0x0000 (0x0038 - 0x0038)
class UJackMeosiSlotGameResultDef final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotGameResultDef">();
	}
	static class UJackMeosiSlotGameResultDef* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotGameResultDef>();
	}
};
static_assert(alignof(UJackMeosiSlotGameResultDef) == 0x000008, "Wrong alignment on UJackMeosiSlotGameResultDef");
static_assert(sizeof(UJackMeosiSlotGameResultDef) == 0x000038, "Wrong size on UJackMeosiSlotGameResultDef");

// Class JackGame.JackMeosiSlotItemDataManager
// 0x0010 (0x0048 - 0x0038)
class UJackMeosiSlotItemDataManager final : public UObject
{
public:
	TArray<class UTexture2D*>                     ItemTextures;                                      // 0x0038(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotItemDataManager">();
	}
	static class UJackMeosiSlotItemDataManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotItemDataManager>();
	}
};
static_assert(alignof(UJackMeosiSlotItemDataManager) == 0x000008, "Wrong alignment on UJackMeosiSlotItemDataManager");
static_assert(sizeof(UJackMeosiSlotItemDataManager) == 0x000048, "Wrong size on UJackMeosiSlotItemDataManager");
static_assert(offsetof(UJackMeosiSlotItemDataManager, ItemTextures) == 0x000038, "Member 'UJackMeosiSlotItemDataManager::ItemTextures' has a wrong offset!");

// Class JackGame.JackMeosiSlotReelControlParameter
// 0x0010 (0x0048 - 0x0038)
class UJackMeosiSlotReelControlParameter final : public UObject
{
public:
	float                                         HandPermissibleRange_WaterMelon;                   // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandPermissibleRange_Bel;                          // 0x003C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HandPermissibleRange_Seven;                        // 0x0040(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotReelControlParameter">();
	}
	static class UJackMeosiSlotReelControlParameter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotReelControlParameter>();
	}
};
static_assert(alignof(UJackMeosiSlotReelControlParameter) == 0x000008, "Wrong alignment on UJackMeosiSlotReelControlParameter");
static_assert(sizeof(UJackMeosiSlotReelControlParameter) == 0x000048, "Wrong size on UJackMeosiSlotReelControlParameter");
static_assert(offsetof(UJackMeosiSlotReelControlParameter, HandPermissibleRange_WaterMelon) == 0x000038, "Member 'UJackMeosiSlotReelControlParameter::HandPermissibleRange_WaterMelon' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotReelControlParameter, HandPermissibleRange_Bel) == 0x00003C, "Member 'UJackMeosiSlotReelControlParameter::HandPermissibleRange_Bel' has a wrong offset!");
static_assert(offsetof(UJackMeosiSlotReelControlParameter, HandPermissibleRange_Seven) == 0x000040, "Member 'UJackMeosiSlotReelControlParameter::HandPermissibleRange_Seven' has a wrong offset!");

// Class JackGame.JackMeosiSlotReelControlProcessor
// 0x0080 (0x00B8 - 0x0038)
class UJackMeosiSlotReelControlProcessor final : public UObject
{
public:
	uint8                                         Pad_38[0x80];                                      // 0x0038(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotReelControlProcessor">();
	}
	static class UJackMeosiSlotReelControlProcessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotReelControlProcessor>();
	}
};
static_assert(alignof(UJackMeosiSlotReelControlProcessor) == 0x000008, "Wrong alignment on UJackMeosiSlotReelControlProcessor");
static_assert(sizeof(UJackMeosiSlotReelControlProcessor) == 0x0000B8, "Wrong size on UJackMeosiSlotReelControlProcessor");

// Class JackGame.JackMeosiSlotReelUnit
// 0x0008 (0x0050 - 0x0048)
class UJackMeosiSlotReelUnit final : public UJackReelUnit
{
public:
	class UJackMeosiSlotReelControlProcessor*     SlotProcessor;                                     // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotReelUnit">();
	}
	static class UJackMeosiSlotReelUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotReelUnit>();
	}
};
static_assert(alignof(UJackMeosiSlotReelUnit) == 0x000008, "Wrong alignment on UJackMeosiSlotReelUnit");
static_assert(sizeof(UJackMeosiSlotReelUnit) == 0x000050, "Wrong size on UJackMeosiSlotReelUnit");
static_assert(offsetof(UJackMeosiSlotReelUnit, SlotProcessor) == 0x000048, "Member 'UJackMeosiSlotReelUnit::SlotProcessor' has a wrong offset!");

// Class JackGame.JackMeosiSlotSimulationComponent
// 0x0008 (0x0130 - 0x0128)
class UJackMeosiSlotSimulationComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Initialize(const struct FJackMeosiSlotStateInitialParam& InParam);
	void Quit();
	void SimQuit();
	void Update();

	struct FJackMeosiSlotVariableReelParam CalculateReelParam() const;
	struct FJackMeosiSlotVariableStateParam GetVariableParam() const;
	bool HasReachedMaxTotalGame() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotSimulationComponent">();
	}
	static class UJackMeosiSlotSimulationComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotSimulationComponent>();
	}
};
static_assert(alignof(UJackMeosiSlotSimulationComponent) == 0x000008, "Wrong alignment on UJackMeosiSlotSimulationComponent");
static_assert(sizeof(UJackMeosiSlotSimulationComponent) == 0x000130, "Wrong size on UJackMeosiSlotSimulationComponent");

// Class JackGame.JackMeosiSlotSoundManager
// 0x0048 (0x0080 - 0x0038)
class UJackMeosiSlotSoundManager final : public UObject
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USoundBase*>                     MeosiSlotSE;                                       // 0x0068(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_78[0x8];                                       // 0x0078(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyBGMID(class FName InName);
	class FName GetBGMID(EJackMeosiSlotBGM InType);
	class USoundBase* GetMeosiSE(class FName SEID);
	int32 GetMeosiSESet();
	class FName GetStockBGMID();
	bool IsBossStockBGM();
	bool IsBounusStockBGM();
	bool IsChangeBGMID(class FName BGMID);
	bool IsCurrentBGMNone();
	bool IsStockBGM();
	bool IsStockBGMPlaying();
	void LoadMeosiSE();
	void PlayBGM(const struct FLatentActionInfo& LatentInfo, EJackMeosiSlotBGM InType, bool bPushMusic);
	void PlayBGMFromID(const struct FLatentActionInfo& LatentInfo, class FName BGMID, bool bPushMusic);
	void PlayStockBGM(const struct FLatentActionInfo& LatentInfo, bool bPushMusic);
	void PopAndPlayBGM();
	void PushSoundBGM();
	void SetStockBGMPlaying(bool bStockBGM);
	void StopBGM(const struct FLatentActionInfo& LatentInfo, float FadeOutTime, bool bDontResumeOldBGM);
	void UnloadMeosiSE();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMeosiSlotSoundManager">();
	}
	static class UJackMeosiSlotSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMeosiSlotSoundManager>();
	}
};
static_assert(alignof(UJackMeosiSlotSoundManager) == 0x000008, "Wrong alignment on UJackMeosiSlotSoundManager");
static_assert(sizeof(UJackMeosiSlotSoundManager) == 0x000080, "Wrong size on UJackMeosiSlotSoundManager");
static_assert(offsetof(UJackMeosiSlotSoundManager, MeosiSlotSE) == 0x000068, "Member 'UJackMeosiSlotSoundManager::MeosiSlotSE' has a wrong offset!");

// Class JackGame.JackMiniGameBase
// 0x0008 (0x03A0 - 0x0398)
class AJackMiniGameBase : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackMiniGameTriggerBase* GetMiniGameTrigger();
	void MiniGameBeginPlay();
	void MiniGameEnd();
	void MiniGameStart();
	void RequestExitMiniGame();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameBase">();
	}
	static class AJackMiniGameBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameBase>();
	}
};
static_assert(alignof(AJackMiniGameBase) == 0x000008, "Wrong alignment on AJackMiniGameBase");
static_assert(sizeof(AJackMiniGameBase) == 0x0003A0, "Wrong size on AJackMiniGameBase");

// Class JackGame.JackMiniGameEffectEmitterPlane
// 0x0010 (0x0400 - 0x03F0)
class UJackMiniGameEffectEmitterPlane final : public UJackMiniGameEffectEmitter
{
public:
	struct FVector2D                              GeneratePosition;                                  // 0x03F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GenerateSize;                                      // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitterPlane">();
	}
	static class UJackMiniGameEffectEmitterPlane* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitterPlane>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitterPlane) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitterPlane");
static_assert(sizeof(UJackMiniGameEffectEmitterPlane) == 0x000400, "Wrong size on UJackMiniGameEffectEmitterPlane");
static_assert(offsetof(UJackMiniGameEffectEmitterPlane, GeneratePosition) == 0x0003F0, "Member 'UJackMiniGameEffectEmitterPlane::GeneratePosition' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterPlane, GenerateSize) == 0x0003F8, "Member 'UJackMiniGameEffectEmitterPlane::GenerateSize' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterPlane, Angle) == 0x0003FC, "Member 'UJackMiniGameEffectEmitterPlane::Angle' has a wrong offset!");

// Class JackGame.JackMiniGameEffectEmitterPoint
// 0x0010 (0x0400 - 0x03F0)
class UJackMiniGameEffectEmitterPoint final : public UJackMiniGameEffectEmitter
{
public:
	struct FVector2D                              GeneratePosition;                                  // 0x03F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x03F8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleRange;                                        // 0x03FC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitterPoint">();
	}
	static class UJackMiniGameEffectEmitterPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitterPoint>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitterPoint) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitterPoint");
static_assert(sizeof(UJackMiniGameEffectEmitterPoint) == 0x000400, "Wrong size on UJackMiniGameEffectEmitterPoint");
static_assert(offsetof(UJackMiniGameEffectEmitterPoint, GeneratePosition) == 0x0003F0, "Member 'UJackMiniGameEffectEmitterPoint::GeneratePosition' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterPoint, Angle) == 0x0003F8, "Member 'UJackMiniGameEffectEmitterPoint::Angle' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterPoint, AngleRange) == 0x0003FC, "Member 'UJackMiniGameEffectEmitterPoint::AngleRange' has a wrong offset!");

// Class JackGame.JackMiniGameEffectEmitterRect
// 0x0020 (0x0410 - 0x03F0)
class UJackMiniGameEffectEmitterRect final : public UJackMiniGameEffectEmitter
{
public:
	struct FVector2D                              GeneratePosition;                                  // 0x03F0(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              GenerateSize;                                      // 0x03F8(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InitialVelocity;                                   // 0x0400(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InitialVelocityRange;                              // 0x0408(0x0008)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectEmitterRect">();
	}
	static class UJackMiniGameEffectEmitterRect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectEmitterRect>();
	}
};
static_assert(alignof(UJackMiniGameEffectEmitterRect) == 0x000008, "Wrong alignment on UJackMiniGameEffectEmitterRect");
static_assert(sizeof(UJackMiniGameEffectEmitterRect) == 0x000410, "Wrong size on UJackMiniGameEffectEmitterRect");
static_assert(offsetof(UJackMiniGameEffectEmitterRect, GeneratePosition) == 0x0003F0, "Member 'UJackMiniGameEffectEmitterRect::GeneratePosition' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterRect, GenerateSize) == 0x0003F8, "Member 'UJackMiniGameEffectEmitterRect::GenerateSize' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterRect, InitialVelocity) == 0x000400, "Member 'UJackMiniGameEffectEmitterRect::InitialVelocity' has a wrong offset!");
static_assert(offsetof(UJackMiniGameEffectEmitterRect, InitialVelocityRange) == 0x000408, "Member 'UJackMiniGameEffectEmitterRect::InitialVelocityRange' has a wrong offset!");

// Class JackGame.JackMiniGameEffectParticle
// 0x0038 (0x03A8 - 0x0370)
class UJackMiniGameEffectParticle final : public UJackUMGWidgetBase
{
public:
	uint8                                         Pad_370[0x38];                                     // 0x0370(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameEffectParticle">();
	}
	static class UJackMiniGameEffectParticle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameEffectParticle>();
	}
};
static_assert(alignof(UJackMiniGameEffectParticle) == 0x000008, "Wrong alignment on UJackMiniGameEffectParticle");
static_assert(sizeof(UJackMiniGameEffectParticle) == 0x0003A8, "Wrong size on UJackMiniGameEffectParticle");

// Class JackGame.JackMiniGameJackPotAccessor
// 0x0020 (0x0058 - 0x0038)
class UJackMiniGameJackPotAccessor final : public UObject
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddDebugMenu();
	void ApplyJackPotDisplayNum();
	void ApplyQuestFlag();
	int32 CalcDividend(EJackMiniGameJackPotMachine InMachineType, EJackMiniGameTableCoinType InCoinType, bool bIsFractionRandom);
	void CheckJackpotCoin();
	int32 GetJackPotDisplayNum();
	EJackMiniGameJackPotState GetJackPotState();
	EJackMiniGameJackPot GetJackPotTypeFromActiveMapID();
	bool IsQuestSession();
	void RemoveDebugMenu();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameJackPotAccessor">();
	}
	static class UJackMiniGameJackPotAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniGameJackPotAccessor>();
	}
};
static_assert(alignof(UJackMiniGameJackPotAccessor) == 0x000008, "Wrong alignment on UJackMiniGameJackPotAccessor");
static_assert(sizeof(UJackMiniGameJackPotAccessor) == 0x000058, "Wrong size on UJackMiniGameJackPotAccessor");

// Class JackGame.JackMiniGamePoker
// 0x0040 (0x03E0 - 0x03A0)
class AJackMiniGamePoker final : public AJackMiniGameBase
{
public:
	uint8                                         SelectCard;                                        // 0x03A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         WinningCard;                                       // 0x03A1(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         TreasureBoxCard;                                   // 0x03A2(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A3[0x5];                                      // 0x03A3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture*>                       CardTextures;                                      // 0x03A8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B8[0x11];                                     // 0x03B8(0x0011)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugTreasureItem;                                // 0x03C9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3CA[0x2];                                      // 0x03CA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DebugItemIndex;                                    // 0x03CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugBetTimes;                                     // 0x03D0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DebugDoubleUpTimes;                                // 0x03D4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugAutoPlayMode;                                // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugOutputLog;                                   // 0x03D9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDisp;                                        // 0x03DA(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DB[0x5];                                      // 0x03DB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddTreasureItemGetCounter(EJackPokerTreasureBox BoxType, int32 BoxIndex);
	void DebugOutputTreasureLog(const TArray<int32>& TreasureBoxCounterData);
	uint8 ExchangeHandCard(int32 HandIndex);
	class UTexture* GetCardTexture(int32 CardID);
	void InitDebugTreasureGetCounter(EJackPokerTreasureBox BoxType, const TArray<class FName>& ItemNameTable, int32 ListStartIndex);
	void InitializeDoubleupGame(EJackPokerDoubleUpResult InDoubleUpResult, int32 InNumDoubleUp);
	void InitializePokerGame(EJackPokerHand HandKind);
	void InitTreasureItemGetCounter(const TArray<class FName>& RedItemName, const TArray<class FName>& BlackItemName, const TArray<class FName>& GoldItemName);
	void LoadTextures();
	void ReplaceHandCard(int32 SelectIndex);
	void SetInvalidCard(int32 HandIndex);
	void SetupTreasureBox_BaseCard(EJackPokerTreasureBox InTreasureBox);
	void SetupTreasureBox_SelectCard(EJackPokerTreasureBox InTreasureBox);
	void UnloadTextures();

	EJackPokerCardNumber DecideBaseCardNumber(EJackPokerDoubleUpResult InDoubleUpResult, int32 InNumDoubleUp) const;
	EJackPokerDoubleUpResult DecidePokerDoubleUpResult(EJackPokerBetUnit InBetUnit, int32 InNumDoubleUp) const;
	EJackPokerHand DecidePokerHand() const;
	bool DecideTreasureBoxAppearance_BaseCard(EJackPokerBetUnit InBetUnit, int32 InNumDoubleUp) const;
	bool DecideTreasureBoxAppearance_SelectCard(EJackPokerBetUnit InBetUnit) const;
	EJackPokerTreasureBox DecideTreasureBoxType(EJackPokerBetUnit InBetUnit) const;
	bool DecideWinOrLose(EJackPokerBetUnit InBetUnit) const;
	int32 GetBetMax() const;
	uint8 GetCardDeckNo(int32 Index_0) const;
	int32 GetDoubleUpMax() const;
	uint8 GetHandCardNo(int32 HandIndex) const;
	int32 GetHandDividendCoin(EJackPokerHand HandKind) const;
	struct FJackPokerHandInfo GetHandInfo() const;
	int32 GetNumInexpensiveCoinDivisor(EJackPokerBetUnit InBetUnit) const;
	float GetNumTreasureBoxCoin(EJackPokerTreasureBox InTreasureBox) const;
	int32 GetNumTreasureBoxKey(EJackPokerTreasureBox InTreasureBox) const;
	int32 GetNumValidCard() const;
	int32 GetSelectIndexDoubleupGame(int32 SelectIndex, EJackPokerSign Sign) const;
	EJackPokerTreasureBox GetTreasureBoxType(uint8 CardNo) const;
	const class FName GetWinMEID(EJackPokerBetUnit InBetUnit, int32 InDividedCoin) const;
	const class FName GetWinMEID_DoubleUp(int32 DoubleUpCount) const;
	const class FName GetWinMEID_Hand(EJackPokerHand HandType) const;
	bool IsValidCard(int32 HandIndex) const;
	int32 JudgePokerDoubleUpResult(int32 HandIndex) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGamePoker">();
	}
	static class AJackMiniGamePoker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGamePoker>();
	}
};
static_assert(alignof(AJackMiniGamePoker) == 0x000008, "Wrong alignment on AJackMiniGamePoker");
static_assert(sizeof(AJackMiniGamePoker) == 0x0003E0, "Wrong size on AJackMiniGamePoker");
static_assert(offsetof(AJackMiniGamePoker, SelectCard) == 0x0003A0, "Member 'AJackMiniGamePoker::SelectCard' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, WinningCard) == 0x0003A1, "Member 'AJackMiniGamePoker::WinningCard' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, TreasureBoxCard) == 0x0003A2, "Member 'AJackMiniGamePoker::TreasureBoxCard' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, CardTextures) == 0x0003A8, "Member 'AJackMiniGamePoker::CardTextures' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, bDebugTreasureItem) == 0x0003C9, "Member 'AJackMiniGamePoker::bDebugTreasureItem' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, DebugItemIndex) == 0x0003CC, "Member 'AJackMiniGamePoker::DebugItemIndex' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, DebugBetTimes) == 0x0003D0, "Member 'AJackMiniGamePoker::DebugBetTimes' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, DebugDoubleUpTimes) == 0x0003D4, "Member 'AJackMiniGamePoker::DebugDoubleUpTimes' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, bDebugAutoPlayMode) == 0x0003D8, "Member 'AJackMiniGamePoker::bDebugAutoPlayMode' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, bDebugOutputLog) == 0x0003D9, "Member 'AJackMiniGamePoker::bDebugOutputLog' has a wrong offset!");
static_assert(offsetof(AJackMiniGamePoker, bDebugDisp) == 0x0003DA, "Member 'AJackMiniGamePoker::bDebugDisp' has a wrong offset!");

// Class JackGame.JackMiniGameRoulette
// 0x0038 (0x03D8 - 0x03A0)
class AJackMiniGameRoulette final : public AJackMiniGameBase
{
public:
	EJackMiniGameJackPot                          JackPotType;                                       // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3];                                      // 0x03A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Coin;                                              // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoinMax;                                           // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJackMiniGameRouletteMainGame*          MainGame;                                          // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackMiniGameRouletteMainMenu*          MainMenu;                                          // 0x03B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C0[0x18];                                     // 0x03C0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyGameInfo();
	struct FJackRouletteGameInfo GetGameInfo();
	int32 GetJackPotCoinNum();
	void SetInstance(class AJackMiniGameRouletteMainGame* InGame, class AJackMiniGameRouletteMainMenu* InMenu);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameRoulette">();
	}
	static class AJackMiniGameRoulette* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameRoulette>();
	}
};
static_assert(alignof(AJackMiniGameRoulette) == 0x000008, "Wrong alignment on AJackMiniGameRoulette");
static_assert(sizeof(AJackMiniGameRoulette) == 0x0003D8, "Wrong size on AJackMiniGameRoulette");
static_assert(offsetof(AJackMiniGameRoulette, JackPotType) == 0x0003A0, "Member 'AJackMiniGameRoulette::JackPotType' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRoulette, Coin) == 0x0003A4, "Member 'AJackMiniGameRoulette::Coin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRoulette, CoinMax) == 0x0003A8, "Member 'AJackMiniGameRoulette::CoinMax' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRoulette, MainGame) == 0x0003B0, "Member 'AJackMiniGameRoulette::MainGame' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRoulette, MainMenu) == 0x0003B8, "Member 'AJackMiniGameRoulette::MainMenu' has a wrong offset!");

// Class JackGame.JackMiniGameRouletteMainGame
// 0x0048 (0x03E0 - 0x0398)
class AJackMiniGameRouletteMainGame final : public AActor
{
public:
	bool                                          bIsStateChanged;                                   // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x3];                                      // 0x0399(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         JackPotNearRange;                                  // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJackPotNear;                                    // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x3F];                                     // 0x03A1(0x003F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 GetBetMagnification(int32 Number);
	TArray<int32> GetBetNumberArray();
	EJackMiniGameRouletteEffect GetEffectType();
	int32 GetResultNumber();
	EJackMiniGameRouletteGameState GetState();
	void InitializeInstance(class AJackRouletteWheel* Wheel, class AJackRouletteBall* Ball);
	bool IsEnd();
	bool IsJackPotLottey();
	void ResetGame();
	void SetGameInfo(const struct FJackRouletteGameInfo& InGameInfo);
	void SetState(EJackMiniGameRouletteGameState State);
	void StartPlay(int32 Number, bool bIsJackPot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameRouletteMainGame">();
	}
	static class AJackMiniGameRouletteMainGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameRouletteMainGame>();
	}
};
static_assert(alignof(AJackMiniGameRouletteMainGame) == 0x000008, "Wrong alignment on AJackMiniGameRouletteMainGame");
static_assert(sizeof(AJackMiniGameRouletteMainGame) == 0x0003E0, "Wrong size on AJackMiniGameRouletteMainGame");
static_assert(offsetof(AJackMiniGameRouletteMainGame, bIsStateChanged) == 0x000398, "Member 'AJackMiniGameRouletteMainGame::bIsStateChanged' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainGame, JackPotNearRange) == 0x00039C, "Member 'AJackMiniGameRouletteMainGame::JackPotNearRange' has a wrong offset!");
static_assert(offsetof(AJackMiniGameRouletteMainGame, bIsJackPotNear) == 0x0003A0, "Member 'AJackMiniGameRouletteMainGame::bIsJackPotNear' has a wrong offset!");

// Class JackGame.JackMiniGameSlot
// 0x0020 (0x03C0 - 0x03A0)
class AJackMiniGameSlot final : public AJackMiniGameBase
{
public:
	int32                                         Coin;                                              // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CoinMax;                                           // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMiniGameTableCoinType                    CoinTableType;                                     // 0x03A8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A9[0x7];                                      // 0x03A9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DefaultReelNumberArray;                            // 0x03B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameSlot">();
	}
	static class AJackMiniGameSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameSlot>();
	}
};
static_assert(alignof(AJackMiniGameSlot) == 0x000008, "Wrong alignment on AJackMiniGameSlot");
static_assert(sizeof(AJackMiniGameSlot) == 0x0003C0, "Wrong size on AJackMiniGameSlot");
static_assert(offsetof(AJackMiniGameSlot, Coin) == 0x0003A0, "Member 'AJackMiniGameSlot::Coin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlot, CoinMax) == 0x0003A4, "Member 'AJackMiniGameSlot::CoinMax' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlot, CoinTableType) == 0x0003A8, "Member 'AJackMiniGameSlot::CoinTableType' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlot, DefaultReelNumberArray) == 0x0003B0, "Member 'AJackMiniGameSlot::DefaultReelNumberArray' has a wrong offset!");

// Class JackGame.JackMiniGameSlotMain
// 0x0098 (0x0450 - 0x03B8)
class AJackMiniGameSlotMain final : public AJackMiniGameInputActor
{
public:
	int32                                         Coin;                                              // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackSlotGameState                            State;                                             // 0x03BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMiniGameTableCoinType                    CoinTableType;                                     // 0x03BD(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BE[0x2];                                      // 0x03BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MetalChangeNum;                                    // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         FreeSpinNum;                                       // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackMiniGameSlotReels>     ReelsClass;                                        // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FJackSlotStartInfo                     StartInfo;                                         // 0x03D0(0x000B)(Edit, BlueprintVisible, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_3DB[0x1];                                      // 0x03DB(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         QueenSlimeProbability;                             // 0x03DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         TreasureBoxCoin;                                   // 0x03E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DividendWorkCoin;                                  // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USoundBase*                             SoundCoinUpN;                                      // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         SoundCoinUpTime;                                   // 0x03F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CurrentCoinUpRatio;                                // 0x03F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MamonoJackPotPercent;                              // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         DividendCoin;                                      // 0x03FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MamonoCasinoJackPotDividend1;                      // 0x0400(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MamonoCasinoJackPotDividend10;                     // 0x0404(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MamonoCasinoJackPotDividend100;                    // 0x0408(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_40C[0x4];                                      // 0x040C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJackMiniGameSlotReels*                 Reels;                                             // 0x0410(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_418[0x38];                                     // 0x0418(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool AddBetCoin();
	void AdjustBetCoinNum();
	void ApplyBetCoin();
	void ApplyDividendCoin(int32 InCoin);
	bool ApplyFreeSpinNum();
	void ApplyLoseCoin();
	bool ApplyMetalChangeNum();
	void ApplyResult();
	void ApplyStartInfo(bool bIs1STLottey);
	void ApplyTresureBoxCoin();
	bool ApplyWinCoin(bool bTreasureBoxCoin);
	bool Calc1StLottey();
	int32 CalcBetCoin();
	int32 CalcDividend();
	int32 CalcRestCoin();
	int32 CalcResultFreeSpin();
	int32 CalcResultMetalChange();
	int32 CalcTreasureBoxCoin();
	int32 ClampDividendCoin(int32 InDividendCoin);
	void ClearTreasureBoxCoin();
	void CoinCountUpInit();
	bool DecBetCoin();
	void DoDecideKeyEvent();
	int32 GetBetCoinNum();
	int32 GetJackPotDivided();
	TArray<int32> GetLineBetCoin();
	int32 GetOneBetCoin();
	TArray<int32> GetReelNumberArray();
	int32 GetSetNumber();
	const class FName GetWinMEID(int32 InCoin, bool bTreasureBox);
	void InitializeReels(class AJackMiniGameSlotReels* InReels);
	bool IsFreeSpin();
	bool IsHaveCoinMax();
	bool IsIncludeFreeSpinHand();
	bool IsIncludeMetalSpinHand();
	bool IsMetalChange();
	bool IsQueenSlime();
	bool IsResultWin();
	bool IsSkipDemo();
	void JackMiniGameSlotInputDelegate__DelegateSignature(const class FName InEventTag);
	void ResetStartInfo();
	bool UpdateCoinCountUp(float DeltaTime);
	bool UpdateInputBetCoin(TDelegate<void(class FName InEventTag)> InDelegate);

	int32 GetResultHitCount(const TArray<struct FJackSlotResultInfo>& InResults) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameSlotMain">();
	}
	static class AJackMiniGameSlotMain* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameSlotMain>();
	}
};
static_assert(alignof(AJackMiniGameSlotMain) == 0x000008, "Wrong alignment on AJackMiniGameSlotMain");
static_assert(sizeof(AJackMiniGameSlotMain) == 0x000450, "Wrong size on AJackMiniGameSlotMain");
static_assert(offsetof(AJackMiniGameSlotMain, Coin) == 0x0003B8, "Member 'AJackMiniGameSlotMain::Coin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, State) == 0x0003BC, "Member 'AJackMiniGameSlotMain::State' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, CoinTableType) == 0x0003BD, "Member 'AJackMiniGameSlotMain::CoinTableType' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, MetalChangeNum) == 0x0003C0, "Member 'AJackMiniGameSlotMain::MetalChangeNum' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, FreeSpinNum) == 0x0003C4, "Member 'AJackMiniGameSlotMain::FreeSpinNum' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, ReelsClass) == 0x0003C8, "Member 'AJackMiniGameSlotMain::ReelsClass' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, StartInfo) == 0x0003D0, "Member 'AJackMiniGameSlotMain::StartInfo' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, QueenSlimeProbability) == 0x0003DC, "Member 'AJackMiniGameSlotMain::QueenSlimeProbability' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, TreasureBoxCoin) == 0x0003E0, "Member 'AJackMiniGameSlotMain::TreasureBoxCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, DividendWorkCoin) == 0x0003E4, "Member 'AJackMiniGameSlotMain::DividendWorkCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, SoundCoinUpN) == 0x0003E8, "Member 'AJackMiniGameSlotMain::SoundCoinUpN' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, SoundCoinUpTime) == 0x0003F0, "Member 'AJackMiniGameSlotMain::SoundCoinUpTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, CurrentCoinUpRatio) == 0x0003F4, "Member 'AJackMiniGameSlotMain::CurrentCoinUpRatio' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, MamonoJackPotPercent) == 0x0003F8, "Member 'AJackMiniGameSlotMain::MamonoJackPotPercent' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, DividendCoin) == 0x0003FC, "Member 'AJackMiniGameSlotMain::DividendCoin' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, MamonoCasinoJackPotDividend1) == 0x000400, "Member 'AJackMiniGameSlotMain::MamonoCasinoJackPotDividend1' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, MamonoCasinoJackPotDividend10) == 0x000404, "Member 'AJackMiniGameSlotMain::MamonoCasinoJackPotDividend10' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, MamonoCasinoJackPotDividend100) == 0x000408, "Member 'AJackMiniGameSlotMain::MamonoCasinoJackPotDividend100' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotMain, Reels) == 0x000410, "Member 'AJackMiniGameSlotMain::Reels' has a wrong offset!");

// Class JackGame.JackMiniGameSlotPicture
// 0x0038 (0x03D0 - 0x0398)
class AJackMiniGameSlotPicture final : public AActor
{
public:
	bool                                          bIsMetalChange;                                    // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMiniGameSlotHand                         ActiveType;                                        // 0x0399(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39A[0x36];                                     // 0x039A(0x0036)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyActiveType();
	class USkeletalMeshComponent* GetActiveMesh();
	EJackMiniGameSlotHand GetAngelChangeType();
	EJackMiniGameSlotHand GetType(bool bAngelChange);
	bool IsAngelChanged();
	void JackMiniGameSlotActionDelegate__DelegateSignature(const class FName InEventTag, int32 ReelLineNumber, int32 ReelColNumber);
	void NativeEventOnInitialize();
	void SetActionDelegate(TDelegate<void(class FName InEventTag, int32 ReelLineNumber, int32 ReelColNumber)> InActionDelegate);
	void SetActiveMesh(class USkeletalMeshComponent* InMesh);
	EJackMiniGameSlotHand ToNormalType(EJackMiniGameSlotHand InType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameSlotPicture">();
	}
	static class AJackMiniGameSlotPicture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameSlotPicture>();
	}
};
static_assert(alignof(AJackMiniGameSlotPicture) == 0x000008, "Wrong alignment on AJackMiniGameSlotPicture");
static_assert(sizeof(AJackMiniGameSlotPicture) == 0x0003D0, "Wrong size on AJackMiniGameSlotPicture");
static_assert(offsetof(AJackMiniGameSlotPicture, bIsMetalChange) == 0x000398, "Member 'AJackMiniGameSlotPicture::bIsMetalChange' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotPicture, ActiveType) == 0x000399, "Member 'AJackMiniGameSlotPicture::ActiveType' has a wrong offset!");

// Class JackGame.JackMiniGameSlotReels
// 0x0058 (0x03F0 - 0x0398)
class AJackMiniGameSlotReels final : public AActor
{
public:
	float                                         StartDelayTime;                                    // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x34];                                     // 0x039C(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReelIndexOffset;                                   // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FJackMiniGameSlotAnimAssetList> AnimAssetLists;                                    // 0x03E0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	TArray<struct FJackSlotResultInfo> GetActiveReelResult(bool bIsQueenSlime, bool bIgnoreNoBetLine);
	TArray<struct FJackSlotResultInfo> GetLastReelResult(bool bIgnoreNoBetLine);
	int32 GetQueenSlimeReelIndex();
	void Initialize(const TArray<class AJackMiniGameSlotReel*>& InArray, const TArray<int32>& InReelNumberArray);
	void JackMiniGameSlotEventDelegate__DelegateSignature(const class FName InEventTag);
	bool ReelStopCheck();
	bool ResetAngelChange();
	void Start(TDelegate<void(class FName InEventTag)> InDelegate, int32 InBetCoinNum);
	void StartAlignAnim();
	bool StartAngelChange();
	void StartQueenSlime(TDelegate<void(class FName InEventTag)> InDelegate);
	void StartReach();
	void StartWin();
	void StopAnimationAll(bool bForce, bool bIgoneAngleSlime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameSlotReels">();
	}
	static class AJackMiniGameSlotReels* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameSlotReels>();
	}
};
static_assert(alignof(AJackMiniGameSlotReels) == 0x000008, "Wrong alignment on AJackMiniGameSlotReels");
static_assert(sizeof(AJackMiniGameSlotReels) == 0x0003F0, "Wrong size on AJackMiniGameSlotReels");
static_assert(offsetof(AJackMiniGameSlotReels, StartDelayTime) == 0x000398, "Member 'AJackMiniGameSlotReels::StartDelayTime' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReels, ReelIndexOffset) == 0x0003D0, "Member 'AJackMiniGameSlotReels::ReelIndexOffset' has a wrong offset!");
static_assert(offsetof(AJackMiniGameSlotReels, AnimAssetLists) == 0x0003E0, "Member 'AJackMiniGameSlotReels::AnimAssetLists' has a wrong offset!");

// Class JackGame.JackMiniGameTriggerBase
// 0x0038 (0x03D0 - 0x0398)
class AJackMiniGameTriggerBase final : public AActor
{
public:
	TSoftClassPtr<class UClass>                   MiniGameAssetClass;                                // 0x0398(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B0[0x8];                                      // 0x03B0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BaseCoinMagnification;                             // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMiniGameKind                             GameKind;                                          // 0x03BC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BD[0x1];                                      // 0x03BD(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	EJackMiniGameTableCoinType                    TableCoinType;                                     // 0x03BE(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BF[0x1];                                      // 0x03BF(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackInteractiveActorComponent*         InteractiveActorComponent;                         // 0x03C0(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackTripleManager>      TripleManagerForCall;                              // 0x03C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CreateMiniGame_End();
	void CreateMiniGame_Start();
	void ExitMiniGame();
	void OnStartFromTriple(class AJackTripleManager* StartPawn);
	void RequestCreateMiniGame();
	void RequestExitMiniGame();

	class UJackInteractiveActorComponent* GetInteractiveActorComponent() const;
	int32 GetNeedCoinNum() const;
	EJackMiniGameTableCoinType GetTableCoinType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniGameTriggerBase">();
	}
	static class AJackMiniGameTriggerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMiniGameTriggerBase>();
	}
};
static_assert(alignof(AJackMiniGameTriggerBase) == 0x000008, "Wrong alignment on AJackMiniGameTriggerBase");
static_assert(sizeof(AJackMiniGameTriggerBase) == 0x0003D0, "Wrong size on AJackMiniGameTriggerBase");
static_assert(offsetof(AJackMiniGameTriggerBase, MiniGameAssetClass) == 0x000398, "Member 'AJackMiniGameTriggerBase::MiniGameAssetClass' has a wrong offset!");
static_assert(offsetof(AJackMiniGameTriggerBase, BaseCoinMagnification) == 0x0003B8, "Member 'AJackMiniGameTriggerBase::BaseCoinMagnification' has a wrong offset!");
static_assert(offsetof(AJackMiniGameTriggerBase, GameKind) == 0x0003BC, "Member 'AJackMiniGameTriggerBase::GameKind' has a wrong offset!");
static_assert(offsetof(AJackMiniGameTriggerBase, TableCoinType) == 0x0003BE, "Member 'AJackMiniGameTriggerBase::TableCoinType' has a wrong offset!");
static_assert(offsetof(AJackMiniGameTriggerBase, InteractiveActorComponent) == 0x0003C0, "Member 'AJackMiniGameTriggerBase::InteractiveActorComponent' has a wrong offset!");
static_assert(offsetof(AJackMiniGameTriggerBase, TripleManagerForCall) == 0x0003C8, "Member 'AJackMiniGameTriggerBase::TripleManagerForCall' has a wrong offset!");

// Class JackGame.JackMiniMapCameraComponent
// 0x0018 (0x0140 - 0x0128)
class UJackMiniMapCameraComponent final : public UActorComponent
{
public:
	class FName                                   MapIDOverride;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFloorArea                                FloorArea;                                         // 0x0130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClippingEnabled;                                  // 0x0131(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_132[0x2];                                      // 0x0132(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector2D                              ClippingOrthoSize;                                 // 0x0134(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13C[0x4];                                      // 0x013C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMiniMapCameraComponent">();
	}
	static class UJackMiniMapCameraComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMiniMapCameraComponent>();
	}
};
static_assert(alignof(UJackMiniMapCameraComponent) == 0x000008, "Wrong alignment on UJackMiniMapCameraComponent");
static_assert(sizeof(UJackMiniMapCameraComponent) == 0x000140, "Wrong size on UJackMiniMapCameraComponent");
static_assert(offsetof(UJackMiniMapCameraComponent, MapIDOverride) == 0x000128, "Member 'UJackMiniMapCameraComponent::MapIDOverride' has a wrong offset!");
static_assert(offsetof(UJackMiniMapCameraComponent, FloorArea) == 0x000130, "Member 'UJackMiniMapCameraComponent::FloorArea' has a wrong offset!");
static_assert(offsetof(UJackMiniMapCameraComponent, bClippingEnabled) == 0x000131, "Member 'UJackMiniMapCameraComponent::bClippingEnabled' has a wrong offset!");
static_assert(offsetof(UJackMiniMapCameraComponent, ClippingOrthoSize) == 0x000134, "Member 'UJackMiniMapCameraComponent::ClippingOrthoSize' has a wrong offset!");

// Class JackGame.JackModeChangeManager
// 0x26D0 (0x2708 - 0x0038)
class UJackModeChangeManager final : public UObject
{
public:
	uint8                                         Pad_38[0x26D0];                                    // 0x0038(0x26D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool ApplyTenseiProcess(const class FName& TenseiId);
	TArray<class FString> Get2DGameDataDiffText();
	TArray<class FString> Get2DGameDataText();
	void SetCurrentMode(EJackModeType InModeType);
	void SetFukkatunojumonId(uint8 InRevivalPointId, uint8 InRevivalParamId);
	void SetLoadedModeChagneTypeFukkatu2D();
	void SetTenseiId(const class FName& TenseiId);

	EJackModeType GetCurrentMode() const;
	class FName GetLoadedModeChagneType() const;
	class FName GetTenseiId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackModeChangeManager">();
	}
	static class UJackModeChangeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackModeChangeManager>();
	}
};
static_assert(alignof(UJackModeChangeManager) == 0x000008, "Wrong alignment on UJackModeChangeManager");
static_assert(sizeof(UJackModeChangeManager) == 0x002708, "Wrong size on UJackModeChangeManager");

// Class JackGame.JackMonsterAIController
// 0x00A0 (0x0620 - 0x0580)
class AJackMonsterAIController : public AJackAIController
{
public:
	class UJackMonsterFieldAIStateMachine*        FieldStateMachine;                                 // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x98];                                     // 0x0588(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnReceiveMoveCompleted(const struct FAIRequestID& RequestID, EPathFollowingResult MovementResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterAIController">();
	}
	static class AJackMonsterAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterAIController>();
	}
};
static_assert(alignof(AJackMonsterAIController) == 0x000008, "Wrong alignment on AJackMonsterAIController");
static_assert(sizeof(AJackMonsterAIController) == 0x000620, "Wrong size on AJackMonsterAIController");
static_assert(offsetof(AJackMonsterAIController, FieldStateMachine) == 0x000580, "Member 'AJackMonsterAIController::FieldStateMachine' has a wrong offset!");

// Class JackGame.JackMonsterAnimationSMComponent
// 0x0010 (0x01B0 - 0x01A0)
class UJackMonsterAnimationSMComponent final : public UJackCharacterComponent
{
public:
	class UJackMonsterAnimationStateMachine*      StateMachine;                                      // 0x01A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A8[0x8];                                      // 0x01A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterAnimationSMComponent">();
	}
	static class UJackMonsterAnimationSMComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterAnimationSMComponent>();
	}
};
static_assert(alignof(UJackMonsterAnimationSMComponent) == 0x000008, "Wrong alignment on UJackMonsterAnimationSMComponent");
static_assert(sizeof(UJackMonsterAnimationSMComponent) == 0x0001B0, "Wrong size on UJackMonsterAnimationSMComponent");
static_assert(offsetof(UJackMonsterAnimationSMComponent, StateMachine) == 0x0001A0, "Member 'UJackMonsterAnimationSMComponent::StateMachine' has a wrong offset!");

// Class JackGame.JackMonsterAnimInstance
// 0x0060 (0x0C40 - 0x0BE0)
class UJackMonsterAnimInstance final : public UJackAnimInstance
{
public:
	uint8                                         Pad_BD8[0x34];                                     // 0x0BD8(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TurnToIdlInitializeValue;                          // 0x0C0C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceSpeed;                                   // 0x0C10(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovementPlayRate;                                  // 0x0C14(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TurningPlayRate;                                   // 0x0C18(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C1C[0x4];                                      // 0x0C1C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMonsterAnimationStateMachine*      MonsterStateMachineRef;                            // 0x0C20(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                LookAtLocation;                                    // 0x0C28(0x000C)(BlueprintVisible, BlueprintReadOnly, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         LookAtAlpha;                                       // 0x0C34(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMonsterBattleStyle                       BattleStyle;                                       // 0x0C38(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C39[0x7];                                      // 0x0C39(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EJackMonsterMovingMode GetMonsterMovingMode() const;
	bool IsMovingRequest() const;
	class UJackMonsterAnimationStateMachine* TryGetJackMonsterAnimationStateMachine() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterAnimInstance">();
	}
	static class UJackMonsterAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterAnimInstance>();
	}
};
static_assert(alignof(UJackMonsterAnimInstance) == 0x000010, "Wrong alignment on UJackMonsterAnimInstance");
static_assert(sizeof(UJackMonsterAnimInstance) == 0x000C40, "Wrong size on UJackMonsterAnimInstance");
static_assert(offsetof(UJackMonsterAnimInstance, TurnToIdlInitializeValue) == 0x000C0C, "Member 'UJackMonsterAnimInstance::TurnToIdlInitializeValue' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, BlendSpaceSpeed) == 0x000C10, "Member 'UJackMonsterAnimInstance::BlendSpaceSpeed' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, MovementPlayRate) == 0x000C14, "Member 'UJackMonsterAnimInstance::MovementPlayRate' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, TurningPlayRate) == 0x000C18, "Member 'UJackMonsterAnimInstance::TurningPlayRate' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, MonsterStateMachineRef) == 0x000C20, "Member 'UJackMonsterAnimInstance::MonsterStateMachineRef' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, LookAtLocation) == 0x000C28, "Member 'UJackMonsterAnimInstance::LookAtLocation' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, LookAtAlpha) == 0x000C34, "Member 'UJackMonsterAnimInstance::LookAtAlpha' has a wrong offset!");
static_assert(offsetof(UJackMonsterAnimInstance, BattleStyle) == 0x000C38, "Member 'UJackMonsterAnimInstance::BattleStyle' has a wrong offset!");

// Class JackGame.JackMonsterCharacter
// 0x0080 (0x1170 - 0x10F0)
class AJackMonsterCharacter final : public AJackCharacter
{
public:
	class UJackMonsterAnimationSMComponent*       AnimSMComponent;                                   // 0x10F0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackBattleAIComponent*                 BattleAIComponent;                                 // 0x10F8(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackInteractiveActorComponent*         InteractiveActorComponent;                         // 0x1100(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackMonsterPartyLotteryComponent*      MonsterPartyLotteryComponent;                      // 0x1108(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackCharacterUIComponent*              CharacterUIComponent;                              // 0x1110(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1118[0x8];                                     // 0x1118(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bChangeVariantForm;                                // 0x1120(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1121[0x7];                                     // 0x1121(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MonsterResourceID;                                 // 0x1128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMonsterAttitudeControlSetting            AttitudeControlSetting;                            // 0x1130(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1131[0x7];                                     // 0x1131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMonsterGameCharacter*              MonsterGameCharacerRef;                            // 0x1138(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1140[0x30];                                    // 0x1140(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AttachToComponentStatic(class USceneComponent* Parent, class FName SocketName, EAttachmentRule LocationRule, EAttachmentRule RotationRule, EAttachmentRule ScaleRule, bool bWeldSimulatedBodies);
	void ChangeVariantForm(bool bInEnable);
	void DetachFromActorStatic(EDetachmentRule LocationRule, EDetachmentRule RotationRule, EDetachmentRule ScaleRule);
	void KillMonsterSymbol();
	void Latent_TrackingLockOnTarget(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMeshComponent* SkeletalMesh, const struct FTransform& RelativeTransform, float Second);
	void Latent_WaitAnimationByMeshComponent(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class USkeletalMeshComponent* SkeletalMesh, class UAnimMontage* AnimMontage);
	void OnConstructBodyParts(class AJackMonsterCharacter* BodyParts);
	void OnInteract(class AActor* OtherActor);
	void OnZukanCharacterInitialize();
	void SetBattleStyle(EJackMonsterBattleStyle InStyle);

	EJackMonsterBattleStyle GetBattleStyle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterCharacter">();
	}
	static class AJackMonsterCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterCharacter>();
	}
};
static_assert(alignof(AJackMonsterCharacter) == 0x000010, "Wrong alignment on AJackMonsterCharacter");
static_assert(sizeof(AJackMonsterCharacter) == 0x001170, "Wrong size on AJackMonsterCharacter");
static_assert(offsetof(AJackMonsterCharacter, AnimSMComponent) == 0x0010F0, "Member 'AJackMonsterCharacter::AnimSMComponent' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, BattleAIComponent) == 0x0010F8, "Member 'AJackMonsterCharacter::BattleAIComponent' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, InteractiveActorComponent) == 0x001100, "Member 'AJackMonsterCharacter::InteractiveActorComponent' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, MonsterPartyLotteryComponent) == 0x001108, "Member 'AJackMonsterCharacter::MonsterPartyLotteryComponent' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, CharacterUIComponent) == 0x001110, "Member 'AJackMonsterCharacter::CharacterUIComponent' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, bChangeVariantForm) == 0x001120, "Member 'AJackMonsterCharacter::bChangeVariantForm' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, MonsterResourceID) == 0x001128, "Member 'AJackMonsterCharacter::MonsterResourceID' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, AttitudeControlSetting) == 0x001130, "Member 'AJackMonsterCharacter::AttitudeControlSetting' has a wrong offset!");
static_assert(offsetof(AJackMonsterCharacter, MonsterGameCharacerRef) == 0x001138, "Member 'AJackMonsterCharacter::MonsterGameCharacerRef' has a wrong offset!");

// Class JackGame.JackMonsterFieldAIStateMachine
// 0x04F8 (0x0530 - 0x0038)
class UJackMonsterFieldAIStateMachine final : public UObject
{
public:
	struct FJackAIStateStructs                    AIStateStructs;                                    // 0x0038(0x0038)(Edit, BlueprintVisible, BlueprintReadOnly, EditConst, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         WaitIntervalMin;                                   // 0x0070(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitIntervalMax;                                   // 0x0074(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WanderringRadius;                                  // 0x0078(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WanderringMoveDistance;                            // 0x007C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EscapeMoveDistance;                                // 0x0080(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RushMoveDistance;                                  // 0x0084(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChaseRadiusFromFindLocation;                       // 0x0088(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChaseRadiusFromFindTargetLocation;                 // 0x008C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChaseRadiusFromPopLocation;                        // 0x0090(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_94[0x49C];                                     // 0x0094(0x049C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterFieldAIStateMachine">();
	}
	static class UJackMonsterFieldAIStateMachine* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterFieldAIStateMachine>();
	}
};
static_assert(alignof(UJackMonsterFieldAIStateMachine) == 0x000008, "Wrong alignment on UJackMonsterFieldAIStateMachine");
static_assert(sizeof(UJackMonsterFieldAIStateMachine) == 0x000530, "Wrong size on UJackMonsterFieldAIStateMachine");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, AIStateStructs) == 0x000038, "Member 'UJackMonsterFieldAIStateMachine::AIStateStructs' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, WaitIntervalMin) == 0x000070, "Member 'UJackMonsterFieldAIStateMachine::WaitIntervalMin' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, WaitIntervalMax) == 0x000074, "Member 'UJackMonsterFieldAIStateMachine::WaitIntervalMax' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, WanderringRadius) == 0x000078, "Member 'UJackMonsterFieldAIStateMachine::WanderringRadius' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, WanderringMoveDistance) == 0x00007C, "Member 'UJackMonsterFieldAIStateMachine::WanderringMoveDistance' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, EscapeMoveDistance) == 0x000080, "Member 'UJackMonsterFieldAIStateMachine::EscapeMoveDistance' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, RushMoveDistance) == 0x000084, "Member 'UJackMonsterFieldAIStateMachine::RushMoveDistance' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, ChaseRadiusFromFindLocation) == 0x000088, "Member 'UJackMonsterFieldAIStateMachine::ChaseRadiusFromFindLocation' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, ChaseRadiusFromFindTargetLocation) == 0x00008C, "Member 'UJackMonsterFieldAIStateMachine::ChaseRadiusFromFindTargetLocation' has a wrong offset!");
static_assert(offsetof(UJackMonsterFieldAIStateMachine, ChaseRadiusFromPopLocation) == 0x000090, "Member 'UJackMonsterFieldAIStateMachine::ChaseRadiusFromPopLocation' has a wrong offset!");

// Class JackGame.JackMonsterGameCharacter
// 0x0100 (0x0750 - 0x0650)
class UJackMonsterGameCharacter final : public UJackGameCharacter
{
public:
	uint8                                         Pad_650[0x100];                                    // 0x0650(0x0100)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	EJackDataTableReferType GetDataTableReferType() const;
	class FName GetId() const;
	struct FJackMonsterData GetMonsterDataBP() const;
	class FName GetMonsterID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterGameCharacter">();
	}
	static class UJackMonsterGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterGameCharacter>();
	}
};
static_assert(alignof(UJackMonsterGameCharacter) == 0x000008, "Wrong alignment on UJackMonsterGameCharacter");
static_assert(sizeof(UJackMonsterGameCharacter) == 0x000750, "Wrong size on UJackMonsterGameCharacter");

// Class JackGame.JackMonsterGeneratorComponent
// 0x0148 (0x0270 - 0x0128)
class UJackMonsterGeneratorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPopMonster;                                      // 0x0130(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDepopMonster;                                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UJackStreamObjectsHolder*               StreamObjectsHolder;                               // 0x0150(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackStreamObjectsHolder*               VoiceStreamObjectsHolder;                          // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_160[0x110];                                    // 0x0160(0x0110)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterGeneratorComponent">();
	}
	static class UJackMonsterGeneratorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterGeneratorComponent>();
	}
};
static_assert(alignof(UJackMonsterGeneratorComponent) == 0x000008, "Wrong alignment on UJackMonsterGeneratorComponent");
static_assert(sizeof(UJackMonsterGeneratorComponent) == 0x000270, "Wrong size on UJackMonsterGeneratorComponent");
static_assert(offsetof(UJackMonsterGeneratorComponent, OnPopMonster) == 0x000130, "Member 'UJackMonsterGeneratorComponent::OnPopMonster' has a wrong offset!");
static_assert(offsetof(UJackMonsterGeneratorComponent, OnDepopMonster) == 0x000140, "Member 'UJackMonsterGeneratorComponent::OnDepopMonster' has a wrong offset!");
static_assert(offsetof(UJackMonsterGeneratorComponent, StreamObjectsHolder) == 0x000150, "Member 'UJackMonsterGeneratorComponent::StreamObjectsHolder' has a wrong offset!");
static_assert(offsetof(UJackMonsterGeneratorComponent, VoiceStreamObjectsHolder) == 0x000158, "Member 'UJackMonsterGeneratorComponent::VoiceStreamObjectsHolder' has a wrong offset!");

// Class JackGame.JackMonsterPartyLotteryComponent
// 0x0088 (0x01B0 - 0x0128)
class UJackMonsterPartyLotteryComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x88];                                     // 0x0128(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPartyLotteryComponent">();
	}
	static class UJackMonsterPartyLotteryComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMonsterPartyLotteryComponent>();
	}
};
static_assert(alignof(UJackMonsterPartyLotteryComponent) == 0x000008, "Wrong alignment on UJackMonsterPartyLotteryComponent");
static_assert(sizeof(UJackMonsterPartyLotteryComponent) == 0x0001B0, "Wrong size on UJackMonsterPartyLotteryComponent");

// Class JackGame.JackMonsterPopArea
// 0x0068 (0x0438 - 0x03D0)
class AJackMonsterPopArea : public AVolume
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GeneratorId;                                       // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMonsterDeployTable;                            // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E1[0x7];                                      // 0x03E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MonsterDeployTable;                                // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackDataTableMonsterDeploy>    DeployedMonsters;                                  // 0x03F0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AJackMonsterPopVolume*>          AdditiveVolumes;                                   // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bActive : 1;                                       // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAddSkeletalMeshOnConstructionScriptForEditor;     // 0x0414(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugDraw;                                        // 0x0415(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_416[0x1A];                                     // 0x0416(0x001A)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMonsterGeneratorComponent*         MonsterGeneratorComponent;                         // 0x0430(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AJackMonsterCharacter* LoadMonsterClass(const struct FJackDataTableMonster& InDataTableMonster);

	class FName GetMonsterDeployHeadId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopArea">();
	}
	static class AJackMonsterPopArea* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterPopArea>();
	}
};
static_assert(alignof(AJackMonsterPopArea) == 0x000008, "Wrong alignment on AJackMonsterPopArea");
static_assert(sizeof(AJackMonsterPopArea) == 0x000438, "Wrong size on AJackMonsterPopArea");
static_assert(offsetof(AJackMonsterPopArea, GeneratorId) == 0x0003D8, "Member 'AJackMonsterPopArea::GeneratorId' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, bUseMonsterDeployTable) == 0x0003E0, "Member 'AJackMonsterPopArea::bUseMonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, MonsterDeployTable) == 0x0003E8, "Member 'AJackMonsterPopArea::MonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, DeployedMonsters) == 0x0003F0, "Member 'AJackMonsterPopArea::DeployedMonsters' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, AdditiveVolumes) == 0x000400, "Member 'AJackMonsterPopArea::AdditiveVolumes' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, bAddSkeletalMeshOnConstructionScriptForEditor) == 0x000414, "Member 'AJackMonsterPopArea::bAddSkeletalMeshOnConstructionScriptForEditor' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, bDebugDraw) == 0x000415, "Member 'AJackMonsterPopArea::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopArea, MonsterGeneratorComponent) == 0x000430, "Member 'AJackMonsterPopArea::MonsterGeneratorComponent' has a wrong offset!");

// Class JackGame.JackMonsterPopInterface
// 0x0000 (0x0038 - 0x0038)
class IJackMonsterPopInterface final : public IInterface
{
public:
	bool OverrideMonsterDeployTable(class UDataTable* InTableAsset);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopInterface">();
	}
	static class IJackMonsterPopInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJackMonsterPopInterface>();
	}
};
static_assert(alignof(IJackMonsterPopInterface) == 0x000008, "Wrong alignment on IJackMonsterPopInterface");
static_assert(sizeof(IJackMonsterPopInterface) == 0x000038, "Wrong size on IJackMonsterPopInterface");

// Class JackGame.JackMonsterPopPoint
// 0x0058 (0x03F0 - 0x0398)
class AJackMonsterPopPoint : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GeneratorId;                                       // 0x03A0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIgnoreRaycast;                                    // 0x03A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMonsterDeployTable;                            // 0x03A9(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AA[0x6];                                      // 0x03AA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MonsterDeployTable;                                // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackDataTableMonsterDeploy>    DeployedMonsters;                                  // 0x03B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bActive : 1;                                       // 0x03C8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         BitPad_3C8_1 : 7;                                  // 0x03C8(0x0001)(Fixing Bit-Field Size For New Byte [ Dumper-7 ])
	uint8                                         Pad_3C9[0xF];                                      // 0x03C9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         bAddSkeletalMeshOnConstructionScriptForEditor : 1; // 0x03D8(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_3D9[0xF];                                      // 0x03D9(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMonsterGeneratorComponent*         MonsterGeneratorComponent;                         // 0x03E8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	class AJackMonsterCharacter* LoadMonsterClass(const struct FJackDataTableMonster& InDataTableMonster);
	bool RequestToAppear();
	bool RequestToPop();

	class FName GetMonsterDeployHeadId() const;
	bool IsNecessaryToPop() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopPoint">();
	}
	static class AJackMonsterPopPoint* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterPopPoint>();
	}
};
static_assert(alignof(AJackMonsterPopPoint) == 0x000008, "Wrong alignment on AJackMonsterPopPoint");
static_assert(sizeof(AJackMonsterPopPoint) == 0x0003F0, "Wrong size on AJackMonsterPopPoint");
static_assert(offsetof(AJackMonsterPopPoint, GeneratorId) == 0x0003A0, "Member 'AJackMonsterPopPoint::GeneratorId' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopPoint, bIgnoreRaycast) == 0x0003A8, "Member 'AJackMonsterPopPoint::bIgnoreRaycast' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopPoint, bUseMonsterDeployTable) == 0x0003A9, "Member 'AJackMonsterPopPoint::bUseMonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopPoint, MonsterDeployTable) == 0x0003B0, "Member 'AJackMonsterPopPoint::MonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopPoint, DeployedMonsters) == 0x0003B8, "Member 'AJackMonsterPopPoint::DeployedMonsters' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopPoint, MonsterGeneratorComponent) == 0x0003E8, "Member 'AJackMonsterPopPoint::MonsterGeneratorComponent' has a wrong offset!");

// Class JackGame.JackMonsterPopVolume
// 0x0020 (0x03F0 - 0x03D0)
class AJackMonsterPopVolume final : public AVolume
{
public:
	uint8                                         Pad_3D0[0x20];                                     // 0x03D0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopVolume">();
	}
	static class AJackMonsterPopVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterPopVolume>();
	}
};
static_assert(alignof(AJackMonsterPopVolume) == 0x000008, "Wrong alignment on AJackMonsterPopVolume");
static_assert(sizeof(AJackMonsterPopVolume) == 0x0003F0, "Wrong size on AJackMonsterPopVolume");

// Class JackGame.JackMonsterPopZone
// 0x0080 (0x0450 - 0x03D0)
class AJackMonsterPopZone : public AVolume
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   GeneratorId;                                       // 0x03D8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRandomEncount;                                    // 0x03E0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMonsterDeployTable;                            // 0x03E1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E2[0x6];                                      // 0x03E2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             MonsterDeployTable;                                // 0x03E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<struct FJackDataTableMonsterDeploy>    DeployedMonsters;                                  // 0x03F0(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AJackMonsterPopVolume*>          AdditiveVolumes;                                   // 0x0400(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         bActive : 1;                                       // 0x0410(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (BlueprintVisible, BlueprintReadOnly, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDraw;                                        // 0x0414(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_415[0x33];                                     // 0x0415(0x0033)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMonsterGeneratorComponent*         MonsterGeneratorComponent;                         // 0x0448(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMonsterPopZone">();
	}
	static class AJackMonsterPopZone* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackMonsterPopZone>();
	}
};
static_assert(alignof(AJackMonsterPopZone) == 0x000008, "Wrong alignment on AJackMonsterPopZone");
static_assert(sizeof(AJackMonsterPopZone) == 0x000450, "Wrong size on AJackMonsterPopZone");
static_assert(offsetof(AJackMonsterPopZone, GeneratorId) == 0x0003D8, "Member 'AJackMonsterPopZone::GeneratorId' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, bRandomEncount) == 0x0003E0, "Member 'AJackMonsterPopZone::bRandomEncount' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, bUseMonsterDeployTable) == 0x0003E1, "Member 'AJackMonsterPopZone::bUseMonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, MonsterDeployTable) == 0x0003E8, "Member 'AJackMonsterPopZone::MonsterDeployTable' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, DeployedMonsters) == 0x0003F0, "Member 'AJackMonsterPopZone::DeployedMonsters' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, AdditiveVolumes) == 0x000400, "Member 'AJackMonsterPopZone::AdditiveVolumes' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, bDebugDraw) == 0x000414, "Member 'AJackMonsterPopZone::bDebugDraw' has a wrong offset!");
static_assert(offsetof(AJackMonsterPopZone, MonsterGeneratorComponent) == 0x000448, "Member 'AJackMonsterPopZone::MonsterGeneratorComponent' has a wrong offset!");

// Class JackGame.JackMovieTrack
// 0x0028 (0x00D0 - 0x00A8)
class UJackMovieTrack final : public UJackToggleBaseTrack
{
public:
	class UMaterial*                              MovieMaterial;                                     // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManaTexture*                           ManaTexture;                                       // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOrchestraMusic;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseSynthesizerMusic;                              // 0x00B9(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableSkipVideoFrame;                            // 0x00BA(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BB[0x5];                                       // 0x00BB(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bFullScreen;                                       // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSynchronizeTimeline;                              // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisableRenderInPlay;                              // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C3[0x5];                                       // 0x00C3(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UManaComponent*                         ManaComponent;                                     // 0x00C8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMovieTrack">();
	}
	static class UJackMovieTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMovieTrack>();
	}
};
static_assert(alignof(UJackMovieTrack) == 0x000008, "Wrong alignment on UJackMovieTrack");
static_assert(sizeof(UJackMovieTrack) == 0x0000D0, "Wrong size on UJackMovieTrack");
static_assert(offsetof(UJackMovieTrack, MovieMaterial) == 0x0000A8, "Member 'UJackMovieTrack::MovieMaterial' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, ManaTexture) == 0x0000B0, "Member 'UJackMovieTrack::ManaTexture' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bUseOrchestraMusic) == 0x0000B8, "Member 'UJackMovieTrack::bUseOrchestraMusic' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bUseSynthesizerMusic) == 0x0000B9, "Member 'UJackMovieTrack::bUseSynthesizerMusic' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bDisableSkipVideoFrame) == 0x0000BA, "Member 'UJackMovieTrack::bDisableSkipVideoFrame' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bFullScreen) == 0x0000C0, "Member 'UJackMovieTrack::bFullScreen' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bSynchronizeTimeline) == 0x0000C1, "Member 'UJackMovieTrack::bSynchronizeTimeline' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, bDisableRenderInPlay) == 0x0000C2, "Member 'UJackMovieTrack::bDisableRenderInPlay' has a wrong offset!");
static_assert(offsetof(UJackMovieTrack, ManaComponent) == 0x0000C8, "Member 'UJackMovieTrack::ManaComponent' has a wrong offset!");

// Class JackGame.JackMovieTrackInst
// 0x0008 (0x0048 - 0x0040)
class UJackMovieTrackInst final : public UJackToggleBaseTrackInst
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMovieTrackInst">();
	}
	static class UJackMovieTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMovieTrackInst>();
	}
};
static_assert(alignof(UJackMovieTrackInst) == 0x000008, "Wrong alignment on UJackMovieTrackInst");
static_assert(sizeof(UJackMovieTrackInst) == 0x000048, "Wrong size on UJackMovieTrackInst");

// Class JackGame.JackMusicContext
// 0x00B0 (0x00E8 - 0x0038)
class UJackMusicContext final : public UObject
{
public:
	UMulticastDelegateProperty_                   MusicStoppedDelegate;                              // 0x0038(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   MusicPauseStateChangedDelegate;                    // 0x0048(0x0010)(ZeroConstructor, Transient, InstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x10];                                      // 0x0058(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundAssetPtr;                                     // 0x0068(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_70[0x78];                                      // 0x0070(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMusicContext">();
	}
	static class UJackMusicContext* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMusicContext>();
	}
};
static_assert(alignof(UJackMusicContext) == 0x000008, "Wrong alignment on UJackMusicContext");
static_assert(sizeof(UJackMusicContext) == 0x0000E8, "Wrong size on UJackMusicContext");
static_assert(offsetof(UJackMusicContext, MusicStoppedDelegate) == 0x000038, "Member 'UJackMusicContext::MusicStoppedDelegate' has a wrong offset!");
static_assert(offsetof(UJackMusicContext, MusicPauseStateChangedDelegate) == 0x000048, "Member 'UJackMusicContext::MusicPauseStateChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJackMusicContext, SoundAssetPtr) == 0x000068, "Member 'UJackMusicContext::SoundAssetPtr' has a wrong offset!");

// Class JackGame.JackMusicMiscControlTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackMusicMiscControlTrack final : public UInterpTrack
{
public:
	TArray<struct FJackMusicMiscControlTrackKey>  KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMusicMiscControlTrack">();
	}
	static class UJackMusicMiscControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMusicMiscControlTrack>();
	}
};
static_assert(alignof(UJackMusicMiscControlTrack) == 0x000008, "Wrong alignment on UJackMusicMiscControlTrack");
static_assert(sizeof(UJackMusicMiscControlTrack) == 0x0000A0, "Wrong size on UJackMusicMiscControlTrack");
static_assert(offsetof(UJackMusicMiscControlTrack, KeyArray) == 0x000090, "Member 'UJackMusicMiscControlTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackMusicMiscControlTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackMusicMiscControlTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackMusicMiscControlTrackInst">();
	}
	static class UJackMusicMiscControlTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackMusicMiscControlTrackInst>();
	}
};
static_assert(alignof(UJackMusicMiscControlTrackInst) == 0x000008, "Wrong alignment on UJackMusicMiscControlTrackInst");
static_assert(sizeof(UJackMusicMiscControlTrackInst) == 0x000040, "Wrong size on UJackMusicMiscControlTrackInst");

// Class JackGame.JackNavMeshAffector
// 0x0000 (0x07B0 - 0x07B0)
class AJackNavMeshAffector final : public ACharacter
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNavMeshAffector">();
	}
	static class AJackNavMeshAffector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackNavMeshAffector>();
	}
};
static_assert(alignof(AJackNavMeshAffector) == 0x000010, "Wrong alignment on AJackNavMeshAffector");
static_assert(sizeof(AJackNavMeshAffector) == 0x0007B0, "Wrong size on AJackNavMeshAffector");

// Class JackGame.JackNavModifierComponent
// 0x0058 (0x01B0 - 0x0158)
class UJackNavModifierComponent final : public UNavRelevantComponent
{
public:
	TSubclassOf<class UNavArea>                   AreaClass;                                         // 0x0158(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_160[0x50];                                     // 0x0160(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNavModifierComponent">();
	}
	static class UJackNavModifierComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackNavModifierComponent>();
	}
};
static_assert(alignof(UJackNavModifierComponent) == 0x000008, "Wrong alignment on UJackNavModifierComponent");
static_assert(sizeof(UJackNavModifierComponent) == 0x0001B0, "Wrong size on UJackNavModifierComponent");
static_assert(offsetof(UJackNavModifierComponent, AreaClass) == 0x000158, "Member 'UJackNavModifierComponent::AreaClass' has a wrong offset!");

// Class JackGame.JackNPC
// 0x0020 (0x1110 - 0x10F0)
class AJackNPC : public AJackCharacter
{
public:
	struct FJackLDT_NPCList                       UniqueID;                                          // 0x10F0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class UJackLookAtComponent*                   LookAtComponent;                                   // 0x1100(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1108[0x8];                                     // 0x1108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNPC">();
	}
	static class AJackNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackNPC>();
	}
};
static_assert(alignof(AJackNPC) == 0x000010, "Wrong alignment on AJackNPC");
static_assert(sizeof(AJackNPC) == 0x001110, "Wrong size on AJackNPC");
static_assert(offsetof(AJackNPC, UniqueID) == 0x0010F0, "Member 'AJackNPC::UniqueID' has a wrong offset!");
static_assert(offsetof(AJackNPC, LookAtComponent) == 0x001100, "Member 'AJackNPC::LookAtComponent' has a wrong offset!");

// Class JackGame.JackNPCComponentBase
// 0x0000 (0x0128 - 0x0128)
class UJackNPCComponentBase : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackNPCComponentBase">();
	}
	static class UJackNPCComponentBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackNPCComponentBase>();
	}
};
static_assert(alignof(UJackNPCComponentBase) == 0x000008, "Wrong alignment on UJackNPCComponentBase");
static_assert(sizeof(UJackNPCComponentBase) == 0x000128, "Wrong size on UJackNPCComponentBase");

// Class JackGame.JackOddEffect
// 0x0030 (0x0068 - 0x0038)
class UJackOddEffect : public UObject
{
public:
	TArray<struct FJackOddEffectAttachedParticle> Particles;                                         // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackOddEffectAttachedParticle> InvokeParticles;                                   // 0x0048(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackOddEffectAttachedParticle> ClearParticles;                                    // 0x0058(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffect">();
	}
	static class UJackOddEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffect>();
	}
};
static_assert(alignof(UJackOddEffect) == 0x000008, "Wrong alignment on UJackOddEffect");
static_assert(sizeof(UJackOddEffect) == 0x000068, "Wrong size on UJackOddEffect");
static_assert(offsetof(UJackOddEffect, Particles) == 0x000038, "Member 'UJackOddEffect::Particles' has a wrong offset!");
static_assert(offsetof(UJackOddEffect, InvokeParticles) == 0x000048, "Member 'UJackOddEffect::InvokeParticles' has a wrong offset!");
static_assert(offsetof(UJackOddEffect, ClearParticles) == 0x000058, "Member 'UJackOddEffect::ClearParticles' has a wrong offset!");

// Class JackGame.JackOddEffectDatabase
// 0x0000 (0x0038 - 0x0038)
class UJackOddEffectDatabase final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectDatabase">();
	}
	static class UJackOddEffectDatabase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectDatabase>();
	}
};
static_assert(alignof(UJackOddEffectDatabase) == 0x000008, "Wrong alignment on UJackOddEffectDatabase");
static_assert(sizeof(UJackOddEffectDatabase) == 0x000038, "Wrong size on UJackOddEffectDatabase");

// Class JackGame.JackOddEffectExec_Normal
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Normal final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Normal">();
	}
	static class UJackOddEffectExec_Normal* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Normal>();
	}
};
static_assert(alignof(UJackOddEffectExec_Normal) == 0x000008, "Wrong alignment on UJackOddEffectExec_Normal");
static_assert(sizeof(UJackOddEffectExec_Normal) == 0x000100, "Wrong size on UJackOddEffectExec_Normal");

// Class JackGame.JackOddEffectExec_Dot
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Dot final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Dot">();
	}
	static class UJackOddEffectExec_Dot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Dot>();
	}
};
static_assert(alignof(UJackOddEffectExec_Dot) == 0x000008, "Wrong alignment on UJackOddEffectExec_Dot");
static_assert(sizeof(UJackOddEffectExec_Dot) == 0x000100, "Wrong size on UJackOddEffectExec_Dot");

// Class JackGame.JackOddEffectExec_Nifuramu
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Nifuramu final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Nifuramu">();
	}
	static class UJackOddEffectExec_Nifuramu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Nifuramu>();
	}
};
static_assert(alignof(UJackOddEffectExec_Nifuramu) == 0x000008, "Wrong alignment on UJackOddEffectExec_Nifuramu");
static_assert(sizeof(UJackOddEffectExec_Nifuramu) == 0x000100, "Wrong size on UJackOddEffectExec_Nifuramu");

// Class JackGame.JackOddEffectExec_MitoreruHantei
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_MitoreruHantei final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_MitoreruHantei">();
	}
	static class UJackOddEffectExec_MitoreruHantei* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_MitoreruHantei>();
	}
};
static_assert(alignof(UJackOddEffectExec_MitoreruHantei) == 0x000008, "Wrong alignment on UJackOddEffectExec_MitoreruHantei");
static_assert(sizeof(UJackOddEffectExec_MitoreruHantei) == 0x000100, "Wrong size on UJackOddEffectExec_MitoreruHantei");

// Class JackGame.JackOddEffectExec_NoroiSokusi
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_NoroiSokusi final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_NoroiSokusi">();
	}
	static class UJackOddEffectExec_NoroiSokusi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_NoroiSokusi>();
	}
};
static_assert(alignof(UJackOddEffectExec_NoroiSokusi) == 0x000008, "Wrong alignment on UJackOddEffectExec_NoroiSokusi");
static_assert(sizeof(UJackOddEffectExec_NoroiSokusi) == 0x000100, "Wrong size on UJackOddEffectExec_NoroiSokusi");

// Class JackGame.JackOddEffectExec_Sokusi
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Sokusi final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Sokusi">();
	}
	static class UJackOddEffectExec_Sokusi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Sokusi>();
	}
};
static_assert(alignof(UJackOddEffectExec_Sokusi) == 0x000008, "Wrong alignment on UJackOddEffectExec_Sokusi");
static_assert(sizeof(UJackOddEffectExec_Sokusi) == 0x000100, "Wrong size on UJackOddEffectExec_Sokusi");

// Class JackGame.JackOddEffectExec_Megante
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Megante final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Megante">();
	}
	static class UJackOddEffectExec_Megante* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Megante>();
	}
};
static_assert(alignof(UJackOddEffectExec_Megante) == 0x000008, "Wrong alignment on UJackOddEffectExec_Megante");
static_assert(sizeof(UJackOddEffectExec_Megante) == 0x000100, "Wrong size on UJackOddEffectExec_Megante");

// Class JackGame.JackOddEffectExec_Konran
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Konran final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Konran">();
	}
	static class UJackOddEffectExec_Konran* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Konran>();
	}
};
static_assert(alignof(UJackOddEffectExec_Konran) == 0x000008, "Wrong alignment on UJackOddEffectExec_Konran");
static_assert(sizeof(UJackOddEffectExec_Konran) == 0x000100, "Wrong size on UJackOddEffectExec_Konran");

// Class JackGame.JackOddEffectExec_Miryou
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Miryou final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Miryou">();
	}
	static class UJackOddEffectExec_Miryou* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Miryou>();
	}
};
static_assert(alignof(UJackOddEffectExec_Miryou) == 0x000008, "Wrong alignment on UJackOddEffectExec_Miryou");
static_assert(sizeof(UJackOddEffectExec_Miryou) == 0x000100, "Wrong size on UJackOddEffectExec_Miryou");

// Class JackGame.JackOddEffectExec_OitemoGenki
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_OitemoGenki final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_OitemoGenki">();
	}
	static class UJackOddEffectExec_OitemoGenki* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_OitemoGenki>();
	}
};
static_assert(alignof(UJackOddEffectExec_OitemoGenki) == 0x000008, "Wrong alignment on UJackOddEffectExec_OitemoGenki");
static_assert(sizeof(UJackOddEffectExec_OitemoGenki) == 0x000100, "Wrong size on UJackOddEffectExec_OitemoGenki");

// Class JackGame.JackOddEffectExec_Asutoron
// 0x0010 (0x0110 - 0x0100)
class UJackOddEffectExec_Asutoron final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x10];                                     // 0x0100(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Asutoron">();
	}
	static class UJackOddEffectExec_Asutoron* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Asutoron>();
	}
};
static_assert(alignof(UJackOddEffectExec_Asutoron) == 0x000008, "Wrong alignment on UJackOddEffectExec_Asutoron");
static_assert(sizeof(UJackOddEffectExec_Asutoron) == 0x000110, "Wrong size on UJackOddEffectExec_Asutoron");

// Class JackGame.JackOddEffectExec_YamiNoKoromoHomerosu
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_YamiNoKoromoHomerosu final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_YamiNoKoromoHomerosu">();
	}
	static class UJackOddEffectExec_YamiNoKoromoHomerosu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_YamiNoKoromoHomerosu>();
	}
};
static_assert(alignof(UJackOddEffectExec_YamiNoKoromoHomerosu) == 0x000008, "Wrong alignment on UJackOddEffectExec_YamiNoKoromoHomerosu");
static_assert(sizeof(UJackOddEffectExec_YamiNoKoromoHomerosu) == 0x000108, "Wrong size on UJackOddEffectExec_YamiNoKoromoHomerosu");

// Class JackGame.JackOddEffectExec_Zibaria
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_Zibaria final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Zibaria">();
	}
	static class UJackOddEffectExec_Zibaria* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Zibaria>();
	}
};
static_assert(alignof(UJackOddEffectExec_Zibaria) == 0x000008, "Wrong alignment on UJackOddEffectExec_Zibaria");
static_assert(sizeof(UJackOddEffectExec_Zibaria) == 0x000108, "Wrong size on UJackOddEffectExec_Zibaria");

// Class JackGame.JackOddEffectExec_DevilMode
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_DevilMode final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_DevilMode">();
	}
	static class UJackOddEffectExec_DevilMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_DevilMode>();
	}
};
static_assert(alignof(UJackOddEffectExec_DevilMode) == 0x000008, "Wrong alignment on UJackOddEffectExec_DevilMode");
static_assert(sizeof(UJackOddEffectExec_DevilMode) == 0x000100, "Wrong size on UJackOddEffectExec_DevilMode");

// Class JackGame.JackOddEffectExec_SatanMode
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_SatanMode final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_SatanMode">();
	}
	static class UJackOddEffectExec_SatanMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_SatanMode>();
	}
};
static_assert(alignof(UJackOddEffectExec_SatanMode) == 0x000008, "Wrong alignment on UJackOddEffectExec_SatanMode");
static_assert(sizeof(UJackOddEffectExec_SatanMode) == 0x000100, "Wrong size on UJackOddEffectExec_SatanMode");

// Class JackGame.JackOddEffectExec_BeastMode
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_BeastMode final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_BeastMode">();
	}
	static class UJackOddEffectExec_BeastMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_BeastMode>();
	}
};
static_assert(alignof(UJackOddEffectExec_BeastMode) == 0x000008, "Wrong alignment on UJackOddEffectExec_BeastMode");
static_assert(sizeof(UJackOddEffectExec_BeastMode) == 0x000100, "Wrong size on UJackOddEffectExec_BeastMode");

// Class JackGame.JackOddEffectExec_LadyFirst
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_LadyFirst final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_LadyFirst">();
	}
	static class UJackOddEffectExec_LadyFirst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_LadyFirst>();
	}
};
static_assert(alignof(UJackOddEffectExec_LadyFirst) == 0x000008, "Wrong alignment on UJackOddEffectExec_LadyFirst");
static_assert(sizeof(UJackOddEffectExec_LadyFirst) == 0x000100, "Wrong size on UJackOddEffectExec_LadyFirst");

// Class JackGame.JackOddEffectExec_Taberu
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Taberu final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Taberu">();
	}
	static class UJackOddEffectExec_Taberu* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Taberu>();
	}
};
static_assert(alignof(UJackOddEffectExec_Taberu) == 0x000008, "Wrong alignment on UJackOddEffectExec_Taberu");
static_assert(sizeof(UJackOddEffectExec_Taberu) == 0x000100, "Wrong size on UJackOddEffectExec_Taberu");

// Class JackGame.JackOddEffectExec_Taberareru
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Taberareru final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Taberareru">();
	}
	static class UJackOddEffectExec_Taberareru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Taberareru>();
	}
};
static_assert(alignof(UJackOddEffectExec_Taberareru) == 0x000008, "Wrong alignment on UJackOddEffectExec_Taberareru");
static_assert(sizeof(UJackOddEffectExec_Taberareru) == 0x000100, "Wrong size on UJackOddEffectExec_Taberareru");

// Class JackGame.JackOddEffectExec_Tozikomeru
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Tozikomeru final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Tozikomeru">();
	}
	static class UJackOddEffectExec_Tozikomeru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Tozikomeru>();
	}
};
static_assert(alignof(UJackOddEffectExec_Tozikomeru) == 0x000008, "Wrong alignment on UJackOddEffectExec_Tozikomeru");
static_assert(sizeof(UJackOddEffectExec_Tozikomeru) == 0x000100, "Wrong size on UJackOddEffectExec_Tozikomeru");

// Class JackGame.JackOddEffectExec_Tozikomerareru
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Tozikomerareru final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Tozikomerareru">();
	}
	static class UJackOddEffectExec_Tozikomerareru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Tozikomerareru>();
	}
};
static_assert(alignof(UJackOddEffectExec_Tozikomerareru) == 0x000008, "Wrong alignment on UJackOddEffectExec_Tozikomerareru");
static_assert(sizeof(UJackOddEffectExec_Tozikomerareru) == 0x000100, "Wrong size on UJackOddEffectExec_Tozikomerareru");

// Class JackGame.JackOddEffectExec_YamiNoKoromo
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_YamiNoKoromo final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_YamiNoKoromo">();
	}
	static class UJackOddEffectExec_YamiNoKoromo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_YamiNoKoromo>();
	}
};
static_assert(alignof(UJackOddEffectExec_YamiNoKoromo) == 0x000008, "Wrong alignment on UJackOddEffectExec_YamiNoKoromo");
static_assert(sizeof(UJackOddEffectExec_YamiNoKoromo) == 0x000100, "Wrong size on UJackOddEffectExec_YamiNoKoromo");

// Class JackGame.JackOddEffectExec_Kirakirapawn
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_Kirakirapawn final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Kirakirapawn">();
	}
	static class UJackOddEffectExec_Kirakirapawn* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Kirakirapawn>();
	}
};
static_assert(alignof(UJackOddEffectExec_Kirakirapawn) == 0x000008, "Wrong alignment on UJackOddEffectExec_Kirakirapawn");
static_assert(sizeof(UJackOddEffectExec_Kirakirapawn) == 0x000100, "Wrong size on UJackOddEffectExec_Kirakirapawn");

// Class JackGame.JackOddEffectExec_Kabau
// 0x0008 (0x0108 - 0x0100)
class UJackOddEffectExec_Kabau final : public UJackOddEffectExec
{
public:
	uint8                                         Pad_100[0x8];                                      // 0x0100(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Kabau">();
	}
	static class UJackOddEffectExec_Kabau* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Kabau>();
	}
};
static_assert(alignof(UJackOddEffectExec_Kabau) == 0x000008, "Wrong alignment on UJackOddEffectExec_Kabau");
static_assert(sizeof(UJackOddEffectExec_Kabau) == 0x000108, "Wrong size on UJackOddEffectExec_Kabau");

// Class JackGame.JackOddEffectExec_NioudatiCast
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_NioudatiCast final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_NioudatiCast">();
	}
	static class UJackOddEffectExec_NioudatiCast* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_NioudatiCast>();
	}
};
static_assert(alignof(UJackOddEffectExec_NioudatiCast) == 0x000008, "Wrong alignment on UJackOddEffectExec_NioudatiCast");
static_assert(sizeof(UJackOddEffectExec_NioudatiCast) == 0x000100, "Wrong size on UJackOddEffectExec_NioudatiCast");

// Class JackGame.JackOddEffectExec_NioudatiTarget
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_NioudatiTarget final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_NioudatiTarget">();
	}
	static class UJackOddEffectExec_NioudatiTarget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_NioudatiTarget>();
	}
};
static_assert(alignof(UJackOddEffectExec_NioudatiTarget) == 0x000008, "Wrong alignment on UJackOddEffectExec_NioudatiTarget");
static_assert(sizeof(UJackOddEffectExec_NioudatiTarget) == 0x000100, "Wrong size on UJackOddEffectExec_NioudatiTarget");

// Class JackGame.JackOddEffectExec_Snowman
// 0x0010 (0x0110 - 0x0100)
class UJackOddEffectExec_Snowman final : public UJackOddEffectExec
{
public:
	class UJackStreamObjectsHolder*               ObjectsHolder;                                     // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_Snowman">();
	}
	static class UJackOddEffectExec_Snowman* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_Snowman>();
	}
};
static_assert(alignof(UJackOddEffectExec_Snowman) == 0x000008, "Wrong alignment on UJackOddEffectExec_Snowman");
static_assert(sizeof(UJackOddEffectExec_Snowman) == 0x000110, "Wrong size on UJackOddEffectExec_Snowman");
static_assert(offsetof(UJackOddEffectExec_Snowman, ObjectsHolder) == 0x000100, "Member 'UJackOddEffectExec_Snowman::ObjectsHolder' has a wrong offset!");

// Class JackGame.JackOddEffectExec_RideMonsterEffect
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_RideMonsterEffect final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_RideMonsterEffect">();
	}
	static class UJackOddEffectExec_RideMonsterEffect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_RideMonsterEffect>();
	}
};
static_assert(alignof(UJackOddEffectExec_RideMonsterEffect) == 0x000008, "Wrong alignment on UJackOddEffectExec_RideMonsterEffect");
static_assert(sizeof(UJackOddEffectExec_RideMonsterEffect) == 0x000100, "Wrong size on UJackOddEffectExec_RideMonsterEffect");

// Class JackGame.JackOddEffectExec_MugenHpRate
// 0x0000 (0x0100 - 0x0100)
class UJackOddEffectExec_MugenHpRate final : public UJackOddEffectExec
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExec_MugenHpRate">();
	}
	static class UJackOddEffectExec_MugenHpRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExec_MugenHpRate>();
	}
};
static_assert(alignof(UJackOddEffectExec_MugenHpRate) == 0x000008, "Wrong alignment on UJackOddEffectExec_MugenHpRate");
static_assert(sizeof(UJackOddEffectExec_MugenHpRate) == 0x000100, "Wrong size on UJackOddEffectExec_MugenHpRate");

// Class JackGame.JackOddEffectExecHolder
// 0x0168 (0x01A0 - 0x0038)
class UJackOddEffectExecHolder final : public UObject
{
public:
	TArray<class UJackOddEffectExec*>             Execs;                                             // 0x0038(0x0010)(Edit, ExportObject, ZeroConstructor, Transient, EditConst, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	class FName                                   OddEffectMotionID;                                 // 0x0048(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   OddEffectFacialID;                                 // 0x0050(0x0008)(Edit, ZeroConstructor, Transient, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x148];                                     // 0x0058(0x0148)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectExecHolder">();
	}
	static class UJackOddEffectExecHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectExecHolder>();
	}
};
static_assert(alignof(UJackOddEffectExecHolder) == 0x000008, "Wrong alignment on UJackOddEffectExecHolder");
static_assert(sizeof(UJackOddEffectExecHolder) == 0x0001A0, "Wrong size on UJackOddEffectExecHolder");
static_assert(offsetof(UJackOddEffectExecHolder, Execs) == 0x000038, "Member 'UJackOddEffectExecHolder::Execs' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExecHolder, OddEffectMotionID) == 0x000048, "Member 'UJackOddEffectExecHolder::OddEffectMotionID' has a wrong offset!");
static_assert(offsetof(UJackOddEffectExecHolder, OddEffectFacialID) == 0x000050, "Member 'UJackOddEffectExecHolder::OddEffectFacialID' has a wrong offset!");

// Class JackGame.JackUMGSerifuWindowController
// 0x0568 (0x05A0 - 0x0038)
class UJackUMGSerifuWindowController : public UObject
{
public:
	TSubclassOf<class UJackUMGSerifuWindow>       SerifuWindowClass;                                 // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSlateFontInfo                         Font;                                              // 0x0040(0x0058)(Edit, DisableEditOnInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ContentSize;                                       // 0x0098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MarginLength;                                      // 0x009C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWindowBase>         SelectYesOrNoWindowClass;                          // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWindowBase>         SelectCustomWindowClass;                           // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWindowBase>         SelectBlacksmithWindowClass;                       // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         RenkeiInfoWindowClass;                             // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGFukubikiSlot>       FukubikiSlotClass;                                 // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x78];                                      // 0x00C8(0x0078)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   TextBPDelegate;                                    // 0x0140(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   MessageScriptEvent;                                // 0x0150(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TDelegate<void(bool bIsOpen, int32 InSelectedIndex)> JackOnSelectWindowOpenCloseDelegate;               // 0x0160(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_170[0x30];                                     // 0x0170(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	EJackSerifuWindowType                         SerifuWindowType;                                  // 0x01A0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1A1[0x7];                                      // 0x01A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackUMGSerifuWindowResources> ResourcesClass;                                    // 0x01A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bConnectToRootPanel;                               // 0x01B0(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackUMGTextJustify                           DefaultTextJustify;                                // 0x01B1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackMessageOutputMode                        DefaultOutputMode;                                 // 0x01B2(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B3[0x1];                                      // 0x01B3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultFadeInTime;                                 // 0x01B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackSpeed                                    OverrideMessageSpeed;                              // 0x01B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B9[0x3];                                      // 0x01B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultTalkSeInterval;                             // 0x01BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         AutoCloseTimeAtTokugiPanelMode;                    // 0x01C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bShowParseErrorAssert;                             // 0x01C4(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C5[0x3];                                      // 0x01C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGManager*                        UMGManager;                                        // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowResources*          Resources;                                         // 0x01D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackCharacter*                         TalkingNpc;                                        // 0x01D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E0[0x88];                                     // 0x01E0(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGSerifuWindow*                   SerifuWindow;                                      // 0x0268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ZOrder;                                            // 0x0270(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_274[0x4];                                      // 0x0274(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGWindowBase*                     SelectWindow;                                      // 0x0278(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGWidgetBase*                     RenkeiInfoWindow;                                  // 0x0280(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGFukubikiSlot*                   FukubikiWidget;                                    // 0x0288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_290[0x60];                                     // 0x0290(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultPageFadeOutTime;                            // 0x02F0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         NumberOfDisplayLines;                              // 0x02F4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2F8[0x44];                                     // 0x02F8(0x0044)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputDisableTime;                                  // 0x033C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_340[0x68];                                     // 0x0340(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DisableChoicesFlagList;                            // 0x03A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 DisableColorChoicesFlagList;                       // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<EJackUMGTextColorSet>                  ChoicesTextColorList;                              // 0x03C8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x20];                                     // 0x03D8(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         BlacksmithCreateItemNameList;                      // 0x03F8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<int32>                                 BlacksmithCreateCountList;                         // 0x0408(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJackUMGWidgetBase>      PrevFocusWidget;                                   // 0x0418(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0xC];                                      // 0x0420(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RubyColorRatio;                                    // 0x042C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x4];                                      // 0x0430(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugOutputEditorLog;                             // 0x0434(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugOutputScreenLog;                             // 0x0435(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackMessageArgumentData>       MessageArgumentDataList;                           // 0x0438(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_448[0x138];                                    // 0x0448(0x0138)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGSerifuWindowLatentMessageEndResult* LatentMessageEndResult;                            // 0x0580(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_588[0x18];                                     // 0x0588(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 AddChoicesContent(class FName TextID, bool bEnable);
	int32 AddChoicesContentByFixedText(const class FString& Text, bool bEnable);
	void AddMessageArgumentDataList(const TArray<struct FJackMessageArgumentData>& Args);
	void AddTextAtFixedMessage(const class FString& MessageScript, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	void AddTextAtTextID(const class FName& TextID, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	const int32 ApplyTextLabelFromExternal(const class FString& MessageScript, const TArray<struct FJackMessageArgumentData>& Args, float BasePosX, const TArray<class UTextBlock*>& TextLabelList, int32 LineTextLabelCount, const TArray<class UImage*>& ImageList, int32 LineImageCount, float TextLineLength, int32 MaxLines);
	void ClearDebugOverrideSelectDialogIndex();
	void ClearMessageArgumentDataList();
	void CloseWindow(bool bRefreshFocus);
	void DoSelectSimpleDelegate(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, int32 InSelectDialogIndex);
	TArray<EJackUMGTextColorSet> GetChoicesColorList();
	TArray<int32> GetDisableChoicesFlagList();
	TArray<int32> GetDisableColorChoicesFlagList();
	const TArray<struct FJackMessageArgumentData> GetMessageArgumentDataList();
	TArray<class FString> GetSelectionContent();
	class UJackUMGSerifuWindow* GetSerifuWindow();
	void HastyCloseSerifuWindow();
	void InitTextAtFixedMessage(const class FString& MessageScript, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	void InitTextAtTextID(const class FName& TextID, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	bool IsPlayingMe();
	void JackMessageScriptEventDelegate__DelegateSignature(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, EJackMessageScriptEventType EventType, const class FString& Param);
	void JackOnUMGSelectWindowOpenCloseDelegate__DelegateSignature(bool bIsOpen, int32 InSelectedIndex);
	void JackSerifuTextParseResultDelegate__DelegateSignature(struct FJackUMGSerifuTextParseResult* InTextParseResult);
	void JackSerifuWindowEndDelegate__DelegateSignature();
	void JackSerifuWindowSelectDelegate__DelegateSignature(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, int32 SelectDialogIndex);
	void NoBindLeftAxis();
	void OnCompleteActionByScheduledNPC(const class AJackScheduledNPC* NPC, EJackNPCActionTypeInBPControl ActionType);
	void OnOpenBlacksmithCreateSelectWindow(class UJackUMGWindowBase* InSelectWindow, const TArray<class FString>& ItemNameList, const TArray<int32>& CountList, int32 ItemNameLangth);
	void OnOpenRenkeiInfoWindow(class UJackUMGWidgetBase* InRenkeiInfoWindow, class UJackUMGTuyosaRenkeiData* RenkeiData);
	void OnOpenSelectWindow(class UJackUMGWindowBase* InSelectWindow);
	void OnPlayMEFinished();
	void OnSelectWindowControl(class FName EventName, class UJackUMGItemBase* InItemBase);
	void OnSelectWindowWidgetEvent(class FName EventTag);
	void OnSerifuWindowEvent(class UJackUMGSerifuWindow* Sender, const class FName Tag, float ExcessTime);
	void OnUpdateTextLabel(int32 LabelIndex, int32 MaxLabelCount, const TArray<class UTextBlock*>& TextLabelList, const TArray<class UImage*>& ImageList, TArray<class UTextBlock*>* RubyLabelList);
	void OverwriteButtonWaitFlagOfLastPage(bool bIsEnd);
	void OverwriteChoicesCursorPosition(int32 CursorPos);
	void ResetChoiceColor();
	void SetChoicesColorList(const TArray<EJackUMGTextColorSet>& ColorList);
	void SetDebugOverrideSelectDialogIndex(int32 Value);
	void SetDisableChoicesFlagList(const TArray<int32>& Value);
	void SetDisableColorChoicesFlagList(const TArray<int32>& Value);
	void SetDisableInputFlag(bool bValue);
	void SetEnableRubyVisibilityInBoukennosyo(bool bEnable);
	void SetEnableRubyVisibilityInSystemMenu(bool bEnable);
	void SetFieldMessageAtFixedMessage(const class FString& MessageScript, const TArray<struct FJackMessageArgumentData>& Args);
	void SetForceShowPageMarker(bool bValue);
	void SetMessageEndDelegate(TDelegate<void()> Value);
	void SetPauseAndHide(bool bValue);
	void SetPipipiTypeSetting(EJackPipipiType Value);
	void SetSerifuType(bool Value);
	void SetSerifuWindowSelectDelegate(TDelegate<void(class UJackUMGSerifuWindowController* Sender, class FName CurrentTextID, int32 SelectDialogIndex)> Value);
	void SetTalkingNPC(class AJackCharacter* Value);
	void SetTextAtFixedMessage(const class FString& MessageScript, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	void SetTextAtTextID(const class FName& TextID, const TArray<struct FJackMessageArgumentData>& Args, bool bIsFocusWindow);
	void SetTextWithVoice(bool bWithVoice);
	void SettingMEFromMEID(class FName InMeId, bool bInBattleType);
	void SetTokugiPanelMessage(class FName TextID, const TArray<struct FJackMessageArgumentData>& Args);
	void SetVisibleBackgroundImage(bool bValue);
	void SetZOrder(int32 InZOrder);
	void ShowBlacksmithCreateSelectWindow(const TArray<class FName>& ItemIDList, const TArray<int32>& CountList);
	void StartFadeOut(float FadeOutTime);
	void TextPageFeed();
	void VoiceStopped();
	void WaitMessageEndFromBP(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class UJackUMGSerifuWindowLatentMessageEndResult** Result);
	void WaitOneFrame(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

	EJackFukubikiPayout GetFukubikiPayout() const;
	void GetSerifuWindowDebugInfo(struct FJackUMGSerifuWindowDebug* OutDebugInfo) const;
	int32 GetSimpleTextLineCount() const;
	const struct FJackUMGSerifuTextParseResult GetTextParseResult() const;
	int32 GetZOrder() const;
	bool IsDebugInvisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSerifuWindowController">();
	}
	static class UJackUMGSerifuWindowController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSerifuWindowController>();
	}
};
static_assert(alignof(UJackUMGSerifuWindowController) == 0x000008, "Wrong alignment on UJackUMGSerifuWindowController");
static_assert(sizeof(UJackUMGSerifuWindowController) == 0x0005A0, "Wrong size on UJackUMGSerifuWindowController");
static_assert(offsetof(UJackUMGSerifuWindowController, SerifuWindowClass) == 0x000038, "Member 'UJackUMGSerifuWindowController::SerifuWindowClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, Font) == 0x000040, "Member 'UJackUMGSerifuWindowController::Font' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, ContentSize) == 0x000098, "Member 'UJackUMGSerifuWindowController::ContentSize' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, MarginLength) == 0x00009C, "Member 'UJackUMGSerifuWindowController::MarginLength' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SelectYesOrNoWindowClass) == 0x0000A0, "Member 'UJackUMGSerifuWindowController::SelectYesOrNoWindowClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SelectCustomWindowClass) == 0x0000A8, "Member 'UJackUMGSerifuWindowController::SelectCustomWindowClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SelectBlacksmithWindowClass) == 0x0000B0, "Member 'UJackUMGSerifuWindowController::SelectBlacksmithWindowClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, RenkeiInfoWindowClass) == 0x0000B8, "Member 'UJackUMGSerifuWindowController::RenkeiInfoWindowClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, FukubikiSlotClass) == 0x0000C0, "Member 'UJackUMGSerifuWindowController::FukubikiSlotClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, TextBPDelegate) == 0x000140, "Member 'UJackUMGSerifuWindowController::TextBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, MessageScriptEvent) == 0x000150, "Member 'UJackUMGSerifuWindowController::MessageScriptEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, JackOnSelectWindowOpenCloseDelegate) == 0x000160, "Member 'UJackUMGSerifuWindowController::JackOnSelectWindowOpenCloseDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SerifuWindowType) == 0x0001A0, "Member 'UJackUMGSerifuWindowController::SerifuWindowType' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, ResourcesClass) == 0x0001A8, "Member 'UJackUMGSerifuWindowController::ResourcesClass' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, bConnectToRootPanel) == 0x0001B0, "Member 'UJackUMGSerifuWindowController::bConnectToRootPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DefaultTextJustify) == 0x0001B1, "Member 'UJackUMGSerifuWindowController::DefaultTextJustify' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DefaultOutputMode) == 0x0001B2, "Member 'UJackUMGSerifuWindowController::DefaultOutputMode' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DefaultFadeInTime) == 0x0001B4, "Member 'UJackUMGSerifuWindowController::DefaultFadeInTime' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, OverrideMessageSpeed) == 0x0001B8, "Member 'UJackUMGSerifuWindowController::OverrideMessageSpeed' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DefaultTalkSeInterval) == 0x0001BC, "Member 'UJackUMGSerifuWindowController::DefaultTalkSeInterval' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, AutoCloseTimeAtTokugiPanelMode) == 0x0001C0, "Member 'UJackUMGSerifuWindowController::AutoCloseTimeAtTokugiPanelMode' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, bShowParseErrorAssert) == 0x0001C4, "Member 'UJackUMGSerifuWindowController::bShowParseErrorAssert' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, UMGManager) == 0x0001C8, "Member 'UJackUMGSerifuWindowController::UMGManager' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, Resources) == 0x0001D0, "Member 'UJackUMGSerifuWindowController::Resources' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, TalkingNpc) == 0x0001D8, "Member 'UJackUMGSerifuWindowController::TalkingNpc' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SerifuWindow) == 0x000268, "Member 'UJackUMGSerifuWindowController::SerifuWindow' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, ZOrder) == 0x000270, "Member 'UJackUMGSerifuWindowController::ZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, SelectWindow) == 0x000278, "Member 'UJackUMGSerifuWindowController::SelectWindow' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, RenkeiInfoWindow) == 0x000280, "Member 'UJackUMGSerifuWindowController::RenkeiInfoWindow' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, FukubikiWidget) == 0x000288, "Member 'UJackUMGSerifuWindowController::FukubikiWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DefaultPageFadeOutTime) == 0x0002F0, "Member 'UJackUMGSerifuWindowController::DefaultPageFadeOutTime' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, NumberOfDisplayLines) == 0x0002F4, "Member 'UJackUMGSerifuWindowController::NumberOfDisplayLines' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, InputDisableTime) == 0x00033C, "Member 'UJackUMGSerifuWindowController::InputDisableTime' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DisableChoicesFlagList) == 0x0003A8, "Member 'UJackUMGSerifuWindowController::DisableChoicesFlagList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, DisableColorChoicesFlagList) == 0x0003B8, "Member 'UJackUMGSerifuWindowController::DisableColorChoicesFlagList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, ChoicesTextColorList) == 0x0003C8, "Member 'UJackUMGSerifuWindowController::ChoicesTextColorList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, BlacksmithCreateItemNameList) == 0x0003F8, "Member 'UJackUMGSerifuWindowController::BlacksmithCreateItemNameList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, BlacksmithCreateCountList) == 0x000408, "Member 'UJackUMGSerifuWindowController::BlacksmithCreateCountList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, PrevFocusWidget) == 0x000418, "Member 'UJackUMGSerifuWindowController::PrevFocusWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, RubyColorRatio) == 0x00042C, "Member 'UJackUMGSerifuWindowController::RubyColorRatio' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, bDebugOutputEditorLog) == 0x000434, "Member 'UJackUMGSerifuWindowController::bDebugOutputEditorLog' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, bDebugOutputScreenLog) == 0x000435, "Member 'UJackUMGSerifuWindowController::bDebugOutputScreenLog' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, MessageArgumentDataList) == 0x000438, "Member 'UJackUMGSerifuWindowController::MessageArgumentDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGSerifuWindowController, LatentMessageEndResult) == 0x000580, "Member 'UJackUMGSerifuWindowController::LatentMessageEndResult' has a wrong offset!");

// Class JackGame.JackOddEffectStructs
// 0x0000 (0x0038 - 0x0038)
class UJackOddEffectStructs final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectStructs">();
	}
	static class UJackOddEffectStructs* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectStructs>();
	}
};
static_assert(alignof(UJackOddEffectStructs) == 0x000008, "Wrong alignment on UJackOddEffectStructs");
static_assert(sizeof(UJackOddEffectStructs) == 0x000038, "Wrong size on UJackOddEffectStructs");

// Class JackGame.JackOddEffectTemporaryMaterial
// 0x0028 (0x0060 - 0x0038)
class UJackOddEffectTemporaryMaterial final : public UObject
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectTemporaryMaterial">();
	}
	static class UJackOddEffectTemporaryMaterial* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectTemporaryMaterial>();
	}
};
static_assert(alignof(UJackOddEffectTemporaryMaterial) == 0x000008, "Wrong alignment on UJackOddEffectTemporaryMaterial");
static_assert(sizeof(UJackOddEffectTemporaryMaterial) == 0x000060, "Wrong size on UJackOddEffectTemporaryMaterial");

// Class JackGame.JackOddEffectTypes
// 0x0000 (0x0038 - 0x0038)
class UJackOddEffectTypes final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOddEffectTypes">();
	}
	static class UJackOddEffectTypes* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOddEffectTypes>();
	}
};
static_assert(alignof(UJackOddEffectTypes) == 0x000008, "Wrong alignment on UJackOddEffectTypes");
static_assert(sizeof(UJackOddEffectTypes) == 0x000038, "Wrong size on UJackOddEffectTypes");

// Class JackGame.JackOmakeMessageWindow
// 0x0090 (0x0260 - 0x01D0)
class UJackOmakeMessageWindow final : public UUserWidget
{
public:
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OneMessageTime;                                    // 0x01E0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E4[0x4];                                      // 0x01E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             SoundTalk;                                         // 0x01E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         SoundTalkStringCount;                              // 0x01F0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1F4[0x6C];                                     // 0x01F4(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Delegate__DelegateSignature();
	void DisplayMessage(class FName InTextId);
	void DoExecuteAction(class FName InName);
	void EndMessageScroll();
	void EndSelectWindow();
	TArray<class FText> GetCurrentText();
	int32 GetDisplayTextLineNum();
	EJackOmakeMessageState GetState();
	bool IsUpdateMessage();
	void JackOmakeWindowBPActionDelegate__DelegateSignature(const class FName EventTag);
	void OnSeSoundPlay(const class FName SEName);
	void SetBPActionDelegate(TDelegate<void(class FName EventTag)> InDelegate);
	void SetMessageEndDelegate(TDelegate<void()> InDelegate);
	void SetTextId(class FName InTextId);
	void Update(float DeltaTime);

	int32 GetStringCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOmakeMessageWindow">();
	}
	static class UJackOmakeMessageWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOmakeMessageWindow>();
	}
};
static_assert(alignof(UJackOmakeMessageWindow) == 0x000008, "Wrong alignment on UJackOmakeMessageWindow");
static_assert(sizeof(UJackOmakeMessageWindow) == 0x000260, "Wrong size on UJackOmakeMessageWindow");
static_assert(offsetof(UJackOmakeMessageWindow, OneMessageTime) == 0x0001E0, "Member 'UJackOmakeMessageWindow::OneMessageTime' has a wrong offset!");
static_assert(offsetof(UJackOmakeMessageWindow, SoundTalk) == 0x0001E8, "Member 'UJackOmakeMessageWindow::SoundTalk' has a wrong offset!");
static_assert(offsetof(UJackOmakeMessageWindow, SoundTalkStringCount) == 0x0001F0, "Member 'UJackOmakeMessageWindow::SoundTalkStringCount' has a wrong offset!");

// Class JackGame.JackOmakeSelectWindow
// 0x0020 (0x01F0 - 0x01D0)
class UJackOmakeSelectWindow final : public UUserWidget
{
public:
	int32                                         CursorPos;                                         // 0x01D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D4[0x1C];                                     // 0x01D4(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitWindow();
	void JackOmakeSelectWindowActionDelegate__DelegateSignature(const class FName EventTag);
	void SetBPActionDelegate(TDelegate<void(class FName EventTag)> InDelegate);
	void Update(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOmakeSelectWindow">();
	}
	static class UJackOmakeSelectWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOmakeSelectWindow>();
	}
};
static_assert(alignof(UJackOmakeSelectWindow) == 0x000008, "Wrong alignment on UJackOmakeSelectWindow");
static_assert(sizeof(UJackOmakeSelectWindow) == 0x0001F0, "Wrong size on UJackOmakeSelectWindow");
static_assert(offsetof(UJackOmakeSelectWindow, CursorPos) == 0x0001D0, "Member 'UJackOmakeSelectWindow::CursorPos' has a wrong offset!");

// Class JackGame.JackOSDKSettings
// 0x0000 (0x0098 - 0x0098)
class UJackOSDKSettings final : public UOSDKSettings
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOSDKSettings">();
	}
	static class UJackOSDKSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOSDKSettings>();
	}
};
static_assert(alignof(UJackOSDKSettings) == 0x000008, "Wrong alignment on UJackOSDKSettings");
static_assert(sizeof(UJackOSDKSettings) == 0x000098, "Wrong size on UJackOSDKSettings");

// Class JackGame.JackOverlappedActorComponent
// 0x0030 (0x0158 - 0x0128)
class UJackOverlappedActorComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x30];                                     // 0x0128(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddOverlappedComponent(class UPrimitiveComponent* OtherComp);
	bool AddOverlappedComponentSyncActorList(class UPrimitiveComponent* OtherComp);
	TArray<class AActor*> GetOverlappedActorList();
	float GetOverlappedActorListTimer(int32 Index_0);
	bool IsTimeExpiredOverlappedActorList(int32 Index_0);
	void RemoveOverlappedComponent(class UPrimitiveComponent* OtherComp);
	bool RemoveOverlappedComponentSyncActorList(class UPrimitiveComponent* OtherComp);
	void SetOverlappedActorListTimer(int32 Index_0, float Timer);
	void SetOverlappedActorListTimerAll(float Timer);
	void SyncActorList(float DeltaTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackOverlappedActorComponent">();
	}
	static class UJackOverlappedActorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackOverlappedActorComponent>();
	}
};
static_assert(alignof(UJackOverlappedActorComponent) == 0x000008, "Wrong alignment on UJackOverlappedActorComponent");
static_assert(sizeof(UJackOverlappedActorComponent) == 0x000158, "Wrong size on UJackOverlappedActorComponent");

// Class JackGame.JackPafuPafuMode
// 0x02B8 (0x0650 - 0x0398)
class AJackPafuPafuMode final : public AActor
{
public:
	class UJackPafuPafuParameter*                 PafuParam[0x2];                                    // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackPafuPafuParameter>     PafuParamClass;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LightThreshold;                                    // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrongThreshold;                                   // 0x03B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StrongestThreshold;                                // 0x03B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BC[0x4];                                      // 0x03BC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(int32 StrongAccleration)>      PafuPafuLeftDelegate;                              // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TDelegate<void(int32 StrongAccleration)>      PafuPafuRightDelegate;                             // 0x03D0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        DelegateList;                                      // 0x03E0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F0[0x260];                                    // 0x03F0(0x0260)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackPafuPafuAccelerationDelegate__DelegateSignature(const int32 StrongAccleration);
	void SetAllMotorReactFlag(bool InReactFlag);
	void SetMaxAcceleration(float InMaxAcceleration);
	void SetPafuPafuDecisionFlag(bool InDecisionFlag);
	void SetReactFlag(int32 InMotorIndex, bool InReactFlag);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPafuPafuMode">();
	}
	static class AJackPafuPafuMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPafuPafuMode>();
	}
};
static_assert(alignof(AJackPafuPafuMode) == 0x000008, "Wrong alignment on AJackPafuPafuMode");
static_assert(sizeof(AJackPafuPafuMode) == 0x000650, "Wrong size on AJackPafuPafuMode");
static_assert(offsetof(AJackPafuPafuMode, PafuParam) == 0x000398, "Member 'AJackPafuPafuMode::PafuParam' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, PafuParamClass) == 0x0003A8, "Member 'AJackPafuPafuMode::PafuParamClass' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, LightThreshold) == 0x0003B0, "Member 'AJackPafuPafuMode::LightThreshold' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, StrongThreshold) == 0x0003B4, "Member 'AJackPafuPafuMode::StrongThreshold' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, StrongestThreshold) == 0x0003B8, "Member 'AJackPafuPafuMode::StrongestThreshold' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, PafuPafuLeftDelegate) == 0x0003C0, "Member 'AJackPafuPafuMode::PafuPafuLeftDelegate' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, PafuPafuRightDelegate) == 0x0003D0, "Member 'AJackPafuPafuMode::PafuPafuRightDelegate' has a wrong offset!");
static_assert(offsetof(AJackPafuPafuMode, DelegateList) == 0x0003E0, "Member 'AJackPafuPafuMode::DelegateList' has a wrong offset!");

// Class JackGame.JackPairingManager
// 0x0050 (0x0088 - 0x0038)
class UJackPairingManager : public UObject
{
public:
	uint8                                         Pad_38[0x50];                                      // 0x0038(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeXboxOnePairing();
	bool IsSignedInXUser();
	void OpenMSGamersTag();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPairingManager">();
	}
	static class UJackPairingManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPairingManager>();
	}
};
static_assert(alignof(UJackPairingManager) == 0x000008, "Wrong alignment on UJackPairingManager");
static_assert(sizeof(UJackPairingManager) == 0x000088, "Wrong size on UJackPairingManager");

// Class JackGame.JackParadeNPC
// 0x02A0 (0x1390 - 0x10F0)
class AJackParadeNPC final : public AJackCharacter
{
public:
	struct FJackLDT_NPCList                       UniqueID;                                          // 0x10F0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	EJackNPCType                                  NPCType;                                           // 0x1100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bParadeCarry_RightPosition;                        // 0x1101(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1102[0x2];                                     // 0x1102(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LoadReduction_SkipFacial_Distance;                 // 0x1104(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipSkeletalMeshComponent_Distance;  // 0x1108(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipSkeletalMeshComponent_Velocity;  // 0x110C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DetectObstacleCapsuleInflation;                    // 0x1110(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionResponseContainer            DetectObstacleResponseParams;                      // 0x1114(0x0020)(Edit, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1134[0x4];                                     // 0x1134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 SpawnClass_ParadeNPC_P005;                         // 0x1138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeDancerNPC1;                       // 0x1140(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeDancerNPC2;                       // 0x1148(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeDancerNPC3;                       // 0x1150(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeDancerNPC4;                       // 0x1158(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeMusicianNPC1;                     // 0x1160(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeMusicianNPC2;                     // 0x1168(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeMusicianNPC3;                     // 0x1170(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeCarryNPC1;                        // 0x1178(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeCarryNPC2;                        // 0x1180(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeCarryNPC3;                        // 0x1188(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 SpawnClass_ParadeCarryNPC4;                        // 0x1190(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           StartAnimMontage;                                  // 0x1198(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           WaitAnimMontage;                                   // 0x11A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           MoveAnimMontage;                                   // 0x11A8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           TurnAnimMontage;                                   // 0x11B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_MoveSpeed;                          // 0x11B8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_TurnSpeed;                          // 0x11BC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_MoveDistance;                       // 0x11C0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_StopDistance;                       // 0x11C4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_MoveRouteDistance;                  // 0x11C8(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_StopRouteDistance;                  // 0x11CC(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_MoveAngle;                          // 0x11D0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PortableShrine_TurnDelaySeconds;                   // 0x11D4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackLoadReductionComponent*            LoadReductionComponent;                            // 0x11D8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackParadeNPC>          ParadeNPC_P005;                                    // 0x11E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackParadeNPC>          ParadeDancerNPC[0x4];                              // 0x11E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackParadeNPC>          ParadeMusicianNPC[0x3];                            // 0x1208(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackParadeNPC>          ParadeCarryNPC[0x4];                               // 0x1220(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UArrowComponent>         PortableShrine_DancerPointRoot;                    // 0x1240(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UArrowComponent>         PortableShrine_DancerPoint[0x4];                   // 0x1248(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UArrowComponent>         PortableShrine_MusicianPointRoot;                  // 0x1268(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UArrowComponent>         PortableShrine_MusicianPoint[0x3];                 // 0x1270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UArrowComponent>         PortableShrine_CarryPoint[0x4];                    // 0x1288(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class USplineComponent>        PortableShrine_MoveSpline;                         // 0x12A8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_12B0[0xE0];                                    // 0x12B0(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitializeForPortableShrine(class AActor* StartPoint);

	struct FTransform GetParadeCarryHandTransform() const;
	float GetParadeCarryRightPositionRate() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParadeNPC">();
	}
	static class AJackParadeNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackParadeNPC>();
	}
};
static_assert(alignof(AJackParadeNPC) == 0x000010, "Wrong alignment on AJackParadeNPC");
static_assert(sizeof(AJackParadeNPC) == 0x001390, "Wrong size on AJackParadeNPC");
static_assert(offsetof(AJackParadeNPC, UniqueID) == 0x0010F0, "Member 'AJackParadeNPC::UniqueID' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, NPCType) == 0x001100, "Member 'AJackParadeNPC::NPCType' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, bParadeCarry_RightPosition) == 0x001101, "Member 'AJackParadeNPC::bParadeCarry_RightPosition' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, LoadReduction_SkipFacial_Distance) == 0x001104, "Member 'AJackParadeNPC::LoadReduction_SkipFacial_Distance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, LoadReduction_SkipSkeletalMeshComponent_Distance) == 0x001108, "Member 'AJackParadeNPC::LoadReduction_SkipSkeletalMeshComponent_Distance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, LoadReduction_SkipSkeletalMeshComponent_Velocity) == 0x00110C, "Member 'AJackParadeNPC::LoadReduction_SkipSkeletalMeshComponent_Velocity' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, DetectObstacleCapsuleInflation) == 0x001110, "Member 'AJackParadeNPC::DetectObstacleCapsuleInflation' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, DetectObstacleResponseParams) == 0x001114, "Member 'AJackParadeNPC::DetectObstacleResponseParams' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeNPC_P005) == 0x001138, "Member 'AJackParadeNPC::SpawnClass_ParadeNPC_P005' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeDancerNPC1) == 0x001140, "Member 'AJackParadeNPC::SpawnClass_ParadeDancerNPC1' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeDancerNPC2) == 0x001148, "Member 'AJackParadeNPC::SpawnClass_ParadeDancerNPC2' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeDancerNPC3) == 0x001150, "Member 'AJackParadeNPC::SpawnClass_ParadeDancerNPC3' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeDancerNPC4) == 0x001158, "Member 'AJackParadeNPC::SpawnClass_ParadeDancerNPC4' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeMusicianNPC1) == 0x001160, "Member 'AJackParadeNPC::SpawnClass_ParadeMusicianNPC1' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeMusicianNPC2) == 0x001168, "Member 'AJackParadeNPC::SpawnClass_ParadeMusicianNPC2' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeMusicianNPC3) == 0x001170, "Member 'AJackParadeNPC::SpawnClass_ParadeMusicianNPC3' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeCarryNPC1) == 0x001178, "Member 'AJackParadeNPC::SpawnClass_ParadeCarryNPC1' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeCarryNPC2) == 0x001180, "Member 'AJackParadeNPC::SpawnClass_ParadeCarryNPC2' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeCarryNPC3) == 0x001188, "Member 'AJackParadeNPC::SpawnClass_ParadeCarryNPC3' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, SpawnClass_ParadeCarryNPC4) == 0x001190, "Member 'AJackParadeNPC::SpawnClass_ParadeCarryNPC4' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, StartAnimMontage) == 0x001198, "Member 'AJackParadeNPC::StartAnimMontage' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, WaitAnimMontage) == 0x0011A0, "Member 'AJackParadeNPC::WaitAnimMontage' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, MoveAnimMontage) == 0x0011A8, "Member 'AJackParadeNPC::MoveAnimMontage' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, TurnAnimMontage) == 0x0011B0, "Member 'AJackParadeNPC::TurnAnimMontage' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MoveSpeed) == 0x0011B8, "Member 'AJackParadeNPC::PortableShrine_MoveSpeed' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_TurnSpeed) == 0x0011BC, "Member 'AJackParadeNPC::PortableShrine_TurnSpeed' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MoveDistance) == 0x0011C0, "Member 'AJackParadeNPC::PortableShrine_MoveDistance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_StopDistance) == 0x0011C4, "Member 'AJackParadeNPC::PortableShrine_StopDistance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MoveRouteDistance) == 0x0011C8, "Member 'AJackParadeNPC::PortableShrine_MoveRouteDistance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_StopRouteDistance) == 0x0011CC, "Member 'AJackParadeNPC::PortableShrine_StopRouteDistance' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MoveAngle) == 0x0011D0, "Member 'AJackParadeNPC::PortableShrine_MoveAngle' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_TurnDelaySeconds) == 0x0011D4, "Member 'AJackParadeNPC::PortableShrine_TurnDelaySeconds' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, LoadReductionComponent) == 0x0011D8, "Member 'AJackParadeNPC::LoadReductionComponent' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, ParadeNPC_P005) == 0x0011E0, "Member 'AJackParadeNPC::ParadeNPC_P005' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, ParadeDancerNPC) == 0x0011E8, "Member 'AJackParadeNPC::ParadeDancerNPC' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, ParadeMusicianNPC) == 0x001208, "Member 'AJackParadeNPC::ParadeMusicianNPC' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, ParadeCarryNPC) == 0x001220, "Member 'AJackParadeNPC::ParadeCarryNPC' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_DancerPointRoot) == 0x001240, "Member 'AJackParadeNPC::PortableShrine_DancerPointRoot' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_DancerPoint) == 0x001248, "Member 'AJackParadeNPC::PortableShrine_DancerPoint' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MusicianPointRoot) == 0x001268, "Member 'AJackParadeNPC::PortableShrine_MusicianPointRoot' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MusicianPoint) == 0x001270, "Member 'AJackParadeNPC::PortableShrine_MusicianPoint' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_CarryPoint) == 0x001288, "Member 'AJackParadeNPC::PortableShrine_CarryPoint' has a wrong offset!");
static_assert(offsetof(AJackParadeNPC, PortableShrine_MoveSpline) == 0x0012A8, "Member 'AJackParadeNPC::PortableShrine_MoveSpline' has a wrong offset!");

// Class JackGame.JackUMGTokugiPanelData
// 0x00E0 (0x0118 - 0x0038)
class UJackUMGTokugiPanelData : public UObject
{
public:
	class FName                                   ID;                                                // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Order;                                             // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PanelPos;                                          // 0x0044(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NeedSkillPoint;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSealed;                                           // 0x0050(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockPanel;                                        // 0x0051(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x2];                                       // 0x0052(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LockCount;                                         // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAtariPanel;                                       // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IconType;                                          // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJackSkillLine>                        SkillLineTypeList;                                 // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	EJackItem_Classification                      ConfirmWeaponType;                                 // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConfirmMessage;                                    // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LearnedMessage;                                    // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SingleLearnedMessage;                              // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_90[0x40];                                      // 0x0090(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             IconTexture;                                       // 0x00D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D8[0xC];                                       // 0x00D8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Index_0;                                           // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackTokugiPanelPieceState                    State;                                             // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x7];                                       // 0x00E9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            TargetWidget;                                      // 0x00F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UUserWidget*                            LockWidget;                                        // 0x00F8(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PanelDrawPos;                                      // 0x0100(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x1];                                      // 0x0108(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackUMGTokugiPanelAdjoinData          AdjoinData;                                        // 0x0109(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bProvMasterCheck;                                  // 0x0111(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnoughSkillPoint;                                 // 0x0112(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnoughRemainSkillPoint;                           // 0x0113(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RenkeiLearningFlag;                                // 0x0114(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static TArray<class UJackUMGTokugiPanelData*> GetTokugiPanelDataListTest2(class UObject* WorldContextObject, TSubclassOf<class UJackUMGTokugiPanelData> MakeClass, EJackCharacter TargetCharacter, EJackTokugiPanelScenario ScenarioFlag, bool bInBattleResult);

	bool HasSkillLineType(EJackSkillLine SkillLineType);

	bool CanOpen() const;
	class FName GetActionID() const;
	class FString GetDescription() const;
	TArray<class UTexture2D*> GetExecutableWeaponIconList() const;
	class UTexture2D* GetIconTexture() const;
	class FString GetName() const;
	class FName GetNameId() const;
	class FString GetNeedSkillPointText() const;
	class FString GetPanelStateString() const;
	int32 GetRemainLockCount() const;
	class FString GetSkillLineName() const;
	EJackTokugiType GetSkillType() const;
	int32 GetUseMp() const;
	bool IsBasePanel() const;
	bool IsLimitedExecutableWeapon() const;
	bool IsNowLock() const;
	bool IsSealedOrLock() const;
	bool IsWithBareHands() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPanelData">();
	}
	static class UJackUMGTokugiPanelData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPanelData>();
	}
};
static_assert(alignof(UJackUMGTokugiPanelData) == 0x000008, "Wrong alignment on UJackUMGTokugiPanelData");
static_assert(sizeof(UJackUMGTokugiPanelData) == 0x000118, "Wrong size on UJackUMGTokugiPanelData");
static_assert(offsetof(UJackUMGTokugiPanelData, ID) == 0x000038, "Member 'UJackUMGTokugiPanelData::ID' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, Order) == 0x000040, "Member 'UJackUMGTokugiPanelData::Order' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, PanelPos) == 0x000044, "Member 'UJackUMGTokugiPanelData::PanelPos' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, NeedSkillPoint) == 0x00004C, "Member 'UJackUMGTokugiPanelData::NeedSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bSealed) == 0x000050, "Member 'UJackUMGTokugiPanelData::bSealed' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bLockPanel) == 0x000051, "Member 'UJackUMGTokugiPanelData::bLockPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, LockCount) == 0x000054, "Member 'UJackUMGTokugiPanelData::LockCount' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bAtariPanel) == 0x000058, "Member 'UJackUMGTokugiPanelData::bAtariPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, IconType) == 0x00005C, "Member 'UJackUMGTokugiPanelData::IconType' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, SkillLineTypeList) == 0x000060, "Member 'UJackUMGTokugiPanelData::SkillLineTypeList' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, ConfirmWeaponType) == 0x000070, "Member 'UJackUMGTokugiPanelData::ConfirmWeaponType' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, ConfirmMessage) == 0x000078, "Member 'UJackUMGTokugiPanelData::ConfirmMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, LearnedMessage) == 0x000080, "Member 'UJackUMGTokugiPanelData::LearnedMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, SingleLearnedMessage) == 0x000088, "Member 'UJackUMGTokugiPanelData::SingleLearnedMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, IconTexture) == 0x0000D0, "Member 'UJackUMGTokugiPanelData::IconTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, Index_0) == 0x0000E4, "Member 'UJackUMGTokugiPanelData::Index_0' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, State) == 0x0000E8, "Member 'UJackUMGTokugiPanelData::State' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, TargetWidget) == 0x0000F0, "Member 'UJackUMGTokugiPanelData::TargetWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, LockWidget) == 0x0000F8, "Member 'UJackUMGTokugiPanelData::LockWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, PanelDrawPos) == 0x000100, "Member 'UJackUMGTokugiPanelData::PanelDrawPos' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, AdjoinData) == 0x000109, "Member 'UJackUMGTokugiPanelData::AdjoinData' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bProvMasterCheck) == 0x000111, "Member 'UJackUMGTokugiPanelData::bProvMasterCheck' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bEnoughSkillPoint) == 0x000112, "Member 'UJackUMGTokugiPanelData::bEnoughSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, bEnoughRemainSkillPoint) == 0x000113, "Member 'UJackUMGTokugiPanelData::bEnoughRemainSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelData, RenkeiLearningFlag) == 0x000114, "Member 'UJackUMGTokugiPanelData::RenkeiLearningFlag' has a wrong offset!");

// Class JackGame.JackParameterUpdaterFloat
// 0x0010 (0x00F0 - 0x00E0)
class UJackParameterUpdaterFloat final : public UJackParameterUpdater
{
public:
	uint8                                         Pad_E0[0x10];                                      // 0x00E0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParameterUpdaterFloat">();
	}
	static class UJackParameterUpdaterFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParameterUpdaterFloat>();
	}
};
static_assert(alignof(UJackParameterUpdaterFloat) == 0x000008, "Wrong alignment on UJackParameterUpdaterFloat");
static_assert(sizeof(UJackParameterUpdaterFloat) == 0x0000F0, "Wrong size on UJackParameterUpdaterFloat");

// Class JackGame.JackParameterUpdaterLinearColor
// 0x0030 (0x0110 - 0x00E0)
class UJackParameterUpdaterLinearColor final : public UJackParameterUpdater
{
public:
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParameterUpdaterLinearColor">();
	}
	static class UJackParameterUpdaterLinearColor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParameterUpdaterLinearColor>();
	}
};
static_assert(alignof(UJackParameterUpdaterLinearColor) == 0x000008, "Wrong alignment on UJackParameterUpdaterLinearColor");
static_assert(sizeof(UJackParameterUpdaterLinearColor) == 0x000110, "Wrong size on UJackParameterUpdaterLinearColor");

// Class JackGame.JackParameterUpdaterVector
// 0x0030 (0x0110 - 0x00E0)
class UJackParameterUpdaterVector final : public UJackParameterUpdater
{
public:
	uint8                                         Pad_E0[0x30];                                      // 0x00E0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParameterUpdaterVector">();
	}
	static class UJackParameterUpdaterVector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParameterUpdaterVector>();
	}
};
static_assert(alignof(UJackParameterUpdaterVector) == 0x000008, "Wrong alignment on UJackParameterUpdaterVector");
static_assert(sizeof(UJackParameterUpdaterVector) == 0x000110, "Wrong size on UJackParameterUpdaterVector");

// Class JackGame.JackParticleEventSystem
// 0x0000 (0x0038 - 0x0038)
class UJackParticleEventSystem final : public UParticleEventSystem
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackParticleEventSystem">();
	}
	static class UJackParticleEventSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackParticleEventSystem>();
	}
};
static_assert(alignof(UJackParticleEventSystem) == 0x000008, "Wrong alignment on UJackParticleEventSystem");
static_assert(sizeof(UJackParticleEventSystem) == 0x000038, "Wrong size on UJackParticleEventSystem");

// Class JackGame.JackPartyManager
// 0x0148 (0x04E0 - 0x0398)
class AJackPartyManager : public AActor
{
public:
	uint8                                         Pad_398[0xA0];                                     // 0x0398(0x00A0)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackStreamObjectsHolder*>       VehicleClassArray;                                 // 0x0438(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_448[0x18];                                     // 0x0448(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               PartyTalkCharacterAssetHolder;                     // 0x0460(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_468[0x8];                                      // 0x0468(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               GuestNPCCharacterAssetHolder;                      // 0x0470(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_478[0x4];                                      // 0x0478(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ThinCapsuleRadiusSpeed;                            // 0x047C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackFriendAnimation                          FollowingFriendAnimationType;                      // 0x0480(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackActionCursor                             FollowingCharacterActionCursorType;                // 0x0481(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_482[0x5E];                                     // 0x0482(0x005E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnVehicleSpawnMessage(class AActor* Vehicle, bool bMustTransferPossess);
	void PreloadVehicleClass(EJackVehicleModelId ModelId);
	void UnloadVehicleClass(EJackVehicleModelId ModelId);

	bool IsPreloadVehicleClassComplete(EJackVehicleModelId ModelId) const;
	bool IsPreloadVehicleClassCompleteAll() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPartyManager">();
	}
	static class AJackPartyManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPartyManager>();
	}
};
static_assert(alignof(AJackPartyManager) == 0x000008, "Wrong alignment on AJackPartyManager");
static_assert(sizeof(AJackPartyManager) == 0x0004E0, "Wrong size on AJackPartyManager");
static_assert(offsetof(AJackPartyManager, VehicleClassArray) == 0x000438, "Member 'AJackPartyManager::VehicleClassArray' has a wrong offset!");
static_assert(offsetof(AJackPartyManager, PartyTalkCharacterAssetHolder) == 0x000460, "Member 'AJackPartyManager::PartyTalkCharacterAssetHolder' has a wrong offset!");
static_assert(offsetof(AJackPartyManager, GuestNPCCharacterAssetHolder) == 0x000470, "Member 'AJackPartyManager::GuestNPCCharacterAssetHolder' has a wrong offset!");
static_assert(offsetof(AJackPartyManager, ThinCapsuleRadiusSpeed) == 0x00047C, "Member 'AJackPartyManager::ThinCapsuleRadiusSpeed' has a wrong offset!");
static_assert(offsetof(AJackPartyManager, FollowingFriendAnimationType) == 0x000480, "Member 'AJackPartyManager::FollowingFriendAnimationType' has a wrong offset!");
static_assert(offsetof(AJackPartyManager, FollowingCharacterActionCursorType) == 0x000481, "Member 'AJackPartyManager::FollowingCharacterActionCursorType' has a wrong offset!");

// Class JackGame.JackPasserbyGenerator
// 0x0040 (0x03E0 - 0x03A0)
class AJackPasserbyGenerator final : public AJackLocator
{
public:
	TSubclassOf<class UJackPasserbyTable>         PasserbyTable;                                     // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x34];                                     // 0x03AC(0x0034)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPasserbyGenerator">();
	}
	static class AJackPasserbyGenerator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPasserbyGenerator>();
	}
};
static_assert(alignof(AJackPasserbyGenerator) == 0x000008, "Wrong alignment on AJackPasserbyGenerator");
static_assert(sizeof(AJackPasserbyGenerator) == 0x0003E0, "Wrong size on AJackPasserbyGenerator");
static_assert(offsetof(AJackPasserbyGenerator, PasserbyTable) == 0x0003A0, "Member 'AJackPasserbyGenerator::PasserbyTable' has a wrong offset!");
static_assert(offsetof(AJackPasserbyGenerator, Radius) == 0x0003A8, "Member 'AJackPasserbyGenerator::Radius' has a wrong offset!");

// Class JackGame.JackPasserbyTable
// 0x0040 (0x0078 - 0x0038)
class UJackPasserbyTable final : public UObject
{
public:
	float                                         MinDistance;                                       // 0x0038(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxDistance;                                       // 0x003C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EJackWorldWeather>                     WeatherList;                                       // 0x0040(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EJackTimeZone>                         TimeZoneList;                                      // 0x0050(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class UClass*>                         PasserbyNPC;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         PasserbyNum;                                       // 0x0070(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPasserbyTable">();
	}
	static class UJackPasserbyTable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPasserbyTable>();
	}
};
static_assert(alignof(UJackPasserbyTable) == 0x000008, "Wrong alignment on UJackPasserbyTable");
static_assert(sizeof(UJackPasserbyTable) == 0x000078, "Wrong size on UJackPasserbyTable");
static_assert(offsetof(UJackPasserbyTable, MinDistance) == 0x000038, "Member 'UJackPasserbyTable::MinDistance' has a wrong offset!");
static_assert(offsetof(UJackPasserbyTable, MaxDistance) == 0x00003C, "Member 'UJackPasserbyTable::MaxDistance' has a wrong offset!");
static_assert(offsetof(UJackPasserbyTable, WeatherList) == 0x000040, "Member 'UJackPasserbyTable::WeatherList' has a wrong offset!");
static_assert(offsetof(UJackPasserbyTable, TimeZoneList) == 0x000050, "Member 'UJackPasserbyTable::TimeZoneList' has a wrong offset!");
static_assert(offsetof(UJackPasserbyTable, PasserbyNPC) == 0x000060, "Member 'UJackPasserbyTable::PasserbyNPC' has a wrong offset!");
static_assert(offsetof(UJackPasserbyTable, PasserbyNum) == 0x000070, "Member 'UJackPasserbyTable::PasserbyNum' has a wrong offset!");

// Class JackGame.JackPauseTrackInst
// 0x0078 (0x00B0 - 0x0038)
class UJackPauseTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x78];                                      // 0x0038(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPauseTrackInst">();
	}
	static class UJackPauseTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPauseTrackInst>();
	}
};
static_assert(alignof(UJackPauseTrackInst) == 0x000008, "Wrong alignment on UJackPauseTrackInst");
static_assert(sizeof(UJackPauseTrackInst) == 0x0000B0, "Wrong size on UJackPauseTrackInst");

// Class JackGame.JackPhotoModeControllerInterface
// 0x0000 (0x0038 - 0x0038)
class IJackPhotoModeControllerInterface final : public IInterface
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhotoModeControllerInterface">();
	}
	static class IJackPhotoModeControllerInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IJackPhotoModeControllerInterface>();
	}
};
static_assert(alignof(IJackPhotoModeControllerInterface) == 0x000008, "Wrong alignment on IJackPhotoModeControllerInterface");
static_assert(sizeof(IJackPhotoModeControllerInterface) == 0x000038, "Wrong size on IJackPhotoModeControllerInterface");

// Class JackGame.JackPhotoModeSetting
// 0x0030 (0x0068 - 0x0038)
class UJackPhotoModeSetting : public UObject
{
public:
	struct FJackPhotoModeCharaSettingCommon       Common;                                            // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackPhotoModeCharaSetting>     Characters;                                        // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         FocalRegion;                                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NearBlurSize;                                      // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FarBlurSize;                                       // 0x0060(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhotoModeSetting">();
	}
	static class UJackPhotoModeSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhotoModeSetting>();
	}
};
static_assert(alignof(UJackPhotoModeSetting) == 0x000008, "Wrong alignment on UJackPhotoModeSetting");
static_assert(sizeof(UJackPhotoModeSetting) == 0x000068, "Wrong size on UJackPhotoModeSetting");
static_assert(offsetof(UJackPhotoModeSetting, Common) == 0x000038, "Member 'UJackPhotoModeSetting::Common' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeSetting, Characters) == 0x000048, "Member 'UJackPhotoModeSetting::Characters' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeSetting, FocalRegion) == 0x000058, "Member 'UJackPhotoModeSetting::FocalRegion' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeSetting, NearBlurSize) == 0x00005C, "Member 'UJackPhotoModeSetting::NearBlurSize' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeSetting, FarBlurSize) == 0x000060, "Member 'UJackPhotoModeSetting::FarBlurSize' has a wrong offset!");

// Class JackGame.JackPhotoModeCapture
// 0x0008 (0x03A0 - 0x0398)
class AJackPhotoModeCapture : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FPostProcessSettings GetCapturePostProcessSettings();
	void SetRenderTargetTexture(class UTextureRenderTarget2D* InTexture);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhotoModeCapture">();
	}
	static class AJackPhotoModeCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPhotoModeCapture>();
	}
};
static_assert(alignof(AJackPhotoModeCapture) == 0x000008, "Wrong alignment on AJackPhotoModeCapture");
static_assert(sizeof(AJackPhotoModeCapture) == 0x0003A0, "Wrong size on AJackPhotoModeCapture");

// Class JackGame.JackPhotoModeManager
// 0x0930 (0x0968 - 0x0038)
class UJackPhotoModeManager : public UObject
{
public:
	UMulticastDelegateProperty_                   PhotoModeBPDelegate;                               // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackPhotoModeSetting>      PhotoModeSettingClass;                             // 0x0048(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackPhotoModeSetting*                  PhotoModeSetting;                                  // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackPhotoModeCapture>      PhotoModeCaptureClass;                             // 0x0058(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackPhotoModeCapture*                  PhotoModeCapture;                                  // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_68[0x900];                                     // 0x0068(0x0900)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CheckSavePosition(TArray<class AJackCharacter*>* OutReturnCharacter, float InDiff);
	void DelegateEvent(EJackPhotoModeEvent InEvent);
	bool ExecCapturePreviousFrame();
	bool GetBokehEnable();
	int32 GetEmoteNum(EJackPhotoModeEmote InEmote);
	float GetExecCaptureDelaySeconds();
	class AJackPhotoModeCapture* GetPhotoModeCapture();
	void GetPhotoModeCharacters(TArray<class AJackCharacter*>* OutCharacters);
	void GetPhotoModeFollowingCharacters(TArray<class AJackCharacter*>* OutCharacters, int32 InOffset);
	float GetPostAnimationDelaySeconds();
	float GetPostCaptureDelaySeconds();
	float GetPreCaptureDelaySeconds();
	float GetPreviewCaptureDelaySeconds();
	void InputDelegate(struct FJackUIInputDelegateInfo* InDelegateInfo);
	bool IsCaptureExecuted();
	bool IsCaptureRequested();
	bool IsEndStabilizePose();
	bool IsHeadLookAtEnable();
	bool IsHidden(EJackCharacter InCharacter);
	bool IsHudEnable();
	bool IsPhotoMode();
	bool IsResamplingEnd();
	bool IsScreenPercentageChanged();
	EJackPhotoModeCommand JackKeysToPhotoModeCommand(EJackKeys InKeyType);
	void JackUMGPhotoModeBPDelegate__DelegateSignature(EJackPhotoModeEvent EventType);
	void PhotoModeFadeEnter(bool bRelocate);
	void PhotoModeLeave();
	void PhotoModeMenuEnter();
	void PhotoModeMenuLeave();
	void PhotoModeMenuLeaveAfter();
	bool PostAnimation();
	bool PostCapture();
	bool PostPreviewCapture();
	bool PreCapture();
	bool PrePreviewCapture();
	bool RequestAlignment(int32 InAlignmentType);
	void RequestAnimDynamicsIdling(const TArray<class AJackCharacter*>& InCharacters, int32 InIdlingCount);
	void RequestHeadLookAt();
	void RequestHeadLookAtEnd();
	void RequestHidden(bool bInHidden, float InRequiredSeconds);
	void RequestHiddenCharacter(EJackCharacter InCharacter, bool bInHidden, float InRequiredSeconds);
	void RequestLookAt();
	void RequestPlayEmote(EJackPhotoModeEmote InEmote, int32 InIndex);
	bool RequestRelocation(bool bIgnoreVisibleCharacter);
	void RequestResetCharacter(EJackCharacter InCharacter, bool bInImmediately);
	void RequestStabilizePose(const TArray<class AJackCharacter*>& InCharacters, bool bInImmediately, bool bInLight, int32 InIdlingCount);
	void RequestStopEmote();
	void RequestSwitchHidden(EJackCharacter InCharacter, bool bInHidden);
	void ResetNoRelocationCharacters();
	bool SaveAlbumBuffer();
	bool SaveAlbumRenderTarget();
	void SetBokehEnbale(bool InEnable);
	void SetCameraAxisSlideEnable(bool InEnable);
	bool SetHudEnable(bool bInHudEnable);
	void SetNoRelocationCharacter(EJackCharacter InCharacterType, bool bEnable);
	void ShowHUD();
	void Tick(float InDeltaSeconds);
	void UpdateSavePosistion();

	EJackPhotoModeErrorCode GetSaveAlbumErrorCode() const;
	int32 GetSaveAlbumState() const;
	bool IsPhotoModeNotAvailable() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhotoModeManager">();
	}
	static class UJackPhotoModeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhotoModeManager>();
	}
};
static_assert(alignof(UJackPhotoModeManager) == 0x000008, "Wrong alignment on UJackPhotoModeManager");
static_assert(sizeof(UJackPhotoModeManager) == 0x000968, "Wrong size on UJackPhotoModeManager");
static_assert(offsetof(UJackPhotoModeManager, PhotoModeBPDelegate) == 0x000038, "Member 'UJackPhotoModeManager::PhotoModeBPDelegate' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeManager, PhotoModeSettingClass) == 0x000048, "Member 'UJackPhotoModeManager::PhotoModeSettingClass' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeManager, PhotoModeSetting) == 0x000050, "Member 'UJackPhotoModeManager::PhotoModeSetting' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeManager, PhotoModeCaptureClass) == 0x000058, "Member 'UJackPhotoModeManager::PhotoModeCaptureClass' has a wrong offset!");
static_assert(offsetof(UJackPhotoModeManager, PhotoModeCapture) == 0x000060, "Member 'UJackPhotoModeManager::PhotoModeCapture' has a wrong offset!");

// Class JackGame.JackPhysicsBlendRateTrack
// 0x0018 (0x00C8 - 0x00B0)
class UJackPhysicsBlendRateTrack final : public UInterpTrackFloatBase
{
public:
	TArray<struct FJackLDT_Coordinate>            ApplyCoordinates;                                  // 0x00B0(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bUpperBody;                                        // 0x00C0(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLowerBody;                                        // 0x00C1(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBodyExtra;                                        // 0x00C2(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHair;                                             // 0x00C3(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHairExtra;                                        // 0x00C4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMantle;                                           // 0x00C5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOther;                                            // 0x00C6(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C7[0x1];                                       // 0x00C7(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsBlendRateTrack">();
	}
	static class UJackPhysicsBlendRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicsBlendRateTrack>();
	}
};
static_assert(alignof(UJackPhysicsBlendRateTrack) == 0x000008, "Wrong alignment on UJackPhysicsBlendRateTrack");
static_assert(sizeof(UJackPhysicsBlendRateTrack) == 0x0000C8, "Wrong size on UJackPhysicsBlendRateTrack");
static_assert(offsetof(UJackPhysicsBlendRateTrack, ApplyCoordinates) == 0x0000B0, "Member 'UJackPhysicsBlendRateTrack::ApplyCoordinates' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bUpperBody) == 0x0000C0, "Member 'UJackPhysicsBlendRateTrack::bUpperBody' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bLowerBody) == 0x0000C1, "Member 'UJackPhysicsBlendRateTrack::bLowerBody' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bBodyExtra) == 0x0000C2, "Member 'UJackPhysicsBlendRateTrack::bBodyExtra' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bHair) == 0x0000C3, "Member 'UJackPhysicsBlendRateTrack::bHair' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bHairExtra) == 0x0000C4, "Member 'UJackPhysicsBlendRateTrack::bHairExtra' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bMantle) == 0x0000C5, "Member 'UJackPhysicsBlendRateTrack::bMantle' has a wrong offset!");
static_assert(offsetof(UJackPhysicsBlendRateTrack, bOther) == 0x0000C6, "Member 'UJackPhysicsBlendRateTrack::bOther' has a wrong offset!");

// Class JackGame.JackPhysicsSuppressionTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackPhysicsSuppressionTrack final : public UInterpTrackFloatBase
{
public:
	float                                         SuppressionSec;                                    // 0x00B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AttenuationSec;                                    // 0x00B4(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsSuppressionTrack">();
	}
	static class UJackPhysicsSuppressionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicsSuppressionTrack>();
	}
};
static_assert(alignof(UJackPhysicsSuppressionTrack) == 0x000008, "Wrong alignment on UJackPhysicsSuppressionTrack");
static_assert(sizeof(UJackPhysicsSuppressionTrack) == 0x0000B8, "Wrong size on UJackPhysicsSuppressionTrack");
static_assert(offsetof(UJackPhysicsSuppressionTrack, SuppressionSec) == 0x0000B0, "Member 'UJackPhysicsSuppressionTrack::SuppressionSec' has a wrong offset!");
static_assert(offsetof(UJackPhysicsSuppressionTrack, AttenuationSec) == 0x0000B4, "Member 'UJackPhysicsSuppressionTrack::AttenuationSec' has a wrong offset!");

// Class JackGame.JackPhysicsSuppressionTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackPhysicsSuppressionTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsSuppressionTrackInst">();
	}
	static class UJackPhysicsSuppressionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicsSuppressionTrackInst>();
	}
};
static_assert(alignof(UJackPhysicsSuppressionTrackInst) == 0x000008, "Wrong alignment on UJackPhysicsSuppressionTrackInst");
static_assert(sizeof(UJackPhysicsSuppressionTrackInst) == 0x000040, "Wrong size on UJackPhysicsSuppressionTrackInst");

// Class JackGame.JackPhysicsTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackPhysicsTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsTrack">();
	}
	static class UJackPhysicsTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPhysicsTrack>();
	}
};
static_assert(alignof(UJackPhysicsTrack) == 0x000008, "Wrong alignment on UJackPhysicsTrack");
static_assert(sizeof(UJackPhysicsTrack) == 0x0000A8, "Wrong size on UJackPhysicsTrack");

// Class JackGame.JackPhysicsVolume
// 0x0028 (0x0408 - 0x03E0)
class AJackPhysicsVolume : public APhysicsVolume
{
public:
	UMulticastDelegateProperty_                   EnteredVolume;                                     // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   LeavingVolume;                                     // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bUseBlueprintOverlapFunction;                      // 0x0400(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsOverlapInVolume(bool bDefaultOverlap, const class USceneComponent* TestComponent) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPhysicsVolume">();
	}
	static class AJackPhysicsVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPhysicsVolume>();
	}
};
static_assert(alignof(AJackPhysicsVolume) == 0x000008, "Wrong alignment on AJackPhysicsVolume");
static_assert(sizeof(AJackPhysicsVolume) == 0x000408, "Wrong size on AJackPhysicsVolume");
static_assert(offsetof(AJackPhysicsVolume, EnteredVolume) == 0x0003E0, "Member 'AJackPhysicsVolume::EnteredVolume' has a wrong offset!");
static_assert(offsetof(AJackPhysicsVolume, LeavingVolume) == 0x0003F0, "Member 'AJackPhysicsVolume::LeavingVolume' has a wrong offset!");
static_assert(offsetof(AJackPhysicsVolume, bUseBlueprintOverlapFunction) == 0x000400, "Member 'AJackPhysicsVolume::bUseBlueprintOverlapFunction' has a wrong offset!");

// Class JackGame.JackPlayableBattleMovementMode
// 0x0000 (0x0040 - 0x0040)
class UJackPlayableBattleMovementMode final : public UJackPlayableDefaultMovementMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableBattleMovementMode">();
	}
	static class UJackPlayableBattleMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableBattleMovementMode>();
	}
};
static_assert(alignof(UJackPlayableBattleMovementMode) == 0x000008, "Wrong alignment on UJackPlayableBattleMovementMode");
static_assert(sizeof(UJackPlayableBattleMovementMode) == 0x000040, "Wrong size on UJackPlayableBattleMovementMode");

// Class JackGame.JackPlayableCharacterCapsuleComponent
// 0x0010 (0x09D0 - 0x09C0)
class UJackPlayableCharacterCapsuleComponent final : public UJackCharacterCapsuleComponent
{
public:
	bool                                          bCapsuleRadiusControlByMovementVelocity;           // 0x09B8(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_9B9[0x3];                                      // 0x09B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinCapsuleRadius;                                  // 0x09BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxCapsuleRadius;                                  // 0x09C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         HorizontalVelocityByMaxCapsuleRadius;              // 0x09C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleControlSpeedToDown;                         // 0x09C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CapsuleControlSpeedToUp;                           // 0x09CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetCapsuleControlCollisionForGimmick(ECollisionChannel Channel, ECollisionResponse Response);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableCharacterCapsuleComponent">();
	}
	static class UJackPlayableCharacterCapsuleComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableCharacterCapsuleComponent>();
	}
};
static_assert(alignof(UJackPlayableCharacterCapsuleComponent) == 0x000010, "Wrong alignment on UJackPlayableCharacterCapsuleComponent");
static_assert(sizeof(UJackPlayableCharacterCapsuleComponent) == 0x0009D0, "Wrong size on UJackPlayableCharacterCapsuleComponent");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, bCapsuleRadiusControlByMovementVelocity) == 0x0009B8, "Member 'UJackPlayableCharacterCapsuleComponent::bCapsuleRadiusControlByMovementVelocity' has a wrong offset!");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, MinCapsuleRadius) == 0x0009BC, "Member 'UJackPlayableCharacterCapsuleComponent::MinCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, MaxCapsuleRadius) == 0x0009C0, "Member 'UJackPlayableCharacterCapsuleComponent::MaxCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, HorizontalVelocityByMaxCapsuleRadius) == 0x0009C4, "Member 'UJackPlayableCharacterCapsuleComponent::HorizontalVelocityByMaxCapsuleRadius' has a wrong offset!");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, CapsuleControlSpeedToDown) == 0x0009C8, "Member 'UJackPlayableCharacterCapsuleComponent::CapsuleControlSpeedToDown' has a wrong offset!");
static_assert(offsetof(UJackPlayableCharacterCapsuleComponent, CapsuleControlSpeedToUp) == 0x0009CC, "Member 'UJackPlayableCharacterCapsuleComponent::CapsuleControlSpeedToUp' has a wrong offset!");

// Class JackGame.JackPlayableFieldMovementMode
// 0x0000 (0x0040 - 0x0040)
class UJackPlayableFieldMovementMode final : public UJackPlayableDefaultMovementMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableFieldMovementMode">();
	}
	static class UJackPlayableFieldMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableFieldMovementMode>();
	}
};
static_assert(alignof(UJackPlayableFieldMovementMode) == 0x000008, "Wrong alignment on UJackPlayableFieldMovementMode");
static_assert(sizeof(UJackPlayableFieldMovementMode) == 0x000040, "Wrong size on UJackPlayableFieldMovementMode");

// Class JackGame.JackPlayableSplineMovementMode
// 0x0048 (0x0088 - 0x0040)
class UJackPlayableSplineMovementMode : public UJackPlayableDefaultMovementMode
{
public:
	UMulticastDelegateProperty_                   OnArriveBeginPoint;                                // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnArriveEndPoint;                                  // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_60[0x28];                                      // 0x0060(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayableSplineMovementModeDelegate__DelegateSignature();
	void RegistAnimationMontage(EJackPlayableMovementAnimMontage Type, const TArray<class UAnimMontage*>& AnimMontage);
	void SetSnapOffsetLocation(const struct FVector& InOffsetLocationInActorSpace);
	void SetSnapToSplineEnabled(bool bEnabled);
	void SetSplineComponent(class USplineComponent* InSplineComponent);
	void SetStartInterpolationAnimMontage(class UAnimMontage* AnimMontage, float StartInterpolationMontageSec, float EndInterpolationMontageSec, float InterpolationRate);
	void SnapToClosestSplinePoint();

	struct FVector GetClosestSplinePoint(class USplineComponent* InSplineComponent, const struct FVector& InWorldLocation) const;
	bool IsArrivedBeginPoint() const;
	bool IsArrivedEndPoint() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableSplineMovementMode">();
	}
	static class UJackPlayableSplineMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableSplineMovementMode>();
	}
};
static_assert(alignof(UJackPlayableSplineMovementMode) == 0x000008, "Wrong alignment on UJackPlayableSplineMovementMode");
static_assert(sizeof(UJackPlayableSplineMovementMode) == 0x000088, "Wrong size on UJackPlayableSplineMovementMode");
static_assert(offsetof(UJackPlayableSplineMovementMode, OnArriveBeginPoint) == 0x000040, "Member 'UJackPlayableSplineMovementMode::OnArriveBeginPoint' has a wrong offset!");
static_assert(offsetof(UJackPlayableSplineMovementMode, OnArriveEndPoint) == 0x000050, "Member 'UJackPlayableSplineMovementMode::OnArriveEndPoint' has a wrong offset!");

// Class JackGame.JackPlayableRopeClimbMovementMode
// 0x0048 (0x00D0 - 0x0088)
class UJackPlayableRopeClimbMovementMode : public UJackPlayableSplineMovementMode
{
public:
	UMulticastDelegateProperty_                   OnClimbUp;                                         // 0x0088(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnClimbDown;                                       // 0x0098(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnBeginFalling;                                    // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B8[0x18];                                      // 0x00B8(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAutoMovementEnable(bool bEnable);
	void SetAutoRapeling(bool bEnabled);

	bool IsAutoMovementEnable() const;
	bool IsAutoRapeling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableRopeClimbMovementMode">();
	}
	static class UJackPlayableRopeClimbMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableRopeClimbMovementMode>();
	}
};
static_assert(alignof(UJackPlayableRopeClimbMovementMode) == 0x000008, "Wrong alignment on UJackPlayableRopeClimbMovementMode");
static_assert(sizeof(UJackPlayableRopeClimbMovementMode) == 0x0000D0, "Wrong size on UJackPlayableRopeClimbMovementMode");
static_assert(offsetof(UJackPlayableRopeClimbMovementMode, OnClimbUp) == 0x000088, "Member 'UJackPlayableRopeClimbMovementMode::OnClimbUp' has a wrong offset!");
static_assert(offsetof(UJackPlayableRopeClimbMovementMode, OnClimbDown) == 0x000098, "Member 'UJackPlayableRopeClimbMovementMode::OnClimbDown' has a wrong offset!");
static_assert(offsetof(UJackPlayableRopeClimbMovementMode, OnBeginFalling) == 0x0000A8, "Member 'UJackPlayableRopeClimbMovementMode::OnBeginFalling' has a wrong offset!");

// Class JackGame.JackPlayableLadderMovementMode
// 0x0098 (0x0168 - 0x00D0)
class UJackPlayableLadderMovementMode final : public UJackPlayableRopeClimbMovementMode
{
public:
	UMulticastDelegateProperty_                   OnStepUp;                                          // 0x00D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnStepDown;                                        // 0x00E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnMovementStateChanged;                            // 0x00F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, Protected, NativeAccessSpecifierProtected)
	bool                                          bForwardCalculation;                               // 0x0100(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_101[0x57];                                     // 0x0101(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             AutoRapelingLoopSound;                             // 0x0158(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAudioComponent*                        AutoRapelingSoundComponent;                        // 0x0160(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void PlayableLadderMovementModeChangeStateDelegate__DelegateSignature(EJackLadderMovementState MovementState);
	void PlayableLadderMovementModeStepDelegate__DelegateSignature(bool bRightHandUp, float MovementRate);
	void SetAutoRapelingSound(class USoundBase* InAutoRapelingLoopSound);
	void SetLadderInfo(int32 InMaxStep, float InStepHeight, int32 InCurrentStep);
	void SetMovementAnimationTime(float InAnimationTime, float InSnapTime);
	void SetOriginLocation(const struct FVector& InLocation);

	bool IsInLowerStep() const;
	bool IsInUpperStep() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableLadderMovementMode">();
	}
	static class UJackPlayableLadderMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableLadderMovementMode>();
	}
};
static_assert(alignof(UJackPlayableLadderMovementMode) == 0x000008, "Wrong alignment on UJackPlayableLadderMovementMode");
static_assert(sizeof(UJackPlayableLadderMovementMode) == 0x000168, "Wrong size on UJackPlayableLadderMovementMode");
static_assert(offsetof(UJackPlayableLadderMovementMode, OnStepUp) == 0x0000D0, "Member 'UJackPlayableLadderMovementMode::OnStepUp' has a wrong offset!");
static_assert(offsetof(UJackPlayableLadderMovementMode, OnStepDown) == 0x0000E0, "Member 'UJackPlayableLadderMovementMode::OnStepDown' has a wrong offset!");
static_assert(offsetof(UJackPlayableLadderMovementMode, OnMovementStateChanged) == 0x0000F0, "Member 'UJackPlayableLadderMovementMode::OnMovementStateChanged' has a wrong offset!");
static_assert(offsetof(UJackPlayableLadderMovementMode, bForwardCalculation) == 0x000100, "Member 'UJackPlayableLadderMovementMode::bForwardCalculation' has a wrong offset!");
static_assert(offsetof(UJackPlayableLadderMovementMode, AutoRapelingLoopSound) == 0x000158, "Member 'UJackPlayableLadderMovementMode::AutoRapelingLoopSound' has a wrong offset!");
static_assert(offsetof(UJackPlayableLadderMovementMode, AutoRapelingSoundComponent) == 0x000160, "Member 'UJackPlayableLadderMovementMode::AutoRapelingSoundComponent' has a wrong offset!");

// Class JackGame.JackPlayableNavMeshMovementMode
// 0x0008 (0x0048 - 0x0040)
class UJackPlayableNavMeshMovementMode final : public UJackPlayableDefaultMovementMode
{
public:
	uint8                                         Pad_40[0x8];                                       // 0x0040(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableNavMeshMovementMode">();
	}
	static class UJackPlayableNavMeshMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableNavMeshMovementMode>();
	}
};
static_assert(alignof(UJackPlayableNavMeshMovementMode) == 0x000008, "Wrong alignment on UJackPlayableNavMeshMovementMode");
static_assert(sizeof(UJackPlayableNavMeshMovementMode) == 0x000048, "Wrong size on UJackPlayableNavMeshMovementMode");

// Class JackGame.JackPlayableRopeWalkMovementMode
// 0x00E0 (0x0168 - 0x0088)
class UJackPlayableRopeWalkMovementMode final : public UJackPlayableSplineMovementMode
{
public:
	uint8                                         Pad_88[0xE0];                                      // 0x0088(0x00E0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStartInterpolationAnimMontage(class UAnimMontage* InAnimMontage, float InStartInterpolationMontageSec, float InEndInterpolationMontageSec, float InInterpolationRate);
	void SetTurnSec(float InStartTurnSec, float InEndTurnSec);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableRopeWalkMovementMode">();
	}
	static class UJackPlayableRopeWalkMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableRopeWalkMovementMode>();
	}
};
static_assert(alignof(UJackPlayableRopeWalkMovementMode) == 0x000008, "Wrong alignment on UJackPlayableRopeWalkMovementMode");
static_assert(sizeof(UJackPlayableRopeWalkMovementMode) == 0x000168, "Wrong size on UJackPlayableRopeWalkMovementMode");

// Class JackGame.JackPlayableSurisuriMovementMode
// 0x0080 (0x0108 - 0x0088)
class UJackPlayableSurisuriMovementMode : public UJackPlayableSplineMovementMode
{
public:
	uint8                                         Pad_88[0x80];                                      // 0x0088(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStartInterpolationAnimMontage(class UAnimMontage* InAnimMontage, float InStartInterpolationMontageSec, float InEndInterpolationMontageSec, float InInterpolationRate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableSurisuriMovementMode">();
	}
	static class UJackPlayableSurisuriMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableSurisuriMovementMode>();
	}
};
static_assert(alignof(UJackPlayableSurisuriMovementMode) == 0x000008, "Wrong alignment on UJackPlayableSurisuriMovementMode");
static_assert(sizeof(UJackPlayableSurisuriMovementMode) == 0x000108, "Wrong size on UJackPlayableSurisuriMovementMode");

// Class JackGame.JackPlayableUmaRaceMovementMode
// 0x0048 (0x0088 - 0x0040)
class UJackPlayableUmaRaceMovementMode final : public UJackPlayableDefaultMovementMode
{
public:
	uint8                                         Pad_40[0x48];                                      // 0x0040(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableUmaRaceMovementMode">();
	}
	static class UJackPlayableUmaRaceMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableUmaRaceMovementMode>();
	}
};
static_assert(alignof(UJackPlayableUmaRaceMovementMode) == 0x000008, "Wrong alignment on UJackPlayableUmaRaceMovementMode");
static_assert(sizeof(UJackPlayableUmaRaceMovementMode) == 0x000088, "Wrong size on UJackPlayableUmaRaceMovementMode");

// Class JackGame.JackPlayableV104GakeMovementMode
// 0x0020 (0x0128 - 0x0108)
class UJackPlayableV104GakeMovementMode final : public UJackPlayableSurisuriMovementMode
{
public:
	uint8                                         Pad_108[0x20];                                     // 0x0108(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetStartInterpolation(float InMaxInterpSec, float InStartInterpolationMontageSec, float InEndInterpolationMontageSec, float InInterpolationRate);
	void SetUpperDir(const struct FVector& InUpperDir, float InRotInterpSpeed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayableV104GakeMovementMode">();
	}
	static class UJackPlayableV104GakeMovementMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayableV104GakeMovementMode>();
	}
};
static_assert(alignof(UJackPlayableV104GakeMovementMode) == 0x000008, "Wrong alignment on UJackPlayableV104GakeMovementMode");
static_assert(sizeof(UJackPlayableV104GakeMovementMode) == 0x000128, "Wrong size on UJackPlayableV104GakeMovementMode");

// Class JackGame.JackPlayerAnimInstance
// 0x0040 (0x0D20 - 0x0CE0)
#pragma pack(push, 0x1)
class alignas(0x10) UJackPlayerAnimInstance : public UJackPlayableAnimInstance
{
public:
	uint8                                         Pad_CD8[0x10];                                     // 0x0CD8(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EJackPlayerAnimBaseStateMachineMode           BaseStateMachineType;                              // 0x0CE8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackPlayableMovementDefault                  PlayableMovementDetaultType;                       // 0x0CE9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackPlayableMovement                         PlayableMovementType;                              // 0x0CEA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackVehicle                                  RideVehicleType;                                   // 0x0CEB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSlippingOff;                                      // 0x0CEC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bRighthandUpForLadder;                             // 0x0CED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bEnterToShotBowgunState;                           // 0x0CEE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bLeaveFromShotBowgunState;                         // 0x0CEF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BlendSpaceValueX;                                  // 0x0CF0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParadeWaitMotionRate;                              // 0x0CF4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ParadeWaitMotionRateInterpSpeed;                   // 0x0CF8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_CFC[0x4];                                      // 0x0CFC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WalkRunUpperBodyAnimRate;                          // 0x0D00(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WalkRunUpperBodyAnimRateInterpSpeed;               // 0x0D04(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         IdlingMovementRateThreshould;                      // 0x0D08(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         BaseStateUpperBodyAnimBlendWeight;                 // 0x0D0C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseStateUpperBodyAnimBlendWeightInterpSpeed;      // 0x0D10(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsInBattle;                                       // 0x0D14(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDashRun;                                          // 0x0D15(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D16[0x2];                                      // 0x0D16(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetToTransition();
	void SetBaseStateMachineType(EJackPlayerAnimBaseStateMachineMode InType);
	void SetUpperBodyAnimationBlendEnabled(bool bEnable);
	void UpdateBaseStateMachine();

	EJackPlayerAnimBaseStateMachineMode GetBaseStateMachineType() const;
	float GetBlendSpaceValueX() const;
	float GetBlendSpaceValueY() const;
	struct FJackArmIKResult GetLeftArmIKReslt() const;
	EJackPlayableMovementDefault GetPlayableMovementDefaultType() const;
	EJackPlayableMovement GetPlayableMovementType() const;
	struct FJackArmIKResult GetRightArmIKReslt() const;
	bool IsAutoRapelingInLadder() const;
	bool IsReuiredTransitionState(EJackPlayerAnimInstanceStateMachineState TransitionState) const;
	bool IsRightHandUp() const;
	bool IsSlippingOff() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerAnimInstance">();
	}
	static class UJackPlayerAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerAnimInstance>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackPlayerAnimInstance) == 0x000010, "Wrong alignment on UJackPlayerAnimInstance");
static_assert(sizeof(UJackPlayerAnimInstance) == 0x000D20, "Wrong size on UJackPlayerAnimInstance");
static_assert(offsetof(UJackPlayerAnimInstance, BaseStateMachineType) == 0x000CE8, "Member 'UJackPlayerAnimInstance::BaseStateMachineType' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, PlayableMovementDetaultType) == 0x000CE9, "Member 'UJackPlayerAnimInstance::PlayableMovementDetaultType' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, PlayableMovementType) == 0x000CEA, "Member 'UJackPlayerAnimInstance::PlayableMovementType' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, RideVehicleType) == 0x000CEB, "Member 'UJackPlayerAnimInstance::RideVehicleType' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bSlippingOff) == 0x000CEC, "Member 'UJackPlayerAnimInstance::bSlippingOff' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bRighthandUpForLadder) == 0x000CED, "Member 'UJackPlayerAnimInstance::bRighthandUpForLadder' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bEnterToShotBowgunState) == 0x000CEE, "Member 'UJackPlayerAnimInstance::bEnterToShotBowgunState' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bLeaveFromShotBowgunState) == 0x000CEF, "Member 'UJackPlayerAnimInstance::bLeaveFromShotBowgunState' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, BlendSpaceValueX) == 0x000CF0, "Member 'UJackPlayerAnimInstance::BlendSpaceValueX' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, ParadeWaitMotionRate) == 0x000CF4, "Member 'UJackPlayerAnimInstance::ParadeWaitMotionRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, ParadeWaitMotionRateInterpSpeed) == 0x000CF8, "Member 'UJackPlayerAnimInstance::ParadeWaitMotionRateInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, WalkRunUpperBodyAnimRate) == 0x000D00, "Member 'UJackPlayerAnimInstance::WalkRunUpperBodyAnimRate' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, WalkRunUpperBodyAnimRateInterpSpeed) == 0x000D04, "Member 'UJackPlayerAnimInstance::WalkRunUpperBodyAnimRateInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, IdlingMovementRateThreshould) == 0x000D08, "Member 'UJackPlayerAnimInstance::IdlingMovementRateThreshould' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, BaseStateUpperBodyAnimBlendWeight) == 0x000D0C, "Member 'UJackPlayerAnimInstance::BaseStateUpperBodyAnimBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, BaseStateUpperBodyAnimBlendWeightInterpSpeed) == 0x000D10, "Member 'UJackPlayerAnimInstance::BaseStateUpperBodyAnimBlendWeightInterpSpeed' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bIsInBattle) == 0x000D14, "Member 'UJackPlayerAnimInstance::bIsInBattle' has a wrong offset!");
static_assert(offsetof(UJackPlayerAnimInstance, bDashRun) == 0x000D15, "Member 'UJackPlayerAnimInstance::bDashRun' has a wrong offset!");

// Class JackGame.JackDofFocalDistanceOverrider
// 0x0018 (0x0050 - 0x0038)
class UJackDofFocalDistanceOverrider final : public UObject
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackDofFocalDistanceOverrider">();
	}
	static class UJackDofFocalDistanceOverrider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackDofFocalDistanceOverrider>();
	}
};
static_assert(alignof(UJackDofFocalDistanceOverrider) == 0x000008, "Wrong alignment on UJackDofFocalDistanceOverrider");
static_assert(sizeof(UJackDofFocalDistanceOverrider) == 0x000050, "Wrong size on UJackDofFocalDistanceOverrider");

// Class JackGame.JackPlayerCameraManager
// 0x1C20 (0x3710 - 0x1AF0)
class AJackPlayerCameraManager : public APlayerCameraManager
{
public:
	struct FTViewTarget                           NonCameraActorViewTarget;                          // 0x1AF0(0x0570)(Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_2060[0x8];                                     // 0x2060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class USphereComponent*                       CollisionComponent;                                // 0x2068(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      HiddenControlCollisionComponent;                   // 0x2070(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      DisclosedControlCollisionComponent;                // 0x2078(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CloseupHiddenControlCollisionComponent;            // 0x2080(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CloseupDisclosedControlCollisionComponent;         // 0x2088(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UMaterialBillboardComponent*            UIDepthMaskComponent;                              // 0x2090(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DitherHiddenTime;                                  // 0x2098(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_209C[0x1674];                                  // 0x209C(0x1674)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseupDiscloseControlCollisionComponent_OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	void CloseupHiddenControlCollisionComponent_OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void DiscloseControlCollisionComponent_OnComponentEndOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);
	class AEmitterCameraLensEffectBase* FindCameraLensEffectBP(TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass);
	void HiddenControlCollisionComponent_OnComponentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);
	void JackPlayCameraFade(EJackCameraFadeCategory Layer, EJackCameraFadeZLayer ZLayer, const struct FLinearColor& Color, float Alpha, float Time, bool bShouldFadeAudio, bool bHoldWhenFinished);
	void JackSetManualCameraFade(EJackCameraFadeCategory Layer, EJackCameraFadeZLayer ZLayer, const struct FLinearColor& Color, float Alpha, bool bShouldFadeAudio);
	void JackStopCamearFade(EJackCameraFadeCategory Layer);
	void Latent_WaitCameraInterpEnd(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void OnCameraFovChanged(float NewFOV);
	void OnCameraLightDisableChanged(bool bDisable);
	void OnChangeCameraAndPlayerMarkerCollisionIgnored(bool bIgnored);
	void SetCameraLightDisable(EJackCameraLightControlPurpose Purpose, bool bDisable);
	void SetHiddenControlBeginOverlapEnabled(bool bOn);
	void SetListenerLocationAlpha(float InAlpha);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerCameraManager">();
	}
	static class AJackPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayerCameraManager>();
	}
};
static_assert(alignof(AJackPlayerCameraManager) == 0x000010, "Wrong alignment on AJackPlayerCameraManager");
static_assert(sizeof(AJackPlayerCameraManager) == 0x003710, "Wrong size on AJackPlayerCameraManager");
static_assert(offsetof(AJackPlayerCameraManager, NonCameraActorViewTarget) == 0x001AF0, "Member 'AJackPlayerCameraManager::NonCameraActorViewTarget' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, CollisionComponent) == 0x002068, "Member 'AJackPlayerCameraManager::CollisionComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, HiddenControlCollisionComponent) == 0x002070, "Member 'AJackPlayerCameraManager::HiddenControlCollisionComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, DisclosedControlCollisionComponent) == 0x002078, "Member 'AJackPlayerCameraManager::DisclosedControlCollisionComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, CloseupHiddenControlCollisionComponent) == 0x002080, "Member 'AJackPlayerCameraManager::CloseupHiddenControlCollisionComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, CloseupDisclosedControlCollisionComponent) == 0x002088, "Member 'AJackPlayerCameraManager::CloseupDisclosedControlCollisionComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, UIDepthMaskComponent) == 0x002090, "Member 'AJackPlayerCameraManager::UIDepthMaskComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCameraManager, DitherHiddenTime) == 0x002098, "Member 'AJackPlayerCameraManager::DitherHiddenTime' has a wrong offset!");

// Class JackGame.JackPlayerCharacter
// 0x0060 (0x14A0 - 0x1440)
class AJackPlayerCharacter : public AJackPlayableCharacter
{
public:
	class UJackBattleAIComponent*                 BattleAIComponent;                                 // 0x1438(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackEquipmentControlComponent*         EquipmentControlComponent;                         // 0x1440(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLookAtComponent*                   LookAtComponent;                                   // 0x1448(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFriendAnimationSMComponent*        AnimSMComponent;                                   // 0x1450(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackCharacter                                CharacterType;                                     // 0x1458(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1459[0x7];                                     // 0x1459(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnAttachObjectDelegate;                            // 0x1460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDetachObjectDelegate;                            // 0x1470(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         JumpDelayMaxSeconds;                               // 0x1480(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         DashJumpDelayMaxSeconds;                           // 0x1484(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1488[0x4];                                     // 0x1488(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bJumpAccepted;                                     // 0x148C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bReserveFirstParadeAnimation;                      // 0x148D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_148E[0x2];                                     // 0x148E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               TurnRotationRateDuringDash;                        // 0x1490(0x000C)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_149C[0x4];                                     // 0x149C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnAttachObjectDelegate__DelegateSignature();
	void OnDetachObjectDelegate__DelegateSignature();
	void OnFieldActionDisabledChanged(bool bNewCondition);
	void OnJumpRequested();
	void OnMovementDisabledChanged(bool bNewCondition);
	void OnPressDashButton();
	void OnReleaseDashButton();

	bool IsDelayJump() const;
	bool IsIdling() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerCharacter">();
	}
	static class AJackPlayerCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayerCharacter>();
	}
};
static_assert(alignof(AJackPlayerCharacter) == 0x000010, "Wrong alignment on AJackPlayerCharacter");
static_assert(sizeof(AJackPlayerCharacter) == 0x0014A0, "Wrong size on AJackPlayerCharacter");
static_assert(offsetof(AJackPlayerCharacter, BattleAIComponent) == 0x001438, "Member 'AJackPlayerCharacter::BattleAIComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, EquipmentControlComponent) == 0x001440, "Member 'AJackPlayerCharacter::EquipmentControlComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, LookAtComponent) == 0x001448, "Member 'AJackPlayerCharacter::LookAtComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, AnimSMComponent) == 0x001450, "Member 'AJackPlayerCharacter::AnimSMComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, CharacterType) == 0x001458, "Member 'AJackPlayerCharacter::CharacterType' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, OnAttachObjectDelegate) == 0x001460, "Member 'AJackPlayerCharacter::OnAttachObjectDelegate' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, OnDetachObjectDelegate) == 0x001470, "Member 'AJackPlayerCharacter::OnDetachObjectDelegate' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, JumpDelayMaxSeconds) == 0x001480, "Member 'AJackPlayerCharacter::JumpDelayMaxSeconds' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, DashJumpDelayMaxSeconds) == 0x001484, "Member 'AJackPlayerCharacter::DashJumpDelayMaxSeconds' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, bJumpAccepted) == 0x00148C, "Member 'AJackPlayerCharacter::bJumpAccepted' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, bReserveFirstParadeAnimation) == 0x00148D, "Member 'AJackPlayerCharacter::bReserveFirstParadeAnimation' has a wrong offset!");
static_assert(offsetof(AJackPlayerCharacter, TurnRotationRateDuringDash) == 0x001490, "Member 'AJackPlayerCharacter::TurnRotationRateDuringDash' has a wrong offset!");

// Class JackGame.JackPlayerInput
// 0x0000 (0x03A8 - 0x03A8)
class UJackPlayerInput final : public UPlayerInput
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerInput">();
	}
	static class UJackPlayerInput* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerInput>();
	}
};
static_assert(alignof(UJackPlayerInput) == 0x000008, "Wrong alignment on UJackPlayerInput");
static_assert(sizeof(UJackPlayerInput) == 0x0003A8, "Wrong size on UJackPlayerInput");

// Class JackGame.JackPlayerMarker
// 0x0030 (0x03C8 - 0x0398)
class AJackPlayerMarker : public AActor
{
public:
	class USceneComponent*                        RootSceneComponent;                                // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCapsuleComponent*                      CapsuleComponent;                                  // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackInteractorComponent*               InteractorComponent;                               // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B0[0x10];                                     // 0x03B0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackWeatherAffectComponent*            CachedWeatherAffectComponent;                      // 0x03C0(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void OnChangeCameraAndPlayerMarkerCollisionIgnored(bool bIgnored);
	void OnSymbolEncountDisableChanged(bool bDisable);
	void OnSymbolEncountDisableChangedBP(bool bDisable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerMarker">();
	}
	static class AJackPlayerMarker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayerMarker>();
	}
};
static_assert(alignof(AJackPlayerMarker) == 0x000008, "Wrong alignment on AJackPlayerMarker");
static_assert(sizeof(AJackPlayerMarker) == 0x0003C8, "Wrong size on AJackPlayerMarker");
static_assert(offsetof(AJackPlayerMarker, RootSceneComponent) == 0x000398, "Member 'AJackPlayerMarker::RootSceneComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerMarker, CapsuleComponent) == 0x0003A0, "Member 'AJackPlayerMarker::CapsuleComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerMarker, InteractorComponent) == 0x0003A8, "Member 'AJackPlayerMarker::InteractorComponent' has a wrong offset!");
static_assert(offsetof(AJackPlayerMarker, CachedWeatherAffectComponent) == 0x0003C0, "Member 'AJackPlayerMarker::CachedWeatherAffectComponent' has a wrong offset!");

// Class JackGame.JackPlayerMovementComponent
// 0x0020 (0x0E70 - 0x0E50)
class UJackPlayerMovementComponent final : public UJackPlayableMovementComponent
{
public:
	float                                         BrakingDecelerationFloating;                       // 0x0E50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         FloatingGroundFriction;                            // 0x0E54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E58[0xC];                                      // 0x0E58(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         SlipOffFloorAngle;                                 // 0x0E64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bCancelSlipOffOnFreeFalling;                       // 0x0E68(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_E69[0x7];                                      // 0x0E69(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerMovementComponent">();
	}
	static class UJackPlayerMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPlayerMovementComponent>();
	}
};
static_assert(alignof(UJackPlayerMovementComponent) == 0x000010, "Wrong alignment on UJackPlayerMovementComponent");
static_assert(sizeof(UJackPlayerMovementComponent) == 0x000E70, "Wrong size on UJackPlayerMovementComponent");
static_assert(offsetof(UJackPlayerMovementComponent, BrakingDecelerationFloating) == 0x000E50, "Member 'UJackPlayerMovementComponent::BrakingDecelerationFloating' has a wrong offset!");
static_assert(offsetof(UJackPlayerMovementComponent, FloatingGroundFriction) == 0x000E54, "Member 'UJackPlayerMovementComponent::FloatingGroundFriction' has a wrong offset!");
static_assert(offsetof(UJackPlayerMovementComponent, SlipOffFloorAngle) == 0x000E64, "Member 'UJackPlayerMovementComponent::SlipOffFloorAngle' has a wrong offset!");
static_assert(offsetof(UJackPlayerMovementComponent, bCancelSlipOffOnFreeFalling) == 0x000E68, "Member 'UJackPlayerMovementComponent::bCancelSlipOffOnFreeFalling' has a wrong offset!");

// Class JackGame.JackPlayerState
// 0x0000 (0x0428 - 0x0428)
class AJackPlayerState final : public APlayerState
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPlayerState">();
	}
	static class AJackPlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPlayerState>();
	}
};
static_assert(alignof(AJackPlayerState) == 0x000008, "Wrong alignment on AJackPlayerState");
static_assert(sizeof(AJackPlayerState) == 0x000428, "Wrong size on AJackPlayerState");

// Class JackGame.JackPostProcessControlComponent
// 0x0000 (0x01A0 - 0x01A0)
class UJackPostProcessControlComponent final : public UJackCharacterComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPostProcessControlComponent">();
	}
	static class UJackPostProcessControlComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPostProcessControlComponent>();
	}
};
static_assert(alignof(UJackPostProcessControlComponent) == 0x000008, "Wrong alignment on UJackPostProcessControlComponent");
static_assert(sizeof(UJackPostProcessControlComponent) == 0x0001A0, "Wrong size on UJackPostProcessControlComponent");

// Class JackGame.JackPreloadAssetTest
// 0x0038 (0x03D0 - 0x0398)
class AJackPreloadAssetTest final : public AActor
{
public:
	TArray<TSoftObjectPtr<class UObject>>         PreloadAssets;                                     // 0x0398(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftClassPtr<class UClass>>           PreloadClasses;                                    // 0x03A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TSoftObjectPtr<class UObject>>         PreloadActorAssets;                                // 0x03B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	class AActor*                                 ChildActor;                                        // 0x03C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPreloadAssetTest">();
	}
	static class AJackPreloadAssetTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPreloadAssetTest>();
	}
};
static_assert(alignof(AJackPreloadAssetTest) == 0x000008, "Wrong alignment on AJackPreloadAssetTest");
static_assert(sizeof(AJackPreloadAssetTest) == 0x0003D0, "Wrong size on AJackPreloadAssetTest");
static_assert(offsetof(AJackPreloadAssetTest, PreloadAssets) == 0x000398, "Member 'AJackPreloadAssetTest::PreloadAssets' has a wrong offset!");
static_assert(offsetof(AJackPreloadAssetTest, PreloadClasses) == 0x0003A8, "Member 'AJackPreloadAssetTest::PreloadClasses' has a wrong offset!");
static_assert(offsetof(AJackPreloadAssetTest, PreloadActorAssets) == 0x0003B8, "Member 'AJackPreloadAssetTest::PreloadActorAssets' has a wrong offset!");
static_assert(offsetof(AJackPreloadAssetTest, ChildActor) == 0x0003C8, "Member 'AJackPreloadAssetTest::ChildActor' has a wrong offset!");

// Class JackGame.JackWeatherAffectComponent
// 0x0028 (0x01C8 - 0x01A0)
#pragma pack(push, 0x1)
class alignas(0x08) UJackWeatherAffectComponent : public UJackCharacterComponent
{
public:
	TArray<TWeakObjectPtr<class AJackWorldWeatherWindOverrideVolume>> WindOverrideArray;                                 // 0x01A0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	TArray<TWeakObjectPtr<class AJackWorldWeatherVolume>> WeatherVolumeArray;                                // 0x01B0(0x0010)(ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x8];                                      // 0x01C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FName GetLastWeatherVolumeID() const;
	EJackWorldWeather GetNextChangeWeather(EJackTimeZone* OutTimeZone, bool* bOutTomorrow) const;
	EJackWorldWeather GetWeather() const;
	EJackWorldWeather GetWeatherForWeatherReport() const;
	class FName GetWeatherVolumeID() const;
	float GetWindAngle() const;
	EJackWorldWindLevel GetWindLevel() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeatherAffectComponent">();
	}
	static class UJackWeatherAffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWeatherAffectComponent>();
	}
};
#pragma pack(pop)
static_assert(alignof(UJackWeatherAffectComponent) == 0x000008, "Wrong alignment on UJackWeatherAffectComponent");
static_assert(sizeof(UJackWeatherAffectComponent) == 0x0001C8, "Wrong size on UJackWeatherAffectComponent");
static_assert(offsetof(UJackWeatherAffectComponent, WindOverrideArray) == 0x0001A0, "Member 'UJackWeatherAffectComponent::WindOverrideArray' has a wrong offset!");
static_assert(offsetof(UJackWeatherAffectComponent, WeatherVolumeArray) == 0x0001B0, "Member 'UJackWeatherAffectComponent::WeatherVolumeArray' has a wrong offset!");

// Class JackGame.JackPreloadDataList
// 0x00C0 (0x0458 - 0x0398)
class AJackPreloadDataList final : public AActor
{
public:
	bool                                          bButton;                                           // 0x0398(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButton2;                                          // 0x0399(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButton5;                                          // 0x039A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39B[0x5];                                      // 0x039B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackLDT_LevelStreamingStatus          MapStart;                                          // 0x03A0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   CallName;                                          // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButton4;                                          // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bButton3;                                          // 0x03B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3BA[0x6];                                      // 0x03BA(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         LevelDataView;                                     // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LevelDataBloc;                                     // 0x03D0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         LevelDataNoVisible;                                // 0x03E0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           LevelNPC;                                          // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftClassPtr<class UClass>>           LevelMonster;                                      // 0x0400(0x0010)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	struct FJackPreloadDataListLevelStatus        LevelPersis;                                       // 0x0410(0x0030)(NativeAccessSpecifierPublic)
	TArray<struct FJackPreloadDataListLevelStatus> LevelData;                                         // 0x0440(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bDebug;                                            // 0x0450(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_451[0x7];                                      // 0x0451(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPreloadDataList">();
	}
	static class AJackPreloadDataList* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPreloadDataList>();
	}
};
static_assert(alignof(AJackPreloadDataList) == 0x000008, "Wrong alignment on AJackPreloadDataList");
static_assert(sizeof(AJackPreloadDataList) == 0x000458, "Wrong size on AJackPreloadDataList");
static_assert(offsetof(AJackPreloadDataList, bButton) == 0x000398, "Member 'AJackPreloadDataList::bButton' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, bButton2) == 0x000399, "Member 'AJackPreloadDataList::bButton2' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, bButton5) == 0x00039A, "Member 'AJackPreloadDataList::bButton5' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, MapStart) == 0x0003A0, "Member 'AJackPreloadDataList::MapStart' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, CallName) == 0x0003B0, "Member 'AJackPreloadDataList::CallName' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, bButton4) == 0x0003B8, "Member 'AJackPreloadDataList::bButton4' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, bButton3) == 0x0003B9, "Member 'AJackPreloadDataList::bButton3' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelDataView) == 0x0003C0, "Member 'AJackPreloadDataList::LevelDataView' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelDataBloc) == 0x0003D0, "Member 'AJackPreloadDataList::LevelDataBloc' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelDataNoVisible) == 0x0003E0, "Member 'AJackPreloadDataList::LevelDataNoVisible' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelNPC) == 0x0003F0, "Member 'AJackPreloadDataList::LevelNPC' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelMonster) == 0x000400, "Member 'AJackPreloadDataList::LevelMonster' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelPersis) == 0x000410, "Member 'AJackPreloadDataList::LevelPersis' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, LevelData) == 0x000440, "Member 'AJackPreloadDataList::LevelData' has a wrong offset!");
static_assert(offsetof(AJackPreloadDataList, bDebug) == 0x000450, "Member 'AJackPreloadDataList::bDebug' has a wrong offset!");

// Class JackGame.JackPreloadMapManager
// 0x0028 (0x0060 - 0x0038)
class UJackPreloadMapManager final : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UObject*>                        SaveObjects;                                       // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPreloadMapManager">();
	}
	static class UJackPreloadMapManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPreloadMapManager>();
	}
};
static_assert(alignof(UJackPreloadMapManager) == 0x000008, "Wrong alignment on UJackPreloadMapManager");
static_assert(sizeof(UJackPreloadMapManager) == 0x000060, "Wrong size on UJackPreloadMapManager");
static_assert(offsetof(UJackPreloadMapManager, SaveObjects) == 0x000048, "Member 'UJackPreloadMapManager::SaveObjects' has a wrong offset!");

// Class JackGame.JackPreloadMapVolume
// 0x0018 (0x03E8 - 0x03D0)
class AJackPreloadMapVolume final : public AVolume
{
public:
	struct FJackLDT_MapStart                      MapStart;                                          // 0x03D0(0x0010)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTriggerEnabled;                                   // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearPreloadMapWhenEndOverlap;                    // 0x03E1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDivisionDownload;                                 // 0x03E2(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E3[0x5];                                      // 0x03E3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UTextRenderComponent* GetDebugTextComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPreloadMapVolume">();
	}
	static class AJackPreloadMapVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPreloadMapVolume>();
	}
};
static_assert(alignof(AJackPreloadMapVolume) == 0x000008, "Wrong alignment on AJackPreloadMapVolume");
static_assert(sizeof(AJackPreloadMapVolume) == 0x0003E8, "Wrong size on AJackPreloadMapVolume");
static_assert(offsetof(AJackPreloadMapVolume, MapStart) == 0x0003D0, "Member 'AJackPreloadMapVolume::MapStart' has a wrong offset!");
static_assert(offsetof(AJackPreloadMapVolume, bTriggerEnabled) == 0x0003E0, "Member 'AJackPreloadMapVolume::bTriggerEnabled' has a wrong offset!");
static_assert(offsetof(AJackPreloadMapVolume, bClearPreloadMapWhenEndOverlap) == 0x0003E1, "Member 'AJackPreloadMapVolume::bClearPreloadMapWhenEndOverlap' has a wrong offset!");
static_assert(offsetof(AJackPreloadMapVolume, bDivisionDownload) == 0x0003E2, "Member 'AJackPreloadMapVolume::bDivisionDownload' has a wrong offset!");

// Class JackGame.JackPresetMaterialTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackPresetMaterialTrack final : public UInterpTrack
{
public:
	TArray<struct FJackPresetMaterialKey>         KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPresetMaterialTrack">();
	}
	static class UJackPresetMaterialTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPresetMaterialTrack>();
	}
};
static_assert(alignof(UJackPresetMaterialTrack) == 0x000008, "Wrong alignment on UJackPresetMaterialTrack");
static_assert(sizeof(UJackPresetMaterialTrack) == 0x0000A0, "Wrong size on UJackPresetMaterialTrack");
static_assert(offsetof(UJackPresetMaterialTrack, KeyArray) == 0x000090, "Member 'UJackPresetMaterialTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackPresetMaterialTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackPresetMaterialTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPresetMaterialTrackInst">();
	}
	static class UJackPresetMaterialTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPresetMaterialTrackInst>();
	}
};
static_assert(alignof(UJackPresetMaterialTrackInst) == 0x000008, "Wrong alignment on UJackPresetMaterialTrackInst");
static_assert(sizeof(UJackPresetMaterialTrackInst) == 0x000040, "Wrong size on UJackPresetMaterialTrackInst");

// Class JackGame.JackProjectile
// 0x0098 (0x0430 - 0x0398)
class AJackProjectile final : public AActor
{
public:
	class UProjectileMovementComponent*           MovementComp;                                      // 0x0398(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class USphereComponent*                       CollisionComp;                                     // 0x03A0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               ParticleComp;                                      // 0x03A8(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ProjectileLifeSpan;                                // 0x03B0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterImpactLifeSpan;                               // 0x03B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         AfterImpactSoundFadeoutTime;                       // 0x03B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsAttach;                                         // 0x03BC(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3BD[0x3];                                      // 0x03BD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExplosionDamage;                                   // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ExplosionRadius;                                   // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UDamageType>                DamageType;                                        // 0x03C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackCollideEffect>         ExplosionEffect;                                   // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackCollideEffect>         TrailEffect;                                       // 0x03D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BumpNormalSize;                                    // 0x03E0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailDecalMinHeight;                               // 0x03E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailDecalMinDistance;                             // 0x03E8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TrailDecalAddSize;                                 // 0x03EC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F0[0x38];                                     // 0x03F0(0x0038)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bHitTimingCallbackCalled;                          // 0x0428(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x7];                                      // 0x0429(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnImpact(const struct FHitResult& HitResult);
	void OnProjectileBeginOverlap(const struct FHitResult& HitResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackProjectile">();
	}
	static class AJackProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackProjectile>();
	}
};
static_assert(alignof(AJackProjectile) == 0x000008, "Wrong alignment on AJackProjectile");
static_assert(sizeof(AJackProjectile) == 0x000430, "Wrong size on AJackProjectile");
static_assert(offsetof(AJackProjectile, MovementComp) == 0x000398, "Member 'AJackProjectile::MovementComp' has a wrong offset!");
static_assert(offsetof(AJackProjectile, CollisionComp) == 0x0003A0, "Member 'AJackProjectile::CollisionComp' has a wrong offset!");
static_assert(offsetof(AJackProjectile, ParticleComp) == 0x0003A8, "Member 'AJackProjectile::ParticleComp' has a wrong offset!");
static_assert(offsetof(AJackProjectile, ProjectileLifeSpan) == 0x0003B0, "Member 'AJackProjectile::ProjectileLifeSpan' has a wrong offset!");
static_assert(offsetof(AJackProjectile, AfterImpactLifeSpan) == 0x0003B4, "Member 'AJackProjectile::AfterImpactLifeSpan' has a wrong offset!");
static_assert(offsetof(AJackProjectile, AfterImpactSoundFadeoutTime) == 0x0003B8, "Member 'AJackProjectile::AfterImpactSoundFadeoutTime' has a wrong offset!");
static_assert(offsetof(AJackProjectile, bIsAttach) == 0x0003BC, "Member 'AJackProjectile::bIsAttach' has a wrong offset!");
static_assert(offsetof(AJackProjectile, ExplosionDamage) == 0x0003C0, "Member 'AJackProjectile::ExplosionDamage' has a wrong offset!");
static_assert(offsetof(AJackProjectile, ExplosionRadius) == 0x0003C4, "Member 'AJackProjectile::ExplosionRadius' has a wrong offset!");
static_assert(offsetof(AJackProjectile, DamageType) == 0x0003C8, "Member 'AJackProjectile::DamageType' has a wrong offset!");
static_assert(offsetof(AJackProjectile, ExplosionEffect) == 0x0003D0, "Member 'AJackProjectile::ExplosionEffect' has a wrong offset!");
static_assert(offsetof(AJackProjectile, TrailEffect) == 0x0003D8, "Member 'AJackProjectile::TrailEffect' has a wrong offset!");
static_assert(offsetof(AJackProjectile, BumpNormalSize) == 0x0003E0, "Member 'AJackProjectile::BumpNormalSize' has a wrong offset!");
static_assert(offsetof(AJackProjectile, TrailDecalMinHeight) == 0x0003E4, "Member 'AJackProjectile::TrailDecalMinHeight' has a wrong offset!");
static_assert(offsetof(AJackProjectile, TrailDecalMinDistance) == 0x0003E8, "Member 'AJackProjectile::TrailDecalMinDistance' has a wrong offset!");
static_assert(offsetof(AJackProjectile, TrailDecalAddSize) == 0x0003EC, "Member 'AJackProjectile::TrailDecalAddSize' has a wrong offset!");
static_assert(offsetof(AJackProjectile, bHitTimingCallbackCalled) == 0x000428, "Member 'AJackProjectile::bHitTimingCallbackCalled' has a wrong offset!");

// Class JackGame.JackProjectileMovementComponent
// 0x0028 (0x0208 - 0x01E0)
class UJackProjectileMovementComponent final : public UProjectileMovementComponent
{
public:
	uint8                                         Pad_1E0[0x4];                                      // 0x01E0(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DelayMovementSeconds;                              // 0x01E4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnProjectileBeginOverlap;                          // 0x01E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1F8[0x10];                                     // 0x01F8(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnProjectileBeginOverlapDelegate__DelegateSignature(const struct FHitResult& ImpactResult);
	void OnUpdateComponentBeginOverlap(class UPrimitiveComponent* OverlappedComp, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackProjectileMovementComponent">();
	}
	static class UJackProjectileMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackProjectileMovementComponent>();
	}
};
static_assert(alignof(UJackProjectileMovementComponent) == 0x000008, "Wrong alignment on UJackProjectileMovementComponent");
static_assert(sizeof(UJackProjectileMovementComponent) == 0x000208, "Wrong size on UJackProjectileMovementComponent");
static_assert(offsetof(UJackProjectileMovementComponent, DelayMovementSeconds) == 0x0001E4, "Member 'UJackProjectileMovementComponent::DelayMovementSeconds' has a wrong offset!");
static_assert(offsetof(UJackProjectileMovementComponent, OnProjectileBeginOverlap) == 0x0001E8, "Member 'UJackProjectileMovementComponent::OnProjectileBeginOverlap' has a wrong offset!");

// Class JackGame.JackWorldTime
// 0x0058 (0x0090 - 0x0038)
class UJackWorldTime : public UObject
{
public:
	int32                                         StartHour_Morning;                                 // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartHour_Daytime;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartHour_Evening;                                 // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartHour_Night;                                   // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_Morning;                        // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_Daytime;                        // 0x004C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_Evening;                        // 0x0050(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_Night;                          // 0x0054(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_Midnight;                       // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Scenario_StartHour_EarlyMorning;                   // 0x005C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnChangeOfDate;                                    // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_70[0x20];                                      // 0x0070(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FastForward(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, int32 Hour, int32 Minute, float Speed, bool bPause);
	bool IsPause();
	bool IsPauseByPurpose(EJackWorldTimePausePurpose Purpose);
	void OnChangeOfDate__DelegateSignature();
	void ReleaseStopperTime();
	void SetMinutesOf1Day(int32 Minutes);
	void SetNowTime(int32 InNowTime, bool bResetNPCSchedule);
	void SetPause(EJackWorldTimePausePurpose Purpose, bool bPause);
	void SetStopperTime(int32 StopTime);

	int32 GetMinutesOf1Day() const;
	int32 GetNowHour() const;
	int32 GetNowMinute() const;
	int32 GetNowSecond() const;
	int32 GetNowTime() const;
	EJackScenarioTimeZone GetScenarioTimeZone(int32 Time) const;
	bool GetStopperTime(int32* OutStopTime) const;
	EJackTimeZone GetTimeZone(int32 Time) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWorldTime">();
	}
	static class UJackWorldTime* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWorldTime>();
	}
};
static_assert(alignof(UJackWorldTime) == 0x000008, "Wrong alignment on UJackWorldTime");
static_assert(sizeof(UJackWorldTime) == 0x000090, "Wrong size on UJackWorldTime");
static_assert(offsetof(UJackWorldTime, StartHour_Morning) == 0x000038, "Member 'UJackWorldTime::StartHour_Morning' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, StartHour_Daytime) == 0x00003C, "Member 'UJackWorldTime::StartHour_Daytime' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, StartHour_Evening) == 0x000040, "Member 'UJackWorldTime::StartHour_Evening' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, StartHour_Night) == 0x000044, "Member 'UJackWorldTime::StartHour_Night' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_Morning) == 0x000048, "Member 'UJackWorldTime::Scenario_StartHour_Morning' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_Daytime) == 0x00004C, "Member 'UJackWorldTime::Scenario_StartHour_Daytime' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_Evening) == 0x000050, "Member 'UJackWorldTime::Scenario_StartHour_Evening' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_Night) == 0x000054, "Member 'UJackWorldTime::Scenario_StartHour_Night' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_Midnight) == 0x000058, "Member 'UJackWorldTime::Scenario_StartHour_Midnight' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, Scenario_StartHour_EarlyMorning) == 0x00005C, "Member 'UJackWorldTime::Scenario_StartHour_EarlyMorning' has a wrong offset!");
static_assert(offsetof(UJackWorldTime, OnChangeOfDate) == 0x000060, "Member 'UJackWorldTime::OnChangeOfDate' has a wrong offset!");

// Class JackGame.JackPropActor
// 0x0018 (0x03B0 - 0x0398)
class AJackPropActor : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMatineeControlComponent*           MatineeControlComponent;                           // 0x03A0(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A8[0x8];                                      // 0x03A8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnHiddenInGameChanged(bool bNewHiddenInGame);
	void SetHiddenControl(EJackPropHiddenPurpose Purpose, bool bNewHidden);

	bool IsHiddenControl(EJackPropHiddenPurpose Purpose) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPropActor">();
	}
	static class AJackPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackPropActor>();
	}
};
static_assert(alignof(AJackPropActor) == 0x000008, "Wrong alignment on AJackPropActor");
static_assert(sizeof(AJackPropActor) == 0x0003B0, "Wrong size on AJackPropActor");
static_assert(offsetof(AJackPropActor, MatineeControlComponent) == 0x0003A0, "Member 'AJackPropActor::MatineeControlComponent' has a wrong offset!");

// Class JackGame.JackPropsComponent
// 0x00E0 (0x0280 - 0x01A0)
class UJackPropsComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x58];                                     // 0x01A0(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPropAttached;                                    // 0x01F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropDetached;                                    // 0x0208(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bAsyncLoadOnBeginPlay;                             // 0x0218(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_219[0x7];                                      // 0x0219(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               AsyncLoadedClassesHolder;                          // 0x0220(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_228[0x50];                                     // 0x0228(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UDataTable*                             DT_AttachedProps;                                  // 0x0278(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class AJackPropActor* Attach(class FName PropName);
	bool Detach(class FName PropName);
	void JackPropAttachSignature__DelegateSignature(class FName PropName, class AActor* PropActor);
	void JackPropDetachSignature__DelegateSignature(class FName PropName);

	class AJackPropActor* GetPropActor(class FName PropName) const;
	void GetPropActorList(TArray<class AJackPropActor*>* OutActorList) const;
	bool IsAttached(class FName PropName) const;
	bool IsAttachedAnyProps() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPropsComponent">();
	}
	static class UJackPropsComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPropsComponent>();
	}
};
static_assert(alignof(UJackPropsComponent) == 0x000008, "Wrong alignment on UJackPropsComponent");
static_assert(sizeof(UJackPropsComponent) == 0x000280, "Wrong size on UJackPropsComponent");
static_assert(offsetof(UJackPropsComponent, OnPropAttached) == 0x0001F8, "Member 'UJackPropsComponent::OnPropAttached' has a wrong offset!");
static_assert(offsetof(UJackPropsComponent, OnPropDetached) == 0x000208, "Member 'UJackPropsComponent::OnPropDetached' has a wrong offset!");
static_assert(offsetof(UJackPropsComponent, bAsyncLoadOnBeginPlay) == 0x000218, "Member 'UJackPropsComponent::bAsyncLoadOnBeginPlay' has a wrong offset!");
static_assert(offsetof(UJackPropsComponent, AsyncLoadedClassesHolder) == 0x000220, "Member 'UJackPropsComponent::AsyncLoadedClassesHolder' has a wrong offset!");
static_assert(offsetof(UJackPropsComponent, DT_AttachedProps) == 0x000278, "Member 'UJackPropsComponent::DT_AttachedProps' has a wrong offset!");

// Class JackGame.JackRandomAIController
// 0x0008 (0x0B58 - 0x0B50)
class AJackRandomAIController final : public AJackScheduledAIController
{
public:
	uint8                                         Pad_B50[0x8];                                      // 0x0B50(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRandomAIController">();
	}
	static class AJackRandomAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRandomAIController>();
	}
};
static_assert(alignof(AJackRandomAIController) == 0x000008, "Wrong alignment on AJackRandomAIController");
static_assert(sizeof(AJackRandomAIController) == 0x000B58, "Wrong size on AJackRandomAIController");

// Class JackGame.JackRecastFilter
// 0x0000 (0x0038 - 0x0038)
class UJackRecastFilter final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRecastFilter">();
	}
	static class UJackRecastFilter* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRecastFilter>();
	}
};
static_assert(alignof(UJackRecastFilter) == 0x000008, "Wrong alignment on UJackRecastFilter");
static_assert(sizeof(UJackRecastFilter) == 0x000038, "Wrong size on UJackRecastFilter");

// Class JackGame.JackRecipeBookManager
// 0x0080 (0x00B8 - 0x0038)
class UJackRecipeBookManager : public UObject
{
public:
	class UDataTable*                             RecipeBookDataTable;                               // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             RecipeDataTable;                                   // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x70];                                      // 0x0048(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void LearningRecipeSerifuExecution(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, const TArray<class FName>& LearningList, class FName TextID, const class FString& TagString, bool bLastTagIsBr, bool bForceMessageEnd);

	void AddBrowsedRecipeBookList();
	bool IsLearnedRecipeBookFromItemId(class FName ItemID);
	bool IsNewRecipeExists();
	bool LearningRecipeBookFromItemId(class FName ItemID, TArray<class FName>* OutLearningList);
	void MakeBlacksmithNewRecipeBoolList();
	void MakeBlacksmithNewRecipeList();
	void MakeBrowsedRecipeIDList();

	TArray<class FName> GetLearningBlacksmithRecipeList(EJackFusigiKaziParts Type) const;
	TArray<class FName> GetLearningNewRecipeList() const;
	TArray<class FName> GetLearningRecipeBookList() const;
	float GetLearningRecipeCompleteRate() const;
	TArray<class FName> GetLearningRecipeList() const;
	TArray<class FName> GetMaterialIdFromRecipeId(class FName RecipeId) const;
	TArray<int32> GetMaterialNumberFromRecipeId(class FName RecipeId) const;
	const class FName GetProductName(class FName RecipeId) const;
	TArray<class FName> GetRecipeBookEntryId(class FName RecipeBookID) const;
	TArray<class FName> GetRecipeBookEntryIdFromItemId(class FName ItemID) const;
	int32 GetRecipeBookEntryNumber(class FName RecipeBookID) const;
	int32 GetRecipeBookEntryNumberFromItemId(class FName ItemID) const;
	const int32 GetRecipeBookId(class FName RecipeBookID) const;
	const class FString GetRecipeBookName(class FName RecipeBookID) const;
	const class FString GetRecipeBookNameFromItemId(class FName ItemID) const;
	const class FString GetRecipeName(class FName RecipeId) const;
	TArray<struct FJackMessageArgumentData> MakeGetAndReadRecipeBookMessageTag(class FName ItemID, const class FString& ItemNameTagString, const class FString& RareTagString) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRecipeBookManager">();
	}
	static class UJackRecipeBookManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRecipeBookManager>();
	}
};
static_assert(alignof(UJackRecipeBookManager) == 0x000008, "Wrong alignment on UJackRecipeBookManager");
static_assert(sizeof(UJackRecipeBookManager) == 0x0000B8, "Wrong size on UJackRecipeBookManager");
static_assert(offsetof(UJackRecipeBookManager, RecipeBookDataTable) == 0x000038, "Member 'UJackRecipeBookManager::RecipeBookDataTable' has a wrong offset!");
static_assert(offsetof(UJackRecipeBookManager, RecipeDataTable) == 0x000040, "Member 'UJackRecipeBookManager::RecipeDataTable' has a wrong offset!");

// Class JackGame.JackReelUtility
// 0x0000 (0x0038 - 0x0038)
class UJackReelUtility final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackReelUtility">();
	}
	static class UJackReelUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackReelUtility>();
	}
};
static_assert(alignof(UJackReelUtility) == 0x000008, "Wrong alignment on UJackReelUtility");
static_assert(sizeof(UJackReelUtility) == 0x000038, "Wrong size on UJackReelUtility");

// Class JackGame.JackRenkeiManager
// 0x04C8 (0x0860 - 0x0398)
class AJackRenkeiManager : public AActor
{
public:
	uint8                                         Pad_398[0x14];                                     // 0x0398(0x0014)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bStartText;                                        // 0x03AC(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bStartTextMonster;                                 // 0x03AD(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3AE[0x2];                                      // 0x03AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StartTextTime;                                     // 0x03B0(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3B4[0x4];                                      // 0x03B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartTextCamera;                                   // 0x03B8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RenkeiParticle1Location;                           // 0x03C0(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RenkeiParticle2Location;                           // 0x03CC(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                RenkeiParticleBGLocation;                          // 0x03D8(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisibleBattleWhiteLine_PGRenkei;                  // 0x03E4(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bVisibleBattleWhiteLine_MatineeResult;             // 0x03E5(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E6[0x2];                                      // 0x03E6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RenkeiDamageParticleLocation;                      // 0x03E8(0x000C)(Edit, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3F4[0x4];                                      // 0x03F4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           IgnoreMonsterPhysicalPropertyID;                   // 0x03F8(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         RenkeiSkipFadeTime;                                // 0x0408(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RenkeiEndFadeTime;                                 // 0x040C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackRenkeiEndCamera                          RenkeiEndCameraMode;                               // 0x0410(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_411[0x3];                                      // 0x0411(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RenkeiEndAfterTime;                                // 0x0414(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EJackCharacter>                        CharacterChangeRenkeiOrder;                        // 0x0418(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class AMatineeActor*>                  MatineeActorList;                                  // 0x0428(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         SpectacleShowSuccessRate;                          // 0x0438(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_43C[0x4];                                      // 0x043C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackSpectacularShowData>       SpectacularShowData;                               // 0x0440(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackRenkeiFormation>           JackRenkeiFormation;                               // 0x0450(0x0010)(Edit, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         JackRenkeiFormationInterval;                       // 0x0460(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JackRenkeiFormationScale;                          // 0x0464(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JackRenkeiFormationMiniSize;                       // 0x0468(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JackRenkeiFormationMaxSize;                        // 0x046C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_470[0x280];                                    // 0x0470(0x0280)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackGameCharacter*>             TargetCharacters;                                  // 0x06F0(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackGameCharacter*>             HiddenCharacterList;                               // 0x0700(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_710[0x50];                                     // 0x0710(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               StreamObjectsHolder;                               // 0x0760(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackStreamObjectsHolder*               VoiceStreamObjectsHolder;                          // 0x0768(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_770[0x10];                                     // 0x0770(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackRenkeiResourceManager*             RenkeiResourceManager;                             // 0x0780(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_788[0x88];                                     // 0x0788(0x0088)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class AActor>>          CheckAllTextureStreamLoadedActor;                  // 0x0810(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	TArray<TWeakObjectPtr<class AActor>>          RenkeiHiddenControlIgnoredActors;                  // 0x0820(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_830[0x30];                                     // 0x0830(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddHiddenControlIgnoredActors(const TArray<class AActor*>& InActors);
	EJackMatineeRenkeiMonsterSize GetMatineeMonsterSize();
	void InitializeMatineeActor();
	bool IsAllTextureStreamLoaded();
	bool IsMatineeRenkeiSkip();
	bool IsRenkeiPlay();
	bool IsSpectaclShowSuccess();
	void OnCreateMatineeSkipUI();
	void OnMatineeLoadingEnd();
	void OnMatineeMonsterDamageReaction();
	void OnMatineeRenkeiDivisionLoad(const TArray<class FName>& RenkeiLevelNames, const TArray<class FName>& LevelNamePass);
	void OnMatineeRenkeiEnd();
	void OnMatineeRenkeiEndFadeStart(float InFadeTime);
	void OnMatineeRenkeiPlay(class FName RenkeiName, class FName RenkeiLevelName, const TArray<class AJackCharacter*>& AttackerCharaList, class AJackCharacter* TargetCharacter1);
	void OnMatineeRenkeiStart(bool bSuccess);
	void OnSetBattleWhiteLineHiddenDecal(const bool InHidden);
	void OnStartMatineeRenkei_CreateMatineeSkipUI();
	void ReleaseMatineeActor(class AMatineeActor* MatineeActor);
	void RemoveHiddenControlIgnoredActors();
	void RenkeiTeleport(class AJackCharacter* Character, const struct FVector& DestLocation, const struct FRotator& DestRotation, bool bIsATest, bool bNoCheck);
	void SetHiddenControlByMatineeRenkei(class AJackCharacter* Actor, EJackCharacterHiddenPurpose Purpose, bool bNewHidden);
	void SetMatineeRenkeiSkip(bool InEnable);
	void SetupMatineeActor(class AMatineeActor* MatineeActor);

	bool CheckMonsterRenkei(class UJackGameCharacter** OutRenkeiJoinMember, const class UJackGameCharacter* TriggerGameCharacter, const struct FJackActionData& ActionData) const;
	bool IsMatineeRenkeiPlay() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRenkeiManager">();
	}
	static class AJackRenkeiManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRenkeiManager>();
	}
};
static_assert(alignof(AJackRenkeiManager) == 0x000008, "Wrong alignment on AJackRenkeiManager");
static_assert(sizeof(AJackRenkeiManager) == 0x000860, "Wrong size on AJackRenkeiManager");
static_assert(offsetof(AJackRenkeiManager, bStartText) == 0x0003AC, "Member 'AJackRenkeiManager::bStartText' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, bStartTextMonster) == 0x0003AD, "Member 'AJackRenkeiManager::bStartTextMonster' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, StartTextTime) == 0x0003B0, "Member 'AJackRenkeiManager::StartTextTime' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, StartTextCamera) == 0x0003B8, "Member 'AJackRenkeiManager::StartTextCamera' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiParticle1Location) == 0x0003C0, "Member 'AJackRenkeiManager::RenkeiParticle1Location' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiParticle2Location) == 0x0003CC, "Member 'AJackRenkeiManager::RenkeiParticle2Location' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiParticleBGLocation) == 0x0003D8, "Member 'AJackRenkeiManager::RenkeiParticleBGLocation' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, bVisibleBattleWhiteLine_PGRenkei) == 0x0003E4, "Member 'AJackRenkeiManager::bVisibleBattleWhiteLine_PGRenkei' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, bVisibleBattleWhiteLine_MatineeResult) == 0x0003E5, "Member 'AJackRenkeiManager::bVisibleBattleWhiteLine_MatineeResult' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiDamageParticleLocation) == 0x0003E8, "Member 'AJackRenkeiManager::RenkeiDamageParticleLocation' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, IgnoreMonsterPhysicalPropertyID) == 0x0003F8, "Member 'AJackRenkeiManager::IgnoreMonsterPhysicalPropertyID' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiSkipFadeTime) == 0x000408, "Member 'AJackRenkeiManager::RenkeiSkipFadeTime' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiEndFadeTime) == 0x00040C, "Member 'AJackRenkeiManager::RenkeiEndFadeTime' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiEndCameraMode) == 0x000410, "Member 'AJackRenkeiManager::RenkeiEndCameraMode' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiEndAfterTime) == 0x000414, "Member 'AJackRenkeiManager::RenkeiEndAfterTime' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, CharacterChangeRenkeiOrder) == 0x000418, "Member 'AJackRenkeiManager::CharacterChangeRenkeiOrder' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, MatineeActorList) == 0x000428, "Member 'AJackRenkeiManager::MatineeActorList' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, SpectacleShowSuccessRate) == 0x000438, "Member 'AJackRenkeiManager::SpectacleShowSuccessRate' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, SpectacularShowData) == 0x000440, "Member 'AJackRenkeiManager::SpectacularShowData' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, JackRenkeiFormation) == 0x000450, "Member 'AJackRenkeiManager::JackRenkeiFormation' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, JackRenkeiFormationInterval) == 0x000460, "Member 'AJackRenkeiManager::JackRenkeiFormationInterval' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, JackRenkeiFormationScale) == 0x000464, "Member 'AJackRenkeiManager::JackRenkeiFormationScale' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, JackRenkeiFormationMiniSize) == 0x000468, "Member 'AJackRenkeiManager::JackRenkeiFormationMiniSize' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, JackRenkeiFormationMaxSize) == 0x00046C, "Member 'AJackRenkeiManager::JackRenkeiFormationMaxSize' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, TargetCharacters) == 0x0006F0, "Member 'AJackRenkeiManager::TargetCharacters' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, HiddenCharacterList) == 0x000700, "Member 'AJackRenkeiManager::HiddenCharacterList' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, StreamObjectsHolder) == 0x000760, "Member 'AJackRenkeiManager::StreamObjectsHolder' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, VoiceStreamObjectsHolder) == 0x000768, "Member 'AJackRenkeiManager::VoiceStreamObjectsHolder' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiResourceManager) == 0x000780, "Member 'AJackRenkeiManager::RenkeiResourceManager' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, CheckAllTextureStreamLoadedActor) == 0x000810, "Member 'AJackRenkeiManager::CheckAllTextureStreamLoadedActor' has a wrong offset!");
static_assert(offsetof(AJackRenkeiManager, RenkeiHiddenControlIgnoredActors) == 0x000820, "Member 'AJackRenkeiManager::RenkeiHiddenControlIgnoredActors' has a wrong offset!");

// Class JackGame.JackVehicleAnimInstance
// 0x0180 (0x0D60 - 0x0BE0)
class UJackVehicleAnimInstance final : public UJackAnimInstance
{
public:
	uint8                                         Pad_BD8[0x158];                                    // 0x0BD8(0x0158)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MoveMotionRateWalkSpeed;                           // 0x0D30(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootMotionMultiChangeSpeed;                        // 0x0D34(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootMotionMultiLimitMin;                           // 0x0D38(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         RootMotionMultiThreshold;                          // 0x0D3C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         WaitColliderMultiplier;                            // 0x0D40(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D44[0x1C];                                     // 0x0D44(0x001C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActivateDashParticle(bool bActive);
	class USceneComponent* GetMeshRootComponent();
	void PlayDashSE();
	void SetAttitudeControlEnable(bool bOn);
	void SetCallBPConstructionScript();
	void SetDashCancel();
	void SetFootIKEnable(bool bOn, float HeightOffLerpSec);
	void SetForceRun(bool bOn);
	void SetJumpCondition(bool bJump);
	void SetMoveMotionBlendeRate(float Rate);
	void SetMoveMotionTurnAngleRate(float Rate);
	void SetNowIdle(bool bIdle);
	void SetOffsetUpperOn(bool bOn, float InterpSec);
	void SetParameterBool(EJackVehicleParameterBool ID, bool bOn, bool bIgnoreL1R1Turn);
	void SetParameterBoolRaw(EJackVehicleParameterBool ID, bool bOn);
	void SetParameterFloat(EJackVehicleParameterFloat ID, float FloatParameter, bool bIgnoreL1R1Turn);
	void SetParameterFloatRaw(EJackVehicleParameterFloat ID, float FloatParameter);
	void SetRoar(float Timer, float RequestOffAddSec);
	void SetRootMotionMode(ERootMotionMode RootMotionNode);
	void UpdateStateMachineFlags(float DeltaSeconds);
	void UpdateStateMachineFlagsV012(float DeltaSeconds);
	void UpdateStateMachineFlagsV104(float DeltaSeconds);

	bool CanChangeFromRemainingMotion(float Remaining, float Left) const;
	float GetMoveMotionBlendRate() const;
	float GetMoveMotionTurnAngleRate() const;
	bool GetParameterBool(EJackVehicleParameterBool ID) const;
	bool GetParameterFlags(EJackVehicleParameterStateMachineFlags ID) const;
	float GetParameterFloat(EJackVehicleParameterFloat ID) const;
	bool IsCanRoarRequest() const;
	bool IsInRoar() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleAnimInstance">();
	}
	static class UJackVehicleAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleAnimInstance>();
	}
};
static_assert(alignof(UJackVehicleAnimInstance) == 0x000010, "Wrong alignment on UJackVehicleAnimInstance");
static_assert(sizeof(UJackVehicleAnimInstance) == 0x000D60, "Wrong size on UJackVehicleAnimInstance");
static_assert(offsetof(UJackVehicleAnimInstance, MoveMotionRateWalkSpeed) == 0x000D30, "Member 'UJackVehicleAnimInstance::MoveMotionRateWalkSpeed' has a wrong offset!");
static_assert(offsetof(UJackVehicleAnimInstance, RootMotionMultiChangeSpeed) == 0x000D34, "Member 'UJackVehicleAnimInstance::RootMotionMultiChangeSpeed' has a wrong offset!");
static_assert(offsetof(UJackVehicleAnimInstance, RootMotionMultiLimitMin) == 0x000D38, "Member 'UJackVehicleAnimInstance::RootMotionMultiLimitMin' has a wrong offset!");
static_assert(offsetof(UJackVehicleAnimInstance, RootMotionMultiThreshold) == 0x000D3C, "Member 'UJackVehicleAnimInstance::RootMotionMultiThreshold' has a wrong offset!");
static_assert(offsetof(UJackVehicleAnimInstance, WaitColliderMultiplier) == 0x000D40, "Member 'UJackVehicleAnimInstance::WaitColliderMultiplier' has a wrong offset!");

// Class JackGame.JackRenkeiResourceManager
// 0x00C8 (0x0100 - 0x0038)
class UJackRenkeiResourceManager final : public UObject
{
public:
	TMap<uint8, class UJackStreamObjectsHolder*>  ResourceCache;                                     // 0x0038(0x0050)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UJackStreamObjectsHolder*>       ActionResourceCache;                               // 0x0088(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	TArray<class UJackStreamObjectsHolder*>       ActionVoiceResourceCache;                          // 0x0098(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A8[0x58];                                      // 0x00A8(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRenkeiResourceManager">();
	}
	static class UJackRenkeiResourceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRenkeiResourceManager>();
	}
};
static_assert(alignof(UJackRenkeiResourceManager) == 0x000008, "Wrong alignment on UJackRenkeiResourceManager");
static_assert(sizeof(UJackRenkeiResourceManager) == 0x000100, "Wrong size on UJackRenkeiResourceManager");
static_assert(offsetof(UJackRenkeiResourceManager, ResourceCache) == 0x000038, "Member 'UJackRenkeiResourceManager::ResourceCache' has a wrong offset!");
static_assert(offsetof(UJackRenkeiResourceManager, ActionResourceCache) == 0x000088, "Member 'UJackRenkeiResourceManager::ActionResourceCache' has a wrong offset!");
static_assert(offsetof(UJackRenkeiResourceManager, ActionVoiceResourceCache) == 0x000098, "Member 'UJackRenkeiResourceManager::ActionVoiceResourceCache' has a wrong offset!");

// Class JackGame.JackReservedEffectComponent
// 0x01D0 (0x0370 - 0x01A0)
class UJackReservedEffectComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x170];                                    // 0x01A0(0x0170)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TWeakObjectPtr<class UJackBurstEffect>> FiredBurstEffects;                                 // 0x0310(0x0010)(ZeroConstructor, Protected, UObjectWrapper, NativeAccessSpecifierProtected)
	uint8                                         Pad_320[0x50];                                     // 0x0320(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DeactivateActionEffectDirect(class AJackActionEffect* InDeactivateEffect);
	void FireActionEffectDirect(TSubclassOf<class AJackActionEffect> EffectClassTemplate, const class AJackCharacter* TargetCharacter);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackReservedEffectComponent">();
	}
	static class UJackReservedEffectComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackReservedEffectComponent>();
	}
};
static_assert(alignof(UJackReservedEffectComponent) == 0x000008, "Wrong alignment on UJackReservedEffectComponent");
static_assert(sizeof(UJackReservedEffectComponent) == 0x000370, "Wrong size on UJackReservedEffectComponent");
static_assert(offsetof(UJackReservedEffectComponent, FiredBurstEffects) == 0x000310, "Member 'UJackReservedEffectComponent::FiredBurstEffects' has a wrong offset!");

// Class JackGame.JackReservedPlayerControlExecutor
// 0x0000 (0x0398 - 0x0398)
class AJackReservedPlayerControlExecutor final : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackReservedPlayerControlExecutor">();
	}
	static class AJackReservedPlayerControlExecutor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackReservedPlayerControlExecutor>();
	}
};
static_assert(alignof(AJackReservedPlayerControlExecutor) == 0x000008, "Wrong alignment on AJackReservedPlayerControlExecutor");
static_assert(sizeof(AJackReservedPlayerControlExecutor) == 0x000398, "Wrong size on AJackReservedPlayerControlExecutor");

// Class JackGame.JackResetAnimDynamicsTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackResetAnimDynamicsTrack final : public UInterpTrack
{
public:
	TArray<struct FJackResetAnimDynamicsTrackKey> KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackResetAnimDynamicsTrack">();
	}
	static class UJackResetAnimDynamicsTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackResetAnimDynamicsTrack>();
	}
};
static_assert(alignof(UJackResetAnimDynamicsTrack) == 0x000008, "Wrong alignment on UJackResetAnimDynamicsTrack");
static_assert(sizeof(UJackResetAnimDynamicsTrack) == 0x0000A0, "Wrong size on UJackResetAnimDynamicsTrack");
static_assert(offsetof(UJackResetAnimDynamicsTrack, KeyArray) == 0x000090, "Member 'UJackResetAnimDynamicsTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackResetAnimDynamicsTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackResetAnimDynamicsTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackResetAnimDynamicsTrackInst">();
	}
	static class UJackResetAnimDynamicsTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackResetAnimDynamicsTrackInst>();
	}
};
static_assert(alignof(UJackResetAnimDynamicsTrackInst) == 0x000008, "Wrong alignment on UJackResetAnimDynamicsTrackInst");
static_assert(sizeof(UJackResetAnimDynamicsTrackInst) == 0x000040, "Wrong size on UJackResetAnimDynamicsTrackInst");

// Class JackGame.JackRotationControl
// 0x0010 (0x0048 - 0x0038)
class UJackRotationControl final : public UObject
{
public:
	TArray<struct FJackRotationInfo>              RotationInfos;                                     // 0x0038(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRotationControl">();
	}
	static class UJackRotationControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRotationControl>();
	}
};
static_assert(alignof(UJackRotationControl) == 0x000008, "Wrong alignment on UJackRotationControl");
static_assert(sizeof(UJackRotationControl) == 0x000048, "Wrong size on UJackRotationControl");
static_assert(offsetof(UJackRotationControl, RotationInfos) == 0x000038, "Member 'UJackRotationControl::RotationInfos' has a wrong offset!");

// Class JackGame.JackRouletteAccessor
// 0x0000 (0x0038 - 0x0038)
class UJackRouletteAccessor final : public UObject
{
public:
	bool IsRedNumber(int32 InNumber);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRouletteAccessor">();
	}
	static class UJackRouletteAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackRouletteAccessor>();
	}
};
static_assert(alignof(UJackRouletteAccessor) == 0x000008, "Wrong alignment on UJackRouletteAccessor");
static_assert(sizeof(UJackRouletteAccessor) == 0x000038, "Wrong size on UJackRouletteAccessor");

// Class JackGame.JackVehicleRiderComponent
// 0x0020 (0x01C0 - 0x01A0)
class UJackVehicleRiderComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class AJackVehicle* GetRidingOnVehicle() const;
	EJackVehicle GetRidingOnVehicleType() const;
	bool IsRidingOnVehicle() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleRiderComponent">();
	}
	static class UJackVehicleRiderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleRiderComponent>();
	}
};
static_assert(alignof(UJackVehicleRiderComponent) == 0x000008, "Wrong alignment on UJackVehicleRiderComponent");
static_assert(sizeof(UJackVehicleRiderComponent) == 0x0001C0, "Wrong size on UJackVehicleRiderComponent");

// Class JackGame.JackRouletteBall
// 0x0108 (0x04A0 - 0x0398)
class AJackRouletteBall final : public AActor
{
public:
	float                                         StartHeight;                                       // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndHeight;                                         // 0x039C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneBetStopRotateAngle;                             // 0x03A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OneBetStopRotateAngleRange;                        // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundWheelLoop;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundBallMtl;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundBallRck;                                      // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SoundBallPocket;                                   // 0x03C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredAngleSpeed;                                 // 0x03C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x4];                                      // 0x03CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            SplineTimeOfSpeed;                                 // 0x03D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PocketInPositionOffset;                            // 0x03D8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PocketInBallVelocityScale;                         // 0x03E4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USplineComponent*                       SplineComponent;                                   // 0x03F0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UStaticMeshComponent*                   BallMeshComponent;                                 // 0x03F8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0xA0];                                     // 0x0400(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAngle();
	int32 GetCurrentState();
	float GetTargetAngle(class AStaticMeshActor* Mesh);
	void InitializeInstance(class USplineComponent* Object, class UStaticMeshComponent* MeshObject);
	bool IsEnd();
	void SetState(EJackMiniGameRouletteBallState InState);
	void Start(float PlayTimeMax);
	void UpdateOrbit();

	bool IsAnimationEnd() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRouletteBall">();
	}
	static class AJackRouletteBall* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRouletteBall>();
	}
};
static_assert(alignof(AJackRouletteBall) == 0x000008, "Wrong alignment on AJackRouletteBall");
static_assert(sizeof(AJackRouletteBall) == 0x0004A0, "Wrong size on AJackRouletteBall");
static_assert(offsetof(AJackRouletteBall, StartHeight) == 0x000398, "Member 'AJackRouletteBall::StartHeight' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, EndHeight) == 0x00039C, "Member 'AJackRouletteBall::EndHeight' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, OneBetStopRotateAngle) == 0x0003A0, "Member 'AJackRouletteBall::OneBetStopRotateAngle' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, OneBetStopRotateAngleRange) == 0x0003A4, "Member 'AJackRouletteBall::OneBetStopRotateAngleRange' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SoundWheelLoop) == 0x0003A8, "Member 'AJackRouletteBall::SoundWheelLoop' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SoundBallMtl) == 0x0003B0, "Member 'AJackRouletteBall::SoundBallMtl' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SoundBallRck) == 0x0003B8, "Member 'AJackRouletteBall::SoundBallRck' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SoundBallPocket) == 0x0003C0, "Member 'AJackRouletteBall::SoundBallPocket' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, DesiredAngleSpeed) == 0x0003C8, "Member 'AJackRouletteBall::DesiredAngleSpeed' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SplineTimeOfSpeed) == 0x0003D0, "Member 'AJackRouletteBall::SplineTimeOfSpeed' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, PocketInPositionOffset) == 0x0003D8, "Member 'AJackRouletteBall::PocketInPositionOffset' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, PocketInBallVelocityScale) == 0x0003E4, "Member 'AJackRouletteBall::PocketInBallVelocityScale' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, SplineComponent) == 0x0003F0, "Member 'AJackRouletteBall::SplineComponent' has a wrong offset!");
static_assert(offsetof(AJackRouletteBall, BallMeshComponent) == 0x0003F8, "Member 'AJackRouletteBall::BallMeshComponent' has a wrong offset!");

// Class JackGame.JackRouletteMenu
// 0x0058 (0x03F0 - 0x0398)
class AJackRouletteMenu final : public AActor
{
public:
	float                                         CursorSpeed;                                       // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CursorX;                                           // 0x039C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CursorY;                                           // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3A4[0x4];                                      // 0x03A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            AlphaAnimCurve;                                    // 0x03A8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagnificationOffsetX;                              // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MagnificationOffsetY;                              // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJackRouletteBetData*>           BetDataArray;                                      // 0x03B8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C8[0x28];                                     // 0x03C8(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBetCoin(int32 Coin, class UJackUMGWidgetBase* Widget);
	void AddBetCoinAll(int32 Coin, int32 Num, const TArray<class UJackUMGWidgetBase*>& WidgetArray);
	int32 CalcDividend(int32 Number, bool bIsJackPot);
	bool CanBet();
	void CreateWidgetMagnification(int32 ResultNumber, class UCanvasPanel* CanvasPanelRoot, TSubclassOf<class UJackUMGWidgetBase> WidgetClass, TDelegate<void(class UJackUMGWidgetBase* Widget, const struct FVector2D& Position, int32 MagnificationIndex)> Delegate);
	void JackRouletteCreateWidgetDelegate__DelegateSignature(class UJackUMGWidgetBase* Widget, const struct FVector2D& Position, int32 MagnificationIndex);
	class UJackRouletteBetData* Current();
	class UJackRouletteBetData* Find(const class FString& Name_0);
	int32 GetBetCoin();
	int32 GetBetCoinNum();
	TArray<int32> GetBetNumberArray();
	int32 GetCanBetCoinNum(int32 Coin, int32 OneCoin);
	TArray<int32> GetCurrentBetNumberArray();
	struct FVector2D GetCurrentCursorPos();
	struct FVector2D GetCurrentCursorTargetPos();
	int32 GetMagnification();
	TArray<struct FJackRouletteBetCoinSaveData> GetMenuSaveData();
	int32 GetSelectTreasureBoxNo();
	int32 GetTotalBetCoin();
	bool IsBetCoin();
	bool IsCurrentTreasureBox();
	bool JudgeResult(int32 Number);
	bool JudgeResultTest(int32 Number, const TArray<int32>& BetNumber);
	bool MoveCursor(int32 X, int32 Y, bool bIsKeyPressed, bool bImmidiate);
	void ResetCursor();
	int32 RevertBetCoin();
	void SetCursor(int32 X, int32 Y);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRouletteMenu">();
	}
	static class AJackRouletteMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRouletteMenu>();
	}
};
static_assert(alignof(AJackRouletteMenu) == 0x000008, "Wrong alignment on AJackRouletteMenu");
static_assert(sizeof(AJackRouletteMenu) == 0x0003F0, "Wrong size on AJackRouletteMenu");
static_assert(offsetof(AJackRouletteMenu, CursorSpeed) == 0x000398, "Member 'AJackRouletteMenu::CursorSpeed' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, CursorX) == 0x00039C, "Member 'AJackRouletteMenu::CursorX' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, CursorY) == 0x0003A0, "Member 'AJackRouletteMenu::CursorY' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, AlphaAnimCurve) == 0x0003A8, "Member 'AJackRouletteMenu::AlphaAnimCurve' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, MagnificationOffsetX) == 0x0003B0, "Member 'AJackRouletteMenu::MagnificationOffsetX' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, MagnificationOffsetY) == 0x0003B4, "Member 'AJackRouletteMenu::MagnificationOffsetY' has a wrong offset!");
static_assert(offsetof(AJackRouletteMenu, BetDataArray) == 0x0003B8, "Member 'AJackRouletteMenu::BetDataArray' has a wrong offset!");

// Class JackGame.JackRouletteWheel
// 0x00C8 (0x0460 - 0x0398)
class AJackRouletteWheel final : public AActor
{
public:
	float                                         JackPotDecelerationAngle;                          // 0x0398(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotDecelerationAngleRange;                     // 0x039C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotNearDecelerationAngle;                      // 0x03A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotNearDecelerationAngleRange;                 // 0x03A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotLowerLimitAngleSpeed;                       // 0x03A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotStopOffset;                                 // 0x03AC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JackPotCurve;                                      // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            JackPotNearCurve;                                  // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JackPotCameraDemoStartAngle;                       // 0x03C0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DesiredAngleVelocity;                              // 0x03C4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StopRandomOffsetRatio;                             // 0x03C8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3CC[0x94];                                     // 0x03CC(0x0094)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float ClampAngle(float AngleEuler);
	void Delegate__DelegateSignature();
	float GetAngle();
	float GetCurrentEndAngleRatio();
	float GetCurrentEndAngleRatioForNearJackPot();
	int32 GetDisplayNumberFromID(int32 ID);
	int32 GetIDFromDisplayNumber(int32 DisplayNumber);
	float GetJackPotResetAngle();
	struct FVector GetJackPotRotationAngle(float OffsetRadius);
	int32 GetResultDisplayNumber(float BallAngle);
	int32 GetResultIDNumber(float BallAngle);
	struct FVector GetResultPocketLocation();
	struct FVector GetResultPocketLocationDistance(float InOffsetRadius);
	void SetCameraEndDelegate(TDelegate<void()> InDelegate);
	void SetRouletteEndCameraDemoDelegate(TDelegate<void()> InDelegate);
	void SetRouletteEndDelegate(TDelegate<void()> InDelegate);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRouletteWheel">();
	}
	static class AJackRouletteWheel* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRouletteWheel>();
	}
};
static_assert(alignof(AJackRouletteWheel) == 0x000008, "Wrong alignment on AJackRouletteWheel");
static_assert(sizeof(AJackRouletteWheel) == 0x000460, "Wrong size on AJackRouletteWheel");
static_assert(offsetof(AJackRouletteWheel, JackPotDecelerationAngle) == 0x000398, "Member 'AJackRouletteWheel::JackPotDecelerationAngle' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotDecelerationAngleRange) == 0x00039C, "Member 'AJackRouletteWheel::JackPotDecelerationAngleRange' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotNearDecelerationAngle) == 0x0003A0, "Member 'AJackRouletteWheel::JackPotNearDecelerationAngle' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotNearDecelerationAngleRange) == 0x0003A4, "Member 'AJackRouletteWheel::JackPotNearDecelerationAngleRange' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotLowerLimitAngleSpeed) == 0x0003A8, "Member 'AJackRouletteWheel::JackPotLowerLimitAngleSpeed' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotStopOffset) == 0x0003AC, "Member 'AJackRouletteWheel::JackPotStopOffset' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotCurve) == 0x0003B0, "Member 'AJackRouletteWheel::JackPotCurve' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotNearCurve) == 0x0003B8, "Member 'AJackRouletteWheel::JackPotNearCurve' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, JackPotCameraDemoStartAngle) == 0x0003C0, "Member 'AJackRouletteWheel::JackPotCameraDemoStartAngle' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, DesiredAngleVelocity) == 0x0003C4, "Member 'AJackRouletteWheel::DesiredAngleVelocity' has a wrong offset!");
static_assert(offsetof(AJackRouletteWheel, StopRandomOffsetRatio) == 0x0003C8, "Member 'AJackRouletteWheel::StopRandomOffsetRatio' has a wrong offset!");

// Class JackGame.JackRuraBase
// 0x01D0 (0x0568 - 0x0398)
class AJackRuraBase : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNoUseAnimMontageJumpWaitEnd;                      // 0x03A0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             RuraCeilCheckChannel;                              // 0x03A1(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A2[0x2];                                      // 0x03A2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CeilLength;                                        // 0x03A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CeilLowerLength;                                   // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AC[0x4];                                      // 0x03AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartAnimName;                                     // 0x03B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   StartAnimNonPlayerName;                            // 0x03B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           StartAnimVehicleFromName;                          // 0x03C0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StartAnimV011;                                     // 0x03D0(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StartAnimShip;                                     // 0x03E8(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UAnimMontage>            StartA028Anim;                                     // 0x0400(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   EndAnimName;                                       // 0x0418(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplSingAnimName;                                   // 0x0420(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplSingAnimNonPlayerName;                          // 0x0428(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SplSingAnimVehicleName;                            // 0x0430(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SplPlayAnimName;                                   // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplPlayAnimNonPlayerName;                          // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SplPlayAnimVehicleName;                            // 0x0450(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SplPlayEndAnimName;                                // 0x0460(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SplPlayEndAnimNonPlayerName;                       // 0x0468(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           SplPlayEndAnimVehicleName;                         // 0x0470(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              RuraSoundAtShipOrKetos;                            // 0x0480(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class USoundBase>              RuraEndSoundAtShipOrKetos;                         // 0x0498(0x0018)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraUse;                                           // 0x04B0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraCannotUse;                                     // 0x04B8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RuraMissTextIdStrangePower;                        // 0x04C0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChimeraUse;                                        // 0x04C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChimeraCannotUse;                                  // 0x04D0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ChimeraMissTextIdStrangePower;                     // 0x04D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiremitoUse;                                       // 0x04E0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiremitoCannotUse;                                 // 0x04E8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RiremitoMissTextIdStrangePower;                    // 0x04F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemUse;                                           // 0x04F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemCannotUse;                                     // 0x0500(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemMissTextIdStrangePower;                        // 0x0508(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MissTextIdCeil;                                    // 0x0510(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_518[0x50];                                     // 0x0518(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class AJackRuraBase* CreateRuraActor(class UObject* WorldContextObject);
	static EJackRuraPurpose GetJumpPurpose(const class UObject* WorldContext);
	static class FName GetJumpTag(class UObject* WorldContext);
	static void ResetRuraJumpPurpose(class UObject* WorldContext);

	void DelegateBindWaitEndSerif();
	void EndJump();
	bool IsCancelEnd();
	void Latent_EndJump(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void Latent_StartJump(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, EJackRuraPurpose InType, class FName InJumpTag, EJackItem_Bag BagType, int32 ItemIndex, EJackCharacter InCharaType);
	void OnDebugCheck(EJackRuraFail InFail);
	void OnDebugCheckOverlapActor(class AActor* InActor);
	void OnEndJump();
	void OnRiremitoJumpNoAnimMontageStart(EJackRuraFail InType);
	void OnStartJump(EJackRuraPurpose InPurpose, class FName InJumpTag);
	void OnStartJumpNoAnimMontageStart(EJackRuraFail InType);
	void SetRuraFailSetting(EJackRuraFail InFailType, int32 Level);
	void StartJump(EJackCharacter InCharaType, EJackRuraPurpose InType, class FName InJumpTag, EJackItem_Bag BagType, int32 ItemIndex);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackRuraBase">();
	}
	static class AJackRuraBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackRuraBase>();
	}
};
static_assert(alignof(AJackRuraBase) == 0x000008, "Wrong alignment on AJackRuraBase");
static_assert(sizeof(AJackRuraBase) == 0x000568, "Wrong size on AJackRuraBase");
static_assert(offsetof(AJackRuraBase, bNoUseAnimMontageJumpWaitEnd) == 0x0003A0, "Member 'AJackRuraBase::bNoUseAnimMontageJumpWaitEnd' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraCeilCheckChannel) == 0x0003A1, "Member 'AJackRuraBase::RuraCeilCheckChannel' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, CeilLength) == 0x0003A4, "Member 'AJackRuraBase::CeilLength' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, CeilLowerLength) == 0x0003A8, "Member 'AJackRuraBase::CeilLowerLength' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartAnimName) == 0x0003B0, "Member 'AJackRuraBase::StartAnimName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartAnimNonPlayerName) == 0x0003B8, "Member 'AJackRuraBase::StartAnimNonPlayerName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartAnimVehicleFromName) == 0x0003C0, "Member 'AJackRuraBase::StartAnimVehicleFromName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartAnimV011) == 0x0003D0, "Member 'AJackRuraBase::StartAnimV011' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartAnimShip) == 0x0003E8, "Member 'AJackRuraBase::StartAnimShip' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, StartA028Anim) == 0x000400, "Member 'AJackRuraBase::StartA028Anim' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, EndAnimName) == 0x000418, "Member 'AJackRuraBase::EndAnimName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplSingAnimName) == 0x000420, "Member 'AJackRuraBase::SplSingAnimName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplSingAnimNonPlayerName) == 0x000428, "Member 'AJackRuraBase::SplSingAnimNonPlayerName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplSingAnimVehicleName) == 0x000430, "Member 'AJackRuraBase::SplSingAnimVehicleName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayAnimName) == 0x000440, "Member 'AJackRuraBase::SplPlayAnimName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayAnimNonPlayerName) == 0x000448, "Member 'AJackRuraBase::SplPlayAnimNonPlayerName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayAnimVehicleName) == 0x000450, "Member 'AJackRuraBase::SplPlayAnimVehicleName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayEndAnimName) == 0x000460, "Member 'AJackRuraBase::SplPlayEndAnimName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayEndAnimNonPlayerName) == 0x000468, "Member 'AJackRuraBase::SplPlayEndAnimNonPlayerName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, SplPlayEndAnimVehicleName) == 0x000470, "Member 'AJackRuraBase::SplPlayEndAnimVehicleName' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraSoundAtShipOrKetos) == 0x000480, "Member 'AJackRuraBase::RuraSoundAtShipOrKetos' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraEndSoundAtShipOrKetos) == 0x000498, "Member 'AJackRuraBase::RuraEndSoundAtShipOrKetos' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraUse) == 0x0004B0, "Member 'AJackRuraBase::RuraUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraCannotUse) == 0x0004B8, "Member 'AJackRuraBase::RuraCannotUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RuraMissTextIdStrangePower) == 0x0004C0, "Member 'AJackRuraBase::RuraMissTextIdStrangePower' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ChimeraUse) == 0x0004C8, "Member 'AJackRuraBase::ChimeraUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ChimeraCannotUse) == 0x0004D0, "Member 'AJackRuraBase::ChimeraCannotUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ChimeraMissTextIdStrangePower) == 0x0004D8, "Member 'AJackRuraBase::ChimeraMissTextIdStrangePower' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RiremitoUse) == 0x0004E0, "Member 'AJackRuraBase::RiremitoUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RiremitoCannotUse) == 0x0004E8, "Member 'AJackRuraBase::RiremitoCannotUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, RiremitoMissTextIdStrangePower) == 0x0004F0, "Member 'AJackRuraBase::RiremitoMissTextIdStrangePower' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ItemUse) == 0x0004F8, "Member 'AJackRuraBase::ItemUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ItemCannotUse) == 0x000500, "Member 'AJackRuraBase::ItemCannotUse' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, ItemMissTextIdStrangePower) == 0x000508, "Member 'AJackRuraBase::ItemMissTextIdStrangePower' has a wrong offset!");
static_assert(offsetof(AJackRuraBase, MissTextIdCeil) == 0x000510, "Member 'AJackRuraBase::MissTextIdCeil' has a wrong offset!");

// Class JackGame.JackSafeAreaManager
// 0x0058 (0x03F0 - 0x0398)
class AJackSafeAreaManager : public AActor
{
public:
	uint8                                         Pad_398[0x50];                                     // 0x0398(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bDebugDrawEnabled;                                 // 0x03E8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3E9[0x7];                                      // 0x03E9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CalcSafeArea(struct FVector* OutLocation, const struct FVector& InLocation, float InRadius);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSafeAreaManager">();
	}
	static class AJackSafeAreaManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackSafeAreaManager>();
	}
};
static_assert(alignof(AJackSafeAreaManager) == 0x000008, "Wrong alignment on AJackSafeAreaManager");
static_assert(sizeof(AJackSafeAreaManager) == 0x0003F0, "Wrong size on AJackSafeAreaManager");
static_assert(offsetof(AJackSafeAreaManager, bDebugDrawEnabled) == 0x0003E8, "Member 'AJackSafeAreaManager::bDebugDrawEnabled' has a wrong offset!");

// Class JackGame.JackSafeAreaVolume
// 0x0010 (0x03E0 - 0x03D0)
class AJackSafeAreaVolume final : public AVolume
{
public:
	bool                                          bDirectionEnable;                                  // 0x03D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPinpointEnable;                                   // 0x03D1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D2[0x2];                                      // 0x03D2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackLocator>            PointLocator;                                      // 0x03D4(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInvalid;                                        // 0x03DC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3DD[0x3];                                      // 0x03DD(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSafeAreaVolume">();
	}
	static class AJackSafeAreaVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackSafeAreaVolume>();
	}
};
static_assert(alignof(AJackSafeAreaVolume) == 0x000008, "Wrong alignment on AJackSafeAreaVolume");
static_assert(sizeof(AJackSafeAreaVolume) == 0x0003E0, "Wrong size on AJackSafeAreaVolume");
static_assert(offsetof(AJackSafeAreaVolume, bDirectionEnable) == 0x0003D0, "Member 'AJackSafeAreaVolume::bDirectionEnable' has a wrong offset!");
static_assert(offsetof(AJackSafeAreaVolume, bPinpointEnable) == 0x0003D1, "Member 'AJackSafeAreaVolume::bPinpointEnable' has a wrong offset!");
static_assert(offsetof(AJackSafeAreaVolume, PointLocator) == 0x0003D4, "Member 'AJackSafeAreaVolume::PointLocator' has a wrong offset!");
static_assert(offsetof(AJackSafeAreaVolume, bIsInvalid) == 0x0003DC, "Member 'AJackSafeAreaVolume::bIsInvalid' has a wrong offset!");

// Class JackGame.JackSaveLoadManager
// 0x00D0 (0x0108 - 0x0038)
class UJackSaveLoadManager final : public UObject
{
public:
	uint8                                         Pad_38[0xD0];                                      // 0x0038(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSaveLoadManager">();
	}
	static class UJackSaveLoadManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSaveLoadManager>();
	}
};
static_assert(alignof(UJackSaveLoadManager) == 0x000008, "Wrong alignment on UJackSaveLoadManager");
static_assert(sizeof(UJackSaveLoadManager) == 0x000108, "Wrong size on UJackSaveLoadManager");

// Class JackGame.JackSceneInRoomTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSceneInRoomTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSceneInRoomTrack">();
	}
	static class UJackSceneInRoomTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSceneInRoomTrack>();
	}
};
static_assert(alignof(UJackSceneInRoomTrack) == 0x000008, "Wrong alignment on UJackSceneInRoomTrack");
static_assert(sizeof(UJackSceneInRoomTrack) == 0x0000A8, "Wrong size on UJackSceneInRoomTrack");

// Class JackGame.JackSceneInRoomTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSceneInRoomTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSceneInRoomTrackInst">();
	}
	static class UJackSceneInRoomTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSceneInRoomTrackInst>();
	}
};
static_assert(alignof(UJackSceneInRoomTrackInst) == 0x000008, "Wrong alignment on UJackSceneInRoomTrackInst");
static_assert(sizeof(UJackSceneInRoomTrackInst) == 0x000040, "Wrong size on UJackSceneInRoomTrackInst");

// Class JackGame.JackScheduledNPC
// 0x32B0 (0x43C0 - 0x1110)
class AJackScheduledNPC : public AJackNPC
{
public:
	EJackNPCType                                  NPCType;                                           // 0x1110(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                CharacterType;                                     // 0x1111(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackPipipiType                               PipipiType;                                        // 0x1112(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1113[0x5];                                     // 0x1113(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ScheduleJumpFinishEventName;                       // 0x1118(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkStartEventName;                                // 0x1120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkSequenceEventName;                             // 0x1128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TalkEndEventName;                                  // 0x1130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceTalkStartEventName;                           // 0x1138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceTalkSequenceEventName;                        // 0x1140(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ForceTalkEndEventName;                             // 0x1148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExtraPropsIDList;                                  // 0x1150(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FJackSerifuAutomationFlags             SerifuAutomationFlags;                             // 0x1160(0x0005)(Edit, BlueprintVisible, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1165[0x3];                                     // 0x1165(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           DefaultAnimMontageAfterInterruptWait;              // 0x1168(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           AnimMontageTurnWhileTalking;                       // 0x1170(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimationAsset*                        SynchroAnimationWhileRiding;                       // 0x1178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackExtraNPCCapsuleComponent> ExtraNPCCapsuleComponentClass;                     // 0x1180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipFootIK_Distance;                 // 0x1188(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipFacial_Distance;                 // 0x118C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipAnimDynamics_Distance;           // 0x1190(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipLookAt_Distance;                 // 0x1194(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_PauseOwner_Distance;                 // 0x1198(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_HiddenOwner_Distance;                // 0x119C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipSkeletalMeshComponent_Distance;  // 0x11A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LoadReduction_SkipSkeletalMeshComponent_Velocity;  // 0x11A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UsingDitherDistance;                               // 0x11A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceAccelerationUp;                          // 0x11AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendSpaceAccelerationDown;                        // 0x11B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DefaultSpeed;                                      // 0x11B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumTrackSpeed;                                 // 0x11B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AfterInterruptPlayerLeaveDistance;                 // 0x11BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialHide;                                      // 0x11C0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bThinCapsuleRadiusEnable;                          // 0x11C1(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bGroundSlopeMatching;                              // 0x11C2(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSynchroAnimationWithProps;                        // 0x11C3(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverPlaySlotAnimation;                           // 0x11C4(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeverEnabledFootIK;                               // 0x11C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11C6[0x2];                                     // 0x11C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HazukasiiNoroiTalkRate;                            // 0x11C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11CC[0x4];                                     // 0x11CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackScheduledNPCMoveParameter> MoveParameterList;                                 // 0x11D0(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AJackScheduledNPC>       RidingCharacter;                                   // 0x11E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AJackScheduledNPC>       RodeCharacter;                                     // 0x11E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class AActor>                  GazeTriggerActor;                                  // 0x11F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_11F8[0x108];                                   // 0x11F8(0x0108)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UJackInteractiveActorComponent> InteractiveActorComponent;                         // 0x1300(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJackInteractorComponent> InteractorComponent;                               // 0x1308(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UJackPropsComponent>     PropsComponent;                                    // 0x1310(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackLoadReductionComponent*            LoadReductionComponent;                            // 0x1318(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1320[0x178];                                   // 0x1320(0x0178)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class UAnimMontage>            AfterInterruptTurnAnimation;                       // 0x1498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TWeakObjectPtr<class UAnimMontage>            AfterInterruptWaitAnimation;                       // 0x14A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_14A8[0x2F18];                                  // 0x14A8(0x2F18)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearSchedule();
	class UAnimMontage* CorrectTalkPlayAnimation(class FName MessageName, bool bOriginalPlayAnimation, class UAnimMontage* AnimMontage);
	void FinishTalkEndEvent();
	void FinishTalkSequenceEvent();
	void FinishTalkStartEvent();
	void ForciblyGrounded();
	void Latent_WaitForInitialize(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, bool bStartBPControl, bool bWaitOnGround);
	void Latent_WaitForTalk(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void LookAtEndSetting();
	void LookAtStartSetting();
	void MovableForciblyEvenIfNotGrounded();
	void OnInitializeProps();
	void OnReplaceNPCTalkEndAnimation(class UAnimMontage* AnimMontage, bool bForceSkipAnimation);
	void OverwriteMoveSpeed();
	void PlayAnimationByTypeInBPControl(const class FName& AnimationID, bool bCanSkipImmidiately);
	void PlayAnimationInBPControl(class UAnimMontage* AnimMontage, class UAnimMontage* AdditiveAnimMontage, float AdditiveRate, bool bCanSkipImmidiately);
	void ResumeSchedulePattern();
	void ScheduleEntry_Alight();
	void ScheduleEntry_Animation(class UAnimMontage* AnimMontage, class UAnimMontage* AdditiveAnimMontage, int32 Minute, int32 ScheduleControlIndex, int32 ScheduleControlCounter, class UAnimMontage* ScheduleChangeAnimMontage1, class UAnimMontage* ScheduleChangeAnimMontage1_Additive, class UAnimMontage* ScheduleChangeAnimMontage2, class UAnimMontage* ScheduleChangeAnimMontage2_Additive);
	void ScheduleEntry_AnimationStop(class UAnimMontage* AnimMontage);
	void ScheduleEntry_AttachObjectAnimation(class AActor* AttachObject, class UAnimMontage* AnimMontage, bool bStop);
	void ScheduleEntry_CallCustomEvent(class FName EventName);
	void ScheduleEntry_IncScheduleControlCounter(int32 Index_0);
	void ScheduleEntry_LookAtCharacter(class AJackCharacter* Character, class FName Socket, bool bSingleNode, float Distance, float Angle);
	void ScheduleEntry_LookAtEnd();
	void ScheduleEntry_LookAtLocation(const struct FVector& Location, bool bSingleNode, float Distance, float Angle);
	void ScheduleEntry_LoopTop();
	void ScheduleEntry_MoveToActor(class AActor* Goal, float Speed, class UAnimMontage* AnimMontage);
	void ScheduleEntry_MoveToComponent(class UPrimitiveComponent* Goal, float Speed, class UAnimMontage* AnimMontage);
	void ScheduleEntry_MoveToLocation(const struct FVector& Goal, float Speed, class UAnimMontage* AnimMontage);
	void ScheduleEntry_NearActorAction(class AActor* CheckActor, float DistanceThreshold, float ResetDistance, int32 PatternID, bool bUsingStack, class FName EventName);
	void ScheduleEntry_ReleaseSynchroNPC(class AJackScheduledNPC* SynchroNPC);
	void ScheduleEntry_ResumeSchedulePattern();
	void ScheduleEntry_Ride(class AJackScheduledNPC* RideCharacter, class FName RideSocketName);
	void ScheduleEntry_SetAttachObject(class AActor* AttachObject, class FName SocketName, bool bAttachImmediately);
	void ScheduleEntry_SetBlendSpaceNo(int32 BlendSpaceNo);
	void ScheduleEntry_SetInterruptMode(bool bAcceptTalk, bool bAcceptPlayerAvoid, bool bAcceptEscapeFastMoving);
	void ScheduleEntry_SetMonologueInfo(const class FString& FukidasiID, bool bOnceOnly);
	void ScheduleEntry_SetScheduleControlCounter(int32 Index_0, int32 Counter);
	void ScheduleEntry_SetSynchroNPC(class AJackScheduledNPC* SynchroNPC, float FormationAngle, float FormationDistance);
	void ScheduleEntry_SetTalkParameter(class FName FrontMessageName, class FName BehindMessageName, EJackNPCTalkGazeMode GazeMode, class UAnimMontage* StartAnimMontage, class UAnimMontage* EndAnimMontage, class UAnimMontage* EndWaitAnimMontage, bool bPlayAnimation, bool bUseCommonTalkCamera, bool bDisableTalkSoonAfterTalk, class FName StartEventName, class FName SequenceEventName, class FName EndEventName);
	void ScheduleEntry_SynchroNPCAnimation(class AJackScheduledNPC* SynchroNPC, class UAnimMontage* AnimMontage, bool bStop, bool bWait);
	void ScheduleEntry_SynchroNPCTurnToActor(class AJackScheduledNPC* SynchroNPC, class AActor* Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage, bool bWait);
	void ScheduleEntry_Teleport(const struct FVector& Location, float Angle);
	void ScheduleEntry_TrackToActor(class AActor* Actor, int32 DurationMinute, int32 ScheduleControlIndex, int32 ScheduleControlCounter);
	void ScheduleEntry_TurnToActor(class AActor* Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void ScheduleEntry_TurnToAngle(float Angle, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void ScheduleEntry_TurnToComponent(class UPrimitiveComponent* Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void ScheduleEntry_TurnToLocation(const struct FVector& Gaze, float Speed, float Allowance, class UAnimMontage* AnimMontage);
	void ScheduleEntry_WaitScheduleControlCounter(int32 Index_0, int32 Counter);
	void ScheduleEntry_WaitSynchroNPC(class AJackScheduledNPC* SynchroNPC);
	void ScheduleEntry_WanderAround(class AActor* Center, float Radius, float Speed, int32 MinWaitMinute, int32 MaxWaitMinute, int32 DurationMinute, int32 ScheduleControlIndex, int32 ScheduleControlCounter);
	void ScheduleEntryStart(int32 StartHour, int32 StartMinute, int32 EndHour, int32 EndMinute, int32 Pattern, bool bLoop, bool bDisappear, bool bDoNotSkipTickAtLoadReduction, bool bIgnoreCollision, bool bDoNotSkipTickAtLoadReductionDoSkip);
	void SetBlendSpaceAcceleration(float AccelerationUp, float AccelerationDown);
	void SetCampInitialize();
	void SetExecuteNextScheduleBeforeMovingComplete(bool bMode);
	void SetForceAfterInterruptPlayerLeaveDistance(float Distance);
	void SetForceFixedLocation(bool bFlag, bool bCollisionCheck);
	void SetImportance(EJackNPCImportance NowImportance);
	void SetInterruptAccept(bool bTalk, bool bPlayerAvoid, bool bEscapeFastMoving, bool bReactionAroundPlayer, bool bStopAtPlayerForTalk);
	void SetLoadReduction_HiddenOwner_Distance(float Distance);
	void SetLoadReduction_SkipFootIK_Distance(float Distance);
	void SetLoadReduction_SkipLookAt_Distance(float Distance);
	void SetReactionExternalTrigger(EJackNPCReactionExternalTrigger Trigger);
	void SetSchedulePattern(int32 NextPatternID, bool bUsingStack);
	void SetupPartyTalkVoice(const struct FJackPartyTalkDescription& InDescription);
	void SetupPartyTalkVoiceTag(EJackCharacter InVoiceCharacter, class FName InTextId);
	void StartTalk(class AActor* SayActor, bool bOverrideTalkParameter, const struct FJackTalkParameter& OverrideTalkParameter);
	void StartTalkEx(class AActor* SayActor, bool bOverrideTalkParameter, const struct FJackTalkParameter& OverrideTalkParameter, const TArray<struct FJackMessageArgumentData>& OverrideTagValueList);
	void TalkTurnSetting(EJackNPCTalkGazeMode GazeMode, class AJackCharacter* Gaze);
	void TurnToActorInBPControl(class AActor* Gaze, class UAnimMontage* AnimMontage, float Speed, bool bAnimationStop);

	EJackNPCTalkGazeMode CorrectTalkGazeMode(class FName MessageName, bool bTalkBehind) const;
	float GetBlendSpaceRate(int32 Index_0) const;
	float GetBlendSpaceSpeed() const;
	EJackNPCImportance GetImportance() const;
	float GetMaxSpeed(int32 BlendSpaceIndex) const;
	int32 GetSchedulePattern() const;
	const TArray<struct FJackMessageArgumentData> GetTagValueList() const;
	EJackNPCTalkMode GetTalkMode() const;
	struct FJackTalkParameter GetTalkParameter(bool bCorrectGazeMode) const;
	bool IsCompletedSchedule() const;
	bool IsDoNotCloseFukidasi() const;
	bool IsFirstGrounded() const;
	bool IsFocusedByPlayer() const;
	bool IsInitialized() const;
	bool IsInterruptAccept(EJackNPCInterruptAccept AcceptFlag) const;
	bool IsInterruptMode() const;
	bool IsValidMonologue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackScheduledNPC">();
	}
	static class AJackScheduledNPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackScheduledNPC>();
	}
};
static_assert(alignof(AJackScheduledNPC) == 0x000010, "Wrong alignment on AJackScheduledNPC");
static_assert(sizeof(AJackScheduledNPC) == 0x0043C0, "Wrong size on AJackScheduledNPC");
static_assert(offsetof(AJackScheduledNPC, NPCType) == 0x001110, "Member 'AJackScheduledNPC::NPCType' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, CharacterType) == 0x001111, "Member 'AJackScheduledNPC::CharacterType' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, PipipiType) == 0x001112, "Member 'AJackScheduledNPC::PipipiType' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ScheduleJumpFinishEventName) == 0x001118, "Member 'AJackScheduledNPC::ScheduleJumpFinishEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, TalkStartEventName) == 0x001120, "Member 'AJackScheduledNPC::TalkStartEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, TalkSequenceEventName) == 0x001128, "Member 'AJackScheduledNPC::TalkSequenceEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, TalkEndEventName) == 0x001130, "Member 'AJackScheduledNPC::TalkEndEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ForceTalkStartEventName) == 0x001138, "Member 'AJackScheduledNPC::ForceTalkStartEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ForceTalkSequenceEventName) == 0x001140, "Member 'AJackScheduledNPC::ForceTalkSequenceEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ForceTalkEndEventName) == 0x001148, "Member 'AJackScheduledNPC::ForceTalkEndEventName' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ExtraPropsIDList) == 0x001150, "Member 'AJackScheduledNPC::ExtraPropsIDList' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, SerifuAutomationFlags) == 0x001160, "Member 'AJackScheduledNPC::SerifuAutomationFlags' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, DefaultAnimMontageAfterInterruptWait) == 0x001168, "Member 'AJackScheduledNPC::DefaultAnimMontageAfterInterruptWait' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, AnimMontageTurnWhileTalking) == 0x001170, "Member 'AJackScheduledNPC::AnimMontageTurnWhileTalking' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, SynchroAnimationWhileRiding) == 0x001178, "Member 'AJackScheduledNPC::SynchroAnimationWhileRiding' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, ExtraNPCCapsuleComponentClass) == 0x001180, "Member 'AJackScheduledNPC::ExtraNPCCapsuleComponentClass' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipFootIK_Distance) == 0x001188, "Member 'AJackScheduledNPC::LoadReduction_SkipFootIK_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipFacial_Distance) == 0x00118C, "Member 'AJackScheduledNPC::LoadReduction_SkipFacial_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipAnimDynamics_Distance) == 0x001190, "Member 'AJackScheduledNPC::LoadReduction_SkipAnimDynamics_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipLookAt_Distance) == 0x001194, "Member 'AJackScheduledNPC::LoadReduction_SkipLookAt_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_PauseOwner_Distance) == 0x001198, "Member 'AJackScheduledNPC::LoadReduction_PauseOwner_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_HiddenOwner_Distance) == 0x00119C, "Member 'AJackScheduledNPC::LoadReduction_HiddenOwner_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipSkeletalMeshComponent_Distance) == 0x0011A0, "Member 'AJackScheduledNPC::LoadReduction_SkipSkeletalMeshComponent_Distance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReduction_SkipSkeletalMeshComponent_Velocity) == 0x0011A4, "Member 'AJackScheduledNPC::LoadReduction_SkipSkeletalMeshComponent_Velocity' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, UsingDitherDistance) == 0x0011A8, "Member 'AJackScheduledNPC::UsingDitherDistance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, BlendSpaceAccelerationUp) == 0x0011AC, "Member 'AJackScheduledNPC::BlendSpaceAccelerationUp' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, BlendSpaceAccelerationDown) == 0x0011B0, "Member 'AJackScheduledNPC::BlendSpaceAccelerationDown' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, DefaultSpeed) == 0x0011B4, "Member 'AJackScheduledNPC::DefaultSpeed' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, MinimumTrackSpeed) == 0x0011B8, "Member 'AJackScheduledNPC::MinimumTrackSpeed' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, AfterInterruptPlayerLeaveDistance) == 0x0011BC, "Member 'AJackScheduledNPC::AfterInterruptPlayerLeaveDistance' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bInitialHide) == 0x0011C0, "Member 'AJackScheduledNPC::bInitialHide' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bThinCapsuleRadiusEnable) == 0x0011C1, "Member 'AJackScheduledNPC::bThinCapsuleRadiusEnable' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bGroundSlopeMatching) == 0x0011C2, "Member 'AJackScheduledNPC::bGroundSlopeMatching' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bSynchroAnimationWithProps) == 0x0011C3, "Member 'AJackScheduledNPC::bSynchroAnimationWithProps' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bNeverPlaySlotAnimation) == 0x0011C4, "Member 'AJackScheduledNPC::bNeverPlaySlotAnimation' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, bNeverEnabledFootIK) == 0x0011C5, "Member 'AJackScheduledNPC::bNeverEnabledFootIK' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, HazukasiiNoroiTalkRate) == 0x0011C8, "Member 'AJackScheduledNPC::HazukasiiNoroiTalkRate' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, MoveParameterList) == 0x0011D0, "Member 'AJackScheduledNPC::MoveParameterList' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, RidingCharacter) == 0x0011E0, "Member 'AJackScheduledNPC::RidingCharacter' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, RodeCharacter) == 0x0011E8, "Member 'AJackScheduledNPC::RodeCharacter' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, GazeTriggerActor) == 0x0011F0, "Member 'AJackScheduledNPC::GazeTriggerActor' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, InteractiveActorComponent) == 0x001300, "Member 'AJackScheduledNPC::InteractiveActorComponent' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, InteractorComponent) == 0x001308, "Member 'AJackScheduledNPC::InteractorComponent' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, PropsComponent) == 0x001310, "Member 'AJackScheduledNPC::PropsComponent' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, LoadReductionComponent) == 0x001318, "Member 'AJackScheduledNPC::LoadReductionComponent' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, AfterInterruptTurnAnimation) == 0x001498, "Member 'AJackScheduledNPC::AfterInterruptTurnAnimation' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPC, AfterInterruptWaitAnimation) == 0x0014A0, "Member 'AJackScheduledNPC::AfterInterruptWaitAnimation' has a wrong offset!");

// Class JackGame.JackScheduledNPCManager
// 0x0320 (0x06B8 - 0x0398)
class AJackScheduledNPCManager : public AActor
{
public:
	class UDataTable*                             ReactionTable;                                     // 0x0398(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             ReactionAnimationTable;                            // 0x03A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             InterruptControlTable;                             // 0x03A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             UsoTalkTable;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackHazukasiiNoroiTalk>        HazukasiiNoroiTalkParams;                          // 0x03B8(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   CompleteActionInBPControl;                         // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D8[0x210];                                    // 0x03D8(0x0210)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<int32, struct FJackScheduledNPCAppendObjectInfo> AppendObjectInfoList;                              // 0x05E8(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_638[0x80];                                     // 0x0638(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CompleteActionInBPControl__DelegateSignature(const class AJackScheduledNPC* NPC, EJackNPCActionTypeInBPControl ActionType);
	struct FJackHazukasiiNoroiTalkParam HazukasiiNoroiTalkCheck(class AJackScheduledNPC* NPC);
	struct FJackHazukasiiNoroiTalkParam HazukasiiNoroiTalkCheckByRate(int32 InRate);
	void RequestAsyncLoadAppendObjectCallback(const TArray<struct FSoftObjectPath>& TargetsToStream, const TArray<class UObject*>& LoadedObjects, int32 UniqueNumber);
	class FName UsoWoTsukuTalkCheck(class AJackScheduledNPC* NPC);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackScheduledNPCManager">();
	}
	static class AJackScheduledNPCManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackScheduledNPCManager>();
	}
};
static_assert(alignof(AJackScheduledNPCManager) == 0x000008, "Wrong alignment on AJackScheduledNPCManager");
static_assert(sizeof(AJackScheduledNPCManager) == 0x0006B8, "Wrong size on AJackScheduledNPCManager");
static_assert(offsetof(AJackScheduledNPCManager, ReactionTable) == 0x000398, "Member 'AJackScheduledNPCManager::ReactionTable' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, ReactionAnimationTable) == 0x0003A0, "Member 'AJackScheduledNPCManager::ReactionAnimationTable' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, InterruptControlTable) == 0x0003A8, "Member 'AJackScheduledNPCManager::InterruptControlTable' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, UsoTalkTable) == 0x0003B0, "Member 'AJackScheduledNPCManager::UsoTalkTable' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, HazukasiiNoroiTalkParams) == 0x0003B8, "Member 'AJackScheduledNPCManager::HazukasiiNoroiTalkParams' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, CompleteActionInBPControl) == 0x0003C8, "Member 'AJackScheduledNPCManager::CompleteActionInBPControl' has a wrong offset!");
static_assert(offsetof(AJackScheduledNPCManager, AppendObjectInfoList) == 0x0005E8, "Member 'AJackScheduledNPCManager::AppendObjectInfoList' has a wrong offset!");

// Class JackGame.JackSeparateTranslucencyTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSeparateTranslucencyTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSeparateTranslucencyTrack">();
	}
	static class UJackSeparateTranslucencyTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSeparateTranslucencyTrack>();
	}
};
static_assert(alignof(UJackSeparateTranslucencyTrack) == 0x000008, "Wrong alignment on UJackSeparateTranslucencyTrack");
static_assert(sizeof(UJackSeparateTranslucencyTrack) == 0x0000A8, "Wrong size on UJackSeparateTranslucencyTrack");

// Class JackGame.JackSerifuInputDisableTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSerifuInputDisableTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSerifuInputDisableTrack">();
	}
	static class UJackSerifuInputDisableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSerifuInputDisableTrack>();
	}
};
static_assert(alignof(UJackSerifuInputDisableTrack) == 0x000008, "Wrong alignment on UJackSerifuInputDisableTrack");
static_assert(sizeof(UJackSerifuInputDisableTrack) == 0x0000A8, "Wrong size on UJackSerifuInputDisableTrack");

// Class JackGame.JackSerifuInputDisableTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSerifuInputDisableTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSerifuInputDisableTrackInst">();
	}
	static class UJackSerifuInputDisableTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSerifuInputDisableTrackInst>();
	}
};
static_assert(alignof(UJackSerifuInputDisableTrackInst) == 0x000008, "Wrong alignment on UJackSerifuInputDisableTrackInst");
static_assert(sizeof(UJackSerifuInputDisableTrackInst) == 0x000040, "Wrong size on UJackSerifuInputDisableTrackInst");

// Class JackGame.JackSetBlinkEnableTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSetBlinkEnableTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetBlinkEnableTrack">();
	}
	static class UJackSetBlinkEnableTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetBlinkEnableTrack>();
	}
};
static_assert(alignof(UJackSetBlinkEnableTrack) == 0x000008, "Wrong alignment on UJackSetBlinkEnableTrack");
static_assert(sizeof(UJackSetBlinkEnableTrack) == 0x0000A8, "Wrong size on UJackSetBlinkEnableTrack");

// Class JackGame.JackSetEmotionTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackSetEmotionTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetEmotionTrack">();
	}
	static class UJackSetEmotionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetEmotionTrack>();
	}
};
static_assert(alignof(UJackSetEmotionTrack) == 0x000008, "Wrong alignment on UJackSetEmotionTrack");
static_assert(sizeof(UJackSetEmotionTrack) == 0x0000B0, "Wrong size on UJackSetEmotionTrack");

// Class JackGame.JackSetEmotionTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSetEmotionTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetEmotionTrackInst">();
	}
	static class UJackSetEmotionTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetEmotionTrackInst>();
	}
};
static_assert(alignof(UJackSetEmotionTrackInst) == 0x000008, "Wrong alignment on UJackSetEmotionTrackInst");
static_assert(sizeof(UJackSetEmotionTrackInst) == 0x000040, "Wrong size on UJackSetEmotionTrackInst");

// Class JackGame.JackSetLowerFacePoseTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackSetLowerFacePoseTrack final : public UInterpTrack
{
public:
	class UDataTable*                             FaceNameTable;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackSetLowerFacePoseKeyValue>  KeyArray;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetLowerFacePoseTrack">();
	}
	static class UJackSetLowerFacePoseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetLowerFacePoseTrack>();
	}
};
static_assert(alignof(UJackSetLowerFacePoseTrack) == 0x000008, "Wrong alignment on UJackSetLowerFacePoseTrack");
static_assert(sizeof(UJackSetLowerFacePoseTrack) == 0x0000A8, "Wrong size on UJackSetLowerFacePoseTrack");
static_assert(offsetof(UJackSetLowerFacePoseTrack, FaceNameTable) == 0x000090, "Member 'UJackSetLowerFacePoseTrack::FaceNameTable' has a wrong offset!");
static_assert(offsetof(UJackSetLowerFacePoseTrack, KeyArray) == 0x000098, "Member 'UJackSetLowerFacePoseTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackSetToneTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackSetToneTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetToneTrack">();
	}
	static class UJackSetToneTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetToneTrack>();
	}
};
static_assert(alignof(UJackSetToneTrack) == 0x000008, "Wrong alignment on UJackSetToneTrack");
static_assert(sizeof(UJackSetToneTrack) == 0x0000B0, "Wrong size on UJackSetToneTrack");

// Class JackGame.JackSetToneTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSetToneTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetToneTrackInst">();
	}
	static class UJackSetToneTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetToneTrackInst>();
	}
};
static_assert(alignof(UJackSetToneTrackInst) == 0x000008, "Wrong alignment on UJackSetToneTrackInst");
static_assert(sizeof(UJackSetToneTrackInst) == 0x000040, "Wrong size on UJackSetToneTrackInst");

// Class JackGame.JackSetUpperFacePoseTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackSetUpperFacePoseTrack final : public UInterpTrack
{
public:
	class UDataTable*                             FaceNameTable;                                     // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackSetUpperFacePoseKeyValue>  KeyArray;                                          // 0x0098(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetUpperFacePoseTrack">();
	}
	static class UJackSetUpperFacePoseTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetUpperFacePoseTrack>();
	}
};
static_assert(alignof(UJackSetUpperFacePoseTrack) == 0x000008, "Wrong alignment on UJackSetUpperFacePoseTrack");
static_assert(sizeof(UJackSetUpperFacePoseTrack) == 0x0000A8, "Wrong size on UJackSetUpperFacePoseTrack");
static_assert(offsetof(UJackSetUpperFacePoseTrack, FaceNameTable) == 0x000090, "Member 'UJackSetUpperFacePoseTrack::FaceNameTable' has a wrong offset!");
static_assert(offsetof(UJackSetUpperFacePoseTrack, KeyArray) == 0x000098, "Member 'UJackSetUpperFacePoseTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackSetWorldTimeTrack
// 0x0010 (0x00C0 - 0x00B0)
class UJackSetWorldTimeTrack final : public UInterpTrackFloatBase
{
public:
	TArray<struct FJackSetWorldTimeTrackInfo>     TimeInfos;                                         // 0x00B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetWorldTimeTrack">();
	}
	static class UJackSetWorldTimeTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetWorldTimeTrack>();
	}
};
static_assert(alignof(UJackSetWorldTimeTrack) == 0x000008, "Wrong alignment on UJackSetWorldTimeTrack");
static_assert(sizeof(UJackSetWorldTimeTrack) == 0x0000C0, "Wrong size on UJackSetWorldTimeTrack");
static_assert(offsetof(UJackSetWorldTimeTrack, TimeInfos) == 0x0000B0, "Member 'UJackSetWorldTimeTrack::TimeInfos' has a wrong offset!");

// Class JackGame.JackSetWorldTimeTrackInst
// 0x0018 (0x0050 - 0x0038)
class UJackSetWorldTimeTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSetWorldTimeTrackInst">();
	}
	static class UJackSetWorldTimeTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSetWorldTimeTrackInst>();
	}
};
static_assert(alignof(UJackSetWorldTimeTrackInst) == 0x000008, "Wrong alignment on UJackSetWorldTimeTrackInst");
static_assert(sizeof(UJackSetWorldTimeTrackInst) == 0x000050, "Wrong size on UJackSetWorldTimeTrackInst");

// Class JackGame.JackShadowRadiusThresholdTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackShadowRadiusThresholdTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackShadowRadiusThresholdTrackInst">();
	}
	static class UJackShadowRadiusThresholdTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackShadowRadiusThresholdTrackInst>();
	}
};
static_assert(alignof(UJackShadowRadiusThresholdTrackInst) == 0x000008, "Wrong alignment on UJackShadowRadiusThresholdTrackInst");
static_assert(sizeof(UJackShadowRadiusThresholdTrackInst) == 0x000040, "Wrong size on UJackShadowRadiusThresholdTrackInst");

// Class JackGame.JackShadowTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackShadowTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackShadowTrack">();
	}
	static class UJackShadowTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackShadowTrack>();
	}
};
static_assert(alignof(UJackShadowTrack) == 0x000008, "Wrong alignment on UJackShadowTrack");
static_assert(sizeof(UJackShadowTrack) == 0x0000A8, "Wrong size on UJackShadowTrack");

// Class JackGame.JackShareManager
// 0x00A8 (0x00E0 - 0x0038)
class UJackShareManager final : public UObject
{
public:
	uint8                                         Pad_38[0xA8];                                      // 0x0038(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackShareManager">();
	}
	static class UJackShareManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackShareManager>();
	}
};
static_assert(alignof(UJackShareManager) == 0x000008, "Wrong alignment on UJackShareManager");
static_assert(sizeof(UJackShareManager) == 0x0000E0, "Wrong size on UJackShareManager");

// Class JackGame.JackSkipAnimationIntervalTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackSkipAnimationIntervalTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipAnimationIntervalTrack">();
	}
	static class UJackSkipAnimationIntervalTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipAnimationIntervalTrack>();
	}
};
static_assert(alignof(UJackSkipAnimationIntervalTrack) == 0x000008, "Wrong alignment on UJackSkipAnimationIntervalTrack");
static_assert(sizeof(UJackSkipAnimationIntervalTrack) == 0x0000B0, "Wrong size on UJackSkipAnimationIntervalTrack");

// Class JackGame.JackSkipAnimationIntervalTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackSkipAnimationIntervalTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipAnimationIntervalTrackInst">();
	}
	static class UJackSkipAnimationIntervalTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipAnimationIntervalTrackInst>();
	}
};
static_assert(alignof(UJackSkipAnimationIntervalTrackInst) == 0x000008, "Wrong alignment on UJackSkipAnimationIntervalTrackInst");
static_assert(sizeof(UJackSkipAnimationIntervalTrackInst) == 0x000038, "Wrong size on UJackSkipAnimationIntervalTrackInst");

// Class JackGame.JackSkipTimelineTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackSkipTimelineTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipTimelineTrack">();
	}
	static class UJackSkipTimelineTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipTimelineTrack>();
	}
};
static_assert(alignof(UJackSkipTimelineTrack) == 0x000008, "Wrong alignment on UJackSkipTimelineTrack");
static_assert(sizeof(UJackSkipTimelineTrack) == 0x0000A8, "Wrong size on UJackSkipTimelineTrack");

// Class JackGame.JackUMGSerifuWindowResources
// 0x0010 (0x0048 - 0x0038)
class UJackUMGSerifuWindowResources : public UObject
{
public:
	TArray<struct FJackUMGSerifuWindowEmojiData>  EmojiDataArray;                                    // 0x0038(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSerifuWindowResources">();
	}
	static class UJackUMGSerifuWindowResources* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSerifuWindowResources>();
	}
};
static_assert(alignof(UJackUMGSerifuWindowResources) == 0x000008, "Wrong alignment on UJackUMGSerifuWindowResources");
static_assert(sizeof(UJackUMGSerifuWindowResources) == 0x000048, "Wrong size on UJackUMGSerifuWindowResources");
static_assert(offsetof(UJackUMGSerifuWindowResources, EmojiDataArray) == 0x000038, "Member 'UJackUMGSerifuWindowResources::EmojiDataArray' has a wrong offset!");

// Class JackGame.JackSkipTimelineTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSkipTimelineTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSkipTimelineTrackInst">();
	}
	static class UJackSkipTimelineTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSkipTimelineTrackInst>();
	}
};
static_assert(alignof(UJackSkipTimelineTrackInst) == 0x000008, "Wrong alignment on UJackSkipTimelineTrackInst");
static_assert(sizeof(UJackSkipTimelineTrackInst) == 0x000040, "Wrong size on UJackSkipTimelineTrackInst");

// Class JackGame.JackSoftBodyComponent
// 0x0110 (0x02B0 - 0x01A0)
class UJackSoftBodyComponent final : public UJackCharacterComponent
{
public:
	class UMaterialInterface*                     OutlineMaterial;                                   // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ClothBlendWeight;                                  // 0x01A8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1AC[0xD4];                                     // 0x01AC(0x00D4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ClothBlendModeChangeSpeed;                         // 0x0280(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_284[0x4];                                      // 0x0284(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USkeletalMeshComponent*>         ClothMeshes;                                       // 0x0288(0x0010)(ExportObject, ZeroConstructor, Transient, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	uint8                                         Pad_298[0x18];                                     // 0x0298(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyClothBlendWeightMultiplier();
	void CallOnPredictedLODLevelChanged(class USkinnedMeshComponent* SkinndMeshComponent, int32 NewLODLevel, int32 MaxLODLevel);
	void EvaluateClothMeshesAssignment(const TArray<class USkeletalMeshComponent*>& SkeletalMeshComponents);
	void OnPredictedLODLevelChanged(class USkinnedMeshComponent* SkinndMeshComponent, int32 NewLODLevel, int32 MaxLODLevel);
	void SetClothBlendWeightMultiplier(EJackSoftBodyControlPurpose Purpose, float Multiplier);

	float GetClothBlendWeightMultiplier(EJackSoftBodyControlPurpose Purpose) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoftBodyComponent">();
	}
	static class UJackSoftBodyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoftBodyComponent>();
	}
};
static_assert(alignof(UJackSoftBodyComponent) == 0x000008, "Wrong alignment on UJackSoftBodyComponent");
static_assert(sizeof(UJackSoftBodyComponent) == 0x0002B0, "Wrong size on UJackSoftBodyComponent");
static_assert(offsetof(UJackSoftBodyComponent, OutlineMaterial) == 0x0001A0, "Member 'UJackSoftBodyComponent::OutlineMaterial' has a wrong offset!");
static_assert(offsetof(UJackSoftBodyComponent, ClothBlendWeight) == 0x0001A8, "Member 'UJackSoftBodyComponent::ClothBlendWeight' has a wrong offset!");
static_assert(offsetof(UJackSoftBodyComponent, ClothBlendModeChangeSpeed) == 0x000280, "Member 'UJackSoftBodyComponent::ClothBlendModeChangeSpeed' has a wrong offset!");
static_assert(offsetof(UJackSoftBodyComponent, ClothMeshes) == 0x000288, "Member 'UJackSoftBodyComponent::ClothMeshes' has a wrong offset!");

// Class JackGame.JackSoundManager
// 0x0090 (0x00C8 - 0x0038)
class UJackSoundManager : public UObject
{
public:
	UMulticastDelegateProperty_                   SoundChangeWeatherDelegate;                        // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bAllowChangeBGM;                                   // 0x0050(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_51[0xF];                                       // 0x0051(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackSoundContext*>              SoundList;                                         // 0x0060(0x0010)(ZeroConstructor, Transient, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_70[0x28];                                      // 0x0070(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceMuteMusic;                                   // 0x0098(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackSoundRainFootstepAssets           RainFootstepAssets;                                // 0x00A0(0x0028)(Transient, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	void EnableAnimNotifyFootstep(bool bIsEnable);
	void EnableRainFootstepSound(bool IsRainFootstepSound);
	void FadeOutAllSounds(float FadeOutTime, bool bFadeOutBGM);
	bool IsValidEnvSoundByMapId(const class FName& InMapId, bool bInNightTime, EJackWorldWeather InWeatherType, EJackWorldWindLevel InWindLevelType);
	void JackSoundChangeWeatherDelegate__DelegateSignature(bool InEventTag, EJackWorldWeather InWeatherType, EJackWorldWindLevel InWindLevelType);
	void PlaySEFromSound(class USoundBase* InSoundBase);
	void SetBattleFieldCategoryVolume(float InVolume, bool bIsSetCategory);
	void SetChangeBGMAllowed(bool IsChangeBGM);
	void SetCutSceneCategoryVolume(float InVolume, float InFadeTime);
	void SetDokodemoKaziCategoryVolume(float InVolume, float InFadeTime);
	void SetFieldSoundVolume(float Volume, float FadeTime);
	void SetInGameCutSceneCategoryVolume(float InVolume, float InFadeTime);
	void SetInGameSoundVolume(float InVolume, float InFadeTime, bool bIsWithVoice);
	void SetRain(bool IsRain);
	void SetRainFootstepSound(const struct FJackSoundRainFootstepAssets& InRainFootstepAssets);
	void SetVoiceSoundVolume(float InVolume, float InFadeTime);
	void StopAllSounds(float FadeOutTime);
	void StopEnvSound(float InDuration);
	void StopInGameSound(float InFadeTime);

	bool IsEnableAnimNotifyFootstep() const;
	bool IsIdle() const;
	bool IsPlayEnvSound() const;
	bool IsRain() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoundManager">();
	}
	static class UJackSoundManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoundManager>();
	}
};
static_assert(alignof(UJackSoundManager) == 0x000008, "Wrong alignment on UJackSoundManager");
static_assert(sizeof(UJackSoundManager) == 0x0000C8, "Wrong size on UJackSoundManager");
static_assert(offsetof(UJackSoundManager, SoundChangeWeatherDelegate) == 0x000038, "Member 'UJackSoundManager::SoundChangeWeatherDelegate' has a wrong offset!");
static_assert(offsetof(UJackSoundManager, bAllowChangeBGM) == 0x000050, "Member 'UJackSoundManager::bAllowChangeBGM' has a wrong offset!");
static_assert(offsetof(UJackSoundManager, SoundList) == 0x000060, "Member 'UJackSoundManager::SoundList' has a wrong offset!");
static_assert(offsetof(UJackSoundManager, bForceMuteMusic) == 0x000098, "Member 'UJackSoundManager::bForceMuteMusic' has a wrong offset!");
static_assert(offsetof(UJackSoundManager, RainFootstepAssets) == 0x0000A0, "Member 'UJackSoundManager::RainFootstepAssets' has a wrong offset!");

// Class JackGame.JackUMGSyuurenjou004Base
// 0x0000 (0x0370 - 0x0370)
class UJackUMGSyuurenjou004Base : public UJackUMGWidgetBase
{
public:
	void SetSyuurenjouData(const struct FJackDataTableSyuurenjou& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSyuurenjou004Base">();
	}
	static class UJackUMGSyuurenjou004Base* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSyuurenjou004Base>();
	}
};
static_assert(alignof(UJackUMGSyuurenjou004Base) == 0x000008, "Wrong alignment on UJackUMGSyuurenjou004Base");
static_assert(sizeof(UJackUMGSyuurenjou004Base) == 0x000370, "Wrong size on UJackUMGSyuurenjou004Base");

// Class JackGame.JackSoundMiscControlTrack
// 0x0010 (0x00A0 - 0x0090)
class UJackSoundMiscControlTrack final : public UInterpTrack
{
public:
	TArray<struct FJackSoundMiscControlTrackKey>  KeyArray;                                          // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSoundMiscControlTrack">();
	}
	static class UJackSoundMiscControlTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSoundMiscControlTrack>();
	}
};
static_assert(alignof(UJackSoundMiscControlTrack) == 0x000008, "Wrong alignment on UJackSoundMiscControlTrack");
static_assert(sizeof(UJackSoundMiscControlTrack) == 0x0000A0, "Wrong size on UJackSoundMiscControlTrack");
static_assert(offsetof(UJackSoundMiscControlTrack, KeyArray) == 0x000090, "Member 'UJackSoundMiscControlTrack::KeyArray' has a wrong offset!");

// Class JackGame.JackSphereComponent
// 0x0020 (0x0780 - 0x0760)
class UJackSphereComponent final : public USphereComponent
{
public:
	class FString                                 AutoAttachComponentName;                           // 0x0758(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   AutoAttachSocketName;                              // 0x0768(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EAttachLocation                               AutoAttachType;                                    // 0x0770(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_771[0xF];                                      // 0x0771(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSphereComponent">();
	}
	static class UJackSphereComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSphereComponent>();
	}
};
static_assert(alignof(UJackSphereComponent) == 0x000010, "Wrong alignment on UJackSphereComponent");
static_assert(sizeof(UJackSphereComponent) == 0x000780, "Wrong size on UJackSphereComponent");
static_assert(offsetof(UJackSphereComponent, AutoAttachComponentName) == 0x000758, "Member 'UJackSphereComponent::AutoAttachComponentName' has a wrong offset!");
static_assert(offsetof(UJackSphereComponent, AutoAttachSocketName) == 0x000768, "Member 'UJackSphereComponent::AutoAttachSocketName' has a wrong offset!");
static_assert(offsetof(UJackSphereComponent, AutoAttachType) == 0x000770, "Member 'UJackSphereComponent::AutoAttachType' has a wrong offset!");

// Class JackGame.JackSplinePathCameraData
// 0x0020 (0x0060 - 0x0040)
class UJackSplinePathCameraData : public UJackCameraData
{
public:
	struct FRotator                               MoveAngleMin;                                      // 0x0040(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               MoveAngleMax;                                      // 0x004C(0x000C)(Edit, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         CenteringLerpSpeed;                                // 0x0058(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSplinePathCameraData">();
	}
	static class UJackSplinePathCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSplinePathCameraData>();
	}
};
static_assert(alignof(UJackSplinePathCameraData) == 0x000008, "Wrong alignment on UJackSplinePathCameraData");
static_assert(sizeof(UJackSplinePathCameraData) == 0x000060, "Wrong size on UJackSplinePathCameraData");
static_assert(offsetof(UJackSplinePathCameraData, MoveAngleMin) == 0x000040, "Member 'UJackSplinePathCameraData::MoveAngleMin' has a wrong offset!");
static_assert(offsetof(UJackSplinePathCameraData, MoveAngleMax) == 0x00004C, "Member 'UJackSplinePathCameraData::MoveAngleMax' has a wrong offset!");
static_assert(offsetof(UJackSplinePathCameraData, CenteringLerpSpeed) == 0x000058, "Member 'UJackSplinePathCameraData::CenteringLerpSpeed' has a wrong offset!");

// Class JackGame.JackSpotLightInnerConeAngleTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackSpotLightInnerConeAngleTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSpotLightInnerConeAngleTrack">();
	}
	static class UJackSpotLightInnerConeAngleTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSpotLightInnerConeAngleTrack>();
	}
};
static_assert(alignof(UJackSpotLightInnerConeAngleTrack) == 0x000008, "Wrong alignment on UJackSpotLightInnerConeAngleTrack");
static_assert(sizeof(UJackSpotLightInnerConeAngleTrack) == 0x0000B0, "Wrong size on UJackSpotLightInnerConeAngleTrack");

// Class JackGame.JackSpotLightOuterConeAngleTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackSpotLightOuterConeAngleTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSpotLightOuterConeAngleTrack">();
	}
	static class UJackSpotLightOuterConeAngleTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSpotLightOuterConeAngleTrack>();
	}
};
static_assert(alignof(UJackSpotLightOuterConeAngleTrack) == 0x000008, "Wrong alignment on UJackSpotLightOuterConeAngleTrack");
static_assert(sizeof(UJackSpotLightOuterConeAngleTrack) == 0x0000B0, "Wrong size on UJackSpotLightOuterConeAngleTrack");

// Class JackGame.JackSpotLightOuterConeAngleTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackSpotLightOuterConeAngleTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSpotLightOuterConeAngleTrackInst">();
	}
	static class UJackSpotLightOuterConeAngleTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSpotLightOuterConeAngleTrackInst>();
	}
};
static_assert(alignof(UJackSpotLightOuterConeAngleTrackInst) == 0x000008, "Wrong alignment on UJackSpotLightOuterConeAngleTrackInst");
static_assert(sizeof(UJackSpotLightOuterConeAngleTrackInst) == 0x000040, "Wrong size on UJackSpotLightOuterConeAngleTrackInst");

// Class JackGame.JackSQEXNGWordManager
// 0x0030 (0x0068 - 0x0038)
class UJackSQEXNGWordManager final : public UObject
{
public:
	uint8                                         Pad_38[0x30];                                      // 0x0038(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	TArray<class FString> GetNGWordList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSQEXNGWordManager">();
	}
	static class UJackSQEXNGWordManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSQEXNGWordManager>();
	}
};
static_assert(alignof(UJackSQEXNGWordManager) == 0x000008, "Wrong alignment on UJackSQEXNGWordManager");
static_assert(sizeof(UJackSQEXNGWordManager) == 0x000068, "Wrong size on UJackSQEXNGWordManager");

// Class JackGame.JackStaticMeshCollisionActor
// 0x0008 (0x03B0 - 0x03A8)
class AJackStaticMeshCollisionActor final : public AStaticMeshActor
{
public:
	class UStaticMeshComponent*                   CollisionStaticMeshComponent;                      // 0x03A8(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackStaticMeshCollisionActor">();
	}
	static class AJackStaticMeshCollisionActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackStaticMeshCollisionActor>();
	}
};
static_assert(alignof(AJackStaticMeshCollisionActor) == 0x000008, "Wrong alignment on AJackStaticMeshCollisionActor");
static_assert(sizeof(AJackStaticMeshCollisionActor) == 0x0003B0, "Wrong size on AJackStaticMeshCollisionActor");
static_assert(offsetof(AJackStaticMeshCollisionActor, CollisionStaticMeshComponent) == 0x0003A8, "Member 'AJackStaticMeshCollisionActor::CollisionStaticMeshComponent' has a wrong offset!");

// Class JackGame.JackAocManager
// 0x0090 (0x00C8 - 0x0038)
class UJackAocManager final : public UObject
{
public:
	uint8                                         Pad_38[0x90];                                      // 0x0038(0x0090)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackAocManager">();
	}
	static class UJackAocManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackAocManager>();
	}
};
static_assert(alignof(UJackAocManager) == 0x000008, "Wrong alignment on UJackAocManager");
static_assert(sizeof(UJackAocManager) == 0x0000C8, "Wrong size on UJackAocManager");

// Class JackGame.JackStoreManager
// 0x0038 (0x0070 - 0x0038)
class UJackStoreManager : public UObject
{
public:
	class UJackAocManager*                        JackAocManager;                                    // 0x0038(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x30];                                      // 0x0040(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CheckBrowseNetwork();
	EJackStoreResult GetBrowseResult();
	EJackNetworkCheckResult GetCheckBrowseNetworkResult();
	bool IsBrowseOpen();
	bool IsBrowseOpenRequest();
	bool IsCheckingBrowseNetwork();
	bool OpenDuoAppStore();
	bool OpenFukkatunoJumonStore();
	bool OpenOmakeStore();
	bool OpenPresentCodeInputScreen();
	bool OpenPresentItemStore();
	bool OpenVoiceDramaStore();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackStoreManager">();
	}
	static class UJackStoreManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackStoreManager>();
	}
};
static_assert(alignof(UJackStoreManager) == 0x000008, "Wrong alignment on UJackStoreManager");
static_assert(sizeof(UJackStoreManager) == 0x000070, "Wrong size on UJackStoreManager");
static_assert(offsetof(UJackStoreManager, JackAocManager) == 0x000038, "Member 'UJackStoreManager::JackAocManager' has a wrong offset!");

// Class JackGame.JackStreamObjectsReceiver
// 0x0058 (0x0090 - 0x0038)
class UJackStreamObjectsReceiver : public UObject
{
public:
	uint8                                         Pad_38[0x58];                                      // 0x0038(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackStreamObjectsReceiver">();
	}
	static class UJackStreamObjectsReceiver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackStreamObjectsReceiver>();
	}
};
static_assert(alignof(UJackStreamObjectsReceiver) == 0x000008, "Wrong alignment on UJackStreamObjectsReceiver");
static_assert(sizeof(UJackStreamObjectsReceiver) == 0x000090, "Wrong size on UJackStreamObjectsReceiver");

// Class JackGame.JackStreamObjectsHolder
// 0x0030 (0x00C0 - 0x0090)
class UJackStreamObjectsHolder final : public UJackStreamObjectsReceiver
{
public:
	TArray<class UObject*>                        LoadedObjects;                                     // 0x0090(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_A0[0x20];                                      // 0x00A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackStreamObjectsHolder">();
	}
	static class UJackStreamObjectsHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackStreamObjectsHolder>();
	}
};
static_assert(alignof(UJackStreamObjectsHolder) == 0x000008, "Wrong alignment on UJackStreamObjectsHolder");
static_assert(sizeof(UJackStreamObjectsHolder) == 0x0000C0, "Wrong size on UJackStreamObjectsHolder");
static_assert(offsetof(UJackStreamObjectsHolder, LoadedObjects) == 0x000090, "Member 'UJackStreamObjectsHolder::LoadedObjects' has a wrong offset!");

// Class JackGame.JackSynchroCaptionTrack
// 0x0018 (0x00A8 - 0x0090)
class UJackSynchroCaptionTrack final : public UInterpTrack
{
public:
	TArray<struct FJackSynchroCaptionTrackKey>    SynchroCaptionTrack;                               // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bAvailableWhenForwards : 1;                        // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bAvailableWhenBackwards : 1;                       // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSynchroCaptionTrack">();
	}
	static class UJackSynchroCaptionTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSynchroCaptionTrack>();
	}
};
static_assert(alignof(UJackSynchroCaptionTrack) == 0x000008, "Wrong alignment on UJackSynchroCaptionTrack");
static_assert(sizeof(UJackSynchroCaptionTrack) == 0x0000A8, "Wrong size on UJackSynchroCaptionTrack");
static_assert(offsetof(UJackSynchroCaptionTrack, SynchroCaptionTrack) == 0x000090, "Member 'UJackSynchroCaptionTrack::SynchroCaptionTrack' has a wrong offset!");

// Class JackGame.JackSynchronizeTimelineByBGMTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackSynchronizeTimelineByBGMTrack final : public UJackToggleBaseTrack
{
public:
	bool                                          bIsStartedCSSkip;                                  // 0x00A8(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSynchronizeTimelineByBGMTrack">();
	}
	static class UJackSynchronizeTimelineByBGMTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSynchronizeTimelineByBGMTrack>();
	}
};
static_assert(alignof(UJackSynchronizeTimelineByBGMTrack) == 0x000008, "Wrong alignment on UJackSynchronizeTimelineByBGMTrack");
static_assert(sizeof(UJackSynchronizeTimelineByBGMTrack) == 0x0000B0, "Wrong size on UJackSynchronizeTimelineByBGMTrack");
static_assert(offsetof(UJackSynchronizeTimelineByBGMTrack, bIsStartedCSSkip) == 0x0000A8, "Member 'UJackSynchronizeTimelineByBGMTrack::bIsStartedCSSkip' has a wrong offset!");

// Class JackGame.JackSynchronizeTimelineByBGMTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackSynchronizeTimelineByBGMTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSynchronizeTimelineByBGMTrackInst">();
	}
	static class UJackSynchronizeTimelineByBGMTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSynchronizeTimelineByBGMTrackInst>();
	}
};
static_assert(alignof(UJackSynchronizeTimelineByBGMTrackInst) == 0x000008, "Wrong alignment on UJackSynchronizeTimelineByBGMTrackInst");
static_assert(sizeof(UJackSynchronizeTimelineByBGMTrackInst) == 0x000040, "Wrong size on UJackSynchronizeTimelineByBGMTrackInst");

// Class JackGame.JackSystemData
// 0x0088 (0x00C0 - 0x0038)
class UJackSystemData : public UObject
{
public:
	uint8                                         Pad_38[0x88];                                      // 0x0038(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AgreeOnlineService(bool bIsAgree);
	bool IsVoiceDramaDLCompletion();
	void SetClearedPlayerName(const class FString& InPlayerName);
	void SetClearedSecondPlaythrough(bool bCleared);
	void SetVoiceDramaDLCompletion(bool bDLCompletion);

	const class FName GetActiveScenarioFlag() const;
	class FString GetClearedPlayerName() const;
	bool GetDLCInstallFlag(EJackDLCIndex InFlag) const;
	bool IsAgreeOnlineService() const;
	bool IsClearedSecondPlaythrough() const;
	bool IsCreatedSaveDataOnce() const;
	bool IsPlayedSibariPlayOnce() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackSystemData">();
	}
	static class UJackSystemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackSystemData>();
	}
};
static_assert(alignof(UJackSystemData) == 0x000008, "Wrong alignment on UJackSystemData");
static_assert(sizeof(UJackSystemData) == 0x0000C0, "Wrong size on UJackSystemData");

// Class JackGame.JackTalkComponent
// 0x00C0 (0x0260 - 0x01A0)
class UJackTalkComponent final : public UJackCharacterComponent
{
public:
	TWeakObjectPtr<class UJackFacialControlComponent> FacialControlComponent;                            // 0x01A0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   TalkBaseSocket;                                    // 0x01A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class FName                                   LowerFacePose_SuppressRandomLipSync;               // 0x01B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B8[0x18];                                     // 0x01B8(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackStreamObjectsHolder*               PartyTalkVoiceSet;                                 // 0x01D0(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1D8[0x88];                                     // 0x01D8(0x0088)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTalkComponent">();
	}
	static class UJackTalkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTalkComponent>();
	}
};
static_assert(alignof(UJackTalkComponent) == 0x000008, "Wrong alignment on UJackTalkComponent");
static_assert(sizeof(UJackTalkComponent) == 0x000260, "Wrong size on UJackTalkComponent");
static_assert(offsetof(UJackTalkComponent, FacialControlComponent) == 0x0001A0, "Member 'UJackTalkComponent::FacialControlComponent' has a wrong offset!");
static_assert(offsetof(UJackTalkComponent, TalkBaseSocket) == 0x0001A8, "Member 'UJackTalkComponent::TalkBaseSocket' has a wrong offset!");
static_assert(offsetof(UJackTalkComponent, LowerFacePose_SuppressRandomLipSync) == 0x0001B0, "Member 'UJackTalkComponent::LowerFacePose_SuppressRandomLipSync' has a wrong offset!");
static_assert(offsetof(UJackTalkComponent, PartyTalkVoiceSet) == 0x0001D0, "Member 'UJackTalkComponent::PartyTalkVoiceSet' has a wrong offset!");

// Class JackGame.JackTextDataBattle
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataBattle final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataBattle">();
	}
	static class UJackTextDataBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataBattle>();
	}
};
static_assert(alignof(UJackTextDataBattle) == 0x000008, "Wrong alignment on UJackTextDataBattle");
static_assert(sizeof(UJackTextDataBattle) == 0x000038, "Wrong size on UJackTextDataBattle");

// Class JackGame.JackTextDataGame
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataGame final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataGame">();
	}
	static class UJackTextDataGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataGame>();
	}
};
static_assert(alignof(UJackTextDataGame) == 0x000008, "Wrong alignment on UJackTextDataGame");
static_assert(sizeof(UJackTextDataGame) == 0x000038, "Wrong size on UJackTextDataGame");

// Class JackGame.JackTextDataGuide
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataGuide final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataGuide">();
	}
	static class UJackTextDataGuide* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataGuide>();
	}
};
static_assert(alignof(UJackTextDataGuide) == 0x000008, "Wrong alignment on UJackTextDataGuide");
static_assert(sizeof(UJackTextDataGuide) == 0x000038, "Wrong size on UJackTextDataGuide");

// Class JackGame.JackTextDataLocalization
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataLocalization final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataLocalization">();
	}
	static class UJackTextDataLocalization* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataLocalization>();
	}
};
static_assert(alignof(UJackTextDataLocalization) == 0x000008, "Wrong alignment on UJackTextDataLocalization");
static_assert(sizeof(UJackTextDataLocalization) == 0x000038, "Wrong size on UJackTextDataLocalization");

// Class JackGame.JackTextDataMiniGame
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataMiniGame final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataMiniGame">();
	}
	static class UJackTextDataMiniGame* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataMiniGame>();
	}
};
static_assert(alignof(UJackTextDataMiniGame) == 0x000008, "Wrong alignment on UJackTextDataMiniGame");
static_assert(sizeof(UJackTextDataMiniGame) == 0x000038, "Wrong size on UJackTextDataMiniGame");

// Class JackGame.JackTextDataSystem
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataSystem final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataSystem">();
	}
	static class UJackTextDataSystem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataSystem>();
	}
};
static_assert(alignof(UJackTextDataSystem) == 0x000008, "Wrong alignment on UJackTextDataSystem");
static_assert(sizeof(UJackTextDataSystem) == 0x000038, "Wrong size on UJackTextDataSystem");

// Class JackGame.JackTextDataTest
// 0x0000 (0x0038 - 0x0038)
class UJackTextDataTest final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextDataTest">();
	}
	static class UJackTextDataTest* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextDataTest>();
	}
};
static_assert(alignof(UJackTextDataTest) == 0x000008, "Wrong alignment on UJackTextDataTest");
static_assert(sizeof(UJackTextDataTest) == 0x000038, "Wrong size on UJackTextDataTest");

// Class JackGame.JackTextManager
// 0x0170 (0x01A8 - 0x0038)
class UJackTextManager : public UObject
{
public:
	TArray<struct FJackTextDataTableContainer>    TextDataTableList;                                 // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<struct FJackTextDataTableContainer>    TextPackDataTableList;                             // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UDataTable*                             OverrideTextDataTable;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TMap<class FName, EJackTextType>              OverrideTextTypeFromTextPack;                      // 0x0060(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_B0[0xF8];                                      // 0x00B0(0x00F8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FJackPartyTalkDescription Debug_GetPartyTalkDataBP(EJackScenarioID ScenarioID, class FName MapId, class FName ScenarioFlag, EJackCharacter CharacterID, bool bPriorityTalk, bool bCamp) const;
	class FName DetermineBoukenGuideIDinBP(EJackScenarioID ScenarioID, const class FName& ScenarioFlag) const;
	class FString GetBoukenGuideText() const;
	class FString GetJackCharacterDisplayName(EJackCharacter CharacterID) const;
	const class FName GetJackCharacterNPCID(EJackCharacter CharacterID) const;
	const class FString GetMapDisplayName(class FName MapId, bool bMacroReplace, bool bIsList) const;
	const class FString GetMLocationTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	class FString GetNPCDisplayName(class FName NPCID) const;
	struct FJackPartyTalkDescription GetPartyTalkData(EJackCharacter CharacterID, bool bPriorityTalk) const;
	const class FString GetSLocationTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	const class FName GetTalkerIDFromTextID(class FName TextID) const;
	class FString GetTextFromTextPackBP(const class FName& TextID) const;
	class FString GetTextRaw(const class FName& InTextId) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextManager">();
	}
	static class UJackTextManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextManager>();
	}
};
static_assert(alignof(UJackTextManager) == 0x000008, "Wrong alignment on UJackTextManager");
static_assert(sizeof(UJackTextManager) == 0x0001A8, "Wrong size on UJackTextManager");
static_assert(offsetof(UJackTextManager, TextDataTableList) == 0x000038, "Member 'UJackTextManager::TextDataTableList' has a wrong offset!");
static_assert(offsetof(UJackTextManager, TextPackDataTableList) == 0x000048, "Member 'UJackTextManager::TextPackDataTableList' has a wrong offset!");
static_assert(offsetof(UJackTextManager, OverrideTextDataTable) == 0x000058, "Member 'UJackTextManager::OverrideTextDataTable' has a wrong offset!");
static_assert(offsetof(UJackTextManager, OverrideTextTypeFromTextPack) == 0x000060, "Member 'UJackTextManager::OverrideTextTypeFromTextPack' has a wrong offset!");

// Class JackGame.JackTextSetGinkou
// 0x0000 (0x0038 - 0x0038)
class UJackTextSetGinkou final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextSetGinkou">();
	}
	static class UJackTextSetGinkou* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextSetGinkou>();
	}
};
static_assert(alignof(UJackTextSetGinkou) == 0x000008, "Wrong alignment on UJackTextSetGinkou");
static_assert(sizeof(UJackTextSetGinkou) == 0x000038, "Wrong size on UJackTextSetGinkou");

// Class JackGame.JackTextSetShop
// 0x0000 (0x0038 - 0x0038)
class UJackTextSetShop final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextSetShop">();
	}
	static class UJackTextSetShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextSetShop>();
	}
};
static_assert(alignof(UJackTextSetShop) == 0x000008, "Wrong alignment on UJackTextSetShop");
static_assert(sizeof(UJackTextSetShop) == 0x000038, "Wrong size on UJackTextSetShop");

// Class JackGame.JackTextSetYadoya
// 0x0000 (0x0038 - 0x0038)
class UJackTextSetYadoya final : public UJackTextData
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextSetYadoya">();
	}
	static class UJackTextSetYadoya* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextSetYadoya>();
	}
};
static_assert(alignof(UJackTextSetYadoya) == 0x000008, "Wrong alignment on UJackTextSetYadoya");
static_assert(sizeof(UJackTextSetYadoya) == 0x000038, "Wrong size on UJackTextSetYadoya");

// Class JackGame.JackUMGMemberChange
// 0x0078 (0x0478 - 0x0400)
class UJackUMGMemberChange : public UJackUMGWindowBase
{
public:
	UMulticastDelegateProperty_                   EndReloadDelegate;                                 // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemData*>               ItemDataList;                                      // 0x0418(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         SelectedFirst;                                     // 0x0428(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SelectedSecond;                                    // 0x042C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGPageController*                 PageControler;                                     // 0x0430(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<uint8>                                 InitialMemberList;                                 // 0x0438(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   SelectedMemberMain;                                // 0x0448(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SelectedMemberSub;                                 // 0x0450(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StartResourceReload;                               // 0x0458(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_459[0x1F];                                     // 0x0459(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStaticItemList(class UJackUMGItemBase* InItemBase);
	bool ChangeCharacterResource();
	void ChangeMember();
	void ClearItemDataList();
	void InitializeMenber();
	void InitWindowMemberChange(class UCanvasPanel* ItemListCanvas, class UJackUMGItemBase* InItemBase, class UCanvasPanel* FaceCanvasPanelList, int32 ZOrder);
	bool IsEndResourceReload();
	void JackUMGEndReloadDelegate__DelegateSignature();
	bool MoveCursor(int32 Direction, const struct FJackKeyStatus& InKey);
	void RestoreMember();
	void SetItemDataList(const TArray<class UJackUMGItemData*>& InItemDataList);
	void SetItemLists(class UCanvasPanel* InItemListCanvas, class UJackUMGItemBase* InItemBase, class UCanvasPanel* InFaceCanvasPanelList);
	void SetMemberPanelPosition();

	const int32 GetMemberNumber() const;
	bool IsAllDeadAfterMemberChange(const int32 InSelected1st, const int32 InSelected2nd) const;
	bool IsChangedMember() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMemberChange">();
	}
	static class UJackUMGMemberChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMemberChange>();
	}
};
static_assert(alignof(UJackUMGMemberChange) == 0x000008, "Wrong alignment on UJackUMGMemberChange");
static_assert(sizeof(UJackUMGMemberChange) == 0x000478, "Wrong size on UJackUMGMemberChange");
static_assert(offsetof(UJackUMGMemberChange, EndReloadDelegate) == 0x000400, "Member 'UJackUMGMemberChange::EndReloadDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, ItemDataList) == 0x000418, "Member 'UJackUMGMemberChange::ItemDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, SelectedFirst) == 0x000428, "Member 'UJackUMGMemberChange::SelectedFirst' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, SelectedSecond) == 0x00042C, "Member 'UJackUMGMemberChange::SelectedSecond' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, PageControler) == 0x000430, "Member 'UJackUMGMemberChange::PageControler' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, InitialMemberList) == 0x000438, "Member 'UJackUMGMemberChange::InitialMemberList' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, SelectedMemberMain) == 0x000448, "Member 'UJackUMGMemberChange::SelectedMemberMain' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, SelectedMemberSub) == 0x000450, "Member 'UJackUMGMemberChange::SelectedMemberSub' has a wrong offset!");
static_assert(offsetof(UJackUMGMemberChange, StartResourceReload) == 0x000458, "Member 'UJackUMGMemberChange::StartResourceReload' has a wrong offset!");

// Class JackGame.JackTextureFolderComponent
// 0x0050 (0x0780 - 0x0730)
class UJackTextureFolderComponent final : public UPrimitiveComponent
{
public:
	TArray<class UTexture*>                       Textures;                                          // 0x0730(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             Materials;                                         // 0x0740(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    StaticMeshs;                                       // 0x0750(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  SkeletalMeshs;                                     // 0x0760(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UMaterialInterface*>             MaterialCache;                                     // 0x0770(0x0010)(ZeroConstructor, Transient, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTextureFolderComponent">();
	}
	static class UJackTextureFolderComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTextureFolderComponent>();
	}
};
static_assert(alignof(UJackTextureFolderComponent) == 0x000010, "Wrong alignment on UJackTextureFolderComponent");
static_assert(sizeof(UJackTextureFolderComponent) == 0x000780, "Wrong size on UJackTextureFolderComponent");
static_assert(offsetof(UJackTextureFolderComponent, Textures) == 0x000730, "Member 'UJackTextureFolderComponent::Textures' has a wrong offset!");
static_assert(offsetof(UJackTextureFolderComponent, Materials) == 0x000740, "Member 'UJackTextureFolderComponent::Materials' has a wrong offset!");
static_assert(offsetof(UJackTextureFolderComponent, StaticMeshs) == 0x000750, "Member 'UJackTextureFolderComponent::StaticMeshs' has a wrong offset!");
static_assert(offsetof(UJackTextureFolderComponent, SkeletalMeshs) == 0x000760, "Member 'UJackTextureFolderComponent::SkeletalMeshs' has a wrong offset!");
static_assert(offsetof(UJackTextureFolderComponent, MaterialCache) == 0x000770, "Member 'UJackTextureFolderComponent::MaterialCache' has a wrong offset!");

// Class JackGame.JackTiltAlongGroundComponent
// 0x0190 (0x0470 - 0x02E0)
class UJackTiltAlongGroundComponent final : public USceneComponent
{
public:
	uint8                                         Pad_2E0[0x8];                                      // 0x02E0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UMeshComponent*                         TargetMeshComponent;                               // 0x02E8(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class FName>                           SocketNames;                                       // 0x02F0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	float                                         TiltAngleMax;                                      // 0x0300(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TraceSphereRadius;                                 // 0x0304(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_308[0x144];                                    // 0x0308(0x0144)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bBlendEnable;                                      // 0x044C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_44D[0x3];                                      // 0x044D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendInTime;                                       // 0x0450(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendInEasingFunc;                                 // 0x0454(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_455[0x3];                                      // 0x0455(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendOutTime;                                      // 0x0458(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EEasingFunc                                   BlendOutEasingFunc;                                // 0x045C(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_45D[0x13];                                     // 0x045D(0x0013)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTiltAlongGroundComponent">();
	}
	static class UJackTiltAlongGroundComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTiltAlongGroundComponent>();
	}
};
static_assert(alignof(UJackTiltAlongGroundComponent) == 0x000008, "Wrong alignment on UJackTiltAlongGroundComponent");
static_assert(sizeof(UJackTiltAlongGroundComponent) == 0x000470, "Wrong size on UJackTiltAlongGroundComponent");
static_assert(offsetof(UJackTiltAlongGroundComponent, TargetMeshComponent) == 0x0002E8, "Member 'UJackTiltAlongGroundComponent::TargetMeshComponent' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, SocketNames) == 0x0002F0, "Member 'UJackTiltAlongGroundComponent::SocketNames' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, TiltAngleMax) == 0x000300, "Member 'UJackTiltAlongGroundComponent::TiltAngleMax' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, TraceSphereRadius) == 0x000304, "Member 'UJackTiltAlongGroundComponent::TraceSphereRadius' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, bBlendEnable) == 0x00044C, "Member 'UJackTiltAlongGroundComponent::bBlendEnable' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, BlendInTime) == 0x000450, "Member 'UJackTiltAlongGroundComponent::BlendInTime' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, BlendInEasingFunc) == 0x000454, "Member 'UJackTiltAlongGroundComponent::BlendInEasingFunc' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, BlendOutTime) == 0x000458, "Member 'UJackTiltAlongGroundComponent::BlendOutTime' has a wrong offset!");
static_assert(offsetof(UJackTiltAlongGroundComponent, BlendOutEasingFunc) == 0x00045C, "Member 'UJackTiltAlongGroundComponent::BlendOutEasingFunc' has a wrong offset!");

// Class JackGame.JackUMGTokugiQuestion
// 0x00A8 (0x0308 - 0x0260)
class UJackUMGTokugiQuestion : public UJackUMGTokugiPieceBase
{
public:
	uint8                                         Pad_260[0x98];                                     // 0x0260(0x0098)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     CrackTextureList;                                  // 0x02F8(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)

public:
	void ApplyCrackShowState(bool bMain, const TArray<int32>& DirList);
	void PlayCrack(const TArray<int32>& DirList, const TArray<int32>& AnimDirList);
	void PlayNativeAnim(EJackTokugiQuestionAnim AnimType, bool bReverse);
	void SetElements(class UCanvasPanel* InIconRoot, class UCanvasPanel* InIconParts, class UImage* InFaceBright, class UImage* InFaceDark, class UUserWidget* InCrack000Main, class UUserWidget* InCrack000Temp, class UImage* InBackSide, class UImage* InSideSide, class UImage* InCircle, class UImage* InCircle1);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiQuestion">();
	}
	static class UJackUMGTokugiQuestion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiQuestion>();
	}
};
static_assert(alignof(UJackUMGTokugiQuestion) == 0x000008, "Wrong alignment on UJackUMGTokugiQuestion");
static_assert(sizeof(UJackUMGTokugiQuestion) == 0x000308, "Wrong size on UJackUMGTokugiQuestion");
static_assert(offsetof(UJackUMGTokugiQuestion, CrackTextureList) == 0x0002F8, "Member 'UJackUMGTokugiQuestion::CrackTextureList' has a wrong offset!");

// Class JackGame.JackTimeComponent
// 0x0020 (0x01C0 - 0x01A0)
class UJackTimeComponent final : public UJackCharacterComponent
{
public:
	uint8                                         Pad_1A0[0x20];                                     // 0x01A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetActorTimeDilation(EJackTimeDilationPurpose InPurpose, float InTimeDilation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTimeComponent">();
	}
	static class UJackTimeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTimeComponent>();
	}
};
static_assert(alignof(UJackTimeComponent) == 0x000008, "Wrong alignment on UJackTimeComponent");
static_assert(sizeof(UJackTimeComponent) == 0x0001C0, "Wrong size on UJackTimeComponent");

// Class JackGame.JackTimeLineJumperTrack
// 0x0000 (0x00A0 - 0x00A0)
class UJackTimeLineJumperTrack final : public UJackInterpTrackNameBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTimeLineJumperTrack">();
	}
	static class UJackTimeLineJumperTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTimeLineJumperTrack>();
	}
};
static_assert(alignof(UJackTimeLineJumperTrack) == 0x000008, "Wrong alignment on UJackTimeLineJumperTrack");
static_assert(sizeof(UJackTimeLineJumperTrack) == 0x0000A0, "Wrong size on UJackTimeLineJumperTrack");

// Class JackGame.JackTitleGameMode
// 0x0058 (0x0660 - 0x0608)
class AJackTitleGameMode : public AJackGameModeBase
{
public:
	class UDataTable*                             FukkatunojumonDataTable;                           // 0x0608(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FukkatunojumonItemDataTable;                       // 0x0610(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             FukkatunojumonLevelUpDataTable;                    // 0x0618(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GameResumeSettingFlagDataTable;                    // 0x0620(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GameResumeSettingPartyDataTable;                   // 0x0628(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GameResumeSettingItemDataTable;                    // 0x0630(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GameResumeSettingMonsterZukanDataTable;            // 0x0638(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             GameResumeSettingItemZukanDataTable;               // 0x0640(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackPafuPafuMode>          PafuPafuModeClass;                                 // 0x0648(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UDataTable*                             TokugiPanelInfoDataTable;                          // 0x0650(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class AJackPafuPafuMode*                      PafuPafuMode;                                      // 0x0658(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTitleGameMode">();
	}
	static class AJackTitleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTitleGameMode>();
	}
};
static_assert(alignof(AJackTitleGameMode) == 0x000008, "Wrong alignment on AJackTitleGameMode");
static_assert(sizeof(AJackTitleGameMode) == 0x000660, "Wrong size on AJackTitleGameMode");
static_assert(offsetof(AJackTitleGameMode, FukkatunojumonDataTable) == 0x000608, "Member 'AJackTitleGameMode::FukkatunojumonDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, FukkatunojumonItemDataTable) == 0x000610, "Member 'AJackTitleGameMode::FukkatunojumonItemDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, FukkatunojumonLevelUpDataTable) == 0x000618, "Member 'AJackTitleGameMode::FukkatunojumonLevelUpDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, GameResumeSettingFlagDataTable) == 0x000620, "Member 'AJackTitleGameMode::GameResumeSettingFlagDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, GameResumeSettingPartyDataTable) == 0x000628, "Member 'AJackTitleGameMode::GameResumeSettingPartyDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, GameResumeSettingItemDataTable) == 0x000630, "Member 'AJackTitleGameMode::GameResumeSettingItemDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, GameResumeSettingMonsterZukanDataTable) == 0x000638, "Member 'AJackTitleGameMode::GameResumeSettingMonsterZukanDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, GameResumeSettingItemZukanDataTable) == 0x000640, "Member 'AJackTitleGameMode::GameResumeSettingItemZukanDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, PafuPafuModeClass) == 0x000648, "Member 'AJackTitleGameMode::PafuPafuModeClass' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, TokugiPanelInfoDataTable) == 0x000650, "Member 'AJackTitleGameMode::TokugiPanelInfoDataTable' has a wrong offset!");
static_assert(offsetof(AJackTitleGameMode, PafuPafuMode) == 0x000658, "Member 'AJackTitleGameMode::PafuPafuMode' has a wrong offset!");

// Class JackGame.JackTitlePlayerController
// 0x0000 (0x0930 - 0x0930)
class AJackTitlePlayerController : public AJackPlayerController
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTitlePlayerController">();
	}
	static class AJackTitlePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTitlePlayerController>();
	}
};
static_assert(alignof(AJackTitlePlayerController) == 0x000008, "Wrong alignment on AJackTitlePlayerController");
static_assert(sizeof(AJackTitlePlayerController) == 0x000930, "Wrong size on AJackTitlePlayerController");

// Class JackGame.JackUMGNorimonoGauge
// 0x0050 (0x03C0 - 0x0370)
class UJackUMGNorimonoGauge : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   NorimonoGaugeActionDelegate;                       // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ChargeHorseDelegate;                               // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NorimonoSetAutoRunDelegate;                        // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitNorimonoPanel(const TArray<class UJackUMGWidgetBase*>& InNorimonoPanelList);
	void JackUMGChargeHorseDelegate__DelegateSignature(int32 Number, float Rate);
	void JackUMGNorimonoAutoRunSetDelegate__DelegateSignature(class FName Mode);
	void JackUMGNorimonoGaugeActionDelegate__DelegateSignature(EJackUMGNorimonoGaugeAction Action);
	void ResetSpecialAutoRunFlag();
	void SetNorimonoMode(const class FName InMode);

	const class FName GetNorimonoMode() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGNorimonoGauge">();
	}
	static class UJackUMGNorimonoGauge* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGNorimonoGauge>();
	}
};
static_assert(alignof(UJackUMGNorimonoGauge) == 0x000008, "Wrong alignment on UJackUMGNorimonoGauge");
static_assert(sizeof(UJackUMGNorimonoGauge) == 0x0003C0, "Wrong size on UJackUMGNorimonoGauge");
static_assert(offsetof(UJackUMGNorimonoGauge, NorimonoGaugeActionDelegate) == 0x000370, "Member 'UJackUMGNorimonoGauge::NorimonoGaugeActionDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGNorimonoGauge, ChargeHorseDelegate) == 0x000380, "Member 'UJackUMGNorimonoGauge::ChargeHorseDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGNorimonoGauge, NorimonoSetAutoRunDelegate) == 0x000390, "Member 'UJackUMGNorimonoGauge::NorimonoSetAutoRunDelegate' has a wrong offset!");

// Class JackGame.JackToBeContinuedTrack
// 0x0000 (0x00A8 - 0x00A8)
class UJackToBeContinuedTrack final : public UJackToggleBaseTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackToBeContinuedTrack">();
	}
	static class UJackToBeContinuedTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackToBeContinuedTrack>();
	}
};
static_assert(alignof(UJackToBeContinuedTrack) == 0x000008, "Wrong alignment on UJackToBeContinuedTrack");
static_assert(sizeof(UJackToBeContinuedTrack) == 0x0000A8, "Wrong size on UJackToBeContinuedTrack");

// Class JackGame.JackTokiNoKesinAnimInstance
// 0x0010 (0x0BF0 - 0x0BE0)
class UJackTokiNoKesinAnimInstance : public UJackAnimInstance
{
public:
	float                                         MoveMotionBlendRate;                               // 0x0BD8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MovePlayRate;                                      // 0x0BDC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsSit;                                            // 0x0BE0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsMove;                                           // 0x0BE1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_BE2[0xE];                                      // 0x0BE2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTokiNoKesinAnimInstance">();
	}
	static class UJackTokiNoKesinAnimInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTokiNoKesinAnimInstance>();
	}
};
static_assert(alignof(UJackTokiNoKesinAnimInstance) == 0x000010, "Wrong alignment on UJackTokiNoKesinAnimInstance");
static_assert(sizeof(UJackTokiNoKesinAnimInstance) == 0x000BF0, "Wrong size on UJackTokiNoKesinAnimInstance");
static_assert(offsetof(UJackTokiNoKesinAnimInstance, MoveMotionBlendRate) == 0x000BD8, "Member 'UJackTokiNoKesinAnimInstance::MoveMotionBlendRate' has a wrong offset!");
static_assert(offsetof(UJackTokiNoKesinAnimInstance, MovePlayRate) == 0x000BDC, "Member 'UJackTokiNoKesinAnimInstance::MovePlayRate' has a wrong offset!");
static_assert(offsetof(UJackTokiNoKesinAnimInstance, bIsSit) == 0x000BE0, "Member 'UJackTokiNoKesinAnimInstance::bIsSit' has a wrong offset!");
static_assert(offsetof(UJackTokiNoKesinAnimInstance, bIsMove) == 0x000BE1, "Member 'UJackTokiNoKesinAnimInstance::bIsMove' has a wrong offset!");

// Class JackGame.JackUMGTokugiPanelSkillLineData
// 0x0080 (0x00B8 - 0x0038)
class UJackUMGTokugiPanelSkillLineData final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackSkillLine                                SkillLineType;                                     // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              StartPoint;                                        // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FlashEffectPos;                                    // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GroupName;                                         // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   GroupNameId;                                       // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedSkillPoint;                                    // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MasteredSkillCount;                                // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillCount;                                        // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillResetCost;                                    // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ResetReturnSkillPoint;                             // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A4[0x4];                                       // 0x00A4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGTokugiPanelData*>        PieceDataList;                                     // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UJackUMGTokugiPanelSkillLineData* GetTokugiPanelSkillLineData(const class UJackUMGItemData* ItemData);

	void ConstructData(const TArray<class UJackUMGTokugiPanelData*>& BaseDataList);
	struct FVector2D GetStartPoint();
	bool IsAllMastered();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPanelSkillLineData">();
	}
	static class UJackUMGTokugiPanelSkillLineData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPanelSkillLineData>();
	}
};
static_assert(alignof(UJackUMGTokugiPanelSkillLineData) == 0x000008, "Wrong alignment on UJackUMGTokugiPanelSkillLineData");
static_assert(sizeof(UJackUMGTokugiPanelSkillLineData) == 0x0000B8, "Wrong size on UJackUMGTokugiPanelSkillLineData");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, Index_0) == 0x000038, "Member 'UJackUMGTokugiPanelSkillLineData::Index_0' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, SkillLineType) == 0x00003C, "Member 'UJackUMGTokugiPanelSkillLineData::SkillLineType' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, Description) == 0x000040, "Member 'UJackUMGTokugiPanelSkillLineData::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, StartPoint) == 0x000050, "Member 'UJackUMGTokugiPanelSkillLineData::StartPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, FlashEffectPos) == 0x000058, "Member 'UJackUMGTokugiPanelSkillLineData::FlashEffectPos' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, Name_0) == 0x000060, "Member 'UJackUMGTokugiPanelSkillLineData::Name_0' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, NameId) == 0x000070, "Member 'UJackUMGTokugiPanelSkillLineData::NameId' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, GroupName) == 0x000078, "Member 'UJackUMGTokugiPanelSkillLineData::GroupName' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, GroupNameId) == 0x000088, "Member 'UJackUMGTokugiPanelSkillLineData::GroupNameId' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, UsedSkillPoint) == 0x000090, "Member 'UJackUMGTokugiPanelSkillLineData::UsedSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, MasteredSkillCount) == 0x000094, "Member 'UJackUMGTokugiPanelSkillLineData::MasteredSkillCount' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, SkillCount) == 0x000098, "Member 'UJackUMGTokugiPanelSkillLineData::SkillCount' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, SkillResetCost) == 0x00009C, "Member 'UJackUMGTokugiPanelSkillLineData::SkillResetCost' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, ResetReturnSkillPoint) == 0x0000A0, "Member 'UJackUMGTokugiPanelSkillLineData::ResetReturnSkillPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanelSkillLineData, PieceDataList) == 0x0000A8, "Member 'UJackUMGTokugiPanelSkillLineData::PieceDataList' has a wrong offset!");

// Class JackGame.JackTokugiManager
// 0x0000 (0x0038 - 0x0038)
class UJackTokugiManager : public UObject
{
public:
	void OpenTokugiPanel(class FName TokugiPanelID, bool bConsumePoint);
	void ResetSkillLine(EJackCharacter TargetCharacter, EJackSkillLine SkillLineType);
	void ResetTokugiPanel(EJackCharacter TargetCharacter);
	void SetIncreaseTokugiPoint(EJackCharacter TargetCharacter, bool bIncrease);

	int32 GetTokugiPanelConsumePoint(class FName TokugiPanelID) const;
	EJackCharacter GetTokugiPanelTargetCharacter(class FName TokugiPanelID) const;
	class FString GetTokugiPanelText(class FName TokugiPanelID, EJackActionTextType TextType) const;
	bool IsIncreaseTokugiPoint(EJackCharacter TargetCharacter) const;
	bool IsOpenTokugiPanel(class FName TokugiPanelID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTokugiManager">();
	}
	static class UJackTokugiManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTokugiManager>();
	}
};
static_assert(alignof(UJackTokugiManager) == 0x000008, "Wrong alignment on UJackTokugiManager");
static_assert(sizeof(UJackTokugiManager) == 0x000038, "Wrong size on UJackTokugiManager");

// Class JackGame.JackTripleManager
// 0x0088 (0x0480 - 0x03F8)
class AJackTripleManager final : public APawn
{
public:
	TMap<class FName, TSubclassOf<class AActor>>  MiniGameMap;                                       // 0x03F8(0x0050)(Edit, BlueprintVisible, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	uint8                                         Pad_448[0x8];                                      // 0x0448(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackMeosiSlotSimulationComponent*      MeosiSlotSimulationComponent;                      // 0x0450(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_458[0x8];                                      // 0x0458(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   PlayMovieRequestDelegate;                          // 0x0460(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_470[0x10];                                     // 0x0470(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallEndMiniGame();
	void Draw2DWorld(class AHUD* HUD);
	void EndTriple();
	void ForceDisableTriple60fps(bool InDisable);
	void PauseTriple();
	void ResumeTriple();
	void StartTriple();

	bool IsTripleRunning() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTripleManager">();
	}
	static class AJackTripleManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackTripleManager>();
	}
};
static_assert(alignof(AJackTripleManager) == 0x000008, "Wrong alignment on AJackTripleManager");
static_assert(sizeof(AJackTripleManager) == 0x000480, "Wrong size on AJackTripleManager");
static_assert(offsetof(AJackTripleManager, MiniGameMap) == 0x0003F8, "Member 'AJackTripleManager::MiniGameMap' has a wrong offset!");
static_assert(offsetof(AJackTripleManager, MeosiSlotSimulationComponent) == 0x000450, "Member 'AJackTripleManager::MeosiSlotSimulationComponent' has a wrong offset!");
static_assert(offsetof(AJackTripleManager, PlayMovieRequestDelegate) == 0x000460, "Member 'AJackTripleManager::PlayMovieRequestDelegate' has a wrong offset!");

// Class JackGame.JackTripleUtils
// 0x0000 (0x0038 - 0x0038)
class UJackTripleUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTripleUtils">();
	}
	static class UJackTripleUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTripleUtils>();
	}
};
static_assert(alignof(UJackTripleUtils) == 0x000008, "Wrong alignment on UJackTripleUtils");
static_assert(sizeof(UJackTripleUtils) == 0x000038, "Wrong size on UJackTripleUtils");

// Class JackGame.JackUIInputSettings
// 0x0048 (0x0080 - 0x0038)
class UJackUIInputSettings : public UObject
{
public:
	uint8                                         Pad_38[0x4];                                       // 0x0038(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InputProhibitionTime;                              // 0x003C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackUIKeyRepeatSetting                ButtonKeyRepeatSetting;                            // 0x0040(0x0020)(Edit, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<EJackGamePlayerCondition>              UIDisableConditionList;                            // 0x0060(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	float                                         StickToButtonThreshold;                            // 0x0070(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickToButtonAngle;                                // 0x0074(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollVelocityScale;                               // 0x0078(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUIInputSettings">();
	}
	static class UJackUIInputSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUIInputSettings>();
	}
};
static_assert(alignof(UJackUIInputSettings) == 0x000008, "Wrong alignment on UJackUIInputSettings");
static_assert(sizeof(UJackUIInputSettings) == 0x000080, "Wrong size on UJackUIInputSettings");
static_assert(offsetof(UJackUIInputSettings, InputProhibitionTime) == 0x00003C, "Member 'UJackUIInputSettings::InputProhibitionTime' has a wrong offset!");
static_assert(offsetof(UJackUIInputSettings, ButtonKeyRepeatSetting) == 0x000040, "Member 'UJackUIInputSettings::ButtonKeyRepeatSetting' has a wrong offset!");
static_assert(offsetof(UJackUIInputSettings, UIDisableConditionList) == 0x000060, "Member 'UJackUIInputSettings::UIDisableConditionList' has a wrong offset!");
static_assert(offsetof(UJackUIInputSettings, StickToButtonThreshold) == 0x000070, "Member 'UJackUIInputSettings::StickToButtonThreshold' has a wrong offset!");
static_assert(offsetof(UJackUIInputSettings, StickToButtonAngle) == 0x000074, "Member 'UJackUIInputSettings::StickToButtonAngle' has a wrong offset!");
static_assert(offsetof(UJackUIInputSettings, ScrollVelocityScale) == 0x000078, "Member 'UJackUIInputSettings::ScrollVelocityScale' has a wrong offset!");

// Class JackGame.JackVehicleV103
// 0x0030 (0x1B60 - 0x1B30)
class AJackVehicleV103 final : public AJackVehicleMonster
{
public:
	bool                                          bMoveOffFromABP;                                   // 0x1B30(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B31[0x3];                                     // 0x1B31(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AirDumpRate;                                       // 0x1B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B38[0x10];                                    // 0x1B38(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           AnimMontageRiderJumpAdd;                           // 0x1B48(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAnimMontage*                           AnimMontageJumpAdd;                                // 0x1B50(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B58[0x8];                                     // 0x1B58(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV103">();
	}
	static class AJackVehicleV103* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV103>();
	}
};
static_assert(alignof(AJackVehicleV103) == 0x000010, "Wrong alignment on AJackVehicleV103");
static_assert(sizeof(AJackVehicleV103) == 0x001B60, "Wrong size on AJackVehicleV103");
static_assert(offsetof(AJackVehicleV103, bMoveOffFromABP) == 0x001B30, "Member 'AJackVehicleV103::bMoveOffFromABP' has a wrong offset!");
static_assert(offsetof(AJackVehicleV103, AirDumpRate) == 0x001B34, "Member 'AJackVehicleV103::AirDumpRate' has a wrong offset!");
static_assert(offsetof(AJackVehicleV103, AnimMontageRiderJumpAdd) == 0x001B48, "Member 'AJackVehicleV103::AnimMontageRiderJumpAdd' has a wrong offset!");
static_assert(offsetof(AJackVehicleV103, AnimMontageJumpAdd) == 0x001B50, "Member 'AJackVehicleV103::AnimMontageJumpAdd' has a wrong offset!");

// Class JackGame.JackUIInputManager
// 0x00D0 (0x0108 - 0x0038)
class UJackUIInputManager final : public UObject
{
public:
	UMulticastDelegateProperty_                   InputDelegate;                                     // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0xA2];                                      // 0x0048(0x00A2)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          LeftStickButtonLeft;                               // 0x00EA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftStickButtonRight;                              // 0x00EB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftStickButtonUp;                                 // 0x00EC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LeftStickButtonDown;                               // 0x00ED(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_EE[0x2];                                       // 0x00EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickToButtonThreshold;                            // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickToButtonAngle;                                // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScrollVelocityScale;                               // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickInputLength;                                  // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickInputAngle;                                   // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackUIInputDelegate__DelegateSignature(struct FJackUIInputDelegateInfo* InDelegateInfo);

	float GetScrollVelocityScale() const;
	float GetStickInputAngle() const;
	float GetStickInputLength() const;
	float GetStickToButtonAngle() const;
	float GetStickToButtonThreshold() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUIInputManager">();
	}
	static class UJackUIInputManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUIInputManager>();
	}
};
static_assert(alignof(UJackUIInputManager) == 0x000008, "Wrong alignment on UJackUIInputManager");
static_assert(sizeof(UJackUIInputManager) == 0x000108, "Wrong size on UJackUIInputManager");
static_assert(offsetof(UJackUIInputManager, InputDelegate) == 0x000038, "Member 'UJackUIInputManager::InputDelegate' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, LeftStickButtonLeft) == 0x0000EA, "Member 'UJackUIInputManager::LeftStickButtonLeft' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, LeftStickButtonRight) == 0x0000EB, "Member 'UJackUIInputManager::LeftStickButtonRight' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, LeftStickButtonUp) == 0x0000EC, "Member 'UJackUIInputManager::LeftStickButtonUp' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, LeftStickButtonDown) == 0x0000ED, "Member 'UJackUIInputManager::LeftStickButtonDown' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, StickToButtonThreshold) == 0x0000F0, "Member 'UJackUIInputManager::StickToButtonThreshold' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, StickToButtonAngle) == 0x0000F4, "Member 'UJackUIInputManager::StickToButtonAngle' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, ScrollVelocityScale) == 0x0000F8, "Member 'UJackUIInputManager::ScrollVelocityScale' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, StickInputLength) == 0x0000FC, "Member 'UJackUIInputManager::StickInputLength' has a wrong offset!");
static_assert(offsetof(UJackUIInputManager, StickInputAngle) == 0x000100, "Member 'UJackUIInputManager::StickInputAngle' has a wrong offset!");

// Class JackGame.JackUmaRaceAccessor
// 0x0040 (0x0078 - 0x0038)
class UJackUmaRaceAccessor final : public UObject
{
public:
	bool                                          bIsUsePathNo;                                      // 0x0038(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x1F];                                      // 0x0039(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UCameraAnim*>                    CameraAnimDatas;                                   // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_68[0x10];                                      // 0x0068(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ApplyNextReleaseRank();
	void ApplyPrizeForParticipationItem(class UObject* WorldContextObject, const struct FJackDataTableUmaRaceMapData& InData);
	void ApplyReleaseRankMessage(EJackUmaRaceRank InRank);
	void BeginUmaRace();
	void DebugClearAllRank();
	void DebugReleaseRank(class UObject* WorldContextObject, EJackUmaRaceRank InRank);
	void DisableStartDashCheck();
	void EnableStartDashCheck();
	void EndUmaRace();
	bool Get2ndWorldFlag();
	EJackUmaRaceRank GetAvaibalePlayRank();
	class FName GetClearEventItemGetName(class UObject* WorldContextObject, EJackUmaRaceRank InRank, const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	class FName GetClearItem(class UObject* WorldContextObject, EJackUmaRaceRank InRank, const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	class FName GetClearItemFromName(class UObject* WorldContextObject, class FName InName, const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	int32 GetClearItemNum(EJackUmaRaceRank InRank, const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	int32 GetClearItemNumFromName(class FName InName, const struct FJackDataTableUmaRaceMapData& InData, int32 GoalRank);
	int32 GetClearRank(class UObject* WorldContextObject, EJackUmaRaceRank InRank);
	float GetClearTime(class UObject* WorldContextObject, EJackUmaRaceRank InRank);
	void GetDecompositionTime(float InTime, int32* OutMinite, int32* OutSeconds, int32* OutMiliSeconds);
	float GetDesiredRankTime(class UObject* WorldContextObject, EJackUmaRaceRank InSelectRank);
	EJackUmaRaceDifficulty GetDifficulty();
	EJackUmaRaceFarisFlagState GetFarisFlag();
	int32 GetGoalRank();
	float GetLapTime(class UObject* WorldContextObject, EJackUmaRaceRank InRank, int32 LapNo);
	EJackUmaRaceRank GetLastSelectRank();
	class FString GetNextRankTitleCaption();
	class FName GetNextRankTitleCaptionId();
	class FString GetNowRankTitleCaption();
	class FName GetNowRankTitleCaptionId();
	EJackUmaRaceRank GetPlayableMaxRank();
	class FName GetPrizeForParticipation();
	bool GetRankClearFlag(EJackUmaRaceRank InRank);
	class FName GetRankName(EJackUmaRaceRank InRank);
	bool GetRankRelease(EJackUmaRaceRank InRank);
	class FName GetResultItem();
	bool GetSekaiHoukaiFlag();
	EJackUmaRaceRank GetSelectRank();
	class FName GetTitleRankTextId(EJackUmaRaceRank InRank);
	bool GetWishClear();
	void InitializeValue();
	bool IsActiveAllRankClear();
	bool IsAllRankClear();
	bool IsEnableTaduna();
	bool IsFreeRaceRelease();
	bool IsGenerateEffectObject();
	bool IsGenerateGoalObject();
	bool IsGeneratePhysicsObject();
	bool IsReleaseNewRank();
	bool IsReleaseNextRank();
	bool IsReleaseRankMessage(EJackUmaRaceRank InRank);
	bool IsStartDash();
	bool IsStartDashCheck();
	bool IsUsualRoute(EJackUmaRaceRank InRank, class UDataTable* InDataTable);
	void LoadResultCameraAnimAsset(class UObject* WorldContextObject);
	void RandomUnitLocation(const TArray<class AJackUmaRaceUnit*>& Units);
	bool SaveClearRank(int32 InClearRank);
	void SaveLastSelectRank(EJackUmaRaceRank InRank);
	void SetDifficulty(EJackUmaRaceDifficulty InType);
	void SetGenerateEffectObject(bool bIsEnable);
	void SetGenerateGoalObject(bool bIsEnable);
	void SetGeneratePhysicsObject(bool bIsEnable);
	void SetInputDisableMEPurpose(bool bIsDisable);
	void SetPrizeForParticipation(class FName Name_0);
	void SetSelectRank(EJackUmaRaceRank InSelectRank);
	void SetStartDash(bool bIsSuccess);
	void SetTaduna(bool bIsEnable);
	void UnloadResultCameraAnimAsset(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceAccessor">();
	}
	static class UJackUmaRaceAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUmaRaceAccessor>();
	}
};
static_assert(alignof(UJackUmaRaceAccessor) == 0x000008, "Wrong alignment on UJackUmaRaceAccessor");
static_assert(sizeof(UJackUmaRaceAccessor) == 0x000078, "Wrong size on UJackUmaRaceAccessor");
static_assert(offsetof(UJackUmaRaceAccessor, bIsUsePathNo) == 0x000038, "Member 'UJackUmaRaceAccessor::bIsUsePathNo' has a wrong offset!");
static_assert(offsetof(UJackUmaRaceAccessor, CameraAnimDatas) == 0x000058, "Member 'UJackUmaRaceAccessor::CameraAnimDatas' has a wrong offset!");

// Class JackGame.JackUMGVoiceDramaSelect
// 0x0078 (0x04A8 - 0x0430)
class UJackUMGVoiceDramaSelect final : public UJackUMGBrowserBase
{
public:
	uint8                                         Pad_430[0x78];                                     // 0x0430(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseMessageWindowSetting();
	float GetAnimationTime(int32 ButtonIndex);
	struct FJackVoiceDramaSelectButtonAnimation GetButtonAnimationParam(EJackVoiceDramaSelectAnimButton InAnimButtonType);
	EJackVoiceDramaSelectDLCCompleteMode GetDLCCompleteMode();
	class UJackUMGItemData* GetEshopItemList();
	int32 GetOpenPage();
	EJackAudioVolume GetSaveBGMVolume();
	EJackAudioVolume GetSaveSEVolume();
	int32 GetScenarioNoFormItemIndex(int32 ItemIndex);
	class FString GetScenarioOverviewText(int32 ScenarioNumber);
	class FString GetScenarioOverviewTextFrom(int32 InItemListNumber);
	class UTexture2D* GetScenarioTexture(int32 ScenarioNumber);
	class UTexture2D* GetScenarioTextureFromItemListNumber(int32 InItemListNumber);
	EJackVoiceDramaSelectEShop GetSelectEShop();
	EJackVoiceDramaSelectAnimButton GetTypeFromIndex(int32 InIndexNumber);
	const TArray<class UJackUMGItemData*> GetVoiceDramaScenarioList();
	void GetVoiceScenarioData();
	void InitButtonAnim(EJackVoiceDramaSelectAnimButton InAnimButtonType);
	bool IsInitScenarioImage();
	bool IsOpenVoiceDramaStopTick();
	bool IsScenarioValidInterruption(int32 ScenarioNumber);
	void OpenMessageWindowSetting();
	void SaveSystemData();
	void SetAnimationTime(int32 ButtonIndex, float InAnimTime);
	void SetButtonAnimation(int32 ButtonIndex, bool bIsButtonAnim);
	void SetButtonAnimationParam(EJackVoiceDramaSelectAnimButton InAnimButtonType, class UImage* ButtomTexture);
	void SetButtonScale(int32 ButtonIndex, float InScale);
	void SetDLCCompleteMode(EJackVoiceDramaSelectDLCCompleteMode InMode);
	void SetIndexNumber(int32 ItemIndex);
	void SetInitScenarioImage(bool bIsInitScenario);
	void SetLoopAnimation(int32 ButtonIndex, bool bIsLoopAnim);
	void SetMaxIndexPage(int32 InMaxIndexPage);
	void SetOpenPage(int32 InOpenPage);
	void SetOpenVoiceDramaStopTick(bool bIsStopTick);
	void SetSaveVolume(EJackAudioVolume InBGMVolume, EJackAudioVolume InSEVolume);
	void SetSelectEShop(EJackVoiceDramaSelectEShop InSelectEShopType);
	void SetSleep(bool bSleep);
	void SetWait(bool bWait);

	class UImage* GetButtomIcon(int32 ButtonIndex) const;
	int32 GetButtonAnimationSize() const;
	float GetButtonScale(int32 ButtonIndex) const;
	int32 GetIndexNumber() const;
	int32 GetIndexNumberFromScenarioNumber(int32 InScenarioNumber) const;
	int32 GetLatestInterruptScenarioID() const;
	int32 GetMaxIndexPage() const;
	bool IsButtonAnimation(int32 ButtonIndex) const;
	bool IsLoopAnimation(int32 ButtonIndex) const;
	bool IsVoiceDramaComplete(int32 InScenarioNo) const;
	bool IsVoiceDramaSleep() const;
	bool IsWait() const;
	void SetSelectTutorial(bool bSelect) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGVoiceDramaSelect">();
	}
	static class UJackUMGVoiceDramaSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGVoiceDramaSelect>();
	}
};
static_assert(alignof(UJackUMGVoiceDramaSelect) == 0x000008, "Wrong alignment on UJackUMGVoiceDramaSelect");
static_assert(sizeof(UJackUMGVoiceDramaSelect) == 0x0004A8, "Wrong size on UJackUMGVoiceDramaSelect");

// Class JackGame.JackUmaRaceAIController
// 0x0010 (0x0590 - 0x0580)
class AJackUmaRaceAIController final : public AJackAIController
{
public:
	class UJackVehicleControllerComponent*        VehicleControllerComponent;                        // 0x0580(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackVehicleRiderControllerComponent*   VehicleRiderControllerComponent;                   // 0x0588(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceAIController">();
	}
	static class AJackUmaRaceAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceAIController>();
	}
};
static_assert(alignof(AJackUmaRaceAIController) == 0x000008, "Wrong alignment on AJackUmaRaceAIController");
static_assert(sizeof(AJackUmaRaceAIController) == 0x000590, "Wrong size on AJackUmaRaceAIController");
static_assert(offsetof(AJackUmaRaceAIController, VehicleControllerComponent) == 0x000580, "Member 'AJackUmaRaceAIController::VehicleControllerComponent' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceAIController, VehicleRiderControllerComponent) == 0x000588, "Member 'AJackUmaRaceAIController::VehicleRiderControllerComponent' has a wrong offset!");

// Class JackGame.JackUmaRaceCameraData
// 0x0010 (0x0368 - 0x0358)
class UJackUmaRaceCameraData final : public UJackPlayerCameraData
{
public:
	float                                         DeltaMovementLerpSpeed;                            // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaMovementLeapSpeedMax;                         // 0x035C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDeltaMovementLerp;                              // 0x0360(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceCameraData">();
	}
	static class UJackUmaRaceCameraData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUmaRaceCameraData>();
	}
};
static_assert(alignof(UJackUmaRaceCameraData) == 0x000008, "Wrong alignment on UJackUmaRaceCameraData");
static_assert(sizeof(UJackUmaRaceCameraData) == 0x000368, "Wrong size on UJackUmaRaceCameraData");
static_assert(offsetof(UJackUmaRaceCameraData, DeltaMovementLerpSpeed) == 0x000358, "Member 'UJackUmaRaceCameraData::DeltaMovementLerpSpeed' has a wrong offset!");
static_assert(offsetof(UJackUmaRaceCameraData, DeltaMovementLeapSpeedMax) == 0x00035C, "Member 'UJackUmaRaceCameraData::DeltaMovementLeapSpeedMax' has a wrong offset!");
static_assert(offsetof(UJackUmaRaceCameraData, bIsDeltaMovementLerp) == 0x000360, "Member 'UJackUmaRaceCameraData::bIsDeltaMovementLerp' has a wrong offset!");

// Class JackGame.JackUmaRaceEntranceDebugMenu
// 0x0010 (0x03A8 - 0x0398)
class AJackUmaRaceEntranceDebugMenu final : public AActor
{
public:
	uint8                                         Pad_398[0x10];                                     // 0x0398(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceEntranceDebugMenu">();
	}
	static class AJackUmaRaceEntranceDebugMenu* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceEntranceDebugMenu>();
	}
};
static_assert(alignof(AJackUmaRaceEntranceDebugMenu) == 0x000008, "Wrong alignment on AJackUmaRaceEntranceDebugMenu");
static_assert(sizeof(AJackUmaRaceEntranceDebugMenu) == 0x0003A8, "Wrong size on AJackUmaRaceEntranceDebugMenu");

// Class JackGame.JackVehicleV205
// 0x0000 (0x1B30 - 0x1B30)
class AJackVehicleV205 final : public AJackVehicleMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV205">();
	}
	static class AJackVehicleV205* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV205>();
	}
};
static_assert(alignof(AJackVehicleV205) == 0x000010, "Wrong alignment on AJackVehicleV205");
static_assert(sizeof(AJackVehicleV205) == 0x001B30, "Wrong size on AJackVehicleV205");

// Class JackGame.JackUmaRaceGimmick
// 0x0018 (0x03B0 - 0x0398)
class AJackUmaRaceGimmick final : public AActor
{
public:
	bool                                          bIsWallHit;                                        // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x17];                                     // 0x0399(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static bool IsIncludeNumber(const TArray<int32>& CheckNumber, const TArray<int32>& MatchNumber);

	void AddVehicle(class AJackVehicleUmaRace* Vehicle);
	TArray<class AJackVehicleUmaRace*> GetVehicleArray();
	bool IsIncludePathNo(const TArray<int32>& CheckNumber, const TArray<int32>& PathNumberArray, class AJackUmaRaceUnit* Unit);
	bool IsWallHit();
	void RemoveVehicle(class AJackVehicleUmaRace* Vehicle);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceGimmick">();
	}
	static class AJackUmaRaceGimmick* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceGimmick>();
	}
};
static_assert(alignof(AJackUmaRaceGimmick) == 0x000008, "Wrong alignment on AJackUmaRaceGimmick");
static_assert(sizeof(AJackUmaRaceGimmick) == 0x0003B0, "Wrong size on AJackUmaRaceGimmick");
static_assert(offsetof(AJackUmaRaceGimmick, bIsWallHit) == 0x000398, "Member 'AJackUmaRaceGimmick::bIsWallHit' has a wrong offset!");

// Class JackGame.JackUmaRaceHud
// 0x0000 (0x0398 - 0x0398)
class AJackUmaRaceHud final : public AActor
{
public:
	void OnApplyPlayerLapTime(int32 Number, float LapTime, int32 Minite, int32 Seconds, int32 MiliSeconds, int32 TotalMinite, int32 TotalSeconds, int32 TotalMiliSeconds, bool bNewRecord, bool bLastLap, bool bFinalLap, bool bLapNewRecord);
	void OnBeginBrake();
	void OnDashEnd();
	void OnDashGaugeStateChange(EJackUmaRaceDashGaugeState Type);
	void OnDashGaugeUpdate(float Percent);
	void OnDashStart();
	void OnEndBrake();
	void OnHealGauge(float Percent, bool bForceChangeState);
	void OnIntervalTimeEnd();
	void OnRetireBegin();
	void OnUpdatePlayerRank(int32 Rank);
	void OnUpdateTimer(float InRaceTime, int32 Minite, int32 Seconds, int32 MiliSeconds, int32 InLap, int32 InLapMinite, int32 InLapSeconds, int32 InLapMiliSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceHud">();
	}
	static class AJackUmaRaceHud* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceHud>();
	}
};
static_assert(alignof(AJackUmaRaceHud) == 0x000008, "Wrong alignment on AJackUmaRaceHud");
static_assert(sizeof(AJackUmaRaceHud) == 0x000398, "Wrong size on AJackUmaRaceHud");

// Class JackGame.JackUmaRaceSplinePath
// 0x0008 (0x03A0 - 0x0398)
class AJackUmaRaceSplinePath final : public AActor
{
public:
	class USplineComponent*                       SplineComponent;                                   // 0x0398(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, PersistentInstance, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SetSplineComponent(class USplineComponent* InSplineComponent);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceSplinePath">();
	}
	static class AJackUmaRaceSplinePath* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceSplinePath>();
	}
};
static_assert(alignof(AJackUmaRaceSplinePath) == 0x000008, "Wrong alignment on AJackUmaRaceSplinePath");
static_assert(sizeof(AJackUmaRaceSplinePath) == 0x0003A0, "Wrong size on AJackUmaRaceSplinePath");
static_assert(offsetof(AJackUmaRaceSplinePath, SplineComponent) == 0x000398, "Member 'AJackUmaRaceSplinePath::SplineComponent' has a wrong offset!");

// Class JackGame.JackUMGMapDelegateButtonPayload
// 0x0008 (0x0040 - 0x0038)
class UJackUMGMapDelegateButtonPayload final : public UObject
{
public:
	EJackKeys                                     Button;                                            // 0x0038(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPressed;                                          // 0x0039(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapDelegateButtonPayload">();
	}
	static class UJackUMGMapDelegateButtonPayload* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapDelegateButtonPayload>();
	}
};
static_assert(alignof(UJackUMGMapDelegateButtonPayload) == 0x000008, "Wrong alignment on UJackUMGMapDelegateButtonPayload");
static_assert(sizeof(UJackUMGMapDelegateButtonPayload) == 0x000040, "Wrong size on UJackUMGMapDelegateButtonPayload");
static_assert(offsetof(UJackUMGMapDelegateButtonPayload, Button) == 0x000038, "Member 'UJackUMGMapDelegateButtonPayload::Button' has a wrong offset!");
static_assert(offsetof(UJackUMGMapDelegateButtonPayload, bPressed) == 0x000039, "Member 'UJackUMGMapDelegateButtonPayload::bPressed' has a wrong offset!");

// Class JackGame.JackUmaRaceState
// 0x0008 (0x03A0 - 0x0398)
class AJackUmaRaceState final : public AActor
{
public:
	EJackUmaRaceGameState                         State;                                             // 0x0398(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_399[0x7];                                      // 0x0399(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClearChange();
	EJackUmaRaceGameState GetState();
	bool IsChanged();
	void SetState(EJackUmaRaceGameState State_0);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceState">();
	}
	static class AJackUmaRaceState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceState>();
	}
};
static_assert(alignof(AJackUmaRaceState) == 0x000008, "Wrong alignment on AJackUmaRaceState");
static_assert(sizeof(AJackUmaRaceState) == 0x0003A0, "Wrong size on AJackUmaRaceState");
static_assert(offsetof(AJackUmaRaceState, State) == 0x000398, "Member 'AJackUmaRaceState::State' has a wrong offset!");

// Class JackGame.JackUmaRaceUnit
// 0x00C0 (0x0458 - 0x0398)
class AJackUmaRaceUnit final : public AActor
{
public:
	TArray<class AJackUmaRaceSplinePath*>         SplinePathDatas;                                   // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         SpawnOffsetZ;                                      // 0x03A8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsTimeSchedule;                                   // 0x03AC(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3AD[0x3];                                      // 0x03AD(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RecordLapIntervalTime;                             // 0x03B0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         P008Scale;                                         // 0x03B4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                P008LocationOffset;                                // 0x03B8(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C4[0x4];                                      // 0x03C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AJackVehicleUmaRace*                    Vehicle;                                           // 0x03C8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class AJackCharacter>          Character;                                         // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3D8[0x80];                                     // 0x03D8(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AdjustFloor();
	float GetFootStepVolume(int32 InLap);
	int32 GetGoalRank();
	EJackUmaRaceHorseType GetHorseType();
	int32 GetImpactPriority();
	int32 GetPathNo();
	float GetRaceTime();
	void RecordLap();
	void SetPaddockNumber(int32 InPaddockNumber);
	void SetSplineData(const TArray<class USplineComponent*>& SplineDataArray);
	void SetSplineGoalData(const TArray<class USplineComponent*>& InSplineData);
	void SetSplinePathData(const TArray<class AJackUmaRaceSplinePath*>& InSplinePathDataArray);
	void SetUmaRaceManager(class AJackUmaRaceManager* InManager);

	float GetCourseRatioCache() const;
	int32 GetLapCount() const;
	TArray<float> GetLapTimeArray() const;
	float GetLastLapTime() const;
	int32 GetPaddockNumber() const;
	class FString GetPlayerName() const;
	float GetTotalLapTime() const;
	bool IsPlayer() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUmaRaceUnit">();
	}
	static class AJackUmaRaceUnit* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackUmaRaceUnit>();
	}
};
static_assert(alignof(AJackUmaRaceUnit) == 0x000008, "Wrong alignment on AJackUmaRaceUnit");
static_assert(sizeof(AJackUmaRaceUnit) == 0x000458, "Wrong size on AJackUmaRaceUnit");
static_assert(offsetof(AJackUmaRaceUnit, SplinePathDatas) == 0x000398, "Member 'AJackUmaRaceUnit::SplinePathDatas' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, SpawnOffsetZ) == 0x0003A8, "Member 'AJackUmaRaceUnit::SpawnOffsetZ' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, bIsTimeSchedule) == 0x0003AC, "Member 'AJackUmaRaceUnit::bIsTimeSchedule' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, RecordLapIntervalTime) == 0x0003B0, "Member 'AJackUmaRaceUnit::RecordLapIntervalTime' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, P008Scale) == 0x0003B4, "Member 'AJackUmaRaceUnit::P008Scale' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, P008LocationOffset) == 0x0003B8, "Member 'AJackUmaRaceUnit::P008LocationOffset' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, Vehicle) == 0x0003C8, "Member 'AJackUmaRaceUnit::Vehicle' has a wrong offset!");
static_assert(offsetof(AJackUmaRaceUnit, Character) == 0x0003D0, "Member 'AJackUmaRaceUnit::Character' has a wrong offset!");

// Class JackGame.JackTokugiPanelSetting
// 0x0018 (0x0050 - 0x0038)
class UJackTokugiPanelSetting : public UObject
{
public:
	TArray<struct FJackTokugiPanelAtariBonus>     AtariBonusInfoList;                                // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	int32                                         SkillResetPriceBase;                               // 0x0048(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackTokugiPanelSetting">();
	}
	static class UJackTokugiPanelSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackTokugiPanelSetting>();
	}
};
static_assert(alignof(UJackTokugiPanelSetting) == 0x000008, "Wrong alignment on UJackTokugiPanelSetting");
static_assert(sizeof(UJackTokugiPanelSetting) == 0x000050, "Wrong size on UJackTokugiPanelSetting");
static_assert(offsetof(UJackTokugiPanelSetting, AtariBonusInfoList) == 0x000038, "Member 'UJackTokugiPanelSetting::AtariBonusInfoList' has a wrong offset!");
static_assert(offsetof(UJackTokugiPanelSetting, SkillResetPriceBase) == 0x000048, "Member 'UJackTokugiPanelSetting::SkillResetPriceBase' has a wrong offset!");

// Class JackGame.JackUMGAccessorBattle
// 0x0168 (0x01A8 - 0x0040)
class UJackUMGAccessorBattle final : public UJackUMGAccessorBase
{
public:
	UMulticastDelegateProperty_                   ChangePhotoModeDelegate;                           // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class AJackBattlePlayerController*            BattlePlayerController;                            // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackGameCharacter*                     BattleCaster;                                      // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                CasterCharaType;                                   // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackGameCharacter*                     BattleTarget;                                      // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackGameCharacter*>             TargetList;                                        // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsDirectionEdge;                                  // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGUIActionInfo*                   UIActionInfoRef;                                   // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          SelectSoubiRegionType;                             // 0x0090(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x117];                                     // 0x0091(0x0117)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 BattleCommandMenu(class UJackGameCharacter* InCaster, class UJackGameCharacter* InTarget, EJackUMGBattleMenuCommand InCommandType, const class FName InActionId, int32 InIndex, bool IsDontSaveCursor);
	int32 BattleCommandMenuItem(class UJackGameCharacter* InCaster, class UJackGameCharacter* InTarget, const class UJackUMGUIActionInfo* InActionInfo, bool IsDontSaveCursor);
	void BindKeyBattleSakusenYoyaku();
	bool CanOpenRenkei(class UJackGameCharacter* InCaster);
	void ChangeMonsterNamePlateShowFlag(bool bIncrease);
	void ClearSelectedTarget();
	void CloseBattleIrekaeMenu();
	void ExitFirstBattleMenu();
	int32 GetCursorSaveTargetFromCharaTypeList(class UJackGameCharacter* InPlayerRef, const TArray<EJackCharacter>& InCharaTypeList);
	int32 GetCursorSaveTargetIndex(class UJackGameCharacter* InPlayerRef, EJackCursorSaveTarget InSaveTarget);
	int32 GetNearGroupIndex(const TArray<class UJackUMGItemData*>& InGroupList);
	const TArray<class UJackUMGItemData*> GetRenkeiList(const class UJackGameCharacter* InCaster, bool IsOptimisation);
	bool GetSakusenYoyaku();
	TArray<class UJackUMGItemData*> GetTargetGroupList(bool bIsWithPlayer);
	TArray<class UJackUMGItemData*> GetTargetList(bool bIsWithPlayer);
	void GetTokugiNotAvailableReason(class UJackGameCharacter* GameCharacter, class FName ActionID, EJackTokugiNotAvailableReason* NotAvailableReason, class FName* OutActionId, class FName* OutNeedEquippedWeaponStyleTextId);
	void HideAllMonsterNamePlate();
	void InputDelegate(struct FJackUIInputDelegateInfo* InDelegateInfo);
	void JackUMGBattleChangePhotoModeDelegate__DelegateSignature(bool bIsPhotoMode);
	void OnBattleMenuFirstOpen(class UJackGameCharacter* InTarget);
	void OnJumonFocusChanged(const class FName& InActionId);
	void OnTargetFocusChanged(class UJackGameCharacter* InTarget);
	void OpenBattleIrekaeMenu();
	void ResetRenkeiMemberAnimation(bool Initial);
	int32 SelectGroupListInKey(EJackKeys InKey, const TArray<class UJackUMGItemData*>& InDataList, class UJackGameCharacter* InGameCharacter);
	int32 SelectTargetInKey(EJackKeys InKey, class UJackGameCharacter* InGameCharacter);
	void SetBattleMenuCommand(EJackUMGBattleMenuCommand InBattleMenuCommand);
	void SetBattleTarget(class UJackGameCharacter* InCharacter);
	void SetCursorSaveTargetGroup(class UJackGameCharacter* InPlayerRef, class UJackGameCharacter* InTargetRef, int32 InGroupIndex);
	void SetExecCharactersNumber(const int32 InNumber);
	void SetLeftAxisFromBattleCameraMode();
	void SetMatineeSkip(bool IsMatineeSkip);
	struct FVector SetRengekiOffset(class UJackGameCharacter* InGameCharacter, const float InHoff, const float InVoff, const float RengekiIkiti);
	void SetRenkeiMemberAnimation(const int32 InCaster, const TArray<class FText>& InMember);
	void SetReturnedIrekae(bool InFlag);
	void SetSakusenYoyaku(bool InFlag);
	void SetSelectSoubiRegionType(EJackEquipmentRegion InRegionType);
	void SetUIActionInfo(class UJackUMGUIActionInfo* InActionInfo);
	void ShowAllMonsterNamePlate();

	bool CanRenkei(const TArray<class FName>& InMemberList) const;
	TArray<class UJackUMGItemData*> GetActionMemberList(EJackUMGUIActionFlow InUIFlowType, EJackCharacter InWithoutCharType) const;
	class UJackGameCharacter* GetBattleCasster() const;
	int32 GetBattleCassterMP() const;
	EJackUMGBattleMenuCommand GetBattleMenuCommand() const;
	int32 GetExecCharactersNumber() const;
	class UJackGameCharacter* GetFirstTargetCharacter(const class FName InActionId, bool IsEnemy) const;
	int32 GetFirstTargetMenuIndex(const class FName InActionId) const;
	class UJackUMGUIActionInfo* GetKougekiUIActionInfo() const;
	int32 GetMinimumHPTargetIndex() const;
	class UJackGameCharacter* GetNearTargetCharacter(bool IsEnemy) const;
	int32 GetNearTargetIndex(const TArray<class UJackGameCharacter*>& InCharaList) const;
	int32 GetNearTargetMenuIndex() const;
	const struct FJackDataTableRenkei GetRenkeiInfoFromRenkeiId(const class FName& InRenkeiId) const;
	int32 GetSmallestNameIdentifierTarget(const TArray<class UJackGameCharacter*>& InCharaList) const;
	EJackRenkeiSpectacleShowStatus GetSpectacleShowStatus() const;
	bool IsOnOddEffectStatusByParty(EJackUMGMemberList InMemberType, const class FName& InOddEffectStatusId) const;
	bool IsPhotoModeActivated() const;
	bool IsReturnedIrekae() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorBattle">();
	}
	static class UJackUMGAccessorBattle* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorBattle>();
	}
};
static_assert(alignof(UJackUMGAccessorBattle) == 0x000008, "Wrong alignment on UJackUMGAccessorBattle");
static_assert(sizeof(UJackUMGAccessorBattle) == 0x0001A8, "Wrong size on UJackUMGAccessorBattle");
static_assert(offsetof(UJackUMGAccessorBattle, ChangePhotoModeDelegate) == 0x000040, "Member 'UJackUMGAccessorBattle::ChangePhotoModeDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, BattlePlayerController) == 0x000050, "Member 'UJackUMGAccessorBattle::BattlePlayerController' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, BattleCaster) == 0x000058, "Member 'UJackUMGAccessorBattle::BattleCaster' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, CasterCharaType) == 0x000060, "Member 'UJackUMGAccessorBattle::CasterCharaType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, BattleTarget) == 0x000068, "Member 'UJackUMGAccessorBattle::BattleTarget' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, TargetList) == 0x000070, "Member 'UJackUMGAccessorBattle::TargetList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, bIsDirectionEdge) == 0x000080, "Member 'UJackUMGAccessorBattle::bIsDirectionEdge' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, UIActionInfoRef) == 0x000088, "Member 'UJackUMGAccessorBattle::UIActionInfoRef' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorBattle, SelectSoubiRegionType) == 0x000090, "Member 'UJackUMGAccessorBattle::SelectSoubiRegionType' has a wrong offset!");

// Class JackGame.JackUMGAccessorCommon
// 0x0120 (0x0160 - 0x0040)
class UJackUMGAccessorCommon : public UJackUMGAccessorBase
{
public:
	class UDataTable*                             DataTableTabiNoKokoroe;                            // 0x0040(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UDataTable*                             DataTableCoinShopTable;                            // 0x0048(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0xB0];                                      // 0x0050(0x00B0)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RestartPointEventCaptionId;                        // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestartPointCaptionId;                             // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestartPointTownCaptionId;                         // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RestartNoMessageId;                                // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   OmoideId;                                          // 0x0120(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                TokugiPanelCharacterType;                          // 0x0128(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExitGame;                                         // 0x0129(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12A[0x2];                                      // 0x012A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BoukenMode;                                        // 0x012C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGWidgetBase*                     TenseiWidgetSave;                                  // 0x0130(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             DataTableVoiceDramaScenario;                       // 0x0138(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             BookMarkIcon;                                      // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDLComp;                                         // 0x0148(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_149[0x7];                                      // 0x0149(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UTexture2D*>                     StaffListTextures;                                 // 0x0150(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void BindKeyPhotoMode();
	int32 DecreaseGold(int32 InGold);
	void DepositGold(int32 Value);
	void DisplayTabiNoKokoroeFromBP(class FName Key);
	void GetDataVoiceDramaScenario(class FName Key, class FString* OutTitleText, class FString* OutScenarioMinute, class FString* OutScenarioSecond, int32* OutScenarioNo);
	void GetDLCDataVoiceDramaScenario(class FName Key, class FString* OutScenarioMinute, class FString* OutScenarioSecond);
	const class FString GetLocationTitle(const class FName InMapId);
	class UTexture2D* GetScenarioBookMarkIcon();
	class UTexture2D* GetStaffList(int32 InPage);
	int32 GetStaffListSize();
	void GetTabiNoKokoroeData(class FName Key, class FString* OutTitleText, class FString* OutMainText, bool* bOutDisplayTexture, TSoftObjectPtr<class UTexture>* OutTexture);
	void GetTabiNoKokoroePageDataList(class FName Key, TArray<struct FJackUMGTabiNoKokoroePageData>* OutPageDataList);
	int32 IncreaseGold(int32 InGold);
	bool IsScenarioLastVaildInterruption(int32 ItemIndex);
	bool IsScenarioVaildInterruption(int32 ItemIndex);
	bool IsSelectTutorial();
	bool IsTaughtTabiNoKokoroe(class FName Key);
	void OnCloseTabiNoKokoroe();
	void OnCloseTokugiPanel();
	void OnDisplayTabiNoKokoroe(class FName Key);
	void OnOpenTokugiPanelAtBattleResult(EJackCharacter CharacterType);
	void PhotoMode();
	void SetCampMenuInCamp(bool bInCampMenu);
	void SetCasinoCoin(int32 InCount);
	void SetInFusigiKazi(bool bInFlag);
	void SetUtinaosiNoHouju(int32 InCount);
	void ShowTokugiPanalAtBattleResultDebugTest(EJackCharacter CharacterType);
	void UpdateLocaltionTitle();
	void WaitCloseTabiNoKokoroeFromBP(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void WithdrawGold(int32 Value);

	int32 CheckGold(int32 InGold) const;
	bool GetCampMenuInCamp() const;
	int32 GetCasinoCoin() const;
	int32 GetCasinoCoinGettableCount() const;
	int32 GetCoinAndHoujuExchangeRatio() const;
	const class FString GetCurrentSmallLocationTitle() const;
	int32 GetDeposit() const;
	TArray<class FString> GetFukkatuLocation() const;
	int32 GetGold() const;
	bool GetIsInCamp() const;
	int32 GetLimitCasinoCoin() const;
	int32 GetLimitMedal() const;
	int32 GetLimitOfDeposit() const;
	int32 GetLimitOfGold() const;
	int32 GetLimitUtinaosiNoHouju() const;
	int32 GetMedal() const;
	const class FString GetMiddleLocationTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	int32 GetPlayTimeHour() const;
	int32 GetPlayTimeMinutes() const;
	int32 GetPlayTimeSeconds() const;
	const TArray<class UJackUMGItemData*> GetShortcutMenuCommandList() const;
	class UJackUMGItemData* GetSyougouData(const class FName InSyougouId) const;
	bool GetUnlockCasinoCoinFalg() const;
	bool GetUnlockUtinaosiNoHoujuFlag() const;
	int32 GetUtinaosiNoHouju() const;
	int32 GetUtinaosiNoHoujuGettableCount() const;
	bool IsGameFlag(const class FName InFlagName) const;
	bool IsInFusigiKazi() const;
	bool IsLanguageKorea() const;
	bool IsOpenNakamaMenu() const;
	bool IsVoiceDramaDLComplete() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorCommon">();
	}
	static class UJackUMGAccessorCommon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorCommon>();
	}
};
static_assert(alignof(UJackUMGAccessorCommon) == 0x000008, "Wrong alignment on UJackUMGAccessorCommon");
static_assert(sizeof(UJackUMGAccessorCommon) == 0x000160, "Wrong size on UJackUMGAccessorCommon");
static_assert(offsetof(UJackUMGAccessorCommon, DataTableTabiNoKokoroe) == 0x000040, "Member 'UJackUMGAccessorCommon::DataTableTabiNoKokoroe' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, DataTableCoinShopTable) == 0x000048, "Member 'UJackUMGAccessorCommon::DataTableCoinShopTable' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, RestartPointEventCaptionId) == 0x000100, "Member 'UJackUMGAccessorCommon::RestartPointEventCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, RestartPointCaptionId) == 0x000108, "Member 'UJackUMGAccessorCommon::RestartPointCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, RestartPointTownCaptionId) == 0x000110, "Member 'UJackUMGAccessorCommon::RestartPointTownCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, RestartNoMessageId) == 0x000118, "Member 'UJackUMGAccessorCommon::RestartNoMessageId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, OmoideId) == 0x000120, "Member 'UJackUMGAccessorCommon::OmoideId' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, TokugiPanelCharacterType) == 0x000128, "Member 'UJackUMGAccessorCommon::TokugiPanelCharacterType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, bExitGame) == 0x000129, "Member 'UJackUMGAccessorCommon::bExitGame' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, BoukenMode) == 0x00012C, "Member 'UJackUMGAccessorCommon::BoukenMode' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, TenseiWidgetSave) == 0x000130, "Member 'UJackUMGAccessorCommon::TenseiWidgetSave' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, DataTableVoiceDramaScenario) == 0x000138, "Member 'UJackUMGAccessorCommon::DataTableVoiceDramaScenario' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, BookMarkIcon) == 0x000140, "Member 'UJackUMGAccessorCommon::BookMarkIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, bIsDLComp) == 0x000148, "Member 'UJackUMGAccessorCommon::bIsDLComp' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorCommon, StaffListTextures) == 0x000150, "Member 'UJackUMGAccessorCommon::StaffListTextures' has a wrong offset!");

// Class JackGame.JackUMGCasinoCoinBase
// 0x0000 (0x0370 - 0x0370)
class UJackUMGCasinoCoinBase : public UJackUMGWidgetBase
{
public:
	void SetCasinoCoin(int32 InCasinoCoin);
	void UpdateWindowCasino(int32 InCasinoCoin);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCasinoCoinBase">();
	}
	static class UJackUMGCasinoCoinBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCasinoCoinBase>();
	}
};
static_assert(alignof(UJackUMGCasinoCoinBase) == 0x000008, "Wrong alignment on UJackUMGCasinoCoinBase");
static_assert(sizeof(UJackUMGCasinoCoinBase) == 0x000370, "Wrong size on UJackUMGCasinoCoinBase");

// Class JackGame.JackUMGDressupCoordinateInfo
// 0x0090 (0x00D0 - 0x0040)
class UJackUMGDressupCoordinateInfo final : public UJackUMGAccessorBase
{
public:
	EJackCharacter                                CharacterType;                                     // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGMitameSoubiState                      State;                                             // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLocked;                                         // 0x0042(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsOpend;                                          // 0x0043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFirstOpen;                                      // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNewMark;                                       // 0x0045(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0046(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGTextColorSet                          DisplayColor;                                      // 0x0047(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NameId;                                            // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackUMGSoubiData                      SoubiData;                                         // 0x0050(0x0070)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGMitameItemInfo>         ItemList;                                          // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGDressupCoordinateInfo">();
	}
	static class UJackUMGDressupCoordinateInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGDressupCoordinateInfo>();
	}
};
static_assert(alignof(UJackUMGDressupCoordinateInfo) == 0x000008, "Wrong alignment on UJackUMGDressupCoordinateInfo");
static_assert(sizeof(UJackUMGDressupCoordinateInfo) == 0x0000D0, "Wrong size on UJackUMGDressupCoordinateInfo");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, CharacterType) == 0x000040, "Member 'UJackUMGDressupCoordinateInfo::CharacterType' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, State) == 0x000041, "Member 'UJackUMGDressupCoordinateInfo::State' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, bIsLocked) == 0x000042, "Member 'UJackUMGDressupCoordinateInfo::bIsLocked' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, bIsOpend) == 0x000043, "Member 'UJackUMGDressupCoordinateInfo::bIsOpend' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, bIsFirstOpen) == 0x000044, "Member 'UJackUMGDressupCoordinateInfo::bIsFirstOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, bHasNewMark) == 0x000045, "Member 'UJackUMGDressupCoordinateInfo::bHasNewMark' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, bIsEquipped) == 0x000046, "Member 'UJackUMGDressupCoordinateInfo::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, DisplayColor) == 0x000047, "Member 'UJackUMGDressupCoordinateInfo::DisplayColor' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, NameId) == 0x000048, "Member 'UJackUMGDressupCoordinateInfo::NameId' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, SoubiData) == 0x000050, "Member 'UJackUMGDressupCoordinateInfo::SoubiData' has a wrong offset!");
static_assert(offsetof(UJackUMGDressupCoordinateInfo, ItemList) == 0x0000C0, "Member 'UJackUMGDressupCoordinateInfo::ItemList' has a wrong offset!");

// Class JackGame.JackUMGRetryItemSyousai
// 0x0040 (0x0078 - 0x0038)
class UJackUMGRetryItemSyousai final : public UObject
{
public:
	int32                                         PictorialBookNo;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         CountStack;                                        // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x0064(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   RecipeName;                                        // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InBagIndex;                                        // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGRetryItemSyousai">();
	}
	static class UJackUMGRetryItemSyousai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGRetryItemSyousai>();
	}
};
static_assert(alignof(UJackUMGRetryItemSyousai) == 0x000008, "Wrong alignment on UJackUMGRetryItemSyousai");
static_assert(sizeof(UJackUMGRetryItemSyousai) == 0x000078, "Wrong size on UJackUMGRetryItemSyousai");
static_assert(offsetof(UJackUMGRetryItemSyousai, PictorialBookNo) == 0x000038, "Member 'UJackUMGRetryItemSyousai::PictorialBookNo' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, ItemID) == 0x000040, "Member 'UJackUMGRetryItemSyousai::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, ItemName) == 0x000048, "Member 'UJackUMGRetryItemSyousai::ItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, CountStack) == 0x000060, "Member 'UJackUMGRetryItemSyousai::CountStack' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, bIsEquipped) == 0x000064, "Member 'UJackUMGRetryItemSyousai::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, RecipeName) == 0x000068, "Member 'UJackUMGRetryItemSyousai::RecipeName' has a wrong offset!");
static_assert(offsetof(UJackUMGRetryItemSyousai, InBagIndex) == 0x000070, "Member 'UJackUMGRetryItemSyousai::InBagIndex' has a wrong offset!");

// Class JackGame.JackUMGValueController
// 0x01A8 (0x0518 - 0x0370)
class UJackUMGValueController : public UJackUMGWidgetBase
{
public:
	TArray<class UWidget*>                        ValuePanels;                                       // 0x0370(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UWidget*                                CursorPanel;                                       // 0x0380(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNoDisableColor;                                   // 0x0388(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x57];                                     // 0x0389(0x0057)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DecText00;                                         // 0x03E0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText01;                                         // 0x03F8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText02;                                         // 0x0410(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText03;                                         // 0x0428(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText04;                                         // 0x0440(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText05;                                         // 0x0458(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText06;                                         // 0x0470(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText07;                                         // 0x0488(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText08;                                         // 0x04A0(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DecText09;                                         // 0x04B8(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D0[0x48];                                     // 0x04D0(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitValueController(int32 ZOrder);
	void NoDisableColor(bool bNoDisable);
	void SetupNumberRange(int32 InNumMin, int32 InNumMax);
	void SetupValueController(int32 InInitValue, int32 InNumDigits, int32 InMinDigits);

	bool CanInputValue(EJackUMGCheckValueInput InValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGValueController">();
	}
	static class UJackUMGValueController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGValueController>();
	}
};
static_assert(alignof(UJackUMGValueController) == 0x000008, "Wrong alignment on UJackUMGValueController");
static_assert(sizeof(UJackUMGValueController) == 0x000518, "Wrong size on UJackUMGValueController");
static_assert(offsetof(UJackUMGValueController, ValuePanels) == 0x000370, "Member 'UJackUMGValueController::ValuePanels' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, CursorPanel) == 0x000380, "Member 'UJackUMGValueController::CursorPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, bNoDisableColor) == 0x000388, "Member 'UJackUMGValueController::bNoDisableColor' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText00) == 0x0003E0, "Member 'UJackUMGValueController::DecText00' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText01) == 0x0003F8, "Member 'UJackUMGValueController::DecText01' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText02) == 0x000410, "Member 'UJackUMGValueController::DecText02' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText03) == 0x000428, "Member 'UJackUMGValueController::DecText03' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText04) == 0x000440, "Member 'UJackUMGValueController::DecText04' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText05) == 0x000458, "Member 'UJackUMGValueController::DecText05' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText06) == 0x000470, "Member 'UJackUMGValueController::DecText06' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText07) == 0x000488, "Member 'UJackUMGValueController::DecText07' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText08) == 0x0004A0, "Member 'UJackUMGValueController::DecText08' has a wrong offset!");
static_assert(offsetof(UJackUMGValueController, DecText09) == 0x0004B8, "Member 'UJackUMGValueController::DecText09' has a wrong offset!");

// Class JackGame.JackUMGAccessorFusigiKazi
// 0x0428 (0x0468 - 0x0040)
class UJackUMGAccessorFusigiKazi final : public UJackUMGAccessorBase
{
public:
	EJackFusigiKaziCreateCategory                 CreateCategoryType;                                // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFusigiKaziParts                          PartsType;                                         // 0x0041(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFusigiKaziMaterialSpecial                MaterialSpecialType;                               // 0x0042(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFusigiKaziCreateFrame                    CreateFrameType;                                   // 0x0043(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackFusigiKaziGameStat                       GameStatType;                                      // 0x0044(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 SelectPartsList;                                   // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class AJackCharacter*                         KaziPlayerCharacter;                               // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 KaziInteractiveActor;                              // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x18];                                      // 0x0068(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackFusigiKaziGameAction*              KaziAction;                                        // 0x0080(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackFusigiKaziQualityAnalysis*         QualityAnalysis;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGWidgetBase*                     FusigiKaziParts[0x16];                             // 0x0090(0x0008)(Edit, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class AJackFusigiKaziGameMain*                CaptureBP;                                         // 0x0140(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         SerifuWindowController;                            // 0x0148(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_150[0x68];                                     // 0x0150(0x0068)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemData*>               RecipeItemList;                                    // 0x01B8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGItemData*>               MaterialItemList;                                  // 0x01C8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGItemData*>               UseMaterialItemList;                               // 0x01D8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	TArray<int32>                                 NeedMaterialList;                                  // 0x01E8(0x0010)(Edit, ZeroConstructor, EditConst, NativeAccessSpecifierPrivate)
	class UJackFusigiKaziItemCountList*           NeedMaterialItemList[0x5];                         // 0x01F8(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_220[0x248];                                    // 0x0220(0x0248)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddBrowsedRecipeBook();
	int32 AddRetryMaterialItemNum(int32 AddVal);
	struct FVector2D BuckupSelectStartCursorPos();
	int32 CalcRetryMaterialBonus();
	void ChangeUseMaterialItemListData(int32 MaterialIndex, class FName NewItemID);
	void CheckFusigiKaziAchievement();
	class FName CheckLearningTokugi(int32 JudgeStartLevel, int32 PlayerLevel, bool bHissatuCheck);
	bool CheckMaterialUseInfo(EJackFusigiKaziMaterialUseInfo UseType);
	void CheckOutOtherAchievement();
	void ClearBackupSortType();
	void ClearKaziGame();
	void ClearKaziMaterialInfo();
	void ClearKaziWidgetParts(EJackFusigiKaziUMGParts KaziPartsType);
	void ClearStartHissatuCharge();
	void ClearStartMaterialSpecial();
	void CloseKaisinMessage();
	EJackFusigiKaziDifficultyType ConvertUnderDifficultyStringToEnum(const class FString& Difficulty);
	void CreateNeedMaterialList(class FName RecipeName);
	void CreateNewRecipeList();
	void CreateRecipeList();
	void CreateSelectPartsList();
	bool DebugGetKaziCameraMoveEnable();
	bool DebugIsDebugDrawGaugeInfo();
	bool DebugIsDebugDrawRecipeLv();
	void DisplayKaisinMessage();
	bool EffectAddToScreen(class UJackUMGWidgetBase* AddWidget, int32 ZOrder);
	class FName GetActionCategoryName(class FName ItemID);
	class FName GetActionDataNameForIndex(int32 Index_0);
	class FName GetActionNameForCategory(class FName CategoryName);
	int32 GetActionNeedCP();
	int32 GetActionNeedCPForTokugi(class FName ActionID);
	class FName GetActionSetumeiMessageID_Tokugi(class FName ActionName);
	int32 GetActionUseTemperature(class FName ActionName);
	EJackUMGItemSortType GetBackupSortType(EJackItem_Bag BagType);
	int32 GetBackupTopCommandIndex();
	struct FVector2D GetBalloonGeneratePos(int32 Index_0, const struct FVector2D& MassOffset);
	struct FVector2D GetBuckupCursorPos();
	class FName GetBuckupSelectCategoryID();
	int32 GetBuckupSelectTokugiIndex();
	class FName GetCreatableItemName(int32 GroupIndex);
	TArray<class FName> GetCreatableItemNameGroup();
	const EJackFusigiKaziCreateCategory GetCreateCategory();
	EJackFusigiKaziCreateFrame GetCreateFrameType(EJackFusigiKaziParts PType);
	int32 GetCreateItemDisplayStatusParam(const class FName InItemId, EJackItem_ParameterType ParamType);
	EJackFusigiKaziKanagata GetCreateKanagataType();
	EJackFusigiKaziMetalMaterial GetCreateMetalType();
	struct FVector2D GetCursorMassPos(int32 Index_0);
	struct FVector2D GetCursorPos(const struct FVector& StartPos, const struct FVector& RelativePos);
	int32 GetCursorPosToGaugeIndex(class FName ActionName, int32 CursorIndex);
	int32 GetDifficultyRank(class FName ItemID);
	int32 GetDisplayTemperature();
	EJackFusigiKaziEffect GetEffectAfterAction(int32 Index_0);
	EJackFusigiKaziEffect GetEffectBeforeAction();
	class FName GetEnableMaterialItemNameInGroup(class FName ItemID, int32 EnableIndex);
	struct FVector2D GetFrameSize();
	EJackFusigiKaziGameStat GetGameStat();
	int32 GetGameTurn();
	float GetGaugeAvg();
	bool GetGaugeColorUpdateFlag(int32 GaugeIndex);
	float GetGaugeHP(int32 GaugeIndex);
	float GetGaugeMaxHP(int32 GaugeIndex);
	struct FVector2D GetGaugePos(int32 GaugeIndex, float BaseSize);
	float GetGaugeReferenceHP(int32 GaugeIndex);
	float GetGaugeSafetyMax(int32 GaugeIndex);
	float GetGaugeSafetyMin(int32 GaugeIndex);
	struct FVector2D GetGaugeScale(int32 GaugeIndex);
	float GetGaugeSuccessMax(int32 GaugeIndex);
	float GetGaugeSuccessMin(int32 GaugeIndex);
	float GetGaugeWidth(int32 GaugeIndex);
	bool GetHissatuPossibleFlag();
	bool GetHissatuSelectListFlag();
	bool GetHissatuUseFlag();
	float GetIdealVal(int32 GaugeIndex);
	int32 GetItemCountPlusTotalNum(int32 MaterialIndex, int32 ItemRank);
	int32 GetItemCountTotalNum(int32 MaterialIndex);
	EJackEquipmentRegion GetItemEquipRegion();
	int32 GetItemGroupTotalNum(class FName ItemID);
	const class FName GetItemIdFromRecipeName(const class FName& RecipeName);
	int32 GetItemQualityRank(class FName ItemID);
	int32 GetItemTotalNum(class FName ItemID);
	bool GetKaisinFlag(int32 Index_0);
	struct FVector2D GetKanadokoPanelSize();
	class UJackFusigiKaziGameAction* GetKaziAction();
	struct FVector2D GetKaziActionCursorPos(class FName ActionName, int32 CursorIndex);
	int32 GetKaziActionDataGetLV(class FName ActionName);
	int32 GetKaziActionKnockNum(class FName ActionName);
	struct FVector2D GetKaziActionLeftUp();
	class AJackFusigiKaziGameMain* GetKaziCaptureBP();
	int32 GetKaziCategory_Index(class FName PartsName, const class FString& CategoryName);
	EJackFusigiKaziParts GetKaziCategory_PartsType(const class FString& CategoryName, int32 KaziIndex);
	struct FVector2D GetKaziFrameLeftUp();
	int32 GetKaziGamePlayNum_Normal();
	int32 GetKaziGamePlayNum_Retry();
	int32 GetKaziGamePlayNum_Total();
	EJackFusigiKaziGameResult GetKaziGameResult();
	int32 GetKaziMaterialItemNo(int32 MaterialIndex);
	int32 GetKaziMaterialNeedNum(int32 MaterialIndex);
	class FName GetKaziPartsAbbreviatedName();
	const EJackFusigiKaziParts GetKaziPartsType();
	int32 GetKaziTemperature();
	class UJackUMGWidgetBase* GetKaziWidgetParts(EJackFusigiKaziUMGParts KaziPartsType);
	int32 GetKeta(int32 Num);
	EJackFusigiKaziKuwasikuQuality GetKuwasikuQualityType();
	int32 GetLastTimePlayerLv();
	class FString GetLearningTokugiSetumeiID(EJackFusigiKaziGameTokugi TokugiType);
	struct FVector2D GetMassPos(int32 GaugeIndex);
	TArray<class FName> GetMaterialGroupItems(class FName ItemID);
	EJackFusigiKaziMaterialUseInfo GetMaterialUseInfo(int32 MaterialIndex);
	int32 GetMaterialUseInfoNum(EJackFusigiKaziMaterialUseInfo UseType);
	int32 GetMaterialUseMemberNum(int32 MaterialIndex);
	EJackCharacter GetMessageArgEquipCharacter();
	EJackEquipmentRegion GetMessageArgEquipRegion();
	EJackFusigiKaziMetalMaterial GetMetalMaterialType(EJackFusigiKaziParts PType);
	float GetMorphValue(int32 GaugeIndex);
	int32 GetNeedMaterialNum(int32 MaterialIndex);
	struct FVector2D GetPanelImageOffset();
	class FName GetPartsName(int32 PartsID);
	const class FText GetPartsNameFromItemID(const class FName InItemId);
	int32 GetPlayerCP();
	int32 GetPowerUpCP(int32 JudgeStartLevel, int32 PlayerLevel);
	class UJackFusigiKaziQualityAnalysis* GetQualityAnalysis();
	int32 GetRecipeIndex(class FName RecipeName);
	EJackFusigiKaziParts GetRecipeItemPartsType(class FName RecipeName);
	class FName GetRecipeName(class FName ItemID);
	int32 GetRecipeRank(class FName RecipeName);
	int32 GetRequestActionDamage(int32 Index_0);
	float GetRequestAfterWaitTime(int32 Index_0);
	int32 GetResetActiveTime();
	int32 GetRetryAddQualityValue(EJackFusigiKaziGameResult ResultType);
	class FName GetRetryBaseItemID();
	int32 GetRetryBaseQuality();
	bool GetRetryFlow();
	bool GetRetryGameFlag();
	EJackItem_Bag GetRetryItemBagType();
	const TArray<class UJackUMGItemData*> GetRetryItemListNew(EJackItem_Bag InBagType, EJackUMGItemClassRefineType InRefineType);
	int32 GetRetryItemSelectEnableNum(EJackItem_Bag InBagType, const TArray<class UJackUMGItemData*>& BagItemList);
	class UJackUMGRetryItemSyousai* GetRetryItemSyousaiWithBagType(EJackItem_Bag InBagType, int32 BagItemIndex, const TArray<class UJackUMGItemData*>& RetryItemList);
	class FName GetRetryListItemID(EJackItem_Bag InBagType, int32 BagItemIndex, const TArray<class UJackUMGItemData*>& RetryItemList);
	int32 GetRetryMaterialBonus();
	int32 GetRetryMaterialItemNum();
	int32 GetRetryMaterialNum(class FName ItemID);
	class FName GetSelectActionComment();
	int32 GetSelectActionGetLV();
	int32 GetSelectActionKaisin();
	class FName GetSelectActionName();
	int32 GetSelectActionNeedCP();
	int32 GetSelectActionNumData(int32 NumIndex);
	class FName GetSelectActionSetumeiMessageID();
	int32 GetSelectActionSortIndex();
	class FName GetSelectActionType();
	class FString GetSelectMaterialGroupMessage(class FName ItemID);
	class FName GetSelectMaterialMessage(const TArray<class FName>& MaterialNameTable, int32 GroupIndex);
	EJackUMGTextColorSet GetSelectNeedCPColor();
	TArray<class UJackUMGItemData*> GetSelectPartsItemList();
	TArray<int32> GetSelectPartsList();
	class FName GetSelectRecipeName();
	class FName GetSelectTokugiName();
	bool GetStartHissatuCharge();
	bool GetStartMaterialSpecial();
	int32 GetSuccessNum_Normal();
	int32 GetSuccessNum_Retry();
	int32 GetSuccessNum_Total();
	int32 GetTargetUseInfoListIndex(EJackFusigiKaziMaterialUseInfo UseType, int32 Limit);
	class FName GetTokugiActionName(class FName ActionID);
	EJackFusigiKaziGameTokugi GetTokugiTypeFromActionID(class FName ActionID);
	TArray<int32> GetTopMenuUnEnableList();
	EJackFusigiKaziPossibleType GetTypeRetryPossible(class FName ItemID);
	int32 GetUnderCorrectionDifficulty(class FName ItemID);
	float GetUnderCorrectionPercentage(class FName ItemID);
	EJackCharacter GetUseEquipCharacterType(int32 MaterialIndex);
	EJackEquipmentRegion GetUseEquipCharaRegion(int32 MaterialIndex);
	EJackCharacter GetUseMaterialCharacterType(int32 MaterialIndex);
	class FName GetUseMaterialItemID(int32 MaterialIndex);
	float GetValuePos(float HPVal, int32 GaugeIndex, float BaseSize);
	float GetWaitGaugeMoveTimer();
	void InitEffectInfo(class UJackUMGWidgetBase* EffectWidget, EJackFusigiKaziEffect EffectType, int32 ActionIndex, const struct FVector2D& BaseOffset);
	void InitializeDokodemoKaziStartTime();
	void InitKaziGame();
	void InitRequiredMaterialInfo(int32 InIndex, const class FName& InItemId, struct FJackUMGRequiredMaterialInfo* RequiredMaterialInfo);
	void InitScebeCaptureBP(class USceneCaptureComponent2D* SceneCaptureComponent);
	void InitSetting();
	void InitTurn();
	bool IsActionEnableKnockMass();
	bool IsCharacterEquipDualSword(EJackItem_Bag InBagType);
	bool IsCursorActionSelected();
	bool IsEnableGaugeSpace();
	bool IsEndRunAction();
	bool IsGaugeEnable(int32 GaugeIndex);
	bool IsHaveRecipeNeedItems(class FName RecipeName);
	bool IsKaziTableLevelUp();
	bool IsLastAction();
	bool IsTableBreakdown();
	void JackMiniGameFusigiKaziInputDelegate__DelegateSignature(const class FName InEventTag);
	bool JudgeHissatuCharge();
	EJackFusigiKaziGameResult JudgeKaziGameResult();
	bool JudgeMaterialSpecialRun();
	void KaziEnd();
	void NextTurn();
	void OverwriteBackupKaziGamePlayNum();
	int32 RecoverGaugeSetting();
	void ReflectResultKaziItem(class FName ResultItemID, bool EquipAttachFg);
	void RemoveRetryItem(class FName SubtractItemID);
	void ReplaceRetryItem(class FName ResultItemID);
	void RequestAction();
	void RequestNextStat(EJackFusigiKaziGameStat NextStat);
	void RequestRetryFlow(bool RetryFg);
	void ResetCelectNewRecipeViewFlag();
	bool RunAction(int32 Index_0, float ApplyTime);
	void RunRecover(float ApplyTime);
	void SetBackupSortType(EJackItem_Bag BagType, EJackUMGItemSortType SortType);
	void SetBackupTopCommandIndex(int32 CommandIndex);
	void SetBuckupCursorPos(const struct FVector2D& BuckupPos);
	void SetBuckupSelectCategoryID(class FName CategoryID);
	void SetBuckupSelectTokugiIndex(int32 TokugiIndex);
	void SetCreateCategory(EJackFusigiKaziCreateCategory CategoryType);
	void SetGameStat(EJackFusigiKaziGameStat Stat);
	void SetGaugeColorUpdateFlag(int32 GaugeIndex, bool EnableFlag);
	void SetHissatuPossibleFlag(bool Flag);
	void SetHissatuSelectListFlag(bool HissatuFlag);
	void SetHissatuUseFlag(bool Flag);
	void SetKaziActionLeftUp(const struct FVector2D& LeftUpPos);
	void SetKaziCaptureBP(class AJackFusigiKaziGameMain* BPObject);
	void SetKaziGamePlayNum_Normal(int32 PlayNum);
	void SetKaziGamePlayNum_Retry(int32 PlayNum);
	void SetKaziInteractiveActor(class AActor* KaziActor);
	void SetKaziMaterialInfo(int32 RecipeNo);
	void SetKaziPartsType(EJackFusigiKaziParts KaziParts);
	EJackFusigiKaziParts SetKaziPartsTypeForIndex(int32 Index_0);
	void SetKaziPlayerCharacter(class AJackCharacter* Chr);
	void SetKaziWidgetParts(EJackFusigiKaziUMGParts KaziPartsType, class UJackUMGWidgetBase* KaziWidget);
	void SetLastTimePlayerLv(int32 Lv);
	void SetMaterialSpecialTarget();
	void SetPartsTypeFromRecipe(const class FName& InRecipeName);
	bool SetRecipeRank(class FName RecipeName, int32 QualityRank, bool IgnoreCheckFg);
	void SetResetActiveTime(int32 ActiveTime);
	void SetRetryGameInfo(EJackItem_Bag BagType, class FName InBagItemID, class UJackUMGRetryItemSyousai* ItemSyousai);
	void SetRetryMaterialBonus(int32 BonusNum);
	void SetSaveCurrentBGMID(const class FName& InSaveBGMID);
	void SetSelectActionCategoryName(class FName CategoryName);
	void SetSelectRecipeName(class FName RecipeName);
	struct FVector2D SetSelectStartCursorPos();
	void SetSuccessNum_Normal(int32 SuccessNum);
	void SetSuccessNum_Retry(int32 SuccessNum);
	void SetTemperatureChangeValue(int32 GoalTemperature, float ChangeTime);
	void SettingGameStartInfo(bool RetryFlag, int32 QualityValue);
	void SettingRecipeInfo(class FName RecipeName);
	void SettingSelectActionInfo(class FName ActionName);
	void SettingSelectActionInfo_TokugiList(class UJackUMGItemBase* TokugiItem);
	void SettingSelectItemInfo(class FName RecipeName);
	TArray<class UJackUMGItemData*> SortRecipeItemList(EJackUMGItemSortType InSortType);
	void SubtractNeedMaterialItem();
	int32 UpdateCursorInput(TDelegate<void(class FName InEventTag)> InDelegate, EJackKeys KeyType);
	int32 UpdateDisplayTemperature(float DeltaTime);
	float UpdateGaugeReferenceHP(int32 GaugeIndex, float DeltaTime);
	bool WasCanselKey();

	void GetBulkBuyingList(const TArray<struct FJackUMGRequiredMaterialInfo>& InRequiredMaterialList, TArray<struct FJackUIItemBulkBuyingInfo>* OutBulkBuyingList) const;
	const TArray<class UJackUMGItemData*> GetKaziActionList() const;
	const TArray<class UJackUMGItemData*> GetMaterialItemList() const;
	TArray<class UJackUMGItemData*> GetNewRecipeList() const;
	const TArray<class UJackUMGItemData*> GetRecipeItemList() const;
	const class FName GetSaveCurrentBGMID() const;
	const TArray<class UJackUMGItemData*> GetUseMaterialItemList() const;
	bool IsCelectNewRecipeView() const;
	bool IsNewRecipe() const;
	bool IsNewRecipeView() const;
	bool IsSpecifiedDokodemoKaziTimePassed(float InPassedTime) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorFusigiKazi">();
	}
	static class UJackUMGAccessorFusigiKazi* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorFusigiKazi>();
	}
};
static_assert(alignof(UJackUMGAccessorFusigiKazi) == 0x000008, "Wrong alignment on UJackUMGAccessorFusigiKazi");
static_assert(sizeof(UJackUMGAccessorFusigiKazi) == 0x000468, "Wrong size on UJackUMGAccessorFusigiKazi");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, CreateCategoryType) == 0x000040, "Member 'UJackUMGAccessorFusigiKazi::CreateCategoryType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, PartsType) == 0x000041, "Member 'UJackUMGAccessorFusigiKazi::PartsType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, MaterialSpecialType) == 0x000042, "Member 'UJackUMGAccessorFusigiKazi::MaterialSpecialType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, CreateFrameType) == 0x000043, "Member 'UJackUMGAccessorFusigiKazi::CreateFrameType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, GameStatType) == 0x000044, "Member 'UJackUMGAccessorFusigiKazi::GameStatType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, SelectPartsList) == 0x000048, "Member 'UJackUMGAccessorFusigiKazi::SelectPartsList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, KaziPlayerCharacter) == 0x000058, "Member 'UJackUMGAccessorFusigiKazi::KaziPlayerCharacter' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, KaziInteractiveActor) == 0x000060, "Member 'UJackUMGAccessorFusigiKazi::KaziInteractiveActor' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, KaziAction) == 0x000080, "Member 'UJackUMGAccessorFusigiKazi::KaziAction' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, QualityAnalysis) == 0x000088, "Member 'UJackUMGAccessorFusigiKazi::QualityAnalysis' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, FusigiKaziParts) == 0x000090, "Member 'UJackUMGAccessorFusigiKazi::FusigiKaziParts' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, CaptureBP) == 0x000140, "Member 'UJackUMGAccessorFusigiKazi::CaptureBP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, SerifuWindowController) == 0x000148, "Member 'UJackUMGAccessorFusigiKazi::SerifuWindowController' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, RecipeItemList) == 0x0001B8, "Member 'UJackUMGAccessorFusigiKazi::RecipeItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, MaterialItemList) == 0x0001C8, "Member 'UJackUMGAccessorFusigiKazi::MaterialItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, UseMaterialItemList) == 0x0001D8, "Member 'UJackUMGAccessorFusigiKazi::UseMaterialItemList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, NeedMaterialList) == 0x0001E8, "Member 'UJackUMGAccessorFusigiKazi::NeedMaterialList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorFusigiKazi, NeedMaterialItemList) == 0x0001F8, "Member 'UJackUMGAccessorFusigiKazi::NeedMaterialItemList' has a wrong offset!");

// Class JackGame.JackUMGItemBagInfo
// 0x00A8 (0x00E0 - 0x0038)
class UJackUMGItemBagInfo final : public UObject
{
public:
	EJackItem_Bag                                 BagType;                                           // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         IndexInBag;                                        // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0048(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ListItemName;                                      // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   ItemYomi;                                          // 0x0078(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         ClassificationID;                                  // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ClassificationText;                                // 0x0098(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          IsEquipments;                                      // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B1[0x7];                                       // 0x00B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             SmallIcon;                                         // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Description;                                       // 0x00C0(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         InnerCount;                                        // 0x00D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_DC[0x4];                                       // 0x00DC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemBagInfo">();
	}
	static class UJackUMGItemBagInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemBagInfo>();
	}
};
static_assert(alignof(UJackUMGItemBagInfo) == 0x000008, "Wrong alignment on UJackUMGItemBagInfo");
static_assert(sizeof(UJackUMGItemBagInfo) == 0x0000E0, "Wrong size on UJackUMGItemBagInfo");
static_assert(offsetof(UJackUMGItemBagInfo, BagType) == 0x000038, "Member 'UJackUMGItemBagInfo::BagType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, IndexInBag) == 0x00003C, "Member 'UJackUMGItemBagInfo::IndexInBag' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ItemID) == 0x000040, "Member 'UJackUMGItemBagInfo::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ItemName) == 0x000048, "Member 'UJackUMGItemBagInfo::ItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ListItemName) == 0x000060, "Member 'UJackUMGItemBagInfo::ListItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ItemYomi) == 0x000078, "Member 'UJackUMGItemBagInfo::ItemYomi' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ClassificationID) == 0x000090, "Member 'UJackUMGItemBagInfo::ClassificationID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, ClassificationText) == 0x000098, "Member 'UJackUMGItemBagInfo::ClassificationText' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, IsEquipments) == 0x0000B0, "Member 'UJackUMGItemBagInfo::IsEquipments' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, SmallIcon) == 0x0000B8, "Member 'UJackUMGItemBagInfo::SmallIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, Description) == 0x0000C0, "Member 'UJackUMGItemBagInfo::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBagInfo, InnerCount) == 0x0000D8, "Member 'UJackUMGItemBagInfo::InnerCount' has a wrong offset!");

// Class JackGame.JackUMGShopItemSyousai
// 0x0008 (0x0120 - 0x0118)
class UJackUMGShopItemSyousai final : public UJackUMGItemSyousai
{
public:
	bool                                          bIsShopMamono;                                     // 0x0118(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShopOnlyOne;                                    // 0x0119(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsShopOpened;                                     // 0x011A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11B[0x1];                                      // 0x011B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExchangeCount;                                     // 0x011C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGShopItemSyousai">();
	}
	static class UJackUMGShopItemSyousai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGShopItemSyousai>();
	}
};
static_assert(alignof(UJackUMGShopItemSyousai) == 0x000008, "Wrong alignment on UJackUMGShopItemSyousai");
static_assert(sizeof(UJackUMGShopItemSyousai) == 0x000120, "Wrong size on UJackUMGShopItemSyousai");
static_assert(offsetof(UJackUMGShopItemSyousai, bIsShopMamono) == 0x000118, "Member 'UJackUMGShopItemSyousai::bIsShopMamono' has a wrong offset!");
static_assert(offsetof(UJackUMGShopItemSyousai, bIsShopOnlyOne) == 0x000119, "Member 'UJackUMGShopItemSyousai::bIsShopOnlyOne' has a wrong offset!");
static_assert(offsetof(UJackUMGShopItemSyousai, bIsShopOpened) == 0x00011A, "Member 'UJackUMGShopItemSyousai::bIsShopOpened' has a wrong offset!");
static_assert(offsetof(UJackUMGShopItemSyousai, ExchangeCount) == 0x00011C, "Member 'UJackUMGShopItemSyousai::ExchangeCount' has a wrong offset!");

// Class JackGame.JackUMGUIActionInfo
// 0x00D0 (0x0108 - 0x0038)
class UJackUMGUIActionInfo final : public UObject
{
public:
	class FName                                   ItemID;                                            // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ItemName;                                          // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FName                                   ActionID;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UsingActionID;                                     // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   UsingEvent;                                        // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ActionName;                                        // 0x0070(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	EJackActionIconType                           IconType;                                          // 0x0088(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_Classification                      ClassType;                                         // 0x0089(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGItemClassification                    UIClassType;                                       // 0x008A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackActionCategory                           ActionCategory;                                    // 0x008B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackUMGUIActionFlow                          FlowType;                                          // 0x008C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteField;                                     // 0x008D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bExecuteBattle;                                    // 0x008E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8F[0x1];                                       // 0x008F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Soubi;                                             // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionDamageID;                                    // 0x0098(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackActionDamageType                         DamageType;                                        // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ActionOddEffectID;                                 // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OddEffectID;                                       // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C0[0x10];                                      // 0x00C0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           DisplayOddEffectId;                                // 0x00D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_E0[0x1];                                       // 0x00E0(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsEnemyTarget;                                     // 0x00E1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackActionExtentType                         Extent;                                            // 0x00E2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E3[0x1];                                       // 0x00E3(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ExtentExtra;                                       // 0x00E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsWithoutSelf;                                     // 0x00E8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataIndex;                                         // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDougu;                                          // 0x00F0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsJumon;                                          // 0x00F1(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsContinuity;                                     // 0x00F2(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCanConsume;                                       // 0x00F3(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEquipped;                                       // 0x00F4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStoreEquipmentBag;                                // 0x00F5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          EquipmentInRegion;                                 // 0x00F6(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentMultiple                        EquipmentMultiple;                                 // 0x00F7(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          EquipmentRegion;                                   // 0x00F8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          MultipleEquipmentRegion;                           // 0x00F9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackEquipmentRegion                          ReleaseRegion;                                     // 0x00FA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackItem_EquipmentSE                         EquipmentSE;                                       // 0x00FB(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseMP;                                             // 0x00FC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UseGold;                                           // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsConsumableMP;                                   // 0x0104(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMPSyouhi0;                                      // 0x0105(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMPSyouhiZouka;                                  // 0x0106(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_107[0x1];                                      // 0x0107(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CalcMPSyouhi(EJackCharacter InCharaType);
	void SetIsJumon(bool IsJumon);

	void GetActionDescription(class FText* OutDescriptiont, EJackActionTextType InTextType, bool ListFlag) const;
	void GetActionDescriptionString(class FString* OutDescriptiont, EJackActionTextType TextType, bool ListFlag) const;
	bool IsActionId() const;
	bool IsBothHandsEquipment() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGUIActionInfo">();
	}
	static class UJackUMGUIActionInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGUIActionInfo>();
	}
};
static_assert(alignof(UJackUMGUIActionInfo) == 0x000008, "Wrong alignment on UJackUMGUIActionInfo");
static_assert(sizeof(UJackUMGUIActionInfo) == 0x000108, "Wrong size on UJackUMGUIActionInfo");
static_assert(offsetof(UJackUMGUIActionInfo, ItemID) == 0x000038, "Member 'UJackUMGUIActionInfo::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ItemName) == 0x000040, "Member 'UJackUMGUIActionInfo::ItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ActionID) == 0x000058, "Member 'UJackUMGUIActionInfo::ActionID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, UsingActionID) == 0x000060, "Member 'UJackUMGUIActionInfo::UsingActionID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, UsingEvent) == 0x000068, "Member 'UJackUMGUIActionInfo::UsingEvent' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ActionName) == 0x000070, "Member 'UJackUMGUIActionInfo::ActionName' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, IconType) == 0x000088, "Member 'UJackUMGUIActionInfo::IconType' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ClassType) == 0x000089, "Member 'UJackUMGUIActionInfo::ClassType' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, UIClassType) == 0x00008A, "Member 'UJackUMGUIActionInfo::UIClassType' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ActionCategory) == 0x00008B, "Member 'UJackUMGUIActionInfo::ActionCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, FlowType) == 0x00008C, "Member 'UJackUMGUIActionInfo::FlowType' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bExecuteField) == 0x00008D, "Member 'UJackUMGUIActionInfo::bExecuteField' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bExecuteBattle) == 0x00008E, "Member 'UJackUMGUIActionInfo::bExecuteBattle' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, Soubi) == 0x000090, "Member 'UJackUMGUIActionInfo::Soubi' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ActionDamageID) == 0x000098, "Member 'UJackUMGUIActionInfo::ActionDamageID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, DamageType) == 0x0000A0, "Member 'UJackUMGUIActionInfo::DamageType' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ActionOddEffectID) == 0x0000A8, "Member 'UJackUMGUIActionInfo::ActionOddEffectID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, OddEffectID) == 0x0000B0, "Member 'UJackUMGUIActionInfo::OddEffectID' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, DisplayOddEffectId) == 0x0000D0, "Member 'UJackUMGUIActionInfo::DisplayOddEffectId' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, IsEnemyTarget) == 0x0000E1, "Member 'UJackUMGUIActionInfo::IsEnemyTarget' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, Extent) == 0x0000E2, "Member 'UJackUMGUIActionInfo::Extent' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ExtentExtra) == 0x0000E4, "Member 'UJackUMGUIActionInfo::ExtentExtra' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, IsWithoutSelf) == 0x0000E8, "Member 'UJackUMGUIActionInfo::IsWithoutSelf' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, DataIndex) == 0x0000EC, "Member 'UJackUMGUIActionInfo::DataIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsDougu) == 0x0000F0, "Member 'UJackUMGUIActionInfo::bIsDougu' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsJumon) == 0x0000F1, "Member 'UJackUMGUIActionInfo::bIsJumon' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsContinuity) == 0x0000F2, "Member 'UJackUMGUIActionInfo::bIsContinuity' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bCanConsume) == 0x0000F3, "Member 'UJackUMGUIActionInfo::bCanConsume' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsEquipped) == 0x0000F4, "Member 'UJackUMGUIActionInfo::bIsEquipped' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bStoreEquipmentBag) == 0x0000F5, "Member 'UJackUMGUIActionInfo::bStoreEquipmentBag' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, EquipmentInRegion) == 0x0000F6, "Member 'UJackUMGUIActionInfo::EquipmentInRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, EquipmentMultiple) == 0x0000F7, "Member 'UJackUMGUIActionInfo::EquipmentMultiple' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, EquipmentRegion) == 0x0000F8, "Member 'UJackUMGUIActionInfo::EquipmentRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, MultipleEquipmentRegion) == 0x0000F9, "Member 'UJackUMGUIActionInfo::MultipleEquipmentRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, ReleaseRegion) == 0x0000FA, "Member 'UJackUMGUIActionInfo::ReleaseRegion' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, EquipmentSE) == 0x0000FB, "Member 'UJackUMGUIActionInfo::EquipmentSE' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, UseMP) == 0x0000FC, "Member 'UJackUMGUIActionInfo::UseMP' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, UseGold) == 0x000100, "Member 'UJackUMGUIActionInfo::UseGold' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsConsumableMP) == 0x000104, "Member 'UJackUMGUIActionInfo::bIsConsumableMP' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsMPSyouhi0) == 0x000105, "Member 'UJackUMGUIActionInfo::bIsMPSyouhi0' has a wrong offset!");
static_assert(offsetof(UJackUMGUIActionInfo, bIsMPSyouhiZouka) == 0x000106, "Member 'UJackUMGUIActionInfo::bIsMPSyouhiZouka' has a wrong offset!");

// Class JackGame.JackUMGItemQualityInfo
// 0x0058 (0x0090 - 0x0038)
class UJackUMGItemQualityInfo final : public UObject
{
public:
	int32                                         RecipeRank;                                        // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackItem_ParameterType>               MajorParamTypes;                                   // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FText>                           MajorParamNames;                                   // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FName>                           SpecalTextIds;                                     // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class FString>                         SpecalMessage;                                     // 0x0070(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGItemQualityParams>      QualityParams;                                     // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemQualityInfo">();
	}
	static class UJackUMGItemQualityInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemQualityInfo>();
	}
};
static_assert(alignof(UJackUMGItemQualityInfo) == 0x000008, "Wrong alignment on UJackUMGItemQualityInfo");
static_assert(sizeof(UJackUMGItemQualityInfo) == 0x000090, "Wrong size on UJackUMGItemQualityInfo");
static_assert(offsetof(UJackUMGItemQualityInfo, RecipeRank) == 0x000038, "Member 'UJackUMGItemQualityInfo::RecipeRank' has a wrong offset!");
static_assert(offsetof(UJackUMGItemQualityInfo, MajorParamTypes) == 0x000040, "Member 'UJackUMGItemQualityInfo::MajorParamTypes' has a wrong offset!");
static_assert(offsetof(UJackUMGItemQualityInfo, MajorParamNames) == 0x000050, "Member 'UJackUMGItemQualityInfo::MajorParamNames' has a wrong offset!");
static_assert(offsetof(UJackUMGItemQualityInfo, SpecalTextIds) == 0x000060, "Member 'UJackUMGItemQualityInfo::SpecalTextIds' has a wrong offset!");
static_assert(offsetof(UJackUMGItemQualityInfo, SpecalMessage) == 0x000070, "Member 'UJackUMGItemQualityInfo::SpecalMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGItemQualityInfo, QualityParams) == 0x000080, "Member 'UJackUMGItemQualityInfo::QualityParams' has a wrong offset!");

// Class JackGame.JackUMGAccessorMantan
// 0x01A8 (0x01E0 - 0x0038)
class UJackUMGAccessorMantan : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MantanRecoverLoopCount;                            // 0x0040(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         StandbyMemberCorrection;                           // 0x0044(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         SaveMpBorder;                                      // 0x0048(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ManyMpMemberCorrection;                            // 0x004C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RemineMpCorrection;                                // 0x0050(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         KaifukuMaryokuCorrection;                          // 0x0054(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int64                                         InverseCorrection;                                 // 0x0058(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         RecoverToStandbyCorrection;                        // 0x0060(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDisplayMantanMassage;                             // 0x0064(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bUseMultiThread;                                   // 0x0065(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_66[0x2];                                       // 0x0066(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         EisyoSeWaitTime;                                   // 0x0068(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         MantanWaitTime;                                    // 0x006C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugUncheckMpValue;                              // 0x0070(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugOutputMantanLog;                             // 0x0071(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugOutputActionInfoListLog;                     // 0x0072(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bDebugMinimumRecover;                              // 0x0073(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_74[0x64];                                      // 0x0074(0x0064)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackFriendGameCharacter*>       CacheMemberList;                                   // 0x00D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_E8[0xB8];                                      // 0x00E8(0x00B8)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackGameCharacter*                     TreatCaster;                                       // 0x01A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackGameCharacter*                     TreatTarget;                                       // 0x01A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1B0[0x30];                                     // 0x01B0(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugExecCheatCommand();
	void DebugSetMemberHp1();
	void DebugSetMemberMaxHp(EJackCharacter CharacterType, int32 MaxHP);
	void ExecuteMantanCommand(bool bInNearlyFull, TDelegate<void()> EndEvent);
	void JackMantanCommandEndDelegate__DelegateSignature();
	bool IsExecutableMantanCommand(bool bInNearlyFull, bool bInDontCheckParam, bool bInDontCheckAction, bool bInOnlyCheckActionLearned);
	void OnMantanMessageEnd();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorMantan">();
	}
	static class UJackUMGAccessorMantan* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorMantan>();
	}
};
static_assert(alignof(UJackUMGAccessorMantan) == 0x000008, "Wrong alignment on UJackUMGAccessorMantan");
static_assert(sizeof(UJackUMGAccessorMantan) == 0x0001E0, "Wrong size on UJackUMGAccessorMantan");
static_assert(offsetof(UJackUMGAccessorMantan, MantanRecoverLoopCount) == 0x000040, "Member 'UJackUMGAccessorMantan::MantanRecoverLoopCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, StandbyMemberCorrection) == 0x000044, "Member 'UJackUMGAccessorMantan::StandbyMemberCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, SaveMpBorder) == 0x000048, "Member 'UJackUMGAccessorMantan::SaveMpBorder' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, ManyMpMemberCorrection) == 0x00004C, "Member 'UJackUMGAccessorMantan::ManyMpMemberCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, RemineMpCorrection) == 0x000050, "Member 'UJackUMGAccessorMantan::RemineMpCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, KaifukuMaryokuCorrection) == 0x000054, "Member 'UJackUMGAccessorMantan::KaifukuMaryokuCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, InverseCorrection) == 0x000058, "Member 'UJackUMGAccessorMantan::InverseCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, RecoverToStandbyCorrection) == 0x000060, "Member 'UJackUMGAccessorMantan::RecoverToStandbyCorrection' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bDisplayMantanMassage) == 0x000064, "Member 'UJackUMGAccessorMantan::bDisplayMantanMassage' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bUseMultiThread) == 0x000065, "Member 'UJackUMGAccessorMantan::bUseMultiThread' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, EisyoSeWaitTime) == 0x000068, "Member 'UJackUMGAccessorMantan::EisyoSeWaitTime' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, MantanWaitTime) == 0x00006C, "Member 'UJackUMGAccessorMantan::MantanWaitTime' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bDebugUncheckMpValue) == 0x000070, "Member 'UJackUMGAccessorMantan::bDebugUncheckMpValue' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bDebugOutputMantanLog) == 0x000071, "Member 'UJackUMGAccessorMantan::bDebugOutputMantanLog' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bDebugOutputActionInfoListLog) == 0x000072, "Member 'UJackUMGAccessorMantan::bDebugOutputActionInfoListLog' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, bDebugMinimumRecover) == 0x000073, "Member 'UJackUMGAccessorMantan::bDebugMinimumRecover' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, CacheMemberList) == 0x0000D8, "Member 'UJackUMGAccessorMantan::CacheMemberList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, TreatCaster) == 0x0001A0, "Member 'UJackUMGAccessorMantan::TreatCaster' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMantan, TreatTarget) == 0x0001A8, "Member 'UJackUMGAccessorMantan::TreatTarget' has a wrong offset!");

// Class JackGame.JackUMGManager
// 0x05D8 (0x0610 - 0x0038)
class UJackUMGManager : public UObject
{
public:
	TSubclassOf<class UJackUMGWidgetBase>         RootWidgetClass;                                   // 0x0038(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         RenkeiSkipWidgetClass;                             // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HorseEnergyWidgetClass;                            // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudStatusWidgetClass;                              // 0x0050(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudStatus8WidgetClass;                             // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         BattleResultWidgetClass;                           // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         TheaterWidgetClass;                                // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         NakamaKaiwaButtonWidgetClass;                      // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudSibariplayClass;                                // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         GoldWindowWidgetClass;                             // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         BaisokuModeWidgetClass;                            // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudFukidasiBattleClass;                            // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudScenarioFukidasiBattleClass;                    // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         HudScenarioFukidasiBattleLClass;                   // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         MiniMapWidgetClass;                                // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         ManualSaveWidgetClass;                             // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         AutoSaveWidgetClass;                               // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         FailedSaveWidgetClass;                             // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         FadeWidgetClass;                                   // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         ChapterWidgetClass;                                // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MedalStampWidgetClass;                             // 0x00D8(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   SibariTasseiWidgetClass;                           // 0x00F0(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayGo000WidgetClass;                              // 0x0108(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   PlayGo001WidgetClass;                              // 0x0120(0x0018)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         MapHelpButtonWidgetClass;                          // 0x0138(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         QuestClearWidgetClass;                             // 0x0140(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         CasinoCoin000WidgetClass;                          // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         CasinoCoin001WidgetClass;                          // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         Syuurenjou004WidgetClass;                          // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         BoukenStepWidgetClass;                             // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         StaffRollWidgetClass;                              // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowController> SerifuWindowControllerClass;                       // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowController> TenNoKoeWindowControllerClass;                     // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowController> BattleMessageControllerClass;                      // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowController> TokugiPanelMessageControllerClass;                 // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowController> MovieMessageControllerClass;                       // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGFukidasiWindowController> FukidasiWindowControllerClass;                     // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSerifuWindowResources> SerifuWindowResourcesClass;                        // 0x01A0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGMapController>      MapControllerClass;                                // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGHudWindows>         HudWindowsClass;                                   // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackTokugiPanelSetting>    TokugiPanelSettingClass;                           // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGSoundSet>           SoundSetClass;                                     // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGAccessorCommon>     AccessorCommonClass;                               // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGAccessorItem>       AccessorItemClass;                                 // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGAccessorMembers>    AccessorMembersClass;                              // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGAccessorMantan>     AccessorMantanClass;                               // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGAccessorCoordinate> AccessorCoordinateClass;                           // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class UJackUMGLoadMenuAssetData>> MenuAssetDataClasses;                              // 0x01F0(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class UJackUMGLoadMenuAssetData*>      MenuAssetDataList;                                 // 0x0200(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         DisplayUserWidgetClass;                            // 0x0210(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         RemoveUserWidgetClass;                             // 0x0218(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         PairingButtonWidgetClass;                          // 0x0220(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UJackUMGWidgetBase>         RemoveControllerWidgetClass;                       // 0x0228(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0x8];                                      // 0x0230(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGMapController*                  MapController;                                     // 0x0238(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_240[0x8];                                      // 0x0240(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   TitleBGMEndDelegate;                               // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UJackUMGWidgetBase*                     NullWindowRef;                                     // 0x0258(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                WorldObject;                                       // 0x0260(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGWidgetBase*                     RootWidget;                                        // 0x0268(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UPanelWidget*                           RootWidgetRootPanel;                               // 0x0270(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGWidgetBase*                     OpendMenuWidget;                                   // 0x0278(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUMGMenuId                                OpendMenuId;                                       // 0x0280(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MenuResultIndex;                                   // 0x0284(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUMGMenuBGMode                            MenuBGMode;                                        // 0x0288(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MenuBGCaptionId;                                   // 0x0290(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TDelegate<void(EJackUMGMenuId InMenuId, class FName InArgName, int32 InArgValue)> JackOnUMGOpenMenuDelegate;                         // 0x0298(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	TDelegate<void(EJackUMGCutSceneSkipEvent InEventType, bool bInFlag)> CSSkipDelegate;                                    // 0x02A8(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FLinearColor                           WidgetEnableColor;                                 // 0x02B8(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FLinearColor                           WidgetDisableColor;                                // 0x02C8(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGSoundSet*                       SoundSet;                                          // 0x02D8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          IsEnableMenuWindowAnimation;                       // 0x02E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsModernUIMode;                                   // 0x02E1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2E2[0x2];                                      // 0x02E2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultFadeZOrder;                                 // 0x02E4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         ForegroundFadeZOrder;                              // 0x02E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         MessageFadeZOrder;                                 // 0x02EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         CSSkipZOrder;                                      // 0x02F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2F4[0xC];                                      // 0x02F4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UJackUMGManagerSetting>     UMGManagerCommonClass;                             // 0x0300(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGManagerSetting*                 UMGManagerCommon;                                  // 0x0308(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_310[0x50];                                     // 0x0310(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGWidgetBase*>             DeleteList;                                        // 0x0360(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGWidgetBase*>             WidgetList;                                        // 0x0370(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGWidgetBase*>             ViewportList;                                      // 0x0380(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGWidgetBase*>             OpenWidgetList;                                    // 0x0390(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGMenu*>                   MenuStack;                                         // 0x03A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackUMGMenu*                           NewOpenMenu;                                       // 0x03B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3B8[0x8];                                      // 0x03B8(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGPage*>                   MenuPageList;                                      // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackUMGPage*                           PageInFocus;                                       // 0x03D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGPage*>                   MenuPageListAtException;                           // 0x03D8(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackUMGPage*                           PageInFocusAtException;                            // 0x03E8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3F0[0x10];                                     // 0x03F0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGAnimSet>                PresetAnimTable;                                   // 0x0400(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FLinearColor>                   PresetColorTable;                                  // 0x0410(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackUMGWidgetBase*                     TargetSnapWidget;                                  // 0x0420(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGWidgetBase*                     InsertWidgetBase;                                  // 0x0428(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_430[0x10];                                     // 0x0430(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGAccessorCommon*                 AccessorCommon;                                    // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorSaveData*               AccessorSaveData;                                  // 0x0448(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorItem*                   AccessorItem;                                      // 0x0450(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorMembers*                AccessorMembers;                                   // 0x0458(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorShop*                   AccessorShop;                                      // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorSenreki*                AccessorSenreki;                                   // 0x0468(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorFusigiKazi*             AccessorFusigiKazi;                                // 0x0470(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorMantan*                 AccessorMantan;                                    // 0x0478(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorBattle*                 AccessorBattle;                                    // 0x0480(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorSyuurenjou*             AccessorSyuurenjou;                                // 0x0488(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGAccessorCoordinate*             AccessorCoordinate;                                // 0x0490(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGHudWindows*                     HudWindows;                                        // 0x0498(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         SerifuWindowController;                            // 0x04A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         TenNoKoeWindowController;                          // 0x04A8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         BattleMessageController;                           // 0x04B0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         TokugiPanelMessageController;                      // 0x04B8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGSerifuWindowController*         MovieMessageController;                            // 0x04C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGFukidasiWindowController*       FukidasiWindowController;                          // 0x04C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackTokugiPanelSetting*                TokugiPanelSetting;                                // 0x04D0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FJackUMGItemDataAllocator              ItemDataAllocator;                                 // 0x04D8(0x0028)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_500[0x34];                                     // 0x0500(0x0034)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugFixupWaitTime;                                // 0x0534(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_538[0x20];                                     // 0x0538(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGAsyncLoadUserWidgetResult*> AsyncLoadUserWidgetResultList;                     // 0x0558(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UJackUMGAsyncLoad*>              AsyncLoadQueue;                                    // 0x0568(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_578[0x4];                                      // 0x0578(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         NumLoadTextureCached;                              // 0x057C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<struct FJackUMGLoadedCache>            LoadedCacheList;                                   // 0x0580(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_590[0x8];                                      // 0x0590(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGLoadMenuAssetsInfo>     LoadMenuAssetsList;                                // 0x0598(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_5A8[0x68];                                     // 0x05A8(0x0068)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UJackUMGWidgetBase* AddUMGConnectWidgetWithClass(TSubclassOf<class UJackUMGWidgetBase> WidgetType, EJackUMGWidgetConnectTarget InConnectTarget, bool IsNewPage, bool IsFocus);
	class UJackUMGWidgetBase* AddUMGMenuWidgetIfNotGet(const class FName InWidgetName, TSubclassOf<class UJackUMGWidgetBase> InWidgetType, const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType, bool IsFocus);
	class UJackUMGWidgetBase* AddUMGMenuWithSnap(TSubclassOf<class UJackUMGWidgetBase> InWidgetType, const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType, bool IsFocus);
	class UJackUMGWidgetBase* AddUMGMenuWithSnapReusable(TSubclassOf<class UJackUMGWidgetBase> InWidgetType, class UJackUMGWidgetBase* InReusableWidget, const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType, bool IsFocus);
	EJackUMGMenuLoadResult AsyncLoadMenu(EJackUMGMenuId InLoadMenuId);
	int32 AsyncLoadTexture(TSoftObjectPtr<class UTexture> InTextureAsset, TDelegate<void(int32 InResultCode, class UObject* InLoaddedObject, class UJackUMGAsyncLoad* InLoadInfo)> InComprateDelegate, bool bIsCached);
	void AsyncUMGOnMenuWidgetLoadCompletion(int32 InResultCode, class UObject* InLoadObject, class UJackUMGAsyncLoad* InLoadInfo);
	void AsyncUMGOnRootWidgetLoadCompletion(int32 InResultCode, class UObject* InLoadObject, class UJackUMGAsyncLoad* InLoadInfo);
	void AsyncUMGOnUserWidgetLoadCompletion(int32 InResultCode, class UObject* InLoadObject, class UJackUMGAsyncLoad* InLoadInfo);
	void AsyncUMGRootWidgetWithClass(class UObject* WorldContextObject, TSoftClassPtr<class UClass> InWidgetType, const struct FLatentActionInfo& LatentInfo);
	void AsyncUMGUserWidgetWithClass(class UObject* Target, TSoftClassPtr<class UClass> InWidgetType, const struct FLatentActionInfo& LatentInfo, class UJackUMGAsyncLoadUserWidgetResult** Result);
	void CancelASyncLoad(int32 InLoadUniqueId);
	void CancelAsyncUMGUserWidget(class UObject* Target);
	void CancelUISound();
	class FName CheckEquipment(EJackCharacter InCharType, int32 InIndexInBag, EJackEquipmentRegion InRegion);
	void ClearKeyStatus();
	int32 ClearLoadedMenuAssets(EJackUMGMenuId InLoadMenuId);
	void CloseAllMenu(bool IsCompleteByDestructed);
	void CloseBaisokuMode();
	void CloseBattleResultWindow();
	void CloseCutSceneSkipDialog();
	void CloseGamerTagMenu();
	void CloseGoldWindow();
	void CloseHudBoukenStep();
	void CloseHudFukidasiBattleScenarioWindow(class FName WindowName);
	void CloseHudStatus();
	void CloseHudStatusNoAnimation();
	void CloseLocalMap();
	void CloseMapHelpButton();
	void CloseMenu(bool IsCompleteByDestructed);
	void CloseMiniMap(bool bRemoveWidget, bool bIsForceRemove);
	void CloseNakamaKaiwaButton();
	void CloseNorimonoGauge();
	void CloseSibariplayStatus();
	void CloseTheaterWindow();
	void CloseWorldMap();
	void ComplateFixupMessage();
	void CompletedMenuLatent();
	class UJackUMGLoadBrushBase* CreateLoadMaterial(class UWidget* InImagePanel, TSoftObjectPtr<class UMaterialInstance> InMaterialAsset);
	class UJackUMGLoadBrushBase* CreateLoadTexture(class UWidget* InImagePanel, TSoftObjectPtr<class UTexture> InTextureAsset);
	void DebugFunction(int32 InDebugValue, const class FString& InDebugText);
	void DefaultKeyRepeatSetting();
	void DisplayModeSelectCameraInfo();
	void DisplayPressedKeyLog(bool IsShow);
	void DisplayUIEventLog(bool IsShow);
	void DoCutSceneSkipDialogDelegate(EJackUMGCutSceneSkipEvent InEventType, bool bInFlag);
	void DoFieldAction(TDelegate<void(bool bIsCustomFlow)> InDelegate);
	void JackUMGFinishedFieldActionDelegate__DelegateSignature(bool bIsCustomFlow);
	void DoRuraAction(class UObject* WorldContextObject, EJackRuraPurpose InPurpose, class FName InJumpTag, EJackItem_Bag InBagType, int32 IndexInBag, EJackCharacter InCharaType);
	void EndBGM();
	void FinishedFieldAction(bool bIsCustomFlow);
	void FocusUMGWidgetByName(const class FName InWidgetName);
	void FocusUMGWidgetByWidgetRef(class UJackUMGWidgetBase* Widget);
	class UJackUMGSerifuWindowController* GetBattleMessageController();
	class UTexture2D* GetCommonButtonIcon(const EJackKeys InKeyType);
	class UJackUMGFukidasiWindowController* GetFukidasiWindowController();
	class FName GetMenuTextId(const class FName MenuTextId);
	class UJackUMGSerifuWindowController* GetMovieMessageController();
	class UJackUMGSerifuWindowController* GetSerifuWindowController();
	struct FLinearColor GetSyougouWindowColor(EJackUMGSyougouColor InSyougouType);
	class UJackUMGSerifuWindowController* GetTenNoKoeWindowController();
	class UJackUMGSerifuWindowController* GetTokugiPanelMessageController();
	const class FText GetUMGMenuTextFromTextId(const class FName MenuTextId);
	const struct FJackUMGAnimSet GetUMGPresetAnimSet(EJackUMGPresetAnim InPresetType);
	const struct FLinearColor GetUMGPresetColor(EJackUMGPresetColor InColorType);
	class UJackUMGWidgetBase* GetUMGWidgetFromName(const class FName InWidgetName);
	class UJackUMGWidgetBase* GetUMGWidgetInFocus();
	bool HasUMGWidgetInFocus();
	void HideForceWalkingLoadingWidget();
	void HideMenu();
	void HideUMGWidgetByWidgetRef(class UJackUMGWidgetBase* Widget);
	void InitializeXboxOnePairing();
	void InitUMGPresetAnimSet(const TArray<struct FJackUMGAnimSet>& AnimSetArray);
	void InputDelegate(struct FJackUIInputDelegateInfo* InDelegateInfo);
	class UJackUMGWidgetBase* InsertUMGMenuWithSnap(TSubclassOf<class UJackUMGWidgetBase> InWidgetType, const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType, bool IsFocus);
	class UJackUMGWidgetBase* InsertUMGMenuWithSnapReusable(TSubclassOf<class UJackUMGWidgetBase> InWidgetType, class UJackUMGWidgetBase* InReusableWidget, const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType, bool IsFocus);
	bool IsOpenedHudStatus();
	bool IsOpenPairingMenu();
	bool IsUMGWidgetFromName(const class FName InWidgetName);
	void JackOnUMGManagerTitleBGMEndDelegate__DelegateSignature();
	void JackOnUMGOpenMenuDelegate__DelegateSignature(EJackUMGMenuId InMenuId, const class FName InArgName, int32 InArgValue);
	void JackUMGCSSkipDelegate__DelegateSignature(EJackUMGCutSceneSkipEvent InEventType, bool bInFlag);
	class UUserWidget* LoadUMGUserWidgetWithClass(TSoftClassPtr<class UClass> InWidgetType);
	void OpenBaisokuMode();
	void OpenBattleResultWindow(EJackCharacter InCharType, int32 InBeforeLevel, int32 InAfterLevel);
	void OpenCutSceneSkipDialog(TDelegate<void(EJackUMGCutSceneSkipEvent InEventType, bool bInFlag)> InDelegate, EJackUMGCutSceneSkipDialog InSCSkipType, bool bInWithAutoFeed);
	void OpenGoldWindow(bool IsDisplayedInFront);
	void OpenHudBoukenStep(const int32 InStepNumber, const int32 InStepNumber2);
	class UJackUMGHudFukidasiBattleScenario* OpenHudFukidasiBattleScenarioWindow(class FName WindowName);
	void OpenHudStatus(bool IsFieldDamage);
	void OpenLocalMap();
	void OpenMapHelpButton();
	class UJackUMGWidgetBase* OpenMenu(EJackUMGMenuId InOpenMenuId, const class FName InNameId, int32 InValue, bool IsNoStack);
	void OpenMiniMap();
	void OpenNakamaKaiwaButton();
	void OpenNorimonoGauge(const EJackVehicle InVehicleType, const int32 InUmaGaugeCount);
	void OpenNorimonoGaugeCalledNorimono(const EJackUMGNorimonoGauge InType);
	void OpenOpeningMovieSubTitleWidget();
	void OpenSibariplayStatus();
	void OpenTheaterWindow(class UMaterialInterface* InMaterial);
	void OpenToBeContinuedWidget();
	void OpenWorldMap(EJackWorldMapOpenReason OpenReason, bool bNoStack);
	void OpenWorldMapFromMenu();
	void PlayUISound(class USoundBase* InSoundBase, int32 MonophonicId);
	void PlayUISoundWithParam(class USoundBase* InSoundBase, int32 MonophonicId, float InVolume, float InPitch, float InStartTime);
	void RemoveUMGWidget(class UJackUMGWidgetBase* Widget, bool bCloseChildPage, bool bRefreshFoucs, bool IsAcceptNullptr);
	void RemoveUMGWidgetByName(const class FName InWidgetName, bool bCloseChildPage, bool bRefreshFoucs, bool IsAcceptNullptr);
	void ReserveGC();
	void ResetKetteiReversFlag();
	void SetActionNorimonoGauge(const EJackUMGNorimonoGaugeAction InAction);
	void SetCharacterImmediatelyBeforeLevelup(EJackCharacter InCharType);
	void SetCursorSave(EJackCursorSaveScene InSceneType, EJackCharacter InCharType, EJackCursorSaveTarget InSaveTarget, const class FName& InNameId, int32 InIndex);
	void SetDefaultUndilatedFrameTime();
	void SetDisplayDebugSelectedItem();
	void SetEnterButtonRevers(bool IsEnterReverse);
	void SetFacilityModeOfSerifuWindow(bool bEnd);
	void SetFadeWidget(class UJackUMGWidgetBase* Widget, class FName WidgetName, int32 ZOrder, float FadeAlpha, const struct FLinearColor& FadeColor);
	void SetFieldActionFinishDelegate(TDelegate<void(bool bIsCustomFlow)> InDelegate);
	void SetHudStatusEffect(EJackPopupBalloon InBalloonType, class UJackGameCharacter* InGameCharacter);
	void SetMapHelpDisableColor(bool InFlag);
	void SetMaxUndilatedFrameTime();
	void SetMenuBackgroundCaption(const class FName InTextId);
	void SetMenuBackgroundType(EJackUMGMenuBGMode InMenuBGMode);
	void SetMenuLayout(EJackUMGMenuLayout InLayoutType, EJackUMGHudRegion InRegionType, bool bIsForceMenuLayout);
	void SetMessageSpeedSetting(EJackSpeed MessageSpeed);
	void SetModeSelectCameraPlayWait(int32 InValue);
	void SetModeSelectCameraWait(int32 InValue);
	void SetNamaeInputOffsetX(float InOffset);
	void SetRenkeiHudAnime(TArray<int32>* InMemberList, EJackUMGHudAnimationAction InAnimeType);
	void SetSnapTargetWidget(const class UJackUMGWidgetBase* InTargetWidget, EJackUMGSnapType InSnapType);
	void SetTheaterWindow(const struct FLinearColor& InStripeColor, float InStripeWidth);
	void SetTitleDelayTime(float InTime);
	void SetTitleFadeColorWhite(bool InFlag);
	void SetTitleFadeTime(float InTime);
	void SetUIDisableCamera(bool IsDisable, bool IsForceSet);
	void SetUMGPresetAnimSet(EJackUMGPresetAnim InPresetType, const struct FJackUMGAnimSet& InAnimSet);
	void SetVisibility(bool bIsVisible);
	void SetVisibilityBaisokuMode(ESlateVisibility InType);
	class UJackUMGWidgetBase* ShowChapterTitle(const class FName TextID);
	void ShowCutSceneSkipDialog(EJackUMGCutSceneSkipDialog InSCSkipType);
	void ShowForceWalkingLoadingWidget();
	void ShowLocationTitle(bool bIsShort);
	void ShowMenu();
	void ShowSavingIndicator(EJackUMGSaveingIndicator InSavingType);
	void ShowSmallLocationTitle(bool bIsShow);
	void ShowUMGWidgetByWidgetRef(class UJackUMGWidgetBase* Widget);
	class UJackUMGWidgetBase* StartStaffRoll();
	void StopUISound(class USoundBase* InSoundBase);
	void SyncLoadBrush(const TArray<class UJackUMGLoadBrushBase*>& InLoadBrushArray);
	void SyncLoadMaterial(class UWidget* InImagePanel, TSoftObjectPtr<class UMaterialInstance> InMaterialAsset);
	bool SyncLoadTexture(class UWidget* InImagePanel, TSoftObjectPtr<class UTexture> InTextureAsset, bool bIsCached);
	void UnFocusUMGWidget();
	void UpdateGoldWindow();
	void UpdateKeyRepeatSetting(const struct FJackUIKeyRepeatSetting& InSetting);
	void WaitToAsyncFixup(class UObject* WorldContextObject, EJackCharacter InCharacterType, bool IsComplateMessage, const struct FLatentActionInfo& LatentInfo);
	void WaitToEndMenu(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);
	void WaitToEndWidget(class UJackUMGWidgetBase* WaitWidget, const struct FLatentActionInfo& LatentInfo);

	EJackKeys ConvertKeyEventCircleCrossButton(EJackKeys InKeyType) const;
	EJackKeys ConvertKeyEventVoiceDrama(EJackKeys InKeyType, EJackUMGVoiceDramaMode InMode) const;
	const class FText Get2ByteDecText(int32 InValue, int32 InFig, bool InChar, bool IsComma, bool IsSign) const;
	class UJackUMGAccessorBattle* GetAccessorBattle() const;
	class UJackUMGAccessorCommon* GetAccessorCommon() const;
	class UJackUMGAccessorCoordinate* GetAccessorCoordinate() const;
	class UJackUMGAccessorFusigiKazi* GetAccessorFusigiKazi() const;
	class UJackUMGAccessorItem* GetAccessorItem() const;
	class UJackUMGAccessorMantan* GetAccessorMantan() const;
	class UJackUMGAccessorMembers* GetAccessorMembers() const;
	class UJackUMGAccessorSaveData* GetAccessorSaveData() const;
	class UJackUMGAccessorSenreki* GetAccessorSenreki() const;
	class UJackUMGAccessorShop* GetAccessorShop() const;
	class UJackUMGAccessorSyuurenjou* GetAccessorSyuurenjou() const;
	const class FText GetAsciiDecText(int32 InValue, int32 InFig, bool InChar, bool IsComma, bool IsSign) const;
	const class FText GetAsciiDecText2Value(int32 InValue, int32 InValueMax, int32 InFig, bool InChar, bool IsComma, bool IsSign) const;
	class UJackUMGWidgetBase* GetAsyncLoadedWidget() const;
	int32 GetCloseMenuIndex() const;
	struct FJackUMGCursorSaveTarget GetCursorSave(EJackCursorSaveScene InSceneType, EJackCharacter InCharType, EJackCursorSaveTarget InSaveTarget) const;
	const class FText GetDecMenuText(int32 InValue, int32 InFig, const class FName InUnitTextId, bool IsSign, bool IsComma, bool InZeroAlign) const;
	const class FString GetDecMessageString(int32 InValue, int32 InFig, const class FName InUnitTextId, bool IsSign, bool IsComma, bool InZeroAlign) const;
	const struct FJackUMGFontColor GetFontColor(const EJackUMGTextColorSet InColorType) const;
	class AJackHUD* GetHUD() const;
	class UJackUMGHudWindows* GetHudWindows() const;
	EJackSpeed GetMessageSpeedSetting() const;
	float GetNamaeInputOffsetX() const;
	const struct FJackUMGFontColor GetNameFontColor(const EJackUMGTextColorSet InColorType) const;
	EJackUMGMenuId GetOpenMenuId() const;
	class UJackUMGWidgetBase* GetPrevPageWidget(const class UJackUMGWidgetBase* InWidgetBase) const;
	const class FText GetRealText(float InValue, int32 InFig, const class FName InUnitTextId, bool InChar, bool IsComma, bool IsSign, bool Is2Byte) const;
	class UJackUMGSoundSet* GetSoundSet() const;
	float GetTitleDelayTime() const;
	float GetTitleFadeTime() const;
	class UJackTokugiPanelSetting* GetTokugiPanelSetting() const;
	class FString GetUMGMenuStringFromTextId(const class FName MenuTextId) const;
	class FText GetUMGMenuTextFromTextIdInList(const class FName InMenuTextId, bool IsList) const;
	bool IsArasuziDebug() const;
	EJackUMGMenuLoadResult IsComplatedLoadMenu(EJackUMGMenuId InLoadMenuId) const;
	bool IsDebugMode() const;
	bool IsDeluxMode() const;
	bool IsDisplayDebugMenuInfo() const;
	bool IsDisplayDebugMenuList() const;
	bool IsDisplayModeSelectCameraInfo() const;
	bool IsInitialized() const;
	bool IsLoadDataTrial() const;
	bool IsLocalMapOpened() const;
	bool IsMapHelpDisableColor() const;
	bool IsMenuHidden() const;
	bool IsMiniMapOpened() const;
	bool IsModernUIMode() const;
	bool IsOpenedMenu() const;
	bool IsTitleFadeColorWhite() const;
	bool IsWorldMapOpened() const;
	bool KeyDirectFlag(const EJackKeys InKeyType) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGManager">();
	}
	static class UJackUMGManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGManager>();
	}
};
static_assert(alignof(UJackUMGManager) == 0x000008, "Wrong alignment on UJackUMGManager");
static_assert(sizeof(UJackUMGManager) == 0x000610, "Wrong size on UJackUMGManager");
static_assert(offsetof(UJackUMGManager, RootWidgetClass) == 0x000038, "Member 'UJackUMGManager::RootWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, RenkeiSkipWidgetClass) == 0x000040, "Member 'UJackUMGManager::RenkeiSkipWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HorseEnergyWidgetClass) == 0x000048, "Member 'UJackUMGManager::HorseEnergyWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudStatusWidgetClass) == 0x000050, "Member 'UJackUMGManager::HudStatusWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudStatus8WidgetClass) == 0x000058, "Member 'UJackUMGManager::HudStatus8WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, BattleResultWidgetClass) == 0x000060, "Member 'UJackUMGManager::BattleResultWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TheaterWidgetClass) == 0x000068, "Member 'UJackUMGManager::TheaterWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, NakamaKaiwaButtonWidgetClass) == 0x000070, "Member 'UJackUMGManager::NakamaKaiwaButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudSibariplayClass) == 0x000078, "Member 'UJackUMGManager::HudSibariplayClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, GoldWindowWidgetClass) == 0x000080, "Member 'UJackUMGManager::GoldWindowWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, BaisokuModeWidgetClass) == 0x000088, "Member 'UJackUMGManager::BaisokuModeWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudFukidasiBattleClass) == 0x000090, "Member 'UJackUMGManager::HudFukidasiBattleClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudScenarioFukidasiBattleClass) == 0x000098, "Member 'UJackUMGManager::HudScenarioFukidasiBattleClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudScenarioFukidasiBattleLClass) == 0x0000A0, "Member 'UJackUMGManager::HudScenarioFukidasiBattleLClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MiniMapWidgetClass) == 0x0000A8, "Member 'UJackUMGManager::MiniMapWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, ManualSaveWidgetClass) == 0x0000B0, "Member 'UJackUMGManager::ManualSaveWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AutoSaveWidgetClass) == 0x0000B8, "Member 'UJackUMGManager::AutoSaveWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, FailedSaveWidgetClass) == 0x0000C0, "Member 'UJackUMGManager::FailedSaveWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, FadeWidgetClass) == 0x0000C8, "Member 'UJackUMGManager::FadeWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, ChapterWidgetClass) == 0x0000D0, "Member 'UJackUMGManager::ChapterWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MedalStampWidgetClass) == 0x0000D8, "Member 'UJackUMGManager::MedalStampWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SibariTasseiWidgetClass) == 0x0000F0, "Member 'UJackUMGManager::SibariTasseiWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PlayGo000WidgetClass) == 0x000108, "Member 'UJackUMGManager::PlayGo000WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PlayGo001WidgetClass) == 0x000120, "Member 'UJackUMGManager::PlayGo001WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MapHelpButtonWidgetClass) == 0x000138, "Member 'UJackUMGManager::MapHelpButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, QuestClearWidgetClass) == 0x000140, "Member 'UJackUMGManager::QuestClearWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, CasinoCoin000WidgetClass) == 0x000148, "Member 'UJackUMGManager::CasinoCoin000WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, CasinoCoin001WidgetClass) == 0x000150, "Member 'UJackUMGManager::CasinoCoin001WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, Syuurenjou004WidgetClass) == 0x000158, "Member 'UJackUMGManager::Syuurenjou004WidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, BoukenStepWidgetClass) == 0x000160, "Member 'UJackUMGManager::BoukenStepWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, StaffRollWidgetClass) == 0x000168, "Member 'UJackUMGManager::StaffRollWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SerifuWindowControllerClass) == 0x000170, "Member 'UJackUMGManager::SerifuWindowControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TenNoKoeWindowControllerClass) == 0x000178, "Member 'UJackUMGManager::TenNoKoeWindowControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, BattleMessageControllerClass) == 0x000180, "Member 'UJackUMGManager::BattleMessageControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TokugiPanelMessageControllerClass) == 0x000188, "Member 'UJackUMGManager::TokugiPanelMessageControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MovieMessageControllerClass) == 0x000190, "Member 'UJackUMGManager::MovieMessageControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, FukidasiWindowControllerClass) == 0x000198, "Member 'UJackUMGManager::FukidasiWindowControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SerifuWindowResourcesClass) == 0x0001A0, "Member 'UJackUMGManager::SerifuWindowResourcesClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MapControllerClass) == 0x0001A8, "Member 'UJackUMGManager::MapControllerClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudWindowsClass) == 0x0001B0, "Member 'UJackUMGManager::HudWindowsClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TokugiPanelSettingClass) == 0x0001B8, "Member 'UJackUMGManager::TokugiPanelSettingClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SoundSetClass) == 0x0001C0, "Member 'UJackUMGManager::SoundSetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorCommonClass) == 0x0001C8, "Member 'UJackUMGManager::AccessorCommonClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorItemClass) == 0x0001D0, "Member 'UJackUMGManager::AccessorItemClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorMembersClass) == 0x0001D8, "Member 'UJackUMGManager::AccessorMembersClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorMantanClass) == 0x0001E0, "Member 'UJackUMGManager::AccessorMantanClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorCoordinateClass) == 0x0001E8, "Member 'UJackUMGManager::AccessorCoordinateClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuAssetDataClasses) == 0x0001F0, "Member 'UJackUMGManager::MenuAssetDataClasses' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuAssetDataList) == 0x000200, "Member 'UJackUMGManager::MenuAssetDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, DisplayUserWidgetClass) == 0x000210, "Member 'UJackUMGManager::DisplayUserWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, RemoveUserWidgetClass) == 0x000218, "Member 'UJackUMGManager::RemoveUserWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PairingButtonWidgetClass) == 0x000220, "Member 'UJackUMGManager::PairingButtonWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, RemoveControllerWidgetClass) == 0x000228, "Member 'UJackUMGManager::RemoveControllerWidgetClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MapController) == 0x000238, "Member 'UJackUMGManager::MapController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TitleBGMEndDelegate) == 0x000248, "Member 'UJackUMGManager::TitleBGMEndDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, NullWindowRef) == 0x000258, "Member 'UJackUMGManager::NullWindowRef' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, WorldObject) == 0x000260, "Member 'UJackUMGManager::WorldObject' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, RootWidget) == 0x000268, "Member 'UJackUMGManager::RootWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, RootWidgetRootPanel) == 0x000270, "Member 'UJackUMGManager::RootWidgetRootPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, OpendMenuWidget) == 0x000278, "Member 'UJackUMGManager::OpendMenuWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, OpendMenuId) == 0x000280, "Member 'UJackUMGManager::OpendMenuId' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuResultIndex) == 0x000284, "Member 'UJackUMGManager::MenuResultIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuBGMode) == 0x000288, "Member 'UJackUMGManager::MenuBGMode' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuBGCaptionId) == 0x000290, "Member 'UJackUMGManager::MenuBGCaptionId' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, JackOnUMGOpenMenuDelegate) == 0x000298, "Member 'UJackUMGManager::JackOnUMGOpenMenuDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, CSSkipDelegate) == 0x0002A8, "Member 'UJackUMGManager::CSSkipDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, WidgetEnableColor) == 0x0002B8, "Member 'UJackUMGManager::WidgetEnableColor' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, WidgetDisableColor) == 0x0002C8, "Member 'UJackUMGManager::WidgetDisableColor' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SoundSet) == 0x0002D8, "Member 'UJackUMGManager::SoundSet' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, IsEnableMenuWindowAnimation) == 0x0002E0, "Member 'UJackUMGManager::IsEnableMenuWindowAnimation' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, bIsModernUIMode) == 0x0002E1, "Member 'UJackUMGManager::bIsModernUIMode' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, DefaultFadeZOrder) == 0x0002E4, "Member 'UJackUMGManager::DefaultFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, ForegroundFadeZOrder) == 0x0002E8, "Member 'UJackUMGManager::ForegroundFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MessageFadeZOrder) == 0x0002EC, "Member 'UJackUMGManager::MessageFadeZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, CSSkipZOrder) == 0x0002F0, "Member 'UJackUMGManager::CSSkipZOrder' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, UMGManagerCommonClass) == 0x000300, "Member 'UJackUMGManager::UMGManagerCommonClass' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, UMGManagerCommon) == 0x000308, "Member 'UJackUMGManager::UMGManagerCommon' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, DeleteList) == 0x000360, "Member 'UJackUMGManager::DeleteList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, WidgetList) == 0x000370, "Member 'UJackUMGManager::WidgetList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, ViewportList) == 0x000380, "Member 'UJackUMGManager::ViewportList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, OpenWidgetList) == 0x000390, "Member 'UJackUMGManager::OpenWidgetList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuStack) == 0x0003A0, "Member 'UJackUMGManager::MenuStack' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, NewOpenMenu) == 0x0003B0, "Member 'UJackUMGManager::NewOpenMenu' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuPageList) == 0x0003C0, "Member 'UJackUMGManager::MenuPageList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PageInFocus) == 0x0003D0, "Member 'UJackUMGManager::PageInFocus' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MenuPageListAtException) == 0x0003D8, "Member 'UJackUMGManager::MenuPageListAtException' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PageInFocusAtException) == 0x0003E8, "Member 'UJackUMGManager::PageInFocusAtException' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PresetAnimTable) == 0x000400, "Member 'UJackUMGManager::PresetAnimTable' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, PresetColorTable) == 0x000410, "Member 'UJackUMGManager::PresetColorTable' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TargetSnapWidget) == 0x000420, "Member 'UJackUMGManager::TargetSnapWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, InsertWidgetBase) == 0x000428, "Member 'UJackUMGManager::InsertWidgetBase' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorCommon) == 0x000440, "Member 'UJackUMGManager::AccessorCommon' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorSaveData) == 0x000448, "Member 'UJackUMGManager::AccessorSaveData' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorItem) == 0x000450, "Member 'UJackUMGManager::AccessorItem' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorMembers) == 0x000458, "Member 'UJackUMGManager::AccessorMembers' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorShop) == 0x000460, "Member 'UJackUMGManager::AccessorShop' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorSenreki) == 0x000468, "Member 'UJackUMGManager::AccessorSenreki' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorFusigiKazi) == 0x000470, "Member 'UJackUMGManager::AccessorFusigiKazi' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorMantan) == 0x000478, "Member 'UJackUMGManager::AccessorMantan' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorBattle) == 0x000480, "Member 'UJackUMGManager::AccessorBattle' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorSyuurenjou) == 0x000488, "Member 'UJackUMGManager::AccessorSyuurenjou' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AccessorCoordinate) == 0x000490, "Member 'UJackUMGManager::AccessorCoordinate' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, HudWindows) == 0x000498, "Member 'UJackUMGManager::HudWindows' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, SerifuWindowController) == 0x0004A0, "Member 'UJackUMGManager::SerifuWindowController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TenNoKoeWindowController) == 0x0004A8, "Member 'UJackUMGManager::TenNoKoeWindowController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, BattleMessageController) == 0x0004B0, "Member 'UJackUMGManager::BattleMessageController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TokugiPanelMessageController) == 0x0004B8, "Member 'UJackUMGManager::TokugiPanelMessageController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, MovieMessageController) == 0x0004C0, "Member 'UJackUMGManager::MovieMessageController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, FukidasiWindowController) == 0x0004C8, "Member 'UJackUMGManager::FukidasiWindowController' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, TokugiPanelSetting) == 0x0004D0, "Member 'UJackUMGManager::TokugiPanelSetting' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, ItemDataAllocator) == 0x0004D8, "Member 'UJackUMGManager::ItemDataAllocator' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, DebugFixupWaitTime) == 0x000534, "Member 'UJackUMGManager::DebugFixupWaitTime' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AsyncLoadUserWidgetResultList) == 0x000558, "Member 'UJackUMGManager::AsyncLoadUserWidgetResultList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, AsyncLoadQueue) == 0x000568, "Member 'UJackUMGManager::AsyncLoadQueue' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, NumLoadTextureCached) == 0x00057C, "Member 'UJackUMGManager::NumLoadTextureCached' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, LoadedCacheList) == 0x000580, "Member 'UJackUMGManager::LoadedCacheList' has a wrong offset!");
static_assert(offsetof(UJackUMGManager, LoadMenuAssetsList) == 0x000598, "Member 'UJackUMGManager::LoadMenuAssetsList' has a wrong offset!");

// Class JackGame.JackUMGAccessorMemberDataInKyoukai
// 0x0040 (0x0078 - 0x0038)
class UJackUMGAccessorMemberDataInKyoukai final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisibleNumber;                                  // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                CharaType;                                         // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name_0;                                            // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Level;                                             // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RestExp;                                           // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDead;                                           // 0x0058(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDoku;                                           // 0x0059(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNoroi;                                          // 0x005A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5B[0x1];                                       // 0x005B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         HP;                                                // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HPRate;                                            // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OddEffectIdList;                                   // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static bool ExistsDeadMember(const TArray<class UJackUMGItemData*>& ItemDataList);
	static class UJackUMGAccessorMemberDataInKyoukai* GetMemberData(const class UJackUMGItemData* ItemData);

	int32 CalculateDetoxCost(class UObject* Obj);
	int32 CalculateDispelCost(class UObject* Obj);
	int32 CalculateResuscitateCost(class UObject* Obj);
	void ExecDetox(class UObject* Obj);
	void ExecDispel(class UObject* Obj);
	void ExecResuscitate(class UObject* Obj);
	class FName GetOddEffectId(EJackKyoukaiEffectEventType EventType);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorMemberDataInKyoukai">();
	}
	static class UJackUMGAccessorMemberDataInKyoukai* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorMemberDataInKyoukai>();
	}
};
static_assert(alignof(UJackUMGAccessorMemberDataInKyoukai) == 0x000008, "Wrong alignment on UJackUMGAccessorMemberDataInKyoukai");
static_assert(sizeof(UJackUMGAccessorMemberDataInKyoukai) == 0x000078, "Wrong size on UJackUMGAccessorMemberDataInKyoukai");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, Index_0) == 0x000038, "Member 'UJackUMGAccessorMemberDataInKyoukai::Index_0' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, bIsVisibleNumber) == 0x00003C, "Member 'UJackUMGAccessorMemberDataInKyoukai::bIsVisibleNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, CharaType) == 0x00003D, "Member 'UJackUMGAccessorMemberDataInKyoukai::CharaType' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, Name_0) == 0x000040, "Member 'UJackUMGAccessorMemberDataInKyoukai::Name_0' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, Level) == 0x000050, "Member 'UJackUMGAccessorMemberDataInKyoukai::Level' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, RestExp) == 0x000054, "Member 'UJackUMGAccessorMemberDataInKyoukai::RestExp' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, bIsDead) == 0x000058, "Member 'UJackUMGAccessorMemberDataInKyoukai::bIsDead' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, bIsDoku) == 0x000059, "Member 'UJackUMGAccessorMemberDataInKyoukai::bIsDoku' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, bIsNoroi) == 0x00005A, "Member 'UJackUMGAccessorMemberDataInKyoukai::bIsNoroi' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, HP) == 0x00005C, "Member 'UJackUMGAccessorMemberDataInKyoukai::HP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, MaxHP) == 0x000060, "Member 'UJackUMGAccessorMemberDataInKyoukai::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, HPRate) == 0x000064, "Member 'UJackUMGAccessorMemberDataInKyoukai::HPRate' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInKyoukai, OddEffectIdList) == 0x000068, "Member 'UJackUMGAccessorMemberDataInKyoukai::OddEffectIdList' has a wrong offset!");

// Class JackGame.JackUMGAccessorMemberDataInTuyosa
// 0x00C8 (0x0100 - 0x0038)
class UJackUMGAccessorMemberDataInTuyosa final : public UObject
{
public:
	int32                                         Index_0;                                           // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayName;                                       // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UJackGameCharacter*                     GameCharacter;                                     // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstructedOverview;                              // 0x0060(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstructedAll;                                   // 0x0061(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_62[0x6];                                       // 0x0062(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Katagaki;                                          // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGSoubiList*                      SoubiList;                                         // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               TokusyuList;                                       // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               JumonList;                                         // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               TokugiList;                                        // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UJackUMGTuyosaSkillGroupData*>   SkillGroupList;                                    // 0x00B0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               RenkeiList;                                        // 0x00C0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bShowKaziPage;                                     // 0x00D0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MaxCP;                                             // 0x00D4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UJackUMGItemData*>               KaziGameActionList;                                // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxPageCount;                                      // 0x00E8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxJumonPageCount;                                 // 0x00EC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxTokugiPageCount;                                // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxSkillPageCount;                                 // 0x00F4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxRenkeiPageCount;                                // 0x00F8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void GetActionItemListAtPageIndex(EJackTuyosaPage PageType, int32 PageIndexInSkillList, TArray<class UJackUMGItemData*>* DisplayItemList, class FString* PageTitleSub, int32* UsedSkillPoint, int32* VerticalItemCount);

	int32 GetLastJumonPageIndex() const;
	int32 GetLastRenkeiPageIndex() const;
	int32 GetLastSkillPageIndex() const;
	int32 GetLastTokugiPageIndex() const;
	bool IsJumonEmpty() const;
	bool IsJumonInfoOpened() const;
	bool IsKaziGameActionListEmpty() const;
	bool IsKaziGameActionListInfoOpened() const;
	bool IsRenkeiEmpty() const;
	bool IsRenkeiInfoOpened() const;
	bool IsSkillEmpty() const;
	bool IsSkillInfoOpened() const;
	bool IsTokugiEmpty() const;
	bool IsTokugiInfoOpened() const;
	bool IsTokusyuEmpty() const;
	bool IsTokusyuInfoOpened() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorMemberDataInTuyosa">();
	}
	static class UJackUMGAccessorMemberDataInTuyosa* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorMemberDataInTuyosa>();
	}
};
static_assert(alignof(UJackUMGAccessorMemberDataInTuyosa) == 0x000008, "Wrong alignment on UJackUMGAccessorMemberDataInTuyosa");
static_assert(sizeof(UJackUMGAccessorMemberDataInTuyosa) == 0x000100, "Wrong size on UJackUMGAccessorMemberDataInTuyosa");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, Index_0) == 0x000038, "Member 'UJackUMGAccessorMemberDataInTuyosa::Index_0' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, DisplayName) == 0x000040, "Member 'UJackUMGAccessorMemberDataInTuyosa::DisplayName' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, GameCharacter) == 0x000058, "Member 'UJackUMGAccessorMemberDataInTuyosa::GameCharacter' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, bConstructedOverview) == 0x000060, "Member 'UJackUMGAccessorMemberDataInTuyosa::bConstructedOverview' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, bConstructedAll) == 0x000061, "Member 'UJackUMGAccessorMemberDataInTuyosa::bConstructedAll' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, Katagaki) == 0x000068, "Member 'UJackUMGAccessorMemberDataInTuyosa::Katagaki' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, SoubiList) == 0x000078, "Member 'UJackUMGAccessorMemberDataInTuyosa::SoubiList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, TokusyuList) == 0x000080, "Member 'UJackUMGAccessorMemberDataInTuyosa::TokusyuList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, JumonList) == 0x000090, "Member 'UJackUMGAccessorMemberDataInTuyosa::JumonList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, TokugiList) == 0x0000A0, "Member 'UJackUMGAccessorMemberDataInTuyosa::TokugiList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, SkillGroupList) == 0x0000B0, "Member 'UJackUMGAccessorMemberDataInTuyosa::SkillGroupList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, RenkeiList) == 0x0000C0, "Member 'UJackUMGAccessorMemberDataInTuyosa::RenkeiList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, bShowKaziPage) == 0x0000D0, "Member 'UJackUMGAccessorMemberDataInTuyosa::bShowKaziPage' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxCP) == 0x0000D4, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxCP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, KaziGameActionList) == 0x0000D8, "Member 'UJackUMGAccessorMemberDataInTuyosa::KaziGameActionList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxPageCount) == 0x0000E8, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxPageCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxJumonPageCount) == 0x0000EC, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxJumonPageCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxTokugiPageCount) == 0x0000F0, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxTokugiPageCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxSkillPageCount) == 0x0000F4, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxSkillPageCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMemberDataInTuyosa, MaxRenkeiPageCount) == 0x0000F8, "Member 'UJackUMGAccessorMemberDataInTuyosa::MaxRenkeiPageCount' has a wrong offset!");

// Class JackGame.JackUMGTuyosaRenkeiData
// 0x00D0 (0x0108 - 0x0038)
class UJackUMGTuyosaRenkeiData final : public UObject
{
public:
	class FString                                 RenkeiName;                                        // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             RenkeiIcon;                                        // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackUMGTuyosaRenkeiCharacterData      CharacterDataA;                                    // 0x0060(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGTuyosaRenkeiCharacterData      CharacterDataB;                                    // 0x0088(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGTuyosaRenkeiCharacterData      CharacterDataC;                                    // 0x00B0(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackUMGTuyosaRenkeiCharacterData      CharacterDataD;                                    // 0x00D8(0x0028)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	bool                                          bAllNeedZone;                                      // 0x0100(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTuyosaRenkeiData">();
	}
	static class UJackUMGTuyosaRenkeiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTuyosaRenkeiData>();
	}
};
static_assert(alignof(UJackUMGTuyosaRenkeiData) == 0x000008, "Wrong alignment on UJackUMGTuyosaRenkeiData");
static_assert(sizeof(UJackUMGTuyosaRenkeiData) == 0x000108, "Wrong size on UJackUMGTuyosaRenkeiData");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, RenkeiName) == 0x000038, "Member 'UJackUMGTuyosaRenkeiData::RenkeiName' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, RenkeiIcon) == 0x000048, "Member 'UJackUMGTuyosaRenkeiData::RenkeiIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, Description) == 0x000050, "Member 'UJackUMGTuyosaRenkeiData::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, CharacterDataA) == 0x000060, "Member 'UJackUMGTuyosaRenkeiData::CharacterDataA' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, CharacterDataB) == 0x000088, "Member 'UJackUMGTuyosaRenkeiData::CharacterDataB' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, CharacterDataC) == 0x0000B0, "Member 'UJackUMGTuyosaRenkeiData::CharacterDataC' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, CharacterDataD) == 0x0000D8, "Member 'UJackUMGTuyosaRenkeiData::CharacterDataD' has a wrong offset!");
static_assert(offsetof(UJackUMGTuyosaRenkeiData, bAllNeedZone) == 0x000100, "Member 'UJackUMGTuyosaRenkeiData::bAllNeedZone' has a wrong offset!");

// Class JackGame.JackUMGAccessorMembers
// 0x02C0 (0x0300 - 0x0040)
class UJackUMGAccessorMembers : public UJackUMGAccessorBase
{
public:
	TArray<struct FJackUMGTaneIdToTextIdRec>      TaneIdToTextIdTable;                               // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<class FName>                           TokugiActionIdToJumonList;                         // 0x0050(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGJoutaiMiruMember>       JoutaiMiruMember;                                  // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   SenaHairstyleChangedDelegate;                      // 0x0070(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP001;                                      // 0x0080(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP002;                                      // 0x00B0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP003;                                      // 0x00E0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP004_1;                                    // 0x0110(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP004_2;                                    // 0x0140(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP005;                                      // 0x0170(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP006;                                      // 0x01A0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP007;                                      // 0x01D0(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FJackUMGFaceIconTexture                FaceIconP008;                                      // 0x0200(0x0030)(Edit, DisableEditOnInstance, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_230[0xD0];                                     // 0x0230(0x00D0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ActionFieldJumon();
	void CancelGetOsusumeSoubiList(class UJackUMGSoubiList* SoubiList);
	void ChangeGambit(const EJackGambit GambitType);
	void ClearMemberGambitList();
	int32 CountMember();
	class UJackUMGSerifuWindowController* DisplayUseJumonMessage();
	TSoftObjectPtr<class UTexture> GetCharacterFaceIconAssetFromType(EJackCharacter InCharType, EJackUIFaceIcon InIconType);
	class UTexture2D* GetCharacterFaceIconFromType(EJackCharacter InCharType, EJackUIFaceIcon InIconType);
	const TArray<class UJackUMGItemData*> GetMemberListInJoutai(bool IsSubParty);
	class UJackUMGSoubiList* GetOsusumeSoubiListAsync(EJackCharacter InCharType, EJackUMGOsusumeSoubi InOsusumeType, TDelegate<void(class UJackUMGSoubiList* SoubiList)> InDelegate);
	bool IsMultipleCharacters();
	void JackOnSenaHairstyleChangedDelegate__DelegateSignature();
	void MakeMemberListInJoutaiMiru(bool IsSubParty);
	void NakamaKaiwa();
	void PlayFieldActionSE(const class FName& InActionId);
	const class FString ReplaceAccentMoji(const class FString& InName, bool IsB);
	void RestoreMemberGambitList();
	void SetMemberGambit(const EJackGambit InGambit);
	void SetMemberListToWindow(class UJackUMGBrowserBase* InBrowserWindow, int32 InDispIndex, EJackUMGMemberList InMemberType, EJackUMGMembarZenin InZeninType);
	void SetOddEffectLinefeedText(const class FString& InText, const TArray<class UTextBlock*>& TextBlock);
	void SetSelectedCharType(EJackCharacter InCharType);
	void SetSelectedJumonId(const class FName& InJumonId);
	void SetSelectedJumonName(const class FText& Jumon);
	void SetSelectedMember(const int32 SelectedIndex);
	void SetSelectedMemberName(const class FText& Name_0);
	void SetSelectedTokugiId(const class FName& InTokugiId);
	void SetTargetCharType(EJackCharacter InCharType);
	void StoreMemberGambitList();

	void ConstructMemberDataInTuyosa(class UJackUMGAccessorMemberDataInTuyosa* RefTuyosaData, bool bOnlyOverview) const;
	void DebugDispItemList(const TArray<class UJackUMGItemData*>& InList) const;
	const class FText GetActionDescription(const class FName& InActionId, EJackActionTextType TextType, bool ListFlag) const;
	const TArray<class UJackUMGItemData*> GetActionMemberList(EJackUMGMemberList InMemberType, EJackUMGUIActionFlow InUIFlowType, const class FName InActionId, EJackCharacter InWithoutCharType) const;
	const class FText GetActionName(const class FName InActionId, bool ListFlag) const;
	class UJackUMGItemActionStatus* GetActionStatusFromCharacter(const class UJackGameCharacter* GameCharacter) const;
	class UJackUMGItemActionStatus* GetActionStatusFromType(EJackCharacter InCharaType) const;
	TArray<struct FJackUMGOddEffectStatus> GetBadOddEffectIdList(EJackCharacter InCharType) const;
	class UJackUMGBattleResultData* GetBattleResultData(EJackCharacter InCharType, int32 InBeforeLevel, int32 InAfterLevel) const;
	const TArray<class UJackUMGItemData*> GetBattleSakusenCommandList() const;
	const class FString GetCharacterNameFromIndex(int32 InIndex) const;
	const class FString GetCharacterNameFromType(EJackCharacter InType) const;
	class UJackUMGItemData* GetCharacterSoubi(EJackCharacter InCharType) const;
	class UJackUMGDispEquipmentState* GetCharEquipmentState(EJackCharacter InCharType, const class FName& InItemId, EJackEquipmentRegion InRegionType, bool bIsHandedness, bool bIsAllParam) const;
	const class FName GetCharFNameFromType(EJackCharacter InType) const;
	const class FString GetCharNameFromType(EJackCharacter InType) const;
	const TArray<class FName> GetDisplayOddEffectList(EJackCharacter InCharType, const class FName& InActionId) const;
	EJackCharacter GetFirstMembarCharacterType() const;
	TArray<EJackCharacter> GetFriendJoinedAfterList() const;
	TArray<struct FJackUMGOddEffectStatus> GetGoodOddEffectIdList(EJackCharacter InCharType) const;
	const TArray<class UJackUMGItemData*> GetHudStatusList() const;
	TArray<class FName> GetIrekaeKinsiJoutaiIjouList(EJackCharacter InCharType) const;
	class UJackFriendGameCharacter* GetJackCharacterFromType(EJackCharacter InType) const;
	const int32 GetJoutaiIjouNumber(const int32 InIndex) const;
	const TArray<class UJackUMGItemData*> GetJumonListAtGameCharacter(EJackUMGJumonBasyo JumonType, class UJackGameCharacter* GameCharacter, bool IsOptimisation) const;
	const TArray<class UJackUMGItemData*> GetJumonMembarList() const;
	const class FText GetJumonName(const class FName& InJumonId, bool ListFlag) const;
	const int32 GetMaxJoutaiIjouNumber() const;
	const int32 GetMaxMPFromMemberIndex(const int32 InMemberIndex) const;
	const EJackGambit GetMemberGambitIndex(const int32 InIndex) const;
	const TArray<class UJackUMGItemData*> GetMemberList(EJackUMGMemberList InMemberType, EJackUMGMembarZenin ZeninType) const;
	const TArray<class UJackUMGItemData*> GetMemberListInKyoukai() const;
	const TArray<class UJackUMGItemData*> GetMemberListInPhotoModeMenu() const;
	void GetMemberListInTuyosa(TArray<class UJackUMGItemData*>* OutItemDataList) const;
	void GetMemberListInTuyosaToWindow(class UJackUMGBrowserBase* InBrowserBase) const;
	const int32 GetMPFromMemberCharType(EJackCharacter InCharType) const;
	const int32 GetMPFromMemberIndex(const int32 InMemberIndex) const;
	const class FString GetNameFromIndex(int32 InIndex) const;
	TArray<class FName> GetOddEffectIdList(EJackCharacter InCharType) const;
	const class FString GetOddEffectSetumei(const class FName& InOddEffectId, class UJackUMGItemBase* InItemBase, bool IsSubParty) const;
	int32 GetOddEffectSlideRank(EJackCharacter InCharType, class FName InOddEffectId) const;
	TArray<class FName> GetOddEffectWithIconIdList(EJackCharacter InCharType, TArray<int32>* OutSlideValue) const;
	class UJackUMGSoubiList* GetOsusumeSoubiList(EJackCharacter InCharType, EJackUMGOsusumeSoubi InOsusumeType) const;
	const int32 GetPartyMemberIndexFromType(EJackCharacter InType) const;
	EJackPartyTalkState GetPartyTalkState() const;
	const TArray<class UJackUMGItemData*> GetPlayKankyouCommandList() const;
	const TArray<class UJackUMGItemData*> GetPlayKankyouCommandListNE() const;
	const TArray<class UJackUMGItemData*> GetSakusenCommandList() const;
	const TArray<class UJackUMGItemData*> GetSakusenMemberList(EJackUMGMemberList InMemberType, EJackUMGMembarZenin ZeninType) const;
	EJackCharacter GetSelectedCharType() const;
	const class FName GetSelectedJumonId() const;
	const class FText GetSelectedJumonName() const;
	int32 GetSelectedMember() const;
	const class FText GetSelectedMemberName() const;
	const class FName GetSelectedTokugiId() const;
	const TArray<class UJackUMGItemData*> GetSystemCommandList() const;
	const TArray<class UJackUMGItemData*> GetSystemCommandListNE() const;
	const TArray<class UJackUMGItemData*> GetSystemCommandListSteam() const;
	const TArray<class UJackUMGItemData*> GetTaneActionMemberList(EJackUMGMemberList InMemberType, EJackUMGUIActionFlow InUIFlowType, const class FName InItemId) const;
	const class FName GetTaneTextId(const class FName& InTaneId) const;
	class FName GetTextIDWhenRejectedNakamaKaiwa() const;
	const TArray<class UJackUMGItemData*> GetTokugiListAtGameCharacter(EJackUMGJumonBasyo InTokugiType, class UJackGameCharacter* InGameCharacter, bool bInTuyosaMenu, bool IsOptimisation) const;
	void GetTokusyuDescriptionList(class UJackGameCharacter* Member, EJackActionTextType TextType, TArray<class FString>* TokusyuDescriptionList) const;
	bool HasFriendJoined(EJackCharacter InCharaType) const;
	bool IsActivePlayerAI(const int32 InIndex) const;
	bool IsDead(EJackCharacter InCharType) const;
	bool IsEnableIrekae() const;
	bool IsEnableMainCommandJumon() const;
	bool IsJumonListAtGameCharacter(EJackUMGJumonBasyo JumonType, class UJackGameCharacter* GameCharacter) const;
	bool IsLearnedRenkei() const;
	bool IsOnOddEffectStatus(EJackCharacter InCharaType, const class FName& InOddEffectStatusId) const;
	bool IsPartyMemberFromType(EJackCharacter InType) const;
	bool IsPlayerSenaShortHair() const;
	bool IsSyuurenjou() const;
	bool IsTokugiListAtGameCharacter(EJackUMGJumonBasyo InTokugiType, class UJackGameCharacter* InGameCharacter, bool bInTuyosaMenu) const;
	bool IsTrialLevelLimit(const class UJackGameCharacter* InCharacter) const;
	void SetJoutaiIjouFace(class UJackUMGItemBase* InItemBase, const class FText& CharName) const;
	EJackCharacter SetJoutaiIjouFaces(class UJackUMGItemData* InItemData, class UJackUMGItemBase* InItemBase) const;
	void SetJoutaiIjouNames(EJackCharacter InCharType, int32 InOffset, const TArray<class UJackUMGItemBase*>& InItemBase, bool IsSubmember, int32 InIndex, const int32 OddMax) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorMembers">();
	}
	static class UJackUMGAccessorMembers* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorMembers>();
	}
};
static_assert(alignof(UJackUMGAccessorMembers) == 0x000008, "Wrong alignment on UJackUMGAccessorMembers");
static_assert(sizeof(UJackUMGAccessorMembers) == 0x000300, "Wrong size on UJackUMGAccessorMembers");
static_assert(offsetof(UJackUMGAccessorMembers, TaneIdToTextIdTable) == 0x000040, "Member 'UJackUMGAccessorMembers::TaneIdToTextIdTable' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, TokugiActionIdToJumonList) == 0x000050, "Member 'UJackUMGAccessorMembers::TokugiActionIdToJumonList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, JoutaiMiruMember) == 0x000060, "Member 'UJackUMGAccessorMembers::JoutaiMiruMember' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, SenaHairstyleChangedDelegate) == 0x000070, "Member 'UJackUMGAccessorMembers::SenaHairstyleChangedDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP001) == 0x000080, "Member 'UJackUMGAccessorMembers::FaceIconP001' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP002) == 0x0000B0, "Member 'UJackUMGAccessorMembers::FaceIconP002' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP003) == 0x0000E0, "Member 'UJackUMGAccessorMembers::FaceIconP003' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP004_1) == 0x000110, "Member 'UJackUMGAccessorMembers::FaceIconP004_1' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP004_2) == 0x000140, "Member 'UJackUMGAccessorMembers::FaceIconP004_2' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP005) == 0x000170, "Member 'UJackUMGAccessorMembers::FaceIconP005' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP006) == 0x0001A0, "Member 'UJackUMGAccessorMembers::FaceIconP006' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP007) == 0x0001D0, "Member 'UJackUMGAccessorMembers::FaceIconP007' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembers, FaceIconP008) == 0x000200, "Member 'UJackUMGAccessorMembers::FaceIconP008' has a wrong offset!");

// Class JackGame.JackUMGBattleResultData
// 0x0128 (0x0160 - 0x0038)
class UJackUMGBattleResultData final : public UObject
{
public:
	EJackCharacter                                CharType;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         BeforeLevel;                                       // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterLevel;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FJackDataTableLevelUp                  BaseUpData;                                        // 0x0048(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackDataTableLevelUp                  BeforeLevelData;                                   // 0x0098(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FJackDataTableLevelUp                  AfterLevelData;                                    // 0x00E8(0x0050)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class FText                                   LevelUpMessage;                                    // 0x0138(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	TArray<class FText>                           AcquisitionMessageArray;                           // 0x0150(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGBattleResultData">();
	}
	static class UJackUMGBattleResultData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGBattleResultData>();
	}
};
static_assert(alignof(UJackUMGBattleResultData) == 0x000008, "Wrong alignment on UJackUMGBattleResultData");
static_assert(sizeof(UJackUMGBattleResultData) == 0x000160, "Wrong size on UJackUMGBattleResultData");
static_assert(offsetof(UJackUMGBattleResultData, CharType) == 0x000038, "Member 'UJackUMGBattleResultData::CharType' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, BeforeLevel) == 0x00003C, "Member 'UJackUMGBattleResultData::BeforeLevel' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, AfterLevel) == 0x000040, "Member 'UJackUMGBattleResultData::AfterLevel' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, BaseUpData) == 0x000048, "Member 'UJackUMGBattleResultData::BaseUpData' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, BeforeLevelData) == 0x000098, "Member 'UJackUMGBattleResultData::BeforeLevelData' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, AfterLevelData) == 0x0000E8, "Member 'UJackUMGBattleResultData::AfterLevelData' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, LevelUpMessage) == 0x000138, "Member 'UJackUMGBattleResultData::LevelUpMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGBattleResultData, AcquisitionMessageArray) == 0x000150, "Member 'UJackUMGBattleResultData::AcquisitionMessageArray' has a wrong offset!");

// Class JackGame.JackUMGAccessorMembersInChange
// 0x0040 (0x0078 - 0x0038)
class UJackUMGAccessorMembersInChange final : public UObject
{
public:
	int32                                         MaxHP;                                             // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMP;                                             // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KougekiKikite;                                     // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kougeki;                                           // 0x0044(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Syubi;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KougekiMaryoku;                                    // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KaifukuMaryoku;                                    // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Tikara;                                            // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minomamori;                                        // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Subayasa;                                          // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kiyousa;                                           // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Miryoku;                                           // 0x0064(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackGameCharacter*                     GameCharacter;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackCharacter                                CharacterType;                                     // 0x0070(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGAccessorMembersInChange* GetChangeData(const class UJackUMGItemData* ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorMembersInChange">();
	}
	static class UJackUMGAccessorMembersInChange* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorMembersInChange>();
	}
};
static_assert(alignof(UJackUMGAccessorMembersInChange) == 0x000008, "Wrong alignment on UJackUMGAccessorMembersInChange");
static_assert(sizeof(UJackUMGAccessorMembersInChange) == 0x000078, "Wrong size on UJackUMGAccessorMembersInChange");
static_assert(offsetof(UJackUMGAccessorMembersInChange, MaxHP) == 0x000038, "Member 'UJackUMGAccessorMembersInChange::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, MaxMP) == 0x00003C, "Member 'UJackUMGAccessorMembersInChange::MaxMP' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, KougekiKikite) == 0x000040, "Member 'UJackUMGAccessorMembersInChange::KougekiKikite' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Kougeki) == 0x000044, "Member 'UJackUMGAccessorMembersInChange::Kougeki' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Syubi) == 0x000048, "Member 'UJackUMGAccessorMembersInChange::Syubi' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, KougekiMaryoku) == 0x00004C, "Member 'UJackUMGAccessorMembersInChange::KougekiMaryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, KaifukuMaryoku) == 0x000050, "Member 'UJackUMGAccessorMembersInChange::KaifukuMaryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Tikara) == 0x000054, "Member 'UJackUMGAccessorMembersInChange::Tikara' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Minomamori) == 0x000058, "Member 'UJackUMGAccessorMembersInChange::Minomamori' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Subayasa) == 0x00005C, "Member 'UJackUMGAccessorMembersInChange::Subayasa' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Kiyousa) == 0x000060, "Member 'UJackUMGAccessorMembersInChange::Kiyousa' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, Miryoku) == 0x000064, "Member 'UJackUMGAccessorMembersInChange::Miryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, GameCharacter) == 0x000068, "Member 'UJackUMGAccessorMembersInChange::GameCharacter' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorMembersInChange, CharacterType) == 0x000070, "Member 'UJackUMGAccessorMembersInChange::CharacterType' has a wrong offset!");

// Class JackGame.JackUMGMapSymbolInfo
// 0x0030 (0x0080 - 0x0050)
class UJackUMGMapSymbolInfo final : public UJackUMGMapSymbolInfoBase
{
public:
	uint8                                         Pad_50[0x30];                                      // 0x0050(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetMapSymbol(EJackMapSymbol InSymbol);
	void SetMiniMapDrawOffset(const struct FVector2D& InOffset);
	void SetMiniMapDrawScale(float InScale);
	void SetOpacity(float InOpacity);
	void SetWorldMapDrawOffset(const struct FVector2D& InOffset);
	void SetWorldMapDrawScale(float InScale);
	void SetWorldPosition(const struct FVector& InPosition);

	EJackMapSymbol GetMapSymbol() const;
	struct FVector2D GetMiniMapDrawOffset() const;
	float GetMiniMapDrawScale() const;
	float GetOpacity() const;
	struct FVector2D GetWorldMapDrawOffset() const;
	float GetWorldMapDrawScale() const;
	struct FVector GetWorldPosition() const;
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapSymbolInfo">();
	}
	static class UJackUMGMapSymbolInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapSymbolInfo>();
	}
};
static_assert(alignof(UJackUMGMapSymbolInfo) == 0x000008, "Wrong alignment on UJackUMGMapSymbolInfo");
static_assert(sizeof(UJackUMGMapSymbolInfo) == 0x000080, "Wrong size on UJackUMGMapSymbolInfo");

// Class JackGame.JackUMGSaveDataContainer
// 0x0098 (0x00D0 - 0x0038)
class UJackUMGSaveDataContainer final : public UObject
{
public:
	bool                                          bIsValid;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SlotIndex;                                         // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DataNumber;                                        // 0x0040(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerName;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   FukkatuLocation;                                   // 0x0060(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	int32                                         PlayTimeHour;                                      // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayTimeMinutes;                                   // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayTime;                                          // 0x0080(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavedDate;                                         // 0x0090(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SavedTime;                                         // 0x00A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRound2;                                         // 0x00B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackSibariSettings                    SibariSettings;                                    // 0x00B1(0x000B)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsSibariNow;                                      // 0x00BC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIs2DMode;                                         // 0x00BD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BE[0x2];                                       // 0x00BE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   TenseiId;                                          // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackLanguage                                 LanguageType;                                      // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsNewGamePlus;                                    // 0x00C9(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDisplayablePlayerName;                            // 0x00CA(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CB[0x5];                                       // 0x00CB(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGSaveDataContainer* GetSaveDataContainer(const class UJackUMGItemData* ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSaveDataContainer">();
	}
	static class UJackUMGSaveDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSaveDataContainer>();
	}
};
static_assert(alignof(UJackUMGSaveDataContainer) == 0x000008, "Wrong alignment on UJackUMGSaveDataContainer");
static_assert(sizeof(UJackUMGSaveDataContainer) == 0x0000D0, "Wrong size on UJackUMGSaveDataContainer");
static_assert(offsetof(UJackUMGSaveDataContainer, bIsValid) == 0x000038, "Member 'UJackUMGSaveDataContainer::bIsValid' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, SlotIndex) == 0x00003C, "Member 'UJackUMGSaveDataContainer::SlotIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, DataNumber) == 0x000040, "Member 'UJackUMGSaveDataContainer::DataNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, PlayerName) == 0x000048, "Member 'UJackUMGSaveDataContainer::PlayerName' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, PlayerLevel) == 0x000058, "Member 'UJackUMGSaveDataContainer::PlayerLevel' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, FukkatuLocation) == 0x000060, "Member 'UJackUMGSaveDataContainer::FukkatuLocation' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, PlayTimeHour) == 0x000078, "Member 'UJackUMGSaveDataContainer::PlayTimeHour' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, PlayTimeMinutes) == 0x00007C, "Member 'UJackUMGSaveDataContainer::PlayTimeMinutes' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, PlayTime) == 0x000080, "Member 'UJackUMGSaveDataContainer::PlayTime' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, SavedDate) == 0x000090, "Member 'UJackUMGSaveDataContainer::SavedDate' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, SavedTime) == 0x0000A0, "Member 'UJackUMGSaveDataContainer::SavedTime' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, bIsRound2) == 0x0000B0, "Member 'UJackUMGSaveDataContainer::bIsRound2' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, SibariSettings) == 0x0000B1, "Member 'UJackUMGSaveDataContainer::SibariSettings' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, bIsSibariNow) == 0x0000BC, "Member 'UJackUMGSaveDataContainer::bIsSibariNow' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, bIs2DMode) == 0x0000BD, "Member 'UJackUMGSaveDataContainer::bIs2DMode' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, TenseiId) == 0x0000C0, "Member 'UJackUMGSaveDataContainer::TenseiId' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, LanguageType) == 0x0000C8, "Member 'UJackUMGSaveDataContainer::LanguageType' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, bIsNewGamePlus) == 0x0000C9, "Member 'UJackUMGSaveDataContainer::bIsNewGamePlus' has a wrong offset!");
static_assert(offsetof(UJackUMGSaveDataContainer, bDisplayablePlayerName) == 0x0000CA, "Member 'UJackUMGSaveDataContainer::bDisplayablePlayerName' has a wrong offset!");

// Class JackGame.JackGetArasuziDataResult
// 0x0048 (0x0080 - 0x0038)
class UJackGetArasuziDataResult final : public UObject
{
public:
	int32                                         PageCount;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TextList;                                          // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UTexture2D*>                     TextureList;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class FName                                   BGMID;                                             // 0x0060(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCompleteTextureLoad;                              // 0x0068(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSoftObjectPath>                TextureAssetList;                                  // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackGetArasuziDataResult">();
	}
	static class UJackGetArasuziDataResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackGetArasuziDataResult>();
	}
};
static_assert(alignof(UJackGetArasuziDataResult) == 0x000008, "Wrong alignment on UJackGetArasuziDataResult");
static_assert(sizeof(UJackGetArasuziDataResult) == 0x000080, "Wrong size on UJackGetArasuziDataResult");
static_assert(offsetof(UJackGetArasuziDataResult, PageCount) == 0x000038, "Member 'UJackGetArasuziDataResult::PageCount' has a wrong offset!");
static_assert(offsetof(UJackGetArasuziDataResult, TextList) == 0x000040, "Member 'UJackGetArasuziDataResult::TextList' has a wrong offset!");
static_assert(offsetof(UJackGetArasuziDataResult, TextureList) == 0x000050, "Member 'UJackGetArasuziDataResult::TextureList' has a wrong offset!");
static_assert(offsetof(UJackGetArasuziDataResult, BGMID) == 0x000060, "Member 'UJackGetArasuziDataResult::BGMID' has a wrong offset!");
static_assert(offsetof(UJackGetArasuziDataResult, bCompleteTextureLoad) == 0x000068, "Member 'UJackGetArasuziDataResult::bCompleteTextureLoad' has a wrong offset!");
static_assert(offsetof(UJackGetArasuziDataResult, TextureAssetList) == 0x000070, "Member 'UJackGetArasuziDataResult::TextureAssetList' has a wrong offset!");

// Class JackGame.JackUMGSoubiState
// 0x0080 (0x00B8 - 0x0038)
class UJackUMGSoubiState final : public UObject
{
public:
	uint8                                         Pad_38[0x3C];                                      // 0x0038(0x003C)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Tikara;                                            // 0x0074(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minomamori;                                        // 0x0078(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Subayasa;                                          // 0x007C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kiyousa;                                           // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Miryoku;                                           // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KougekiMaryoku;                                    // 0x0088(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KaifukuMaryoku;                                    // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMP;                                             // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Kougekiryoku;                                      // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Syubiryoku;                                        // 0x009C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MPKyuuSyuuRate;                                    // 0x00A0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TateGuardRate;                                     // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BukiGuardRate;                                     // 0x00A8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MikawasiRate;                                      // 0x00AC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalRate;                                      // 0x00B0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ZoneOnRate;                                        // 0x00B4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSoubiState">();
	}
	static class UJackUMGSoubiState* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSoubiState>();
	}
};
static_assert(alignof(UJackUMGSoubiState) == 0x000008, "Wrong alignment on UJackUMGSoubiState");
static_assert(sizeof(UJackUMGSoubiState) == 0x0000B8, "Wrong size on UJackUMGSoubiState");
static_assert(offsetof(UJackUMGSoubiState, Tikara) == 0x000074, "Member 'UJackUMGSoubiState::Tikara' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Minomamori) == 0x000078, "Member 'UJackUMGSoubiState::Minomamori' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Subayasa) == 0x00007C, "Member 'UJackUMGSoubiState::Subayasa' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Kiyousa) == 0x000080, "Member 'UJackUMGSoubiState::Kiyousa' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Miryoku) == 0x000084, "Member 'UJackUMGSoubiState::Miryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, KougekiMaryoku) == 0x000088, "Member 'UJackUMGSoubiState::KougekiMaryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, KaifukuMaryoku) == 0x00008C, "Member 'UJackUMGSoubiState::KaifukuMaryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, MaxHP) == 0x000090, "Member 'UJackUMGSoubiState::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, MaxMP) == 0x000094, "Member 'UJackUMGSoubiState::MaxMP' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Kougekiryoku) == 0x000098, "Member 'UJackUMGSoubiState::Kougekiryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, Syubiryoku) == 0x00009C, "Member 'UJackUMGSoubiState::Syubiryoku' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, MPKyuuSyuuRate) == 0x0000A0, "Member 'UJackUMGSoubiState::MPKyuuSyuuRate' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, TateGuardRate) == 0x0000A4, "Member 'UJackUMGSoubiState::TateGuardRate' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, BukiGuardRate) == 0x0000A8, "Member 'UJackUMGSoubiState::BukiGuardRate' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, MikawasiRate) == 0x0000AC, "Member 'UJackUMGSoubiState::MikawasiRate' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, CriticalRate) == 0x0000B0, "Member 'UJackUMGSoubiState::CriticalRate' has a wrong offset!");
static_assert(offsetof(UJackUMGSoubiState, ZoneOnRate) == 0x0000B4, "Member 'UJackUMGSoubiState::ZoneOnRate' has a wrong offset!");

// Class JackGame.JackUMGAccessorSaveDataInRura
// 0x0050 (0x0088 - 0x0038)
class UJackUMGAccessorSaveDataInRura final : public UObject
{
public:
	class FString                                 Name_0;                                            // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   JumpTag;                                           // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Open;                                              // 0x0060(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_64[0x4];                                       // 0x0064(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WorldMapPoint;                                     // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   WorldMapArea;                                      // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBukiShopFlag;                                     // 0x0078(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBouguShopFlag;                                    // 0x0079(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInnFlag;                                          // 0x007A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDouguShopFlag;                                    // 0x007B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bYorozuShopFlag;                                   // 0x007C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bChurchFlag;                                       // 0x007D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBankFlag;                                         // 0x007E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBlacksmithFlag;                                   // 0x007F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCasinoFlag;                                       // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUmaRaceFlag;                                      // 0x0081(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_82[0x6];                                       // 0x0082(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGAccessorSaveDataInRura* GetRuraData(const class UJackUMGItemData* ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorSaveDataInRura">();
	}
	static class UJackUMGAccessorSaveDataInRura* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorSaveDataInRura>();
	}
};
static_assert(alignof(UJackUMGAccessorSaveDataInRura) == 0x000008, "Wrong alignment on UJackUMGAccessorSaveDataInRura");
static_assert(sizeof(UJackUMGAccessorSaveDataInRura) == 0x000088, "Wrong size on UJackUMGAccessorSaveDataInRura");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, Name_0) == 0x000038, "Member 'UJackUMGAccessorSaveDataInRura::Name_0' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, Description) == 0x000048, "Member 'UJackUMGAccessorSaveDataInRura::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, JumpTag) == 0x000058, "Member 'UJackUMGAccessorSaveDataInRura::JumpTag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, Open) == 0x000060, "Member 'UJackUMGAccessorSaveDataInRura::Open' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, WorldMapPoint) == 0x000068, "Member 'UJackUMGAccessorSaveDataInRura::WorldMapPoint' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, WorldMapArea) == 0x000070, "Member 'UJackUMGAccessorSaveDataInRura::WorldMapArea' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bBukiShopFlag) == 0x000078, "Member 'UJackUMGAccessorSaveDataInRura::bBukiShopFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bBouguShopFlag) == 0x000079, "Member 'UJackUMGAccessorSaveDataInRura::bBouguShopFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bInnFlag) == 0x00007A, "Member 'UJackUMGAccessorSaveDataInRura::bInnFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bDouguShopFlag) == 0x00007B, "Member 'UJackUMGAccessorSaveDataInRura::bDouguShopFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bYorozuShopFlag) == 0x00007C, "Member 'UJackUMGAccessorSaveDataInRura::bYorozuShopFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bChurchFlag) == 0x00007D, "Member 'UJackUMGAccessorSaveDataInRura::bChurchFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bBankFlag) == 0x00007E, "Member 'UJackUMGAccessorSaveDataInRura::bBankFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bBlacksmithFlag) == 0x00007F, "Member 'UJackUMGAccessorSaveDataInRura::bBlacksmithFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bCasinoFlag) == 0x000080, "Member 'UJackUMGAccessorSaveDataInRura::bCasinoFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSaveDataInRura, bUmaRaceFlag) == 0x000081, "Member 'UJackUMGAccessorSaveDataInRura::bUmaRaceFlag' has a wrong offset!");

// Class JackGame.JackUMGSenrekiData
// 0x0020 (0x0058 - 0x0038)
class UJackUMGSenrekiData final : public UObject
{
public:
	class FName                                   ID;                                                // 0x0038(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Text;                                              // 0x0040(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSenrekiData">();
	}
	static class UJackUMGSenrekiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSenrekiData>();
	}
};
static_assert(alignof(UJackUMGSenrekiData) == 0x000008, "Wrong alignment on UJackUMGSenrekiData");
static_assert(sizeof(UJackUMGSenrekiData) == 0x000058, "Wrong size on UJackUMGSenrekiData");
static_assert(offsetof(UJackUMGSenrekiData, ID) == 0x000038, "Member 'UJackUMGSenrekiData::ID' has a wrong offset!");
static_assert(offsetof(UJackUMGSenrekiData, Text) == 0x000040, "Member 'UJackUMGSenrekiData::Text' has a wrong offset!");

// Class JackGame.JackUMGSenrekiQuestData
// 0x0050 (0x0088 - 0x0038)
class UJackUMGSenrekiQuestData final : public UObject
{
public:
	EJackProgression                              State;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackQuestReward                       RewardData;                                        // 0x0060(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bYochiQuest;                                       // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSenrekiQuestData">();
	}
	static class UJackUMGSenrekiQuestData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSenrekiQuestData>();
	}
};
static_assert(alignof(UJackUMGSenrekiQuestData) == 0x000008, "Wrong alignment on UJackUMGSenrekiQuestData");
static_assert(sizeof(UJackUMGSenrekiQuestData) == 0x000088, "Wrong size on UJackUMGSenrekiQuestData");
static_assert(offsetof(UJackUMGSenrekiQuestData, State) == 0x000038, "Member 'UJackUMGSenrekiQuestData::State' has a wrong offset!");
static_assert(offsetof(UJackUMGSenrekiQuestData, Title) == 0x000040, "Member 'UJackUMGSenrekiQuestData::Title' has a wrong offset!");
static_assert(offsetof(UJackUMGSenrekiQuestData, Description) == 0x000050, "Member 'UJackUMGSenrekiQuestData::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGSenrekiQuestData, RewardData) == 0x000060, "Member 'UJackUMGSenrekiQuestData::RewardData' has a wrong offset!");
static_assert(offsetof(UJackUMGSenrekiQuestData, bYochiQuest) == 0x000080, "Member 'UJackUMGSenrekiQuestData::bYochiQuest' has a wrong offset!");

// Class JackGame.JackUMGWorldMapQuestMemoData
// 0x0058 (0x0090 - 0x0038)
class UJackUMGWorldMapQuestMemoData final : public UObject
{
public:
	EJackProgression                              State;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Order;                                             // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHighlight;                                        // 0x0040(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TargetNpcId;                                       // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FJackQuestReward                       RewardData;                                        // 0x0070(0x0020)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWorldMapQuestMemoData">();
	}
	static class UJackUMGWorldMapQuestMemoData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWorldMapQuestMemoData>();
	}
};
static_assert(alignof(UJackUMGWorldMapQuestMemoData) == 0x000008, "Wrong alignment on UJackUMGWorldMapQuestMemoData");
static_assert(sizeof(UJackUMGWorldMapQuestMemoData) == 0x000090, "Wrong size on UJackUMGWorldMapQuestMemoData");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, State) == 0x000038, "Member 'UJackUMGWorldMapQuestMemoData::State' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, Order) == 0x00003C, "Member 'UJackUMGWorldMapQuestMemoData::Order' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, bHighlight) == 0x000040, "Member 'UJackUMGWorldMapQuestMemoData::bHighlight' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, Title) == 0x000048, "Member 'UJackUMGWorldMapQuestMemoData::Title' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, Description) == 0x000058, "Member 'UJackUMGWorldMapQuestMemoData::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, TargetNpcId) == 0x000068, "Member 'UJackUMGWorldMapQuestMemoData::TargetNpcId' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapQuestMemoData, RewardData) == 0x000070, "Member 'UJackUMGWorldMapQuestMemoData::RewardData' has a wrong offset!");

// Class JackGame.JackVehicleControllerComponent
// 0x0110 (0x0238 - 0x0128)
class UJackVehicleControllerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0x8];                                      // 0x0128(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBlendTime;                                   // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EViewTargetBlendFunction                      CameraBlendFunc;                                   // 0x0134(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_135[0x3];                                      // 0x0135(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CameraBlendExp;                                    // 0x0138(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_13C[0xF4];                                     // 0x013C(0x00F4)(Fixing Size After Last Property [ Dumper-7 ])
	TWeakObjectPtr<class AJackFriendAIController> FieldPlayerAIController;                           // 0x0230(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleControllerComponent">();
	}
	static class UJackVehicleControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleControllerComponent>();
	}
};
static_assert(alignof(UJackVehicleControllerComponent) == 0x000008, "Wrong alignment on UJackVehicleControllerComponent");
static_assert(sizeof(UJackVehicleControllerComponent) == 0x000238, "Wrong size on UJackVehicleControllerComponent");
static_assert(offsetof(UJackVehicleControllerComponent, CameraBlendTime) == 0x000130, "Member 'UJackVehicleControllerComponent::CameraBlendTime' has a wrong offset!");
static_assert(offsetof(UJackVehicleControllerComponent, CameraBlendFunc) == 0x000134, "Member 'UJackVehicleControllerComponent::CameraBlendFunc' has a wrong offset!");
static_assert(offsetof(UJackVehicleControllerComponent, CameraBlendExp) == 0x000138, "Member 'UJackVehicleControllerComponent::CameraBlendExp' has a wrong offset!");
static_assert(offsetof(UJackVehicleControllerComponent, FieldPlayerAIController) == 0x000230, "Member 'UJackVehicleControllerComponent::FieldPlayerAIController' has a wrong offset!");

// Class JackGame.JackUMGAccessorShop
// 0x0068 (0x00A0 - 0x0038)
class UJackUMGAccessorShop final : public UObject
{
public:
	class UJackUMGManager*                        UMGManager;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_40[0x60];                                      // 0x0040(0x0060)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindCampMenuResultEvent(TDelegate<void(EJackCampMenuResult CampMenuResult, EJackYadoyaMorningCallTimezone MorningCallTimezone)> Value);
	void JackCampMenuResultEventDelegate__DelegateSignature(EJackCampMenuResult CampMenuResult, EJackYadoyaMorningCallTimezone MorningCallTimezone);
	void BindKyoukaiEffectEvent(TDelegate<void(EJackKyoukaiEffectEventType EventType)> Value);
	void JackKyoukaiEffectEventDelegate__DelegateSignature(EJackKyoukaiEffectEventType EventType);
	void ClearCampMenuResultEvent();
	void ClearKyoukaiEffectEvent();
	void DoCampMenuResultEvent();
	void DoKyoukaiEffectEvent(EJackKyoukaiEffectEventType EventType);
	void ExecuteYadoyaPay();
	void ExecuteYadoyaPayAndSleep();
	void ExecuteYadoyaSleep();
	bool GetBankData(struct FJackDataTableBank* BankData);
	bool GetKyoukaiData(struct FJackDataTableChurch* KyoukaiData);
	bool GetShopData(struct FJackDataTableShop* ShopData);
	bool GetYadoyaData(struct FJackDataTableInn* YadoyaData);
	int32 GetYadoyaPrice();
	bool IsChapterSave();
	bool IsChapterSaveYotti();
	bool IsSeisyo();
	void SetCampMenuResult(EJackCampMenuResult Value);
	void SetKyoukaiEventType(EJackKyoukaiEventType Value);
	void SetKyoukaiSavedFlag(EJackKyoukaiSavedFlag Value);
	void SetMedalShopType(EJackMedal_Shop InMedalShopType);
	void SetResetSibariType(EJackSibari Value);
	void SetShopId(EJackUMGShopType InShopType, class FName InShopId);
	void SetYadoyaEventType(EJackYadoyaEventType Value);
	void SetYadoyaMorningCallTimezone(EJackYadoyaMorningCallTimezone Value);
	void SetYadoyaState(EJackUMGYaodyaState Value);

	EJackCampMenuResult GetCampMenuResult() const;
	EJackKyoukaiEventType GetKyoukaiEventType() const;
	EJackKyoukaiSavedFlag GetKyoukaiSavedFlag() const;
	EJackMedal_Shop GetMedalShopType() const;
	EJackSibari GetResetSibariType() const;
	class FName GetShopId() const;
	EJackUMGShopType GetShopType() const;
	class FString GetTimezoneTextIDSuffix(class UObject* WorldContextObject) const;
	EJackYadoyaEventType GetYadoyaEventType() const;
	EJackYadoyaMorningCallTimezone GetYadoyaMorningCallTimezone() const;
	EJackUMGYaodyaState GetYadoyaState() const;
	class FName MakeShopMenuTextID(const class FString& BaseTextID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorShop">();
	}
	static class UJackUMGAccessorShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorShop>();
	}
};
static_assert(alignof(UJackUMGAccessorShop) == 0x000008, "Wrong alignment on UJackUMGAccessorShop");
static_assert(sizeof(UJackUMGAccessorShop) == 0x0000A0, "Wrong size on UJackUMGAccessorShop");
static_assert(offsetof(UJackUMGAccessorShop, UMGManager) == 0x000038, "Member 'UJackUMGAccessorShop::UMGManager' has a wrong offset!");

// Class JackGame.JackUMGSyuurenjouBattleData
// 0x0038 (0x0070 - 0x0038)
class UJackUMGSyuurenjouBattleData final : public UObject
{
public:
	int32                                         BattleIndex;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsFinalBattle;                                    // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BattleId;                                          // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BattleName;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleMemberCount;                                 // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackCharacter>                        SelectedCharacterList;                             // 0x0060(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSyuurenjouBattleData">();
	}
	static class UJackUMGSyuurenjouBattleData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSyuurenjouBattleData>();
	}
};
static_assert(alignof(UJackUMGSyuurenjouBattleData) == 0x000008, "Wrong alignment on UJackUMGSyuurenjouBattleData");
static_assert(sizeof(UJackUMGSyuurenjouBattleData) == 0x000070, "Wrong size on UJackUMGSyuurenjouBattleData");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, BattleIndex) == 0x000038, "Member 'UJackUMGSyuurenjouBattleData::BattleIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, bIsFinalBattle) == 0x00003C, "Member 'UJackUMGSyuurenjouBattleData::bIsFinalBattle' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, BattleId) == 0x000040, "Member 'UJackUMGSyuurenjouBattleData::BattleId' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, BattleName) == 0x000048, "Member 'UJackUMGSyuurenjouBattleData::BattleName' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, BattleMemberCount) == 0x000058, "Member 'UJackUMGSyuurenjouBattleData::BattleMemberCount' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouBattleData, SelectedCharacterList) == 0x000060, "Member 'UJackUMGSyuurenjouBattleData::SelectedCharacterList' has a wrong offset!");

// Class JackGame.JackUMGSyuurenjouRewardData
// 0x0048 (0x0080 - 0x0038)
class UJackUMGSyuurenjouRewardData final : public UObject
{
public:
	bool                                          bAcquiredReward;                                   // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardConditions;                                  // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ItemID;                                            // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             ItemIcon;                                          // 0x0058(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ItemName;                                          // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ItemCount;                                         // 0x0070(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TWeakObjectPtr<class UJackUMGSyuurenjouItemData> ParentData;                                        // 0x0074(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGSyuurenjouRewardData* GetSyuurenjouRewardData(class UJackUMGItemData* ItemData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSyuurenjouRewardData">();
	}
	static class UJackUMGSyuurenjouRewardData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSyuurenjouRewardData>();
	}
};
static_assert(alignof(UJackUMGSyuurenjouRewardData) == 0x000008, "Wrong alignment on UJackUMGSyuurenjouRewardData");
static_assert(sizeof(UJackUMGSyuurenjouRewardData) == 0x000080, "Wrong size on UJackUMGSyuurenjouRewardData");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, bAcquiredReward) == 0x000038, "Member 'UJackUMGSyuurenjouRewardData::bAcquiredReward' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, RewardConditions) == 0x000040, "Member 'UJackUMGSyuurenjouRewardData::RewardConditions' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, ItemID) == 0x000050, "Member 'UJackUMGSyuurenjouRewardData::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, ItemIcon) == 0x000058, "Member 'UJackUMGSyuurenjouRewardData::ItemIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, ItemName) == 0x000060, "Member 'UJackUMGSyuurenjouRewardData::ItemName' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, ItemCount) == 0x000070, "Member 'UJackUMGSyuurenjouRewardData::ItemCount' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouRewardData, ParentData) == 0x000074, "Member 'UJackUMGSyuurenjouRewardData::ParentData' has a wrong offset!");

// Class JackGame.JackUMGSyuurenjouItemData
// 0x0068 (0x00A0 - 0x0038)
class UJackUMGSyuurenjouItemData final : public UObject
{
public:
	bool                                          bOpen;                                             // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Title;                                             // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DescriptionTitle;                                  // 0x0050(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Description;                                       // 0x0060(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGItemData*                       RewardItemData1;                                   // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGItemData*                       RewardItemData2;                                   // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGItemData*                       RewardItemData3;                                   // 0x0080(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGItemData*                       RewardItemData4;                                   // 0x0088(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleCount;                                       // 0x0090(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BattleMemberCount;                                 // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Score;                                             // 0x0098(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9C[0x4];                                       // 0x009C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGSyuurenjouItemData* GetSyuurenjouItemData(class UJackUMGItemData* ItemData);

	TArray<class UJackUMGItemData*> GetRewardItemDataList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSyuurenjouItemData">();
	}
	static class UJackUMGSyuurenjouItemData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSyuurenjouItemData>();
	}
};
static_assert(alignof(UJackUMGSyuurenjouItemData) == 0x000008, "Wrong alignment on UJackUMGSyuurenjouItemData");
static_assert(sizeof(UJackUMGSyuurenjouItemData) == 0x0000A0, "Wrong size on UJackUMGSyuurenjouItemData");
static_assert(offsetof(UJackUMGSyuurenjouItemData, bOpen) == 0x000038, "Member 'UJackUMGSyuurenjouItemData::bOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, Title) == 0x000040, "Member 'UJackUMGSyuurenjouItemData::Title' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, DescriptionTitle) == 0x000050, "Member 'UJackUMGSyuurenjouItemData::DescriptionTitle' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, Description) == 0x000060, "Member 'UJackUMGSyuurenjouItemData::Description' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, RewardItemData1) == 0x000070, "Member 'UJackUMGSyuurenjouItemData::RewardItemData1' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, RewardItemData2) == 0x000078, "Member 'UJackUMGSyuurenjouItemData::RewardItemData2' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, RewardItemData3) == 0x000080, "Member 'UJackUMGSyuurenjouItemData::RewardItemData3' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, RewardItemData4) == 0x000088, "Member 'UJackUMGSyuurenjouItemData::RewardItemData4' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, BattleCount) == 0x000090, "Member 'UJackUMGSyuurenjouItemData::BattleCount' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, BattleMemberCount) == 0x000094, "Member 'UJackUMGSyuurenjouItemData::BattleMemberCount' has a wrong offset!");
static_assert(offsetof(UJackUMGSyuurenjouItemData, Score) == 0x000098, "Member 'UJackUMGSyuurenjouItemData::Score' has a wrong offset!");

// Class JackGame.JackUMGAccessorSyuurenjou
// 0x0080 (0x00B8 - 0x0038)
class UJackUMGAccessorSyuurenjou final : public UObject
{
public:
	class UJackUMGManager*                        UMGManager;                                        // 0x0038(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FName                                   SelectedSirenKey;                                  // 0x0040(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGSyuurenjouBattleData*>   BattleDataList;                                    // 0x0048(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	int32                                         CurrentBattleIndex;                                // 0x0058(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         UsedTurnCount;                                     // 0x005C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	EJackSyuurenjouMenuResult                     MenuResult;                                        // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61[0x57];                                      // 0x0061(0x0057)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddUsedTurnCount(int32 Value);
	class UJackUMGSyuurenjouItemData* CreateSyuurenjouItemData(bool bOpen, const struct FJackDataTableSyuurenjou& Data);
	void GetMemberSelectPageData(class FString* Title, TArray<class UJackUMGSyuurenjouBattleData*>* OutBattleDataList, TArray<class UJackFriendGameCharacter*>* PartyMemberList);
	int32 GetPartyMemberCount();
	struct FJackDataTableSyuurenjou GetSelectedSyuurenjouData();
	TArray<class UJackUMGItemData*> GetSirenSelectPageData();
	struct FJackDataTableSyuurenjou GetSyuurenjouData(class FName Key);
	void Reset();
	void SaveSelectedCharacterListAtSelectedSiren();
	void SetCurrentBattleIndex(int32 Value);
	void SetMenuResult(EJackSyuurenjouMenuResult Value);
	void SetSelectedSirenKey(class FName Value);
	void SetUsedTurnCount(int32 Value);

	TArray<class UJackUMGSyuurenjouBattleData*> GetBattleDataList() const;
	class UJackUMGSyuurenjouBattleData* GetCurrentBattleData() const;
	int32 GetCurrentBattleIndex() const;
	class UDataTable* GetDataTableSyuurenjou() const;
	EJackSyuurenjouMenuResult GetMenuResult() const;
	class FName GetSelectedSirenKey() const;
	int32 GetUsedTurnCount() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAccessorSyuurenjou">();
	}
	static class UJackUMGAccessorSyuurenjou* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAccessorSyuurenjou>();
	}
};
static_assert(alignof(UJackUMGAccessorSyuurenjou) == 0x000008, "Wrong alignment on UJackUMGAccessorSyuurenjou");
static_assert(sizeof(UJackUMGAccessorSyuurenjou) == 0x0000B8, "Wrong size on UJackUMGAccessorSyuurenjou");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, UMGManager) == 0x000038, "Member 'UJackUMGAccessorSyuurenjou::UMGManager' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, SelectedSirenKey) == 0x000040, "Member 'UJackUMGAccessorSyuurenjou::SelectedSirenKey' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, BattleDataList) == 0x000048, "Member 'UJackUMGAccessorSyuurenjou::BattleDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, CurrentBattleIndex) == 0x000058, "Member 'UJackUMGAccessorSyuurenjou::CurrentBattleIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, UsedTurnCount) == 0x00005C, "Member 'UJackUMGAccessorSyuurenjou::UsedTurnCount' has a wrong offset!");
static_assert(offsetof(UJackUMGAccessorSyuurenjou, MenuResult) == 0x000060, "Member 'UJackUMGAccessorSyuurenjou::MenuResult' has a wrong offset!");

// Class JackGame.JackUMGAnimDelegate
// 0x0010 (0x0068 - 0x0058)
class UJackUMGAnimDelegate final : public UJackUMGAnimBase
{
public:
	TDelegate<void()>                             JackOnAnimDelegate;                                // 0x0058(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimDelegate">();
	}
	static class UJackUMGAnimDelegate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimDelegate>();
	}
};
static_assert(alignof(UJackUMGAnimDelegate) == 0x000008, "Wrong alignment on UJackUMGAnimDelegate");
static_assert(sizeof(UJackUMGAnimDelegate) == 0x000068, "Wrong size on UJackUMGAnimDelegate");
static_assert(offsetof(UJackUMGAnimDelegate, JackOnAnimDelegate) == 0x000058, "Member 'UJackUMGAnimDelegate::JackOnAnimDelegate' has a wrong offset!");

// Class JackGame.JackUMGAnimDelay
// 0x0008 (0x0060 - 0x0058)
class UJackUMGAnimDelay final : public UJackUMGAnimBase
{
public:
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimDelay">();
	}
	static class UJackUMGAnimDelay* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimDelay>();
	}
};
static_assert(alignof(UJackUMGAnimDelay) == 0x000008, "Wrong alignment on UJackUMGAnimDelay");
static_assert(sizeof(UJackUMGAnimDelay) == 0x000060, "Wrong size on UJackUMGAnimDelay");

// Class JackGame.JackVehicleRiderControllerComponent
// 0x00A8 (0x01D0 - 0x0128)
class UJackVehicleRiderControllerComponent final : public UActorComponent
{
public:
	uint8                                         Pad_128[0xA8];                                     // 0x0128(0x00A8)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleRiderControllerComponent">();
	}
	static class UJackVehicleRiderControllerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleRiderControllerComponent>();
	}
};
static_assert(alignof(UJackVehicleRiderControllerComponent) == 0x000008, "Wrong alignment on UJackVehicleRiderControllerComponent");
static_assert(sizeof(UJackVehicleRiderControllerComponent) == 0x0001D0, "Wrong size on UJackVehicleRiderControllerComponent");

// Class JackGame.JackUMGAnimFloat
// 0x0020 (0x0078 - 0x0058)
class UJackUMGAnimFloat final : public UJackUMGAnimBase
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_60[0x8];                                       // 0x0060(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(class UJackUMGAnimFloat* InAnimFloat, float InValue)> JackOnUMGAnimFloatDelegate;                        // 0x0068(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimFloat">();
	}
	static class UJackUMGAnimFloat* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimFloat>();
	}
};
static_assert(alignof(UJackUMGAnimFloat) == 0x000008, "Wrong alignment on UJackUMGAnimFloat");
static_assert(sizeof(UJackUMGAnimFloat) == 0x000078, "Wrong size on UJackUMGAnimFloat");
static_assert(offsetof(UJackUMGAnimFloat, Curve) == 0x000058, "Member 'UJackUMGAnimFloat::Curve' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimFloat, JackOnUMGAnimFloatDelegate) == 0x000068, "Member 'UJackUMGAnimFloat::JackOnUMGAnimFloatDelegate' has a wrong offset!");

// Class JackGame.JackUMGAnimMove
// 0x0018 (0x0070 - 0x0058)
class UJackUMGAnimMove final : public UJackUMGAnimBase
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              StartPosition;                                     // 0x0060(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              EndPosition;                                       // 0x0068(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimMove">();
	}
	static class UJackUMGAnimMove* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimMove>();
	}
};
static_assert(alignof(UJackUMGAnimMove) == 0x000008, "Wrong alignment on UJackUMGAnimMove");
static_assert(sizeof(UJackUMGAnimMove) == 0x000070, "Wrong size on UJackUMGAnimMove");
static_assert(offsetof(UJackUMGAnimMove, Curve) == 0x000058, "Member 'UJackUMGAnimMove::Curve' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimMove, StartPosition) == 0x000060, "Member 'UJackUMGAnimMove::StartPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimMove, EndPosition) == 0x000068, "Member 'UJackUMGAnimMove::EndPosition' has a wrong offset!");

// Class JackGame.JackUMGAnimScale
// 0x0018 (0x0070 - 0x0058)
class UJackUMGAnimScale final : public UJackUMGAnimBase
{
public:
	class UCurveFloat*                            Curve;                                             // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              StartScale;                                        // 0x0060(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector2D                              EndScale;                                          // 0x0068(0x0008)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimScale">();
	}
	static class UJackUMGAnimScale* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimScale>();
	}
};
static_assert(alignof(UJackUMGAnimScale) == 0x000008, "Wrong alignment on UJackUMGAnimScale");
static_assert(sizeof(UJackUMGAnimScale) == 0x000070, "Wrong size on UJackUMGAnimScale");
static_assert(offsetof(UJackUMGAnimScale, Curve) == 0x000058, "Member 'UJackUMGAnimScale::Curve' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimScale, StartScale) == 0x000060, "Member 'UJackUMGAnimScale::StartScale' has a wrong offset!");
static_assert(offsetof(UJackUMGAnimScale, EndScale) == 0x000068, "Member 'UJackUMGAnimScale::EndScale' has a wrong offset!");

// Class JackGame.JackUMGAnimList
// 0x0010 (0x0068 - 0x0058)
class UJackUMGAnimList final : public UJackUMGAnimBase
{
public:
	TArray<class UJackUMGAnimBase*>               AnimList;                                          // 0x0058(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)

public:
	void SetAlphaAnim(int32 InGroup, class UCurveFloat* InCurve, const float Start, const float End);
	void SetAlphaAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const float Start, const float End);
	void SetAlphaToAnim(int32 InGroup, class UCurveFloat* InCurve, const float End);
	void SetAlphaToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const float End);
	void SetAnimDelay(int32 InGroup, float DelayTime);
	void SetAnimDelegate(int32 InGroup, TDelegate<void()> InDelegate);
	bool SetAnimSet(int32 InGroup, const struct FJackUMGAnimSet& InAnimSet);
	bool SetAnimSetOfPanel(int32 InGroup, const struct FJackUMGAnimSet& InAnimSet);
	void SetMoveAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetMoveAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetMoveToAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetMoveToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetScaleAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetScaleAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& Start, const struct FVector2D& End);
	void SetScaleToAnim(int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);
	void SetScaleToAnimOfPanel(class UWidget* InPanel, int32 InGroup, class UCurveFloat* InCurve, const struct FVector2D& End);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAnimList">();
	}
	static class UJackUMGAnimList* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAnimList>();
	}
};
static_assert(alignof(UJackUMGAnimList) == 0x000008, "Wrong alignment on UJackUMGAnimList");
static_assert(sizeof(UJackUMGAnimList) == 0x000068, "Wrong size on UJackUMGAnimList");
static_assert(offsetof(UJackUMGAnimList, AnimList) == 0x000058, "Member 'UJackUMGAnimList::AnimList' has a wrong offset!");

// Class JackGame.JackUMGAsyncLoad
// 0x0038 (0x0070 - 0x0038)
class UJackUMGAsyncLoad : public UObject
{
public:
	TDelegate<void(int32 InResultCode, class UObject* InLoaddedObject, class UJackUMGAsyncLoad* InLoadInfo)> Delegate;                                          // 0x0038(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	class UWorld*                                 World;                                             // 0x0048(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        AssetRef;                                          // 0x0058(0x0008)(HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTexturePanel(int32 InUniqueId, class UImage* InImagePanel);

	int32 GetUniqueID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGAsyncLoad">();
	}
	static class UJackUMGAsyncLoad* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGAsyncLoad>();
	}
};
static_assert(alignof(UJackUMGAsyncLoad) == 0x000008, "Wrong alignment on UJackUMGAsyncLoad");
static_assert(sizeof(UJackUMGAsyncLoad) == 0x000070, "Wrong size on UJackUMGAsyncLoad");
static_assert(offsetof(UJackUMGAsyncLoad, Delegate) == 0x000038, "Member 'UJackUMGAsyncLoad::Delegate' has a wrong offset!");
static_assert(offsetof(UJackUMGAsyncLoad, World) == 0x000048, "Member 'UJackUMGAsyncLoad::World' has a wrong offset!");
static_assert(offsetof(UJackUMGAsyncLoad, Object) == 0x000050, "Member 'UJackUMGAsyncLoad::Object' has a wrong offset!");
static_assert(offsetof(UJackUMGAsyncLoad, AssetRef) == 0x000058, "Member 'UJackUMGAsyncLoad::AssetRef' has a wrong offset!");

// Class JackGame.JackUMGTextureLoadInfo
// 0x0000 (0x0070 - 0x0070)
class UJackUMGTextureLoadInfo final : public UJackUMGAsyncLoad
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTextureLoadInfo">();
	}
	static class UJackUMGTextureLoadInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTextureLoadInfo>();
	}
};
static_assert(alignof(UJackUMGTextureLoadInfo) == 0x000008, "Wrong alignment on UJackUMGTextureLoadInfo");
static_assert(sizeof(UJackUMGTextureLoadInfo) == 0x000070, "Wrong size on UJackUMGTextureLoadInfo");

// Class JackGame.JackUMGWidgetLoadInfo
// 0x0010 (0x0080 - 0x0070)
class UJackUMGWidgetLoadInfo final : public UJackUMGAsyncLoad
{
public:
	uint8                                         Pad_70[0x10];                                      // 0x0070(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWidgetLoadInfo">();
	}
	static class UJackUMGWidgetLoadInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWidgetLoadInfo>();
	}
};
static_assert(alignof(UJackUMGWidgetLoadInfo) == 0x000008, "Wrong alignment on UJackUMGWidgetLoadInfo");
static_assert(sizeof(UJackUMGWidgetLoadInfo) == 0x000080, "Wrong size on UJackUMGWidgetLoadInfo");

// Class JackGame.JackUMGALoadTextureBrush
// 0x0018 (0x0060 - 0x0048)
class UJackUMGALoadTextureBrush final : public UJackUMGLoadBrushBase
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGALoadTextureBrush">();
	}
	static class UJackUMGALoadTextureBrush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGALoadTextureBrush>();
	}
};
static_assert(alignof(UJackUMGALoadTextureBrush) == 0x000008, "Wrong alignment on UJackUMGALoadTextureBrush");
static_assert(sizeof(UJackUMGALoadTextureBrush) == 0x000060, "Wrong size on UJackUMGALoadTextureBrush");

// Class JackGame.JackUMGALoadMaterialBrush
// 0x0018 (0x0060 - 0x0048)
class UJackUMGALoadMaterialBrush final : public UJackUMGLoadBrushBase
{
public:
	uint8                                         Pad_48[0x18];                                      // 0x0048(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGALoadMaterialBrush">();
	}
	static class UJackUMGALoadMaterialBrush* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGALoadMaterialBrush>();
	}
};
static_assert(alignof(UJackUMGALoadMaterialBrush) == 0x000008, "Wrong alignment on UJackUMGALoadMaterialBrush");
static_assert(sizeof(UJackUMGALoadMaterialBrush) == 0x000060, "Wrong size on UJackUMGALoadMaterialBrush");

// Class JackGame.JackUMGBalloon
// 0x00B0 (0x0420 - 0x0370)
class UJackUMGBalloon : public UJackUMGWidgetBase
{
public:
	UMulticastDelegateProperty_                   JackUMGBalloonEnd;                                 // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0380(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         ImageList;                                         // 0x0388(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FJackUMGBalloonInfo                    BalloonInfo;                                       // 0x0398(0x0068)(BlueprintVisible, NativeAccessSpecifierPublic)
	float                                         Timer;                                             // 0x0400(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0404(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40C[0x14];                                     // 0x040C(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitBalloon(const struct FVector& Wpos, EJackPopupBalloon Type, int32 Num, class UJackGameCharacter* InGameCharacter, const struct FVector& TestOffset, class USkeletalMeshComponent* InLocalMesh, class FName InSocketName);
	void JackUMGBalloonDisappearDelegate__DelegateSignature(class UJackUMGBalloon* InBalloon);
	void MakeBalloon(class UCanvasPanel* ItemListCanvas, int32 ZOrder);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGBalloon">();
	}
	static class UJackUMGBalloon* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGBalloon>();
	}
};
static_assert(alignof(UJackUMGBalloon) == 0x000008, "Wrong alignment on UJackUMGBalloon");
static_assert(sizeof(UJackUMGBalloon) == 0x000420, "Wrong size on UJackUMGBalloon");
static_assert(offsetof(UJackUMGBalloon, JackUMGBalloonEnd) == 0x000370, "Member 'UJackUMGBalloon::JackUMGBalloonEnd' has a wrong offset!");
static_assert(offsetof(UJackUMGBalloon, IsFocusable) == 0x000380, "Member 'UJackUMGBalloon::IsFocusable' has a wrong offset!");
static_assert(offsetof(UJackUMGBalloon, ImageList) == 0x000388, "Member 'UJackUMGBalloon::ImageList' has a wrong offset!");
static_assert(offsetof(UJackUMGBalloon, BalloonInfo) == 0x000398, "Member 'UJackUMGBalloon::BalloonInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGBalloon, Timer) == 0x000400, "Member 'UJackUMGBalloon::Timer' has a wrong offset!");
static_assert(offsetof(UJackUMGBalloon, Offset) == 0x000404, "Member 'UJackUMGBalloon::Offset' has a wrong offset!");

// Class JackGame.JackUMGBGMVolumeEditor
// 0x0010 (0x0048 - 0x0038)
class UJackUMGBGMVolumeEditor final : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UJackUMGBGMVolumeEditor* CreateBGMVolumeEditor(class UObject* WorldContextObject);
	static void DeleteBGMVolumeEditor(class UJackUMGBGMVolumeEditor* InBGMVolumeEditor);
	static const class FText GetBGMVolumeTypeText(EJackMusicBGMVolumeType InVolumeType);

	EJackMusicBGMVolumeType ChangeBGMVolumeType(EJackMusicBGMVolumeType InVolumeType, bool bIsOrche);
	void ChangePage(int32 InSelectIndex, bool bIsPageDown);
	class FString GetBGMVolumeTypeAssetName(const class FString& InAssetName, const EJackMusicBGMVolumeType InVolumeType, bool bIsForceOrhce);
	void Initialize(class UJackUMGBrowserBase* InBrowserBase, class UCanvasPanel* InItemListCanvas, class UJackUMGScrollController* InListController, int32 InZOrder);
	void SaveJukeboxItem(class UJackUMGJukeboxItemData* JukeboxItemData, EJackMusicBGMVolumeType InVolumeType);
	void SaveJukeboxList();
	class UJackUMGJukeboxItemData* SetSelectBGMItemData(class UJackUMGItemBase* InItemBase);
	void SetSystemBGMVolumeType(EJackMusicBGMVolumeType InVolumeType);
	EJackMusicBGMVolumeType ToggleBGMVolumeType(EJackMusicBGMVolumeType InVolumeType);
	void UpdateJukeboxList(EJackMusicBGMVolumeType InVolumeType, int32 InSelectIndex, bool bIsForceUpdate);

	EJackMusicBGMVolumeType GetSystemBGMVolumeType() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGBGMVolumeEditor">();
	}
	static class UJackUMGBGMVolumeEditor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGBGMVolumeEditor>();
	}
};
static_assert(alignof(UJackUMGBGMVolumeEditor) == 0x000008, "Wrong alignment on UJackUMGBGMVolumeEditor");
static_assert(sizeof(UJackUMGBGMVolumeEditor) == 0x000048, "Wrong size on UJackUMGBGMVolumeEditor");

// Class JackGame.JackUMGCashierWindow
// 0x0038 (0x0438 - 0x0400)
class UJackUMGCashierWindow : public UJackUMGWindowBase
{
public:
	class UJackUMGValueController*                ValueController;                                   // 0x0400(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsComma;                                           // 0x0408(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsZenkaku;                                         // 0x0409(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_40A[0x2];                                      // 0x040A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ResultCode;                                        // 0x040C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   TotalText;                                         // 0x0410(0x0018)(BlueprintVisible, BlueprintReadOnly, Protected, NativeAccessSpecifierProtected)
	int32                                         TotalPrice;                                        // 0x0428(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         InputValue;                                        // 0x042C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         UnitPrice;                                         // 0x0430(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVisibleUpArrow;                                 // 0x0434(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsVisibleDownArrow;                               // 0x0435(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_436[0x2];                                      // 0x0436(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishShowCashierDelegate();
	void InitCashierWindow(class UJackUMGValueController* InValueController, int32 InZOrder);
	void SetController(class UJackUMGValueController* InValueController);
	void SetupCashier(int32 InInitValue, int32 InUnitPrice, int32 InNumDigits, int32 InMinDigits);
	void SetupNumberRange(int32 InNumMin, int32 InNumMax);
	void WaitResult(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo);

	int32 GetInputValue() const;
	int32 GetTotalPrice() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCashierWindow">();
	}
	static class UJackUMGCashierWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCashierWindow>();
	}
};
static_assert(alignof(UJackUMGCashierWindow) == 0x000008, "Wrong alignment on UJackUMGCashierWindow");
static_assert(sizeof(UJackUMGCashierWindow) == 0x000438, "Wrong size on UJackUMGCashierWindow");
static_assert(offsetof(UJackUMGCashierWindow, ValueController) == 0x000400, "Member 'UJackUMGCashierWindow::ValueController' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, IsComma) == 0x000408, "Member 'UJackUMGCashierWindow::IsComma' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, IsZenkaku) == 0x000409, "Member 'UJackUMGCashierWindow::IsZenkaku' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, ResultCode) == 0x00040C, "Member 'UJackUMGCashierWindow::ResultCode' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, TotalText) == 0x000410, "Member 'UJackUMGCashierWindow::TotalText' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, TotalPrice) == 0x000428, "Member 'UJackUMGCashierWindow::TotalPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, InputValue) == 0x00042C, "Member 'UJackUMGCashierWindow::InputValue' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, UnitPrice) == 0x000430, "Member 'UJackUMGCashierWindow::UnitPrice' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, bIsVisibleUpArrow) == 0x000434, "Member 'UJackUMGCashierWindow::bIsVisibleUpArrow' has a wrong offset!");
static_assert(offsetof(UJackUMGCashierWindow, bIsVisibleDownArrow) == 0x000435, "Member 'UJackUMGCashierWindow::bIsVisibleDownArrow' has a wrong offset!");

// Class JackGame.JackUtils
// 0x0000 (0x0038 - 0x0038)
class UJackUtils final : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUtils">();
	}
	static class UJackUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUtils>();
	}
};
static_assert(alignof(UJackUtils) == 0x000008, "Wrong alignment on UJackUtils");
static_assert(sizeof(UJackUtils) == 0x000038, "Wrong size on UJackUtils");

// Class JackGame.JackUMGCharacterCaptureControlWidget
// 0x0000 (0x0370 - 0x0370)
class UJackUMGCharacterCaptureControlWidget : public UJackUMGWidgetBase
{
public:
	void GetZukanMotionData(class FName MonsterZukanID, bool* bIsFound, struct FJackDataTableMonsterZukanMotion* Data);
	void SetDisplayedDebugInfo(bool bValue);
	void SetDisplayedDebugTargetSize(bool bValue);

	bool GetDisplayedDebugInfo() const;
	bool GetDisplayedDebugTargetSize() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCharacterCaptureControlWidget">();
	}
	static class UJackUMGCharacterCaptureControlWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCharacterCaptureControlWidget>();
	}
};
static_assert(alignof(UJackUMGCharacterCaptureControlWidget) == 0x000008, "Wrong alignment on UJackUMGCharacterCaptureControlWidget");
static_assert(sizeof(UJackUMGCharacterCaptureControlWidget) == 0x000370, "Wrong size on UJackUMGCharacterCaptureControlWidget");

// Class JackGame.JackUMGCharStateType
// 0x0010 (0x0048 - 0x0038)
class UJackUMGCharStateType final : public UObject
{
public:
	int32                                         StateType;                                         // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             Image;                                             // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCharStateType">();
	}
	static class UJackUMGCharStateType* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCharStateType>();
	}
};
static_assert(alignof(UJackUMGCharStateType) == 0x000008, "Wrong alignment on UJackUMGCharStateType");
static_assert(sizeof(UJackUMGCharStateType) == 0x000048, "Wrong size on UJackUMGCharStateType");
static_assert(offsetof(UJackUMGCharStateType, StateType) == 0x000038, "Member 'UJackUMGCharStateType::StateType' has a wrong offset!");
static_assert(offsetof(UJackUMGCharStateType, Image) == 0x000040, "Member 'UJackUMGCharStateType::Image' has a wrong offset!");

// Class JackGame.JackUMGCharacterStatus
// 0x0028 (0x0060 - 0x0038)
class UJackUMGCharacterStatus final : public UObject
{
public:
	EJackCharacter                                CharType;                                          // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGStateDispController*            Iiyatu;                                            // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UJackUMGStateDispController*            Waruyatu;                                          // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresentHP;                                         // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxHP;                                             // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PresentMP;                                         // 0x0058(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMP;                                             // 0x005C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCharacterStatus">();
	}
	static class UJackUMGCharacterStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCharacterStatus>();
	}
};
static_assert(alignof(UJackUMGCharacterStatus) == 0x000008, "Wrong alignment on UJackUMGCharacterStatus");
static_assert(sizeof(UJackUMGCharacterStatus) == 0x000060, "Wrong size on UJackUMGCharacterStatus");
static_assert(offsetof(UJackUMGCharacterStatus, CharType) == 0x000038, "Member 'UJackUMGCharacterStatus::CharType' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, Iiyatu) == 0x000040, "Member 'UJackUMGCharacterStatus::Iiyatu' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, Waruyatu) == 0x000048, "Member 'UJackUMGCharacterStatus::Waruyatu' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, PresentHP) == 0x000050, "Member 'UJackUMGCharacterStatus::PresentHP' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, MaxHP) == 0x000054, "Member 'UJackUMGCharacterStatus::MaxHP' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, PresentMP) == 0x000058, "Member 'UJackUMGCharacterStatus::PresentMP' has a wrong offset!");
static_assert(offsetof(UJackUMGCharacterStatus, MaxMP) == 0x00005C, "Member 'UJackUMGCharacterStatus::MaxMP' has a wrong offset!");

// Class JackGame.JackVoiceTimelineTrack
// 0x0000 (0x0038 - 0x0038)
class UJackVoiceTimelineTrack : public UObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrack">();
	}
	static class UJackVoiceTimelineTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrack>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrack) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrack");
static_assert(sizeof(UJackVoiceTimelineTrack) == 0x000038, "Wrong size on UJackVoiceTimelineTrack");

// Class JackGame.JackVoiceTimelineTrackEyeCloseRate
// 0x0028 (0x0060 - 0x0038)
class UJackVoiceTimelineTrackEyeCloseRate final : public UJackVoiceTimelineTrack
{
public:
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrackEyeCloseRate">();
	}
	static class UJackVoiceTimelineTrackEyeCloseRate* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrackEyeCloseRate>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrackEyeCloseRate) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrackEyeCloseRate");
static_assert(sizeof(UJackVoiceTimelineTrackEyeCloseRate) == 0x000060, "Wrong size on UJackVoiceTimelineTrackEyeCloseRate");

// Class JackGame.JackUMGCopyright
// 0x0030 (0x0460 - 0x0430)
class UJackUMGCopyright : public UJackUMGBrowserBase
{
public:
	UMulticastDelegateProperty_                   CopyrightScrollDelegate;                           // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_440[0x20];                                     // 0x0440(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackUMGCopyrightScrollDelegate__DelegateSignature(bool IsUpScroll);
	void MakeTextPanelList(class UCanvasPanel* TextList);

	const int32 GetCopyrightLineCount(class UTextBlock* TargetTextBlock) const;
	const TArray<class UImage*> GetOutImageList() const;
	const TArray<class UTextBlock*> GetOutTextList() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGCopyright">();
	}
	static class UJackUMGCopyright* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGCopyright>();
	}
};
static_assert(alignof(UJackUMGCopyright) == 0x000008, "Wrong alignment on UJackUMGCopyright");
static_assert(sizeof(UJackUMGCopyright) == 0x000460, "Wrong size on UJackUMGCopyright");
static_assert(offsetof(UJackUMGCopyright, CopyrightScrollDelegate) == 0x000430, "Member 'UJackUMGCopyright::CopyrightScrollDelegate' has a wrong offset!");

// Class JackGame.JackUMGDataContainer
// 0x0050 (0x0088 - 0x0038)
class UJackUMGDataContainer final : public UObject
{
public:
	EJackUMGItemContainerType                     Type;                                              // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Text;                                              // 0x0050(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UMaterial*                              Material;                                          // 0x0068(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0070(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Object;                                            // 0x0078(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsVisible;                                         // 0x0080(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGDataContainer">();
	}
	static class UJackUMGDataContainer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGDataContainer>();
	}
};
static_assert(alignof(UJackUMGDataContainer) == 0x000008, "Wrong alignment on UJackUMGDataContainer");
static_assert(sizeof(UJackUMGDataContainer) == 0x000088, "Wrong size on UJackUMGDataContainer");
static_assert(offsetof(UJackUMGDataContainer, Type) == 0x000038, "Member 'UJackUMGDataContainer::Type' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Tag) == 0x000040, "Member 'UJackUMGDataContainer::Tag' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Value) == 0x000048, "Member 'UJackUMGDataContainer::Value' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Text) == 0x000050, "Member 'UJackUMGDataContainer::Text' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Material) == 0x000068, "Member 'UJackUMGDataContainer::Material' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Texture) == 0x000070, "Member 'UJackUMGDataContainer::Texture' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, Object) == 0x000078, "Member 'UJackUMGDataContainer::Object' has a wrong offset!");
static_assert(offsetof(UJackUMGDataContainer, IsVisible) == 0x000080, "Member 'UJackUMGDataContainer::IsVisible' has a wrong offset!");

// Class JackGame.JackFukidasiLateTickActor
// 0x0008 (0x03A0 - 0x0398)
class AJackFukidasiLateTickActor final : public AActor
{
public:
	uint8                                         Pad_398[0x8];                                      // 0x0398(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackFukidasiLateTickActor">();
	}
	static class AJackFukidasiLateTickActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackFukidasiLateTickActor>();
	}
};
static_assert(alignof(AJackFukidasiLateTickActor) == 0x000008, "Wrong alignment on AJackFukidasiLateTickActor");
static_assert(sizeof(AJackFukidasiLateTickActor) == 0x0003A0, "Wrong size on AJackFukidasiLateTickActor");

// Class JackGame.JackUMGMapTextItemBase
// 0x0028 (0x0398 - 0x0370)
class UJackUMGMapTextItemBase : public UJackUMGWidgetBase
{
public:
	struct FVector2D                              ItemSize;                                          // 0x0370(0x0008)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MapVolumeID;                                       // 0x0378(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapTextItemControlMethod                 ControlMethod;                                     // 0x0380(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_381[0x7];                                      // 0x0381(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ConfigID;                                          // 0x0388(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackGameFlagCategory                         FlagCategory;                                      // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackGameFlagOperator                         FlagOperator;                                      // 0x0391(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackMapTextItemDisplayMethodInNeighborMapMode DisplayMethodInNeighborMapMode;                    // 0x0392(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_393[0x5];                                      // 0x0393(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetBlinkAvailable(bool bAvaiable);
	void SetBlinkEnabled(bool bEnabled);
	void SetBlinkEnabledBP(bool bEnabled);
	void SetConditionalBeginDestroyEnabled(bool bEnabled);
	void UpdateItemSize(const struct FVector2D& Size);

	bool IsBlinkAvailable() const;
	bool IsBlinkEnabled() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapTextItemBase">();
	}
	static class UJackUMGMapTextItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapTextItemBase>();
	}
};
static_assert(alignof(UJackUMGMapTextItemBase) == 0x000008, "Wrong alignment on UJackUMGMapTextItemBase");
static_assert(sizeof(UJackUMGMapTextItemBase) == 0x000398, "Wrong size on UJackUMGMapTextItemBase");
static_assert(offsetof(UJackUMGMapTextItemBase, ItemSize) == 0x000370, "Member 'UJackUMGMapTextItemBase::ItemSize' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, MapVolumeID) == 0x000378, "Member 'UJackUMGMapTextItemBase::MapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, ControlMethod) == 0x000380, "Member 'UJackUMGMapTextItemBase::ControlMethod' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, ConfigID) == 0x000388, "Member 'UJackUMGMapTextItemBase::ConfigID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, FlagCategory) == 0x000390, "Member 'UJackUMGMapTextItemBase::FlagCategory' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, FlagOperator) == 0x000391, "Member 'UJackUMGMapTextItemBase::FlagOperator' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextItemBase, DisplayMethodInNeighborMapMode) == 0x000392, "Member 'UJackUMGMapTextItemBase::DisplayMethodInNeighborMapMode' has a wrong offset!");

// Class JackGame.JackUMGFukidasiBaseData
// 0x0020 (0x00B8 - 0x0098)
class UJackUMGFukidasiBaseData : public UJackUMG3DWidgetData
{
public:
	TWeakObjectPtr<class AJackScheduledNPC>       TargetNPC;                                         // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackNPCImportance                            Importance;                                        // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x17];                                      // 0x00A1(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFukidasiBaseData">();
	}
	static class UJackUMGFukidasiBaseData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFukidasiBaseData>();
	}
};
static_assert(alignof(UJackUMGFukidasiBaseData) == 0x000008, "Wrong alignment on UJackUMGFukidasiBaseData");
static_assert(sizeof(UJackUMGFukidasiBaseData) == 0x0000B8, "Wrong size on UJackUMGFukidasiBaseData");
static_assert(offsetof(UJackUMGFukidasiBaseData, TargetNPC) == 0x000098, "Member 'UJackUMGFukidasiBaseData::TargetNPC' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiBaseData, Importance) == 0x0000A0, "Member 'UJackUMGFukidasiBaseData::Importance' has a wrong offset!");

// Class JackGame.JackUMGFukidasiIconData
// 0x0018 (0x00D0 - 0x00B8)
class UJackUMGFukidasiIconData final : public UJackUMGFukidasiBaseData
{
public:
	uint8                                         Pad_B8[0x4];                                       // 0x00B8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x00BC(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C8[0x8];                                       // 0x00C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFukidasiIconData">();
	}
	static class UJackUMGFukidasiIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFukidasiIconData>();
	}
};
static_assert(alignof(UJackUMGFukidasiIconData) == 0x000008, "Wrong alignment on UJackUMGFukidasiIconData");
static_assert(sizeof(UJackUMGFukidasiIconData) == 0x0000D0, "Wrong size on UJackUMGFukidasiIconData");
static_assert(offsetof(UJackUMGFukidasiIconData, Scale) == 0x0000BC, "Member 'UJackUMGFukidasiIconData::Scale' has a wrong offset!");

// Class JackGame.JackUMGFukidasiData
// 0x0078 (0x0130 - 0x00B8)
class UJackUMGFukidasiData final : public UJackUMGFukidasiBaseData
{
public:
	class FString                                 Message;                                           // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowFaceIcon;                                     // 0x00C8(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x17];                                      // 0x00C9(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           ScaleCurve;                                        // 0x00E0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E8[0x4];                                       // 0x00E8(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Scale;                                             // 0x00EC(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            AlphaCurve;                                        // 0x00F8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x4];                                      // 0x0100(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Alpha;                                             // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveVector*                           FaceIconScaleCurve;                                // 0x0110(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_118[0x4];                                      // 0x0118(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                FaceIconScale;                                     // 0x011C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RemoveRate;                                        // 0x0128(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFukidasiData">();
	}
	static class UJackUMGFukidasiData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFukidasiData>();
	}
};
static_assert(alignof(UJackUMGFukidasiData) == 0x000008, "Wrong alignment on UJackUMGFukidasiData");
static_assert(sizeof(UJackUMGFukidasiData) == 0x000130, "Wrong size on UJackUMGFukidasiData");
static_assert(offsetof(UJackUMGFukidasiData, Message) == 0x0000B8, "Member 'UJackUMGFukidasiData::Message' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, bShowFaceIcon) == 0x0000C8, "Member 'UJackUMGFukidasiData::bShowFaceIcon' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, ScaleCurve) == 0x0000E0, "Member 'UJackUMGFukidasiData::ScaleCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, Scale) == 0x0000EC, "Member 'UJackUMGFukidasiData::Scale' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, AlphaCurve) == 0x0000F8, "Member 'UJackUMGFukidasiData::AlphaCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, Alpha) == 0x000104, "Member 'UJackUMGFukidasiData::Alpha' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, FaceIconScaleCurve) == 0x000110, "Member 'UJackUMGFukidasiData::FaceIconScaleCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, FaceIconScale) == 0x00011C, "Member 'UJackUMGFukidasiData::FaceIconScale' has a wrong offset!");
static_assert(offsetof(UJackUMGFukidasiData, RemoveRate) == 0x000128, "Member 'UJackUMGFukidasiData::RemoveRate' has a wrong offset!");

// Class JackGame.JackUMGItemGetIconData
// 0x0010 (0x00A8 - 0x0098)
class UJackUMGItemGetIconData final : public UJackUMG3DWidgetData
{
public:
	EJackItemGetIcon                              IconType;                                          // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x00A0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemGetIconData">();
	}
	static class UJackUMGItemGetIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemGetIconData>();
	}
};
static_assert(alignof(UJackUMGItemGetIconData) == 0x000008, "Wrong alignment on UJackUMGItemGetIconData");
static_assert(sizeof(UJackUMGItemGetIconData) == 0x0000A8, "Wrong size on UJackUMGItemGetIconData");
static_assert(offsetof(UJackUMGItemGetIconData, IconType) == 0x000098, "Member 'UJackUMGItemGetIconData::IconType' has a wrong offset!");
static_assert(offsetof(UJackUMGItemGetIconData, ItemID) == 0x0000A0, "Member 'UJackUMGItemGetIconData::ItemID' has a wrong offset!");

// Class JackGame.JackUMGMiniMapWidget
// 0x0128 (0x0498 - 0x0370)
class UJackUMGMiniMapWidget : public UJackUMGWidgetBase
{
public:
	float                                         SeaSkyWarpThresholdLength;                         // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackUMGMapController>   MapController;                                     // 0x0374(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapSymbolRenderTextureSize;                        // 0x037C(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCanvasRenderTarget2D*                  MapSymbolRenderTarget;                             // 0x0388(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EJackMapSymbol>                        MapSymbolTypesToDisplay;                           // 0x0390(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	float                                         MapSymbolScale;                                    // 0x03A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         PCFootmarkDisplayCount;                            // 0x03A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCFootmarkDisplayDistance;                         // 0x03A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PCFootmarkDisplayIntervalPixel;                    // 0x03AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            PCFootmarkOpacityCurve;                            // 0x03B0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMapSymbolInfo*>          PCFootmarkSymbolList;                              // 0x03B8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	EJackFloorLevel                               FloorLevel;                                        // 0x03C8(0x0001)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C9[0x3];                                      // 0x03C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         NowLoadingRequestTransitionWait;                   // 0x03CC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MiniMapFlickerPreventionTime;                      // 0x03D0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3D4[0xC];                                      // 0x03D4(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void(int32 RequesterID)>            LoadResourceHookDelegate;                          // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	TDelegate<void(int32 RequesterID)>            LoadResourceDelegate;                              // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_400[0x98];                                     // 0x0400(0x0098)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UJackUMGMainMapOverlayWidgetBase* GetMapTextWidget();
	void LoadMiniMapSymbolTesture(bool bInLoadingFlag);
	void LoadTextureFromSymbol(const class UJackUMGMapSymbolInfoBase* InSymbol);
	void OnChangeFloor(EJackFloorLevel InFloorLevel, EJackFloorArea InFlooorArea);
	void OnChangeNowLoadingDisplay(bool bDisplay);
	void OnConstructWidget();
	void OnDrawMapSymbolRenderTarget(class UCanvas* Canvas, int32 Width, int32 Height);
	void ReleaseMiniMapLoadSymbol();
	void SetNowLoading(bool bNowLoading);

	struct FVector2D GetMiniMapDrawSize() const;
	bool IsInsideMiniMapDisplayRange(const class UJackUMGMapSymbolInfoBase* InSymbol) const;
	bool IsNowLoading() const;
	bool ShouldDisplayNowLoading() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMiniMapWidget">();
	}
	static class UJackUMGMiniMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMiniMapWidget>();
	}
};
static_assert(alignof(UJackUMGMiniMapWidget) == 0x000008, "Wrong alignment on UJackUMGMiniMapWidget");
static_assert(sizeof(UJackUMGMiniMapWidget) == 0x000498, "Wrong size on UJackUMGMiniMapWidget");
static_assert(offsetof(UJackUMGMiniMapWidget, SeaSkyWarpThresholdLength) == 0x000370, "Member 'UJackUMGMiniMapWidget::SeaSkyWarpThresholdLength' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MapController) == 0x000374, "Member 'UJackUMGMiniMapWidget::MapController' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MapSymbolRenderTextureSize) == 0x00037C, "Member 'UJackUMGMiniMapWidget::MapSymbolRenderTextureSize' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MapSymbolRenderTarget) == 0x000388, "Member 'UJackUMGMiniMapWidget::MapSymbolRenderTarget' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MapSymbolTypesToDisplay) == 0x000390, "Member 'UJackUMGMiniMapWidget::MapSymbolTypesToDisplay' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MapSymbolScale) == 0x0003A0, "Member 'UJackUMGMiniMapWidget::MapSymbolScale' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, PCFootmarkDisplayCount) == 0x0003A4, "Member 'UJackUMGMiniMapWidget::PCFootmarkDisplayCount' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, PCFootmarkDisplayDistance) == 0x0003A8, "Member 'UJackUMGMiniMapWidget::PCFootmarkDisplayDistance' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, PCFootmarkDisplayIntervalPixel) == 0x0003AC, "Member 'UJackUMGMiniMapWidget::PCFootmarkDisplayIntervalPixel' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, PCFootmarkOpacityCurve) == 0x0003B0, "Member 'UJackUMGMiniMapWidget::PCFootmarkOpacityCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, PCFootmarkSymbolList) == 0x0003B8, "Member 'UJackUMGMiniMapWidget::PCFootmarkSymbolList' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, FloorLevel) == 0x0003C8, "Member 'UJackUMGMiniMapWidget::FloorLevel' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, NowLoadingRequestTransitionWait) == 0x0003CC, "Member 'UJackUMGMiniMapWidget::NowLoadingRequestTransitionWait' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, MiniMapFlickerPreventionTime) == 0x0003D0, "Member 'UJackUMGMiniMapWidget::MiniMapFlickerPreventionTime' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, LoadResourceHookDelegate) == 0x0003E0, "Member 'UJackUMGMiniMapWidget::LoadResourceHookDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGMiniMapWidget, LoadResourceDelegate) == 0x0003F0, "Member 'UJackUMGMiniMapWidget::LoadResourceDelegate' has a wrong offset!");

// Class JackGame.JackUMGMonsterEmotionIconData
// 0x0010 (0x00A8 - 0x0098)
class UJackUMGMonsterEmotionIconData final : public UJackUMG3DWidgetData
{
public:
	EJackMonsterEmotionIcon                       IconType;                                          // 0x0098(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Timer;                                             // 0x009C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnded;                                            // 0x00A0(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMonsterEmotionIconData">();
	}
	static class UJackUMGMonsterEmotionIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMonsterEmotionIconData>();
	}
};
static_assert(alignof(UJackUMGMonsterEmotionIconData) == 0x000008, "Wrong alignment on UJackUMGMonsterEmotionIconData");
static_assert(sizeof(UJackUMGMonsterEmotionIconData) == 0x0000A8, "Wrong size on UJackUMGMonsterEmotionIconData");
static_assert(offsetof(UJackUMGMonsterEmotionIconData, IconType) == 0x000098, "Member 'UJackUMGMonsterEmotionIconData::IconType' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterEmotionIconData, Timer) == 0x00009C, "Member 'UJackUMGMonsterEmotionIconData::Timer' has a wrong offset!");
static_assert(offsetof(UJackUMGMonsterEmotionIconData, bEnded) == 0x0000A0, "Member 'UJackUMGMonsterEmotionIconData::bEnded' has a wrong offset!");

// Class JackGame.JackUMGMonsterEmotionLoopIconData
// 0x0008 (0x00A0 - 0x0098)
class UJackUMGMonsterEmotionLoopIconData final : public UJackUMG3DWidgetData
{
public:
	EJackMonsterEmotionIcon                       IconType;                                          // 0x0098(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMonsterEmotionLoopIconData">();
	}
	static class UJackUMGMonsterEmotionLoopIconData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMonsterEmotionLoopIconData>();
	}
};
static_assert(alignof(UJackUMGMonsterEmotionLoopIconData) == 0x000008, "Wrong alignment on UJackUMGMonsterEmotionLoopIconData");
static_assert(sizeof(UJackUMGMonsterEmotionLoopIconData) == 0x0000A0, "Wrong size on UJackUMGMonsterEmotionLoopIconData");
static_assert(offsetof(UJackUMGMonsterEmotionLoopIconData, IconType) == 0x000098, "Member 'UJackUMGMonsterEmotionLoopIconData::IconType' has a wrong offset!");

// Class JackGame.JackUMGFusigiKaziEffectData
// 0x0010 (0x00A8 - 0x0098)
class UJackUMGFusigiKaziEffectData final : public UJackUMG3DWidgetData
{
public:
	TArray<class FName>                           ItemIDList;                                        // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFusigiKaziEffectData">();
	}
	static class UJackUMGFusigiKaziEffectData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFusigiKaziEffectData>();
	}
};
static_assert(alignof(UJackUMGFusigiKaziEffectData) == 0x000008, "Wrong alignment on UJackUMGFusigiKaziEffectData");
static_assert(sizeof(UJackUMGFusigiKaziEffectData) == 0x0000A8, "Wrong size on UJackUMGFusigiKaziEffectData");
static_assert(offsetof(UJackUMGFusigiKaziEffectData, ItemIDList) == 0x000098, "Member 'UJackUMGFusigiKaziEffectData::ItemIDList' has a wrong offset!");

// Class JackGame.JackUMGFukubikiSlot
// 0x0118 (0x02E8 - 0x01D0)
class UJackUMGFukubikiSlot : public UUserWidget
{
public:
	TArray<struct FJackFukubikiLotteryInfo>       LotteryInfoList;                                   // 0x01D0(0x0010)(Edit, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_1E0[0x70];                                     // 0x01E0(0x0070)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UImage*>                         LeftReelImageList;                                 // 0x0250(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         CenterReelImageList;                               // 0x0260(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UImage*>                         RightReelImageList;                                // 0x0270(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_280[0x1C];                                     // 0x0280(0x001C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReelRollSpeed;                                     // 0x029C(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReelRoolMinSpeedAtToStop;                          // 0x02A0(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReelStopEaseExp;                                   // 0x02A4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_2A8[0xC];                                      // 0x02A8(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReelRoolSeInterval;                                // 0x02B4(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ReelRoolToStopSeInterval;                          // 0x02B8(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         RoolRoolToStopSeCountMax;                          // 0x02BC(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             SunMarkTexture;                                    // 0x02C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             StarMarkTexture;                                   // 0x02C8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             MoonMarkTexture;                                   // 0x02D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WaterMarkTexture;                                  // 0x02D8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             HeartMarkTexture;                                  // 0x02E0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void OnMeEnd();
	void PlayAtariMe();
	void SetupStartingMarkList();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGFukubikiSlot">();
	}
	static class UJackUMGFukubikiSlot* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGFukubikiSlot>();
	}
};
static_assert(alignof(UJackUMGFukubikiSlot) == 0x000008, "Wrong alignment on UJackUMGFukubikiSlot");
static_assert(sizeof(UJackUMGFukubikiSlot) == 0x0002E8, "Wrong size on UJackUMGFukubikiSlot");
static_assert(offsetof(UJackUMGFukubikiSlot, LotteryInfoList) == 0x0001D0, "Member 'UJackUMGFukubikiSlot::LotteryInfoList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, LeftReelImageList) == 0x000250, "Member 'UJackUMGFukubikiSlot::LeftReelImageList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, CenterReelImageList) == 0x000260, "Member 'UJackUMGFukubikiSlot::CenterReelImageList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, RightReelImageList) == 0x000270, "Member 'UJackUMGFukubikiSlot::RightReelImageList' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, ReelRollSpeed) == 0x00029C, "Member 'UJackUMGFukubikiSlot::ReelRollSpeed' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, ReelRoolMinSpeedAtToStop) == 0x0002A0, "Member 'UJackUMGFukubikiSlot::ReelRoolMinSpeedAtToStop' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, ReelStopEaseExp) == 0x0002A4, "Member 'UJackUMGFukubikiSlot::ReelStopEaseExp' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, ReelRoolSeInterval) == 0x0002B4, "Member 'UJackUMGFukubikiSlot::ReelRoolSeInterval' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, ReelRoolToStopSeInterval) == 0x0002B8, "Member 'UJackUMGFukubikiSlot::ReelRoolToStopSeInterval' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, RoolRoolToStopSeCountMax) == 0x0002BC, "Member 'UJackUMGFukubikiSlot::RoolRoolToStopSeCountMax' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, SunMarkTexture) == 0x0002C0, "Member 'UJackUMGFukubikiSlot::SunMarkTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, StarMarkTexture) == 0x0002C8, "Member 'UJackUMGFukubikiSlot::StarMarkTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, MoonMarkTexture) == 0x0002D0, "Member 'UJackUMGFukubikiSlot::MoonMarkTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, WaterMarkTexture) == 0x0002D8, "Member 'UJackUMGFukubikiSlot::WaterMarkTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGFukubikiSlot, HeartMarkTexture) == 0x0002E0, "Member 'UJackUMGFukubikiSlot::HeartMarkTexture' has a wrong offset!");

// Class JackGame.JackUMGItemBase
// 0x0060 (0x03D0 - 0x0370)
class UJackUMGItemBase : public UJackUMGWidgetBase
{
public:
	bool                                          bIsSelective;                                      // 0x0370(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsChecked;                                        // 0x0371(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFindOffset;                                      // 0x0372(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_373[0x1];                                      // 0x0373(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         TotalIndex;                                        // 0x0374(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ListIndex;                                         // 0x0378(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_37C[0x4];                                      // 0x037C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ItemID;                                            // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TextID;                                            // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         GeneralValue;                                      // 0x0390(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   CaptionText;                                       // 0x0398(0x0018)(Edit, BlueprintVisible, EditConst, NativeAccessSpecifierPublic)
	struct FVector2D                              CursorOffset;                                      // 0x03B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCalcCursorPosition;                             // 0x03B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B9[0x3];                                      // 0x03B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DataNumber;                                        // 0x03BC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(struct FJackUMGItemContainer& ItemContainer)> JackOnUpdateContainerDelegate;                     // 0x03C0(0x0010)(BlueprintVisible, ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)

public:
	void ApplyItemData(const class UJackUMGItemData* ItemData);
	void DoUpdateContainerDelegate(const struct FJackUMGItemContainer& Container);
	void DrawItemBase(class UJackUMGItemData* InItemData);
	void InitItem(class UImage* IconPanel, bool InIsList);
	void JackOnUMGUpdateContainerDelegate__DelegateSignature(const struct FJackUMGItemContainer& ItemContainer);
	void NotificationItemBase(const class FName& NotifyTag, class UJackUMGItemData* InItemData, class UObject* Object, int32 Value);
	void SetCaption(const class FText& InCaption);
	void SetCaptionAndTextHyphenation(const class FString& InCaption, int32 InMaxLines);
	void SetCaptionAndTextHyphenationFromTextId(const class FName InTextId);
	void SetCaptionFromTextId(const class FName InTextId, bool InIsList);
	void SetCaptionInValue(int32 InValue, bool InIs2Byte);
	void SetCursorOffset(const struct FVector2D& InCursorOffset);
	void SetItemData(int32 InListIndex, int32 InDataIndex, const class FName& InItemId, const class FName& InTextId, int32 InGeneralValue);

	const class FText GetCaption() const;
	int32 GetDataIndex() const;
	int32 GetGeneralValue() const;
	const class FName GetItemId() const;
	int32 GetListIndex() const;
	const class FName GetTextId() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGItemBase">();
	}
	static class UJackUMGItemBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGItemBase>();
	}
};
static_assert(alignof(UJackUMGItemBase) == 0x000008, "Wrong alignment on UJackUMGItemBase");
static_assert(sizeof(UJackUMGItemBase) == 0x0003D0, "Wrong size on UJackUMGItemBase");
static_assert(offsetof(UJackUMGItemBase, bIsSelective) == 0x000370, "Member 'UJackUMGItemBase::bIsSelective' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, bIsChecked) == 0x000371, "Member 'UJackUMGItemBase::bIsChecked' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, IsFindOffset) == 0x000372, "Member 'UJackUMGItemBase::IsFindOffset' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, TotalIndex) == 0x000374, "Member 'UJackUMGItemBase::TotalIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, ListIndex) == 0x000378, "Member 'UJackUMGItemBase::ListIndex' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, ItemID) == 0x000380, "Member 'UJackUMGItemBase::ItemID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, TextID) == 0x000388, "Member 'UJackUMGItemBase::TextID' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, GeneralValue) == 0x000390, "Member 'UJackUMGItemBase::GeneralValue' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, CaptionText) == 0x000398, "Member 'UJackUMGItemBase::CaptionText' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, CursorOffset) == 0x0003B0, "Member 'UJackUMGItemBase::CursorOffset' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, bIsCalcCursorPosition) == 0x0003B8, "Member 'UJackUMGItemBase::bIsCalcCursorPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, DataNumber) == 0x0003BC, "Member 'UJackUMGItemBase::DataNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGItemBase, JackOnUpdateContainerDelegate) == 0x0003C0, "Member 'UJackUMGItemBase::JackOnUpdateContainerDelegate' has a wrong offset!");

// Class JackGame.JackUMGWorldMapWidget
// 0x02B0 (0x0620 - 0x0370)
class UJackUMGWorldMapWidget : public UJackUMGWidgetBase
{
public:
	TWeakObjectPtr<class UJackUMGMapController>   MapController;                                     // 0x0370(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackGameFlag>           GameFlag;                                          // 0x0378(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             WorldMapTexture;                                   // 0x0380(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              MapSymbolRenderTextureSize;                        // 0x0388(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCanvasRenderTarget2D*                  MapSymbolRenderTarget;                             // 0x0390(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<EJackMapSymbol>                        MapSymbolTypesToDisplay;                           // 0x0398(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	class UJackUMGMapFloorInfo*                   DisplayingFloorInfo;                               // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MapSymbolScale;                                    // 0x03B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector                                PseudoPCWorldPosition;                             // 0x03B4(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGWidgetBase*                     MapMenuRootWidget;                                 // 0x03C0(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<class UJackUMGWidgetBase*>             MapMenuWidgetList;                                 // 0x03C8(0x0010)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMapTextItemBase*>        SelectedNeighborMapTextItems;                      // 0x03D8(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	float                                         ZoomFactor;                                        // 0x03E8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bKeepViewCenterInZoomOut;                          // 0x03EC(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bZoomDPadScrollEnabled;                            // 0x03ED(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3EE[0x2];                                      // 0x03EE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ZoomOperationAcceptiveAngle;                       // 0x03F0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomMoveDistance;                                  // 0x03F4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomAccelFactor;                                   // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomCenterPositionTolerance;                       // 0x03FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ZoomMoveVelocityCurve;                             // 0x0400(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UCurveFloat*                            ZoomScaleVelocityCurve;                            // 0x0408(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomInOutTime;                                     // 0x0410(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ZoomMoveCenterTime;                                // 0x0414(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ZoomInOutTransCoefficient;                         // 0x0418(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FVector2D                              ZoomInOutScaleCoefficient;                         // 0x0420(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_428[0x30];                                     // 0x0428(0x0030)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGMainMapOverlayWidgetBase*       MapTextWidget;                                     // 0x0458(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_460[0x1B4];                                    // 0x0460(0x01B4)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DebugDeltaTimeScale;                               // 0x0614(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_618[0x8];                                      // 0x0618(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UMaterialInstanceDynamic* CreateMapSymbolMID();
	class UMaterialInstanceDynamic* CreateMID();
	void EnterZoomMode();
	class UCanvasPanel* GetMapTextDrawCanvas();
	class FName GetRenderTargetName();
	void LeaveZoomeMode();
	void MoveZoomCenterPosition(const struct FVector& WorldPosition, bool bWithAnimation);
	void OnConstructWidget();
	void OnDetailedKeyEvent(EJackKeys Key, bool Pressed, bool Released);
	void OnDrawMapSymbolRenderTarget(class UCanvas* Canvas, int32 Width, int32 Height);
	void OnEmptyPointerTargetsEvent();
	void PopMenu(class UJackUMGWidgetBase** PoppedWidget, class UJackUMGWidgetBase** CurrentActiveWidget, bool bRemoveWidget);
	class UJackUMGWidgetBase* PushMenu(TSubclassOf<class UJackUMGWidgetBase> MenuWidgetClass, bool bIsFocus);
	void ResetZoomScale(float InScale);
	void SetKeyExclusiveEnabled(bool bEnabled);
	void SetMapSymbolRenderingEnabled(bool bEnabled);
	class UJackUMGMainMapOverlayWidgetBase* SetMapTextWidget(class UJackUMGWidgetBase* Widget);
	void SetNowLoading(bool bNowLoading);
	void SetSelectedNeighborMapVolumeID(class FName MapVolumeID);
	void UpdateParentMapInfo();
	void UpdateZoomMode(float DeltaTime);

	struct FVector2D GetActualMapViewportSize() const;
	float GetDefaultZoomScale() const;
	struct FVector2D GetDesiredMapViewportSize() const;
	class UJackUMGMainMapOverlayWidgetBase* GetMapTextWidget() const;
	struct FVector GetZoomCenterWorldPosition() const;
	bool IsDisplayingCurrentFloor() const;
	bool IsKeyDown(EJackKeys Key) const;
	bool IsMapSymbolRenderingEnabled() const;
	bool IsNowLoading() const;
	bool IsPCMarkerVisible() const;
	bool IsScrollableToDown() const;
	bool IsScrollableToLeft() const;
	bool IsScrollableToRight() const;
	bool IsScrollableToUp() const;
	bool ShouldDisplayNowLoading() const;
	struct FVector2D TransformToMapView(const struct FVector& WorldPosition) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWorldMapWidget">();
	}
	static class UJackUMGWorldMapWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWorldMapWidget>();
	}
};
static_assert(alignof(UJackUMGWorldMapWidget) == 0x000008, "Wrong alignment on UJackUMGWorldMapWidget");
static_assert(sizeof(UJackUMGWorldMapWidget) == 0x000620, "Wrong size on UJackUMGWorldMapWidget");
static_assert(offsetof(UJackUMGWorldMapWidget, MapController) == 0x000370, "Member 'UJackUMGWorldMapWidget::MapController' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, GameFlag) == 0x000378, "Member 'UJackUMGWorldMapWidget::GameFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, WorldMapTexture) == 0x000380, "Member 'UJackUMGWorldMapWidget::WorldMapTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapSymbolRenderTextureSize) == 0x000388, "Member 'UJackUMGWorldMapWidget::MapSymbolRenderTextureSize' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapSymbolRenderTarget) == 0x000390, "Member 'UJackUMGWorldMapWidget::MapSymbolRenderTarget' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapSymbolTypesToDisplay) == 0x000398, "Member 'UJackUMGWorldMapWidget::MapSymbolTypesToDisplay' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, DisplayingFloorInfo) == 0x0003A8, "Member 'UJackUMGWorldMapWidget::DisplayingFloorInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapSymbolScale) == 0x0003B0, "Member 'UJackUMGWorldMapWidget::MapSymbolScale' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, PseudoPCWorldPosition) == 0x0003B4, "Member 'UJackUMGWorldMapWidget::PseudoPCWorldPosition' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapMenuRootWidget) == 0x0003C0, "Member 'UJackUMGWorldMapWidget::MapMenuRootWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapMenuWidgetList) == 0x0003C8, "Member 'UJackUMGWorldMapWidget::MapMenuWidgetList' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, SelectedNeighborMapTextItems) == 0x0003D8, "Member 'UJackUMGWorldMapWidget::SelectedNeighborMapTextItems' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomFactor) == 0x0003E8, "Member 'UJackUMGWorldMapWidget::ZoomFactor' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, bKeepViewCenterInZoomOut) == 0x0003EC, "Member 'UJackUMGWorldMapWidget::bKeepViewCenterInZoomOut' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, bZoomDPadScrollEnabled) == 0x0003ED, "Member 'UJackUMGWorldMapWidget::bZoomDPadScrollEnabled' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomOperationAcceptiveAngle) == 0x0003F0, "Member 'UJackUMGWorldMapWidget::ZoomOperationAcceptiveAngle' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomMoveDistance) == 0x0003F4, "Member 'UJackUMGWorldMapWidget::ZoomMoveDistance' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomAccelFactor) == 0x0003F8, "Member 'UJackUMGWorldMapWidget::ZoomAccelFactor' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomCenterPositionTolerance) == 0x0003FC, "Member 'UJackUMGWorldMapWidget::ZoomCenterPositionTolerance' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomMoveVelocityCurve) == 0x000400, "Member 'UJackUMGWorldMapWidget::ZoomMoveVelocityCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomScaleVelocityCurve) == 0x000408, "Member 'UJackUMGWorldMapWidget::ZoomScaleVelocityCurve' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomInOutTime) == 0x000410, "Member 'UJackUMGWorldMapWidget::ZoomInOutTime' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomMoveCenterTime) == 0x000414, "Member 'UJackUMGWorldMapWidget::ZoomMoveCenterTime' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomInOutTransCoefficient) == 0x000418, "Member 'UJackUMGWorldMapWidget::ZoomInOutTransCoefficient' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, ZoomInOutScaleCoefficient) == 0x000420, "Member 'UJackUMGWorldMapWidget::ZoomInOutScaleCoefficient' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, MapTextWidget) == 0x000458, "Member 'UJackUMGWorldMapWidget::MapTextWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGWorldMapWidget, DebugDeltaTimeScale) == 0x000614, "Member 'UJackUMGWorldMapWidget::DebugDeltaTimeScale' has a wrong offset!");

// Class JackGame.JackUMGHorizontalParts
// 0x0060 (0x0430 - 0x03D0)
class UJackUMGHorizontalParts : public UJackUMGItemBase
{
public:
	UMulticastDelegateProperty_                   HorizontalSetSEDelegate;                           // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   HorizontalSetGammaDelegate;                        // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UWidget*                                TitlePanel;                                        // 0x03F0(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UWidget*>                        ValuePanels;                                       // 0x03F8(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UWidget*                                CursorPanel;                                       // 0x0408(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_410[0x20];                                     // 0x0410(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void JackUMGHorizontalSetGammaDelegate__DelegateSignature(float InScale);
	void JackUMGHorizontalSetSEDelegate__DelegateSignature();
	void MoveLeftCursor();
	void MoveRightCursor();
	void ReturnToInitialValue();
	void SetActiveFlag(bool InActiveFlag);
	void SetCursorPosition(bool IsDelegate);
	void SetDisableKeyEvent(bool InDisable);
	void SetHorizontalType(const EJackUMGHorizontalMode InType);
	void SetupHorizontalParts(int32 InInitValue, const int32 ItemsCount, bool UseActiveColor, EJackUMGHorizontalMode InType);
	void SetValue(int32 InValue);

	bool GetActiveFlag() const;
	bool GetDisableKeyEvent() const;
	int32 GetValue() const;
	int32 GetValueMax() const;
	int32 GetValueMin() const;
	float GetVarRate() const;
	EJackDisplayGamma IntToDisplayGamma(const int32 InValue) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHorizontalParts">();
	}
	static class UJackUMGHorizontalParts* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHorizontalParts>();
	}
};
static_assert(alignof(UJackUMGHorizontalParts) == 0x000008, "Wrong alignment on UJackUMGHorizontalParts");
static_assert(sizeof(UJackUMGHorizontalParts) == 0x000430, "Wrong size on UJackUMGHorizontalParts");
static_assert(offsetof(UJackUMGHorizontalParts, HorizontalSetSEDelegate) == 0x0003D0, "Member 'UJackUMGHorizontalParts::HorizontalSetSEDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHorizontalParts, HorizontalSetGammaDelegate) == 0x0003E0, "Member 'UJackUMGHorizontalParts::HorizontalSetGammaDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHorizontalParts, TitlePanel) == 0x0003F0, "Member 'UJackUMGHorizontalParts::TitlePanel' has a wrong offset!");
static_assert(offsetof(UJackUMGHorizontalParts, ValuePanels) == 0x0003F8, "Member 'UJackUMGHorizontalParts::ValuePanels' has a wrong offset!");
static_assert(offsetof(UJackUMGHorizontalParts, CursorPanel) == 0x000408, "Member 'UJackUMGHorizontalParts::CursorPanel' has a wrong offset!");

// Class JackGame.JackUMGHudFukidasiBattleScenario
// 0x0030 (0x03A0 - 0x0370)
class UJackUMGHudFukidasiBattleScenario : public UJackUMGWidgetBase
{
public:
	TArray<struct FJackUMGScenarioFukidasiInfo>   FukidasiCue;                                       // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FJackUMGScenarioFukidasiInfo>   ResFukidasiCue;                                    // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bResRequest;                                       // 0x0390(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_391[0x3];                                      // 0x0391(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         FukidasiDisplayTime;                               // 0x0394(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FukidasiCloseTime;                                 // 0x0398(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseFukidasi();
	bool IsOpened();
	void LoopFukidasi();
	void OnEndInAnimation();
	void OnEndOutAnimation();
	void ResetAnimation();
	void SetStringAndFace(const class FString& InString, class FName FaceID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHudFukidasiBattleScenario">();
	}
	static class UJackUMGHudFukidasiBattleScenario* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHudFukidasiBattleScenario>();
	}
};
static_assert(alignof(UJackUMGHudFukidasiBattleScenario) == 0x000008, "Wrong alignment on UJackUMGHudFukidasiBattleScenario");
static_assert(sizeof(UJackUMGHudFukidasiBattleScenario) == 0x0003A0, "Wrong size on UJackUMGHudFukidasiBattleScenario");
static_assert(offsetof(UJackUMGHudFukidasiBattleScenario, FukidasiCue) == 0x000370, "Member 'UJackUMGHudFukidasiBattleScenario::FukidasiCue' has a wrong offset!");
static_assert(offsetof(UJackUMGHudFukidasiBattleScenario, ResFukidasiCue) == 0x000380, "Member 'UJackUMGHudFukidasiBattleScenario::ResFukidasiCue' has a wrong offset!");
static_assert(offsetof(UJackUMGHudFukidasiBattleScenario, bResRequest) == 0x000390, "Member 'UJackUMGHudFukidasiBattleScenario::bResRequest' has a wrong offset!");
static_assert(offsetof(UJackUMGHudFukidasiBattleScenario, FukidasiDisplayTime) == 0x000394, "Member 'UJackUMGHudFukidasiBattleScenario::FukidasiDisplayTime' has a wrong offset!");
static_assert(offsetof(UJackUMGHudFukidasiBattleScenario, FukidasiCloseTime) == 0x000398, "Member 'UJackUMGHudFukidasiBattleScenario::FukidasiCloseTime' has a wrong offset!");

// Class JackGame.JackUMGPairingController
// 0x0000 (0x0398 - 0x0398)
class UJackUMGPairingController : public UJackUMGPairingBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPairingController">();
	}
	static class UJackUMGPairingController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPairingController>();
	}
};
static_assert(alignof(UJackUMGPairingController) == 0x000008, "Wrong alignment on UJackUMGPairingController");
static_assert(sizeof(UJackUMGPairingController) == 0x000398, "Wrong size on UJackUMGPairingController");

// Class JackGame.JackUMGHudStatusBase
// 0x0158 (0x04C8 - 0x0370)
class UJackUMGHudStatusBase : public UJackUMGWidgetBase
{
public:
	struct FVector2D                              Num0_UV;                                           // 0x0370(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Num1_UV;                                           // 0x0378(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Num2_UV;                                           // 0x0380(0x0008)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Unit_Index;                                        // 0x0388(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num0_Index;                                        // 0x038C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num1_Index;                                        // 0x0390(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Num2_Index;                                        // 0x0394(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value_Frame;                                       // 0x0398(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39C[0x4];                                      // 0x039C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemData*>               ItemDataList;                                      // 0x03A0(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ValueChangeDelegate;                               // 0x03B0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NameSetDelegate;                                   // 0x03C0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FaceSetDelegate;                                   // 0x03D0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FaceEffectSetDelegate;                             // 0x03E0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   PlateAnimSetDelegate;                              // 0x03F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   JoutaiIjouDelegate;                                // 0x0400(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   JoutaiIjouListDelegate;                            // 0x0410(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   GoodJoutaiIjouListDelegate;                        // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   BadJoutaiIjouListDelegate;                         // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   LevelChangeDelegate;                               // 0x0440(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_450[0x78];                                     // 0x0450(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeHudBar(const int32 Now, const int32 Max, EJackUMGTextColorSet Type, bool bIsInit);
	const float GetJoutaiijouIconAlpha();
	bool IsSuperMode();
	void JackUMGBadJoutaiListDelegate__DelegateSignature(const TArray<struct FJackUMGOddEffectStatus>& OddEffectList);
	void JackUMGFaceDelegate__DelegateSignature(EJackCharacter Type, EJackUIFaceIcon InIconType);
	void JackUMGFaceEffectDelegate__DelegateSignature(EJackCharacter Type, EJackUIFaceIcon InIconType);
	void JackUMGGoodJoutaiListDelegate__DelegateSignature(const TArray<struct FJackUMGOddEffectStatus>& OddEffectList);
	void JackUMGJoutaiDelegate__DelegateSignature(int32 Type);
	void JackUMGJoutaiListDelegate__DelegateSignature(const TArray<class FName>& NameList);
	void JackUMGLevelChangeDelegate__DelegateSignature(int32 Level, EJackUMGTextColorSet ColorType);
	void JackUMGNameDelegate__DelegateSignature(const class FString& Name_0);
	void JackUMGPlateDelegate__DelegateSignature(EJackUMGHudPlateAnim Type);
	void JackUMGValueChangeDelegate__DelegateSignature(int32 Index_0, int32 ColorNum);
	void RequestCloseWidget();
	void SetBadJoutaiIjouList(const TArray<struct FJackUMGOddEffectStatus>& OddEffectList);
	void SetDataFromTuyosa(const int32 Now, const int32 Max, EJackUMGTextColorSet Type, bool bIsInit);
	void SetGoodJoutaiIjouList(const TArray<struct FJackUMGOddEffectStatus>& OddEffectList);
	void SetNameText(const class FString& InName);
	void SetStatusTextColor(const int32 Index_0, const int32 ColorNum);
	void SetStatusValue(EJackUMGHudStatusMode InType, const int32 Value0, const int32 Value1);
	void SetSubLevel(const int32 InLevel, EJackUMGTextColorSet InColorType);
	void SetTestTextJustification(ETextJustify InJustification);
	void SetTextJustification(ETextJustify InJustification);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHudStatusBase">();
	}
	static class UJackUMGHudStatusBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHudStatusBase>();
	}
};
static_assert(alignof(UJackUMGHudStatusBase) == 0x000008, "Wrong alignment on UJackUMGHudStatusBase");
static_assert(sizeof(UJackUMGHudStatusBase) == 0x0004C8, "Wrong size on UJackUMGHudStatusBase");
static_assert(offsetof(UJackUMGHudStatusBase, Num0_UV) == 0x000370, "Member 'UJackUMGHudStatusBase::Num0_UV' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Num1_UV) == 0x000378, "Member 'UJackUMGHudStatusBase::Num1_UV' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Num2_UV) == 0x000380, "Member 'UJackUMGHudStatusBase::Num2_UV' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Unit_Index) == 0x000388, "Member 'UJackUMGHudStatusBase::Unit_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Num0_Index) == 0x00038C, "Member 'UJackUMGHudStatusBase::Num0_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Num1_Index) == 0x000390, "Member 'UJackUMGHudStatusBase::Num1_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Num2_Index) == 0x000394, "Member 'UJackUMGHudStatusBase::Num2_Index' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, Value_Frame) == 0x000398, "Member 'UJackUMGHudStatusBase::Value_Frame' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, ItemDataList) == 0x0003A0, "Member 'UJackUMGHudStatusBase::ItemDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, ValueChangeDelegate) == 0x0003B0, "Member 'UJackUMGHudStatusBase::ValueChangeDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, NameSetDelegate) == 0x0003C0, "Member 'UJackUMGHudStatusBase::NameSetDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, FaceSetDelegate) == 0x0003D0, "Member 'UJackUMGHudStatusBase::FaceSetDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, FaceEffectSetDelegate) == 0x0003E0, "Member 'UJackUMGHudStatusBase::FaceEffectSetDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, PlateAnimSetDelegate) == 0x0003F0, "Member 'UJackUMGHudStatusBase::PlateAnimSetDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, JoutaiIjouDelegate) == 0x000400, "Member 'UJackUMGHudStatusBase::JoutaiIjouDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, JoutaiIjouListDelegate) == 0x000410, "Member 'UJackUMGHudStatusBase::JoutaiIjouListDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, GoodJoutaiIjouListDelegate) == 0x000420, "Member 'UJackUMGHudStatusBase::GoodJoutaiIjouListDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, BadJoutaiIjouListDelegate) == 0x000430, "Member 'UJackUMGHudStatusBase::BadJoutaiIjouListDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatusBase, LevelChangeDelegate) == 0x000440, "Member 'UJackUMGHudStatusBase::LevelChangeDelegate' has a wrong offset!");

// Class JackGame.JackUMGHudStatus
// 0x0028 (0x04F0 - 0x04C8)
class UJackUMGHudStatus final : public UJackUMGHudStatusBase
{
public:
	UMulticastDelegateProperty_                   HpChangeDelegate;                                  // 0x04C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x04D8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFullMember;                                      // 0x04D9(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4DA[0x16];                                     // 0x04DA(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitHudStatus(class UCanvasPanel* ItemListCanvas, const TArray<class UJackUMGItemData*>& ItemList, bool AllMember, int32 InZOrder);
	void JackUMGHpChangeDelegate__DelegateSignature(int32 Index_0, int32 ColorNum);
	void RequestCloseWidget();
	void SetScaleAllHud(const float InScale);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGHudStatus">();
	}
	static class UJackUMGHudStatus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGHudStatus>();
	}
};
static_assert(alignof(UJackUMGHudStatus) == 0x000008, "Wrong alignment on UJackUMGHudStatus");
static_assert(sizeof(UJackUMGHudStatus) == 0x0004F0, "Wrong size on UJackUMGHudStatus");
static_assert(offsetof(UJackUMGHudStatus, HpChangeDelegate) == 0x0004C8, "Member 'UJackUMGHudStatus::HpChangeDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatus, IsFocusable) == 0x0004D8, "Member 'UJackUMGHudStatus::IsFocusable' has a wrong offset!");
static_assert(offsetof(UJackUMGHudStatus, IsFullMember) == 0x0004D9, "Member 'UJackUMGHudStatus::IsFullMember' has a wrong offset!");

// Class JackGame.JackUMGJoutaiMiru
// 0x0038 (0x0468 - 0x0430)
class UJackUMGJoutaiMiru : public UJackUMGBrowserBase
{
public:
	UMulticastDelegateProperty_                   JoutaiMiruScrollDelegate;                          // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          IsSubParty;                                        // 0x0440(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_441[0x7];                                      // 0x0441(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGItemBase*>               SelectItemListMiru;                                // 0x0448(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         OddEffectMax;                                      // 0x0458(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45C[0xC];                                      // 0x045C(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddStaticItemList(class UJackUMGItemBase* InItemBase);
	void JackUMGJoutaiMiruScrollDelegate__DelegateSignature(const int32 InListOffset);
	bool MoveCursor(const int32 Direction, const struct FJackKeyStatus& InKey);
	bool SetJoutaiIjouParts(EJackCharacter InCharacterType, bool IsSubmember, const int32 InIndex);
	void SetJoutaiMiruListOffset(const int32 InOffset);
	void SetVisibilitySubPage(ESlateVisibility InVisibilityType, const int32 InSubMenberNum);

	const int32 GetJoutaiMiruListOffset() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGJoutaiMiru">();
	}
	static class UJackUMGJoutaiMiru* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGJoutaiMiru>();
	}
};
static_assert(alignof(UJackUMGJoutaiMiru) == 0x000008, "Wrong alignment on UJackUMGJoutaiMiru");
static_assert(sizeof(UJackUMGJoutaiMiru) == 0x000468, "Wrong size on UJackUMGJoutaiMiru");
static_assert(offsetof(UJackUMGJoutaiMiru, JoutaiMiruScrollDelegate) == 0x000430, "Member 'UJackUMGJoutaiMiru::JoutaiMiruScrollDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGJoutaiMiru, IsSubParty) == 0x000440, "Member 'UJackUMGJoutaiMiru::IsSubParty' has a wrong offset!");
static_assert(offsetof(UJackUMGJoutaiMiru, SelectItemListMiru) == 0x000448, "Member 'UJackUMGJoutaiMiru::SelectItemListMiru' has a wrong offset!");
static_assert(offsetof(UJackUMGJoutaiMiru, OddEffectMax) == 0x000458, "Member 'UJackUMGJoutaiMiru::OddEffectMax' has a wrong offset!");

// Class JackGame.JackUMGKeyConfig
// 0x0030 (0x0430 - 0x0400)
class UJackUMGKeyConfig : public UJackUMGWindowBase
{
public:
	bool                                          bEnableNativeTick;                                 // 0x0400(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   JustPressedKeyText;                                // 0x0408(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	class FName                                   JustPressedKeyName;                                // 0x0420(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         JustPressedKeyNumber;                              // 0x0428(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42C[0x4];                                      // 0x042C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetDisableTerminateByKey();
	void SetEnableTerminateByKey();

	const TArray<class UJackUMGItemData*> GetKeyConfigKeyPanelSteam() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGKeyConfig">();
	}
	static class UJackUMGKeyConfig* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGKeyConfig>();
	}
};
static_assert(alignof(UJackUMGKeyConfig) == 0x000008, "Wrong alignment on UJackUMGKeyConfig");
static_assert(sizeof(UJackUMGKeyConfig) == 0x000430, "Wrong size on UJackUMGKeyConfig");
static_assert(offsetof(UJackUMGKeyConfig, bEnableNativeTick) == 0x000400, "Member 'UJackUMGKeyConfig::bEnableNativeTick' has a wrong offset!");
static_assert(offsetof(UJackUMGKeyConfig, JustPressedKeyText) == 0x000408, "Member 'UJackUMGKeyConfig::JustPressedKeyText' has a wrong offset!");
static_assert(offsetof(UJackUMGKeyConfig, JustPressedKeyName) == 0x000420, "Member 'UJackUMGKeyConfig::JustPressedKeyName' has a wrong offset!");
static_assert(offsetof(UJackUMGKeyConfig, JustPressedKeyNumber) == 0x000428, "Member 'UJackUMGKeyConfig::JustPressedKeyNumber' has a wrong offset!");

// Class JackGame.JackVector4PropertyTrackInst
// 0x0018 (0x0060 - 0x0048)
class UJackVector4PropertyTrackInst final : public UInterpTrackInstProperty
{
public:
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector4                               ResetVector;                                       // 0x0050(0x0010)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVector4PropertyTrackInst">();
	}
	static class UJackVector4PropertyTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVector4PropertyTrackInst>();
	}
};
static_assert(alignof(UJackVector4PropertyTrackInst) == 0x000010, "Wrong alignment on UJackVector4PropertyTrackInst");
static_assert(sizeof(UJackVector4PropertyTrackInst) == 0x000060, "Wrong size on UJackVector4PropertyTrackInst");
static_assert(offsetof(UJackVector4PropertyTrackInst, ResetVector) == 0x000050, "Member 'UJackVector4PropertyTrackInst::ResetVector' has a wrong offset!");

// Class JackGame.JackUMGScrollController
// 0x0008 (0x0388 - 0x0380)
class UJackUMGScrollController : public UJackUMGListController
{
public:
	int32                                         DispTopNumber;                                     // 0x0380(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_384[0x4];                                      // 0x0384(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void InitScrollController(int32 ZOrder);
	void SetupScrollController(int32 InItemsPerPage, int32 InNumData);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGScrollController">();
	}
	static class UJackUMGScrollController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGScrollController>();
	}
};
static_assert(alignof(UJackUMGScrollController) == 0x000008, "Wrong alignment on UJackUMGScrollController");
static_assert(sizeof(UJackUMGScrollController) == 0x000388, "Wrong size on UJackUMGScrollController");
static_assert(offsetof(UJackUMGScrollController, DispTopNumber) == 0x000380, "Member 'UJackUMGScrollController::DispTopNumber' has a wrong offset!");

// Class JackGame.JackUMGMainMapOverlayWidgetBase
// 0x0040 (0x03B0 - 0x0370)
class UJackUMGMainMapOverlayWidgetBase : public UJackUMGWidgetBase
{
public:
	class FName                                   MapVolumeID;                                       // 0x0370(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_378[0x8];                                      // 0x0378(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackUMGMapTextItemGroup>       LocationItemSetList;                               // 0x0380(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<struct FJackUMGMainMapOverlayItemInfo> ChildWidgets;                                      // 0x0390(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)
	TArray<class UJackUMGMapTextImageItem*>       ChildWidgetsShowingOnMiniMap;                      // 0x03A0(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPrivate)

public:
	void EnterZoomMode();
	void LeaveZoomMode();
	void SetConditionalBeginDestroyEnabled(bool bEnabled, bool bAppliesChildren);
	void SetMapTextFontColor(EJackUMGTextColorSet ColorType);
	void SetMapTextVisible(bool bVisible, bool bForcibly);
	void UpdateMapTextCondition();
	void UpdateZoomMode(const struct FLinearColor& TexCoord);

	TArray<class UJackUMGMapTextImageItem*> FindImageItemsForMapVolumeID(class FName MapVolumeID_0) const;
	TArray<class UJackUMGMapTextLocationNameItem*> FindLocationNameItemsForMapVolumeID(class FName MapVolumeID_0) const;
	bool GetMapTextVisible() const;
	struct FVector2D GetOriginOffset() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMainMapOverlayWidgetBase">();
	}
	static class UJackUMGMainMapOverlayWidgetBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMainMapOverlayWidgetBase>();
	}
};
static_assert(alignof(UJackUMGMainMapOverlayWidgetBase) == 0x000008, "Wrong alignment on UJackUMGMainMapOverlayWidgetBase");
static_assert(sizeof(UJackUMGMainMapOverlayWidgetBase) == 0x0003B0, "Wrong size on UJackUMGMainMapOverlayWidgetBase");
static_assert(offsetof(UJackUMGMainMapOverlayWidgetBase, MapVolumeID) == 0x000370, "Member 'UJackUMGMainMapOverlayWidgetBase::MapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGMainMapOverlayWidgetBase, LocationItemSetList) == 0x000380, "Member 'UJackUMGMainMapOverlayWidgetBase::LocationItemSetList' has a wrong offset!");
static_assert(offsetof(UJackUMGMainMapOverlayWidgetBase, ChildWidgets) == 0x000390, "Member 'UJackUMGMainMapOverlayWidgetBase::ChildWidgets' has a wrong offset!");
static_assert(offsetof(UJackUMGMainMapOverlayWidgetBase, ChildWidgetsShowingOnMiniMap) == 0x0003A0, "Member 'UJackUMGMainMapOverlayWidgetBase::ChildWidgetsShowingOnMiniMap' has a wrong offset!");

// Class JackGame.JackUMGTheaterWindowSetting
// 0x0018 (0x0050 - 0x0038)
class UJackUMGTheaterWindowSetting final : public UObject
{
public:
	struct FLinearColor                           StripeColor;                                       // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StripeWidth;                                       // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTheaterWindowSetting">();
	}
	static class UJackUMGTheaterWindowSetting* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTheaterWindowSetting>();
	}
};
static_assert(alignof(UJackUMGTheaterWindowSetting) == 0x000008, "Wrong alignment on UJackUMGTheaterWindowSetting");
static_assert(sizeof(UJackUMGTheaterWindowSetting) == 0x000050, "Wrong size on UJackUMGTheaterWindowSetting");
static_assert(offsetof(UJackUMGTheaterWindowSetting, StripeColor) == 0x000038, "Member 'UJackUMGTheaterWindowSetting::StripeColor' has a wrong offset!");
static_assert(offsetof(UJackUMGTheaterWindowSetting, StripeWidth) == 0x000048, "Member 'UJackUMGTheaterWindowSetting::StripeWidth' has a wrong offset!");

// Class JackGame.JackUMGLoadMenuAssetData
// 0x0038 (0x0070 - 0x0038)
class UJackUMGLoadMenuAssetData : public UObject
{
public:
	EJackUMGMenuId                                MenuId;                                            // 0x0038(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftClassPtr<class UClass>>           WidgetAssets;                                      // 0x0040(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSoftObjectPtr<class UTexture>>        TextureAssets;                                     // 0x0050(0x0010)(Edit, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<struct FSoftObjectPath>                OtherAssets;                                       // 0x0060(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGLoadMenuAssetData">();
	}
	static class UJackUMGLoadMenuAssetData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGLoadMenuAssetData>();
	}
};
static_assert(alignof(UJackUMGLoadMenuAssetData) == 0x000008, "Wrong alignment on UJackUMGLoadMenuAssetData");
static_assert(sizeof(UJackUMGLoadMenuAssetData) == 0x000070, "Wrong size on UJackUMGLoadMenuAssetData");
static_assert(offsetof(UJackUMGLoadMenuAssetData, MenuId) == 0x000038, "Member 'UJackUMGLoadMenuAssetData::MenuId' has a wrong offset!");
static_assert(offsetof(UJackUMGLoadMenuAssetData, WidgetAssets) == 0x000040, "Member 'UJackUMGLoadMenuAssetData::WidgetAssets' has a wrong offset!");
static_assert(offsetof(UJackUMGLoadMenuAssetData, TextureAssets) == 0x000050, "Member 'UJackUMGLoadMenuAssetData::TextureAssets' has a wrong offset!");
static_assert(offsetof(UJackUMGLoadMenuAssetData, OtherAssets) == 0x000060, "Member 'UJackUMGLoadMenuAssetData::OtherAssets' has a wrong offset!");

// Class JackGame.JackUMGMapResourceRequester
// 0x00B8 (0x00F0 - 0x0038)
class UJackUMGMapResourceRequester final : public UObject
{
public:
	int32                                         RequesterID;                                       // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapResourceLoadChannel                   Channel;                                           // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   MapVolumeID;                                       // 0x0040(0x0008)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIndependent;                                      // 0x0048(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGMapFloorInfo*                   FloorInfo;                                         // 0x0050(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<TDelegate<void(int32 RequesterID)>>    AsyncLoadDelegateList;                             // 0x0058(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x80];                                      // 0x0068(0x0080)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             DynamicTextureForJourneyTexture;                   // 0x00E8(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapResourceRequester">();
	}
	static class UJackUMGMapResourceRequester* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapResourceRequester>();
	}
};
static_assert(alignof(UJackUMGMapResourceRequester) == 0x000008, "Wrong alignment on UJackUMGMapResourceRequester");
static_assert(sizeof(UJackUMGMapResourceRequester) == 0x0000F0, "Wrong size on UJackUMGMapResourceRequester");
static_assert(offsetof(UJackUMGMapResourceRequester, RequesterID) == 0x000038, "Member 'UJackUMGMapResourceRequester::RequesterID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, Channel) == 0x00003C, "Member 'UJackUMGMapResourceRequester::Channel' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, MapVolumeID) == 0x000040, "Member 'UJackUMGMapResourceRequester::MapVolumeID' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, bIndependent) == 0x000048, "Member 'UJackUMGMapResourceRequester::bIndependent' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, FloorInfo) == 0x000050, "Member 'UJackUMGMapResourceRequester::FloorInfo' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, AsyncLoadDelegateList) == 0x000058, "Member 'UJackUMGMapResourceRequester::AsyncLoadDelegateList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapResourceRequester, DynamicTextureForJourneyTexture) == 0x0000E8, "Member 'UJackUMGMapResourceRequester::DynamicTextureForJourneyTexture' has a wrong offset!");

// Class JackGame.JackUMGMapController
// 0x02E0 (0x0318 - 0x0038)
class UJackUMGMapController : public UObject
{
public:
	UMulticastDelegateProperty_                   MapSymbolVisibleChanged;                           // 0x0038(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   BoukenGuideVisibleChanged;                         // 0x0048(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class FName>                           SeaMapIDList;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<class FName>                           SkyMapIDList;                                      // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	EJackKeys                                     MapSymbolOnOffButton;                              // 0x0078(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackKeys                                     BoukenGuideOnOffbutton;                            // 0x0079(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_7A[0x6];                                       // 0x007A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EJackWorldMapState>                    BoukenGuideToggleVisibilityDisableStates;          // 0x0080(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	TArray<EJackWorldMapState>                    MapSymbolToggleVisibilityDisableStates;            // 0x0090(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, Protected, NativeAccessSpecifierProtected)
	class UTexture2D*                             DefaultMapMaskTexture;                             // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             TranceparentTexture;                               // 0x00A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UTexture2D*                             CensoredMapTexture;                                // 0x00B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMapCameraCullingEnabled;                          // 0x00B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_B9[0x3];                                       // 0x00B9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WaitTimeForLoadResource;                           // 0x00BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         NowLoadingDisplayingThreshold;                     // 0x00C0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackUIMapZoomState                           ZoomState;                                         // 0x00C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIconZoomEnabled;                                  // 0x00C5(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_C6[0x2];                                       // 0x00C6(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IconZoomFactorMin;                                 // 0x00C8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IconZoomFactorMax;                                 // 0x00CC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bIsScrollAdjustmentByFrameRate;                    // 0x00D0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_D1[0x7];                                       // 0x00D1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGMapSymbolInfoBase*>      MapSymbolInfoList;                                 // 0x00D8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, EditConst, Protected, NativeAccessSpecifierProtected)
	TArray<class UJackUMGMapTextImageSymbolInfo*> MapTextImageSymbolInfoList;                        // 0x00E8(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackUMGMiniMapWidget>   MiniMapWidget;                                     // 0x00F8(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackUMGWorldMapWidget>  LocalMapWidget;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackUMGWorldMapWidget>  WorldMapWidget;                                    // 0x0108(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TWeakObjectPtr<class UJackUMGWidgetBase>      BoukenGuideWidget;                                 // 0x0110(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         JourneyTextureResolution;                          // 0x0118(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_11C[0x4];                                      // 0x011C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 PointerTargetList;                                 // 0x0120(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_130[0x50];                                     // 0x0130(0x0050)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGMapFloorInfo*>           MapFloorInfoList;                                  // 0x0180(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UJackUMGMapDelegateButtonPayload*       MapSymbolVisibleDelegatePayload;                   // 0x0190(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UJackUMGMapDelegateButtonPayload*       BoukenGuideVisibleDelegatePayload;                 // 0x0198(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TArray<class UJackMapKiraAccessorBase*>       KiraList;                                          // 0x01A0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FJackTextureRenderTargetDict>   RenderTargetList;                                  // 0x01B0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1C0[0x48];                                     // 0x01C0(0x0048)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGMapResourceRequesterSet*> RequesterSetList;                                  // 0x0208(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTexture2D*                             MapTraceModeBaseTexture;                           // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMapTraceMode;                                     // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bUseMapTraceBaseTexture;                           // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_222[0x2];                                      // 0x0222(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MapTraceModeDiameter;                              // 0x0224(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDrawJourneyTextureOnly;                           // 0x0228(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bMapSymbolDebugMode;                               // 0x0229(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bDebugIgnoreKiraPickedUpFlag;                      // 0x022A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bForceCenteringMiniMap;                            // 0x022B(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_22C[0xEC];                                     // 0x022C(0x00EC)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static TArray<EJackMapSymbol> GetAllMapSymbolTypes();
	static class UJackMiniMapCameraComponent* GetMiniMapCameraComponent(const class ACameraActor* MiniMapCamera);
	static bool IsKiraSymbol(EJackMapSymbol InType);
	static bool IsVehicleSymbol(EJackMapSymbol InType);

	void AddPointerTargetMapSymbol(int32 UniqueNo);
	void ClearMiniMapCamera();
	void ClearWorldMapState(EJackWorldMapState WorldMapState);
	void ClearWorldMapStates(const TArray<EJackWorldMapState>& WorltMapStates);
	void CreateMapTextImageSymbolInfo(class UJackUMGMainMapOverlayWidgetBase* InMapTextWidget);
	void EmptyFloorInfo(bool bExceptsCurrentFloor);
	void EmptyMapTextImageSymbolInfo();
	void EmptyPCFootmark();
	void EmptyPointerTargets();
	TArray<class UJackUMGMapSymbolInfoBase*> FindAllMapSymbolInfo(const TArray<EJackMapSymbol>& MapSymbolTypes);
	class UJackUMGMapSymbolInfoBase* FindMapSymbolInfo(int32 UniqueNo);
	class UJackUMGMapResourceRequester* FindResourceRequester(int32 RequesterID);
	class UJackUMGMainMapOverlayWidgetBase* GetCurrentMapTextWidget();
	TArray<class UJackMapKiraAccessorBase*> GetKiraAccessorList();
	TArray<class UJackUMGItemData*> GetKiraUMGItemDataList(bool bIgnoreHasPickedUpFlag);
	TArray<class UJackUMGMapSymbolInfoBase*> GetMapSymbolInfoList();
	TArray<class UJackUMGMapTextImageSymbolInfo*> GetMapTextImageSymbolInfoList();
	TArray<int32> GetPointerTargetList();
	void InvalidateResourceRequester(int32 RequesterID);
	void OnAddPointerTargetMapSymbol(int32 UniqueNo);
	void OnEmptyPointerTargets();
	void OnRemovePointerTargetMapSymbol(int32 UniqueNo);
	void OnUpdate(float DeltaTime, bool bAssetLoadingNow);
	void RemovePointerTargetMapSymbol(int32 UniqueNo);
	int32 RequestFloorInfo(int32 RelativeLevel, const TArray<EJackUMGMapResourceType>& ResourceList, EJackMapResourceLoadChannel Channel, bool bIndependent, const TDelegate<void(int32 RequesterID)>& Delegate);
	int32 RequestFloorInfoForVolumeID(class FName MapVolumeID, const TArray<EJackUMGMapResourceType>& ResourceList, EJackMapResourceLoadChannel Channel, bool bIndependent, const TDelegate<void(int32 RequesterID)>& Delegate);
	void SetBoukenGuideVisible(bool bVisible);
	void SetFloorWithVolumeID(class FName InMapVolumeID, bool bNotChangeSLocation);
	void SetMapSymbolVisible(bool bVisible);
	void SetMapVisitFlagEnabled(bool bEnabled);
	void SetMiniMapCamera(class ACameraActor* InMiniMapCamera, class FName InMapId);
	void SetWorldMapOpenReason(EJackWorldMapOpenReason OpenReason, bool bForceSet);
	void SetWorldMapState(EJackWorldMapState WorldMapState);
	void SortMapSymbolInfoListByDrawPriority(bool bDescending);

	struct FLinearColor CalcMapTextureCoordCenteringOnWorldPosition(const struct FVector& WorldPosition, float Scale, bool bForMiniMap) const;
	bool ExistsFloor(int32 RelativeLevel, int32* OutFloorKeyIndex) const;
	class UTexture2D* FindMapSymbolTexture(EJackMapSymbol Type) const;
	TArray<class UJackUMGMapSymbolInfoBase*> FindNearbyMapSymbol(const struct FVector& WorldPosition, float Distance) const;
	bool GetBoukenGuideVisible() const;
	EJackMapFieldType GetCurrentMapFieldType() const;
	float GetCurrentMapZoomFactorMax() const;
	const class FString GetCurrentSLocationName() const;
	EJackFloorArea GetFloorArea() const;
	EJackFloorLevel GetFloorLevel() const;
	int32 GetFloorLevelCount() const;
	const TArray<class FName> GetLinkedFloorMapVolumeIDList() const;
	class FName GetMapID() const;
	struct FVector GetMapOrigin(bool bForMiniMap) const;
	TArray<EJackMapSymbol> GetMapSymbolTypeListForMapMode(EJackWorldMapState WorldMapState) const;
	bool GetMapSymbolVisible() const;
	class FName GetMapVolumeID() const;
	float GetMiniMapDisplayDiameter() const;
	TArray<class UJackMiniMapTargetComponent*> GetMiniMapTargetComponentList() const;
	float GetMiniMapZoomRate() const;
	const class FString GetMLocationTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	class FName GetParentMapVolumeID() const;
	class FName GetSLocationMapVolumeID() const;
	const class FString GetSLocationTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	EJackWorldMapOpenReason GetWorldMapOpenReason() const;
	const class FString GetWorldMapTitle(class FName MapVolumeID, bool bIgnoreOpenFlag) const;
	bool IsBoukenGuideVisibilityToggleEnabled() const;
	bool IsCurrentFloorSymbol(const class UJackUMGMapSymbolInfoBase* Symbol, bool bForMiniMap) const;
	bool IsCurrentMapUnleashed() const;
	bool IsDisplayingWorldMap() const;
	bool IsMapSymbolVisibilityToggleEnabled() const;
	bool IsMapTextImageItem(const class UWidget* Widget) const;
	bool IsPermittedToOpenMiniMap() const;
	bool IsSeaMap() const;
	bool IsSeaOrSkyMap() const;
	bool IsSeaOrSkyMapVolumeID(class FName MapVolumeID) const;
	bool IsShipAvailable() const;
	bool IsSkyMap() const;
	bool IsValidCurrentMapInfo() const;
	bool IsValidCurrentSLocationID() const;
	bool TestsWorldMapState(EJackWorldMapState WorldMapState) const;
	bool TestsWorldMapStates(const TArray<EJackWorldMapState>& WorltMapStates, bool bAND_Operation) const;
	struct FVector2D TransformToWorldMapViewPosition(class UJackUMGWorldMapWidget* WorldMapWidget_0, const struct FVector& WorldPosition, float Scale) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapController">();
	}
	static class UJackUMGMapController* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapController>();
	}
};
static_assert(alignof(UJackUMGMapController) == 0x000008, "Wrong alignment on UJackUMGMapController");
static_assert(sizeof(UJackUMGMapController) == 0x000318, "Wrong size on UJackUMGMapController");
static_assert(offsetof(UJackUMGMapController, MapSymbolVisibleChanged) == 0x000038, "Member 'UJackUMGMapController::MapSymbolVisibleChanged' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, BoukenGuideVisibleChanged) == 0x000048, "Member 'UJackUMGMapController::BoukenGuideVisibleChanged' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, SeaMapIDList) == 0x000058, "Member 'UJackUMGMapController::SeaMapIDList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, SkyMapIDList) == 0x000068, "Member 'UJackUMGMapController::SkyMapIDList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapSymbolOnOffButton) == 0x000078, "Member 'UJackUMGMapController::MapSymbolOnOffButton' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, BoukenGuideOnOffbutton) == 0x000079, "Member 'UJackUMGMapController::BoukenGuideOnOffbutton' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, BoukenGuideToggleVisibilityDisableStates) == 0x000080, "Member 'UJackUMGMapController::BoukenGuideToggleVisibilityDisableStates' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapSymbolToggleVisibilityDisableStates) == 0x000090, "Member 'UJackUMGMapController::MapSymbolToggleVisibilityDisableStates' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, DefaultMapMaskTexture) == 0x0000A0, "Member 'UJackUMGMapController::DefaultMapMaskTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, TranceparentTexture) == 0x0000A8, "Member 'UJackUMGMapController::TranceparentTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, CensoredMapTexture) == 0x0000B0, "Member 'UJackUMGMapController::CensoredMapTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bMapCameraCullingEnabled) == 0x0000B8, "Member 'UJackUMGMapController::bMapCameraCullingEnabled' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, WaitTimeForLoadResource) == 0x0000BC, "Member 'UJackUMGMapController::WaitTimeForLoadResource' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, NowLoadingDisplayingThreshold) == 0x0000C0, "Member 'UJackUMGMapController::NowLoadingDisplayingThreshold' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, ZoomState) == 0x0000C4, "Member 'UJackUMGMapController::ZoomState' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bIconZoomEnabled) == 0x0000C5, "Member 'UJackUMGMapController::bIconZoomEnabled' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, IconZoomFactorMin) == 0x0000C8, "Member 'UJackUMGMapController::IconZoomFactorMin' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, IconZoomFactorMax) == 0x0000CC, "Member 'UJackUMGMapController::IconZoomFactorMax' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bIsScrollAdjustmentByFrameRate) == 0x0000D0, "Member 'UJackUMGMapController::bIsScrollAdjustmentByFrameRate' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapSymbolInfoList) == 0x0000D8, "Member 'UJackUMGMapController::MapSymbolInfoList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapTextImageSymbolInfoList) == 0x0000E8, "Member 'UJackUMGMapController::MapTextImageSymbolInfoList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MiniMapWidget) == 0x0000F8, "Member 'UJackUMGMapController::MiniMapWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, LocalMapWidget) == 0x000100, "Member 'UJackUMGMapController::LocalMapWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, WorldMapWidget) == 0x000108, "Member 'UJackUMGMapController::WorldMapWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, BoukenGuideWidget) == 0x000110, "Member 'UJackUMGMapController::BoukenGuideWidget' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, JourneyTextureResolution) == 0x000118, "Member 'UJackUMGMapController::JourneyTextureResolution' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, PointerTargetList) == 0x000120, "Member 'UJackUMGMapController::PointerTargetList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapFloorInfoList) == 0x000180, "Member 'UJackUMGMapController::MapFloorInfoList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapSymbolVisibleDelegatePayload) == 0x000190, "Member 'UJackUMGMapController::MapSymbolVisibleDelegatePayload' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, BoukenGuideVisibleDelegatePayload) == 0x000198, "Member 'UJackUMGMapController::BoukenGuideVisibleDelegatePayload' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, KiraList) == 0x0001A0, "Member 'UJackUMGMapController::KiraList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, RenderTargetList) == 0x0001B0, "Member 'UJackUMGMapController::RenderTargetList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, RequesterSetList) == 0x000208, "Member 'UJackUMGMapController::RequesterSetList' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapTraceModeBaseTexture) == 0x000218, "Member 'UJackUMGMapController::MapTraceModeBaseTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bMapTraceMode) == 0x000220, "Member 'UJackUMGMapController::bMapTraceMode' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bUseMapTraceBaseTexture) == 0x000221, "Member 'UJackUMGMapController::bUseMapTraceBaseTexture' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, MapTraceModeDiameter) == 0x000224, "Member 'UJackUMGMapController::MapTraceModeDiameter' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bDrawJourneyTextureOnly) == 0x000228, "Member 'UJackUMGMapController::bDrawJourneyTextureOnly' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bMapSymbolDebugMode) == 0x000229, "Member 'UJackUMGMapController::bMapSymbolDebugMode' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bDebugIgnoreKiraPickedUpFlag) == 0x00022A, "Member 'UJackUMGMapController::bDebugIgnoreKiraPickedUpFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGMapController, bForceCenteringMiniMap) == 0x00022B, "Member 'UJackUMGMapController::bForceCenteringMiniMap' has a wrong offset!");

// Class JackGame.JackUMGMapKiraSymbolInfo
// 0x0010 (0x0070 - 0x0060)
class UJackUMGMapKiraSymbolInfo final : public UJackUMGComponentBasedMapSymbolInfo
{
public:
	bool                                          bDrawsPopCondition;                                // 0x0060(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsVisible() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapKiraSymbolInfo">();
	}
	static class UJackUMGMapKiraSymbolInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapKiraSymbolInfo>();
	}
};
static_assert(alignof(UJackUMGMapKiraSymbolInfo) == 0x000008, "Wrong alignment on UJackUMGMapKiraSymbolInfo");
static_assert(sizeof(UJackUMGMapKiraSymbolInfo) == 0x000070, "Wrong size on UJackUMGMapKiraSymbolInfo");
static_assert(offsetof(UJackUMGMapKiraSymbolInfo, bDrawsPopCondition) == 0x000060, "Member 'UJackUMGMapKiraSymbolInfo::bDrawsPopCondition' has a wrong offset!");

// Class JackGame.JackUMGMapTextImageItem
// 0x0090 (0x0428 - 0x0398)
class UJackUMGMapTextImageItem : public UJackUMGMapTextItemBase
{
public:
	struct FSlateBrush                            ImageBrush;                                        // 0x0398(0x0078)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bIgnoreZoomScale;                                  // 0x0410(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackMapTextItemDrawTarget                    DrawTarget;                                        // 0x0411(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_412[0x6];                                      // 0x0412(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             BrushOriginalTexture;                              // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	float GetAngle() const;
	class UTexture2D* GetImageTexture() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapTextImageItem">();
	}
	static class UJackUMGMapTextImageItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapTextImageItem>();
	}
};
static_assert(alignof(UJackUMGMapTextImageItem) == 0x000008, "Wrong alignment on UJackUMGMapTextImageItem");
static_assert(sizeof(UJackUMGMapTextImageItem) == 0x000428, "Wrong size on UJackUMGMapTextImageItem");
static_assert(offsetof(UJackUMGMapTextImageItem, ImageBrush) == 0x000398, "Member 'UJackUMGMapTextImageItem::ImageBrush' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextImageItem, bIgnoreZoomScale) == 0x000410, "Member 'UJackUMGMapTextImageItem::bIgnoreZoomScale' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextImageItem, DrawTarget) == 0x000411, "Member 'UJackUMGMapTextImageItem::DrawTarget' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextImageItem, BrushOriginalTexture) == 0x000418, "Member 'UJackUMGMapTextImageItem::BrushOriginalTexture' has a wrong offset!");

// Class JackGame.JackUMGMapTextLocationNameItem
// 0x0038 (0x03D0 - 0x0398)
class UJackUMGMapTextLocationNameItem final : public UJackUMGMapTextItemBase
{
public:
	class FText                                   CaptionText;                                       // 0x0398(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ETextJustify                                  TextJustification;                                 // 0x03B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B1[0x7];                                      // 0x03B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   PreviewText;                                       // 0x03B8(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMapTextLocationNameItem">();
	}
	static class UJackUMGMapTextLocationNameItem* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMapTextLocationNameItem>();
	}
};
static_assert(alignof(UJackUMGMapTextLocationNameItem) == 0x000008, "Wrong alignment on UJackUMGMapTextLocationNameItem");
static_assert(sizeof(UJackUMGMapTextLocationNameItem) == 0x0003D0, "Wrong size on UJackUMGMapTextLocationNameItem");
static_assert(offsetof(UJackUMGMapTextLocationNameItem, CaptionText) == 0x000398, "Member 'UJackUMGMapTextLocationNameItem::CaptionText' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextLocationNameItem, TextJustification) == 0x0003B0, "Member 'UJackUMGMapTextLocationNameItem::TextJustification' has a wrong offset!");
static_assert(offsetof(UJackUMGMapTextLocationNameItem, PreviewText) == 0x0003B8, "Member 'UJackUMGMapTextLocationNameItem::PreviewText' has a wrong offset!");

// Class JackGame.JackUMGMeosiSlotDirection
// 0x0020 (0x01F0 - 0x01D0)
class UJackUMGMeosiSlotDirection final : public UUserWidget
{
public:
	uint8                                         Pad_1D0[0x10];                                     // 0x01D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class UWidgetAnimation*                       CurrentAnimation;                                  // 0x01E0(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_1E8[0x8];                                      // 0x01E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelWidgetAnimation(bool InCurrentAnimationStop);
	void RequestWidgetAnimationPlay(const class UWidgetAnimation* InAnimation, bool InLoop);
	void RequestWidgetAnimationStop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGMeosiSlotDirection">();
	}
	static class UJackUMGMeosiSlotDirection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGMeosiSlotDirection>();
	}
};
static_assert(alignof(UJackUMGMeosiSlotDirection) == 0x000008, "Wrong alignment on UJackUMGMeosiSlotDirection");
static_assert(sizeof(UJackUMGMeosiSlotDirection) == 0x0001F0, "Wrong size on UJackUMGMeosiSlotDirection");
static_assert(offsetof(UJackUMGMeosiSlotDirection, CurrentAnimation) == 0x0001E0, "Member 'UJackUMGMeosiSlotDirection::CurrentAnimation' has a wrong offset!");

// Class JackGame.JackUMGModeSelect
// 0x0040 (0x0470 - 0x0430)
class UJackUMGModeSelect : public UJackUMGBrowserBase
{
public:
	class UManaComponent*                         ManaComponent3d;                                   // 0x0430(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManaComponent*                         ManaComponent2d;                                   // 0x0438(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MovieMaterial3d;                                   // 0x0440(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterial*                              MovieMaterial2d;                                   // 0x0448(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManaTexture*                           ManaTexture3d;                                     // 0x0450(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UManaTexture*                           ManaTexture2d;                                     // 0x0458(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_460[0x10];                                     // 0x0460(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishManaComponent();
	bool IsReady2D3DMovie();
	bool IsValidMovieData();
	void SelectMovie(bool IsSelected2d);
	void SetInitialFadeValue();
	void SetMediaSource();
	void SetModeSelectGotoState(EJackUMGModeSelectGotoState InState);
	void SetValidMovieData(bool bValid);

	EJackUMGModeSelectGotoState GetModeSelectGotoState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGModeSelect">();
	}
	static class UJackUMGModeSelect* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGModeSelect>();
	}
};
static_assert(alignof(UJackUMGModeSelect) == 0x000008, "Wrong alignment on UJackUMGModeSelect");
static_assert(sizeof(UJackUMGModeSelect) == 0x000470, "Wrong size on UJackUMGModeSelect");
static_assert(offsetof(UJackUMGModeSelect, ManaComponent3d) == 0x000430, "Member 'UJackUMGModeSelect::ManaComponent3d' has a wrong offset!");
static_assert(offsetof(UJackUMGModeSelect, ManaComponent2d) == 0x000438, "Member 'UJackUMGModeSelect::ManaComponent2d' has a wrong offset!");
static_assert(offsetof(UJackUMGModeSelect, MovieMaterial3d) == 0x000440, "Member 'UJackUMGModeSelect::MovieMaterial3d' has a wrong offset!");
static_assert(offsetof(UJackUMGModeSelect, MovieMaterial2d) == 0x000448, "Member 'UJackUMGModeSelect::MovieMaterial2d' has a wrong offset!");
static_assert(offsetof(UJackUMGModeSelect, ManaTexture3d) == 0x000450, "Member 'UJackUMGModeSelect::ManaTexture3d' has a wrong offset!");
static_assert(offsetof(UJackUMGModeSelect, ManaTexture2d) == 0x000458, "Member 'UJackUMGModeSelect::ManaTexture2d' has a wrong offset!");

// Class JackGame.JackUMGName
// 0x00D8 (0x04D8 - 0x0400)
class UJackUMGName : public UJackUMGWindowBase
{
public:
	TArray<class UJackUMGItemBase*>               SelectNameList;                                    // 0x0400(0x0010)(BlueprintVisible, ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bEndOfNameInput;                                   // 0x0410(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_411[0x7];                                      // 0x0411(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   EndDelegate;                                       // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   FlashUnderBarDelegate;                             // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   HiddenUnderBarDelegate;                            // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   ModoruDelegate;                                    // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FString                                 InputName;                                         // 0x0458(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InputNameMaxAsia;                                  // 0x0468(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_46C[0x6C];                                     // 0x046C(0x006C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class FString CanUseFont(const struct FSlateFontInfo& InFontInfo);
	bool CheckFukkatuNoJumon();
	bool CheckInputNameMaxAsia();
	bool CheckInputNameZeroAsia();
	bool CheckNGWord();
	void ClearInputName();
	void CutSpaceFromTop();
	void GetInputNameAsia();
	void InitNamaeMoji();
	void InitNamaeMojiFukkatu();
	void InitNameDisplay(class UCanvasPanel* NameListCanvas);
	bool IsInputNameEmpty();
	void JackUMGNameEndDelegate__DelegateSignature();
	void JackUMGNameFlashUnderBarDelegate__DelegateSignature();
	void JackUMGNameHiddenUnderBarDelegate__DelegateSignature();
	void JackUMGNameModoruDelegate__DelegateSignature();
	void NamaeMojiCheckAsia(const class FString& InInputName, const struct FSlateFontInfo& InFontInfo);
	void NamaeMojiCheckHans(const class FString& InInputName);
	void NamaeMojiCheckHant(const class FString& InInputName, const struct FSlateFontInfo& InFontInfo);
	void NamaeMojiCheckKorea(const class FString& InInputName);
	void OpenIMEAsia();
	void RestoreName();
	void SetCheatFukkatuNoJumon(const class FString& InFukkatuNoJumon);
	void SetFukkatuNoJumonString(const class FString& InString);
	EJackUMGNamePlatform SwitchPlatform();

	class FString GetUnderBarText() const;
	bool IsInNameBlackSquare() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGName">();
	}
	static class UJackUMGName* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGName>();
	}
};
static_assert(alignof(UJackUMGName) == 0x000008, "Wrong alignment on UJackUMGName");
static_assert(sizeof(UJackUMGName) == 0x0004D8, "Wrong size on UJackUMGName");
static_assert(offsetof(UJackUMGName, SelectNameList) == 0x000400, "Member 'UJackUMGName::SelectNameList' has a wrong offset!");
static_assert(offsetof(UJackUMGName, bEndOfNameInput) == 0x000410, "Member 'UJackUMGName::bEndOfNameInput' has a wrong offset!");
static_assert(offsetof(UJackUMGName, EndDelegate) == 0x000418, "Member 'UJackUMGName::EndDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGName, FlashUnderBarDelegate) == 0x000428, "Member 'UJackUMGName::FlashUnderBarDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGName, HiddenUnderBarDelegate) == 0x000438, "Member 'UJackUMGName::HiddenUnderBarDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGName, ModoruDelegate) == 0x000448, "Member 'UJackUMGName::ModoruDelegate' has a wrong offset!");
static_assert(offsetof(UJackUMGName, InputName) == 0x000458, "Member 'UJackUMGName::InputName' has a wrong offset!");
static_assert(offsetof(UJackUMGName, InputNameMaxAsia) == 0x000468, "Member 'UJackUMGName::InputNameMaxAsia' has a wrong offset!");

// Class JackGame.JackUMGPairingInitialize
// 0x0000 (0x0398 - 0x0398)
class UJackUMGPairingInitialize : public UJackUMGPairingBase
{
public:
	const class FText GetInitialPairingTextId();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPairingInitialize">();
	}
	static class UJackUMGPairingInitialize* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPairingInitialize>();
	}
};
static_assert(alignof(UJackUMGPairingInitialize) == 0x000008, "Wrong alignment on UJackUMGPairingInitialize");
static_assert(sizeof(UJackUMGPairingInitialize) == 0x000398, "Wrong size on UJackUMGPairingInitialize");

// Class JackGame.JackUMGPairingProfile
// 0x0000 (0x0398 - 0x0398)
class UJackUMGPairingProfile : public UJackUMGPairingBase
{
public:
	void OpenPicker();
	void OpenRemoveControllerMenuDebug();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGPairingProfile">();
	}
	static class UJackUMGPairingProfile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGPairingProfile>();
	}
};
static_assert(alignof(UJackUMGPairingProfile) == 0x000008, "Wrong alignment on UJackUMGPairingProfile");
static_assert(sizeof(UJackUMGPairingProfile) == 0x000398, "Wrong size on UJackUMGPairingProfile");

// Class JackGame.JackUMGQuestClearBase
// 0x0008 (0x0378 - 0x0370)
class UJackUMGQuestClearBase : public UJackUMGWidgetBase
{
public:
	bool                                          bFinishedInAnimation;                              // 0x0370(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedOutAnimation;                             // 0x0371(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_372[0x6];                                      // 0x0372(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallPlayCloseAnimation();
	void CallPlayOpenAnimation();
	void CallSetData(const class FName& QuestId, bool bFromOrder);

	bool CallIsFinishedCloseAnimation() const;
	bool CallIsFinishedOpenAnimation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGQuestClearBase">();
	}
	static class UJackUMGQuestClearBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGQuestClearBase>();
	}
};
static_assert(alignof(UJackUMGQuestClearBase) == 0x000008, "Wrong alignment on UJackUMGQuestClearBase");
static_assert(sizeof(UJackUMGQuestClearBase) == 0x000378, "Wrong size on UJackUMGQuestClearBase");
static_assert(offsetof(UJackUMGQuestClearBase, bFinishedInAnimation) == 0x000370, "Member 'UJackUMGQuestClearBase::bFinishedInAnimation' has a wrong offset!");
static_assert(offsetof(UJackUMGQuestClearBase, bFinishedOutAnimation) == 0x000371, "Member 'UJackUMGQuestClearBase::bFinishedOutAnimation' has a wrong offset!");

// Class JackGame.JackUMGSoundSet
// 0x01D0 (0x0208 - 0x0038)
class UJackUMGSoundSet : public UObject
{
public:
	uint8                                         Pad_38[0x20];                                      // 0x0038(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundBase*                             BasicEnter;                                        // 0x0058(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             BasicCancel;                                       // 0x0060(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WindowOpen;                                        // 0x0068(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             WindowClose;                                       // 0x0070(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MsgOpenSelector;                                   // 0x0078(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TalkLowest;                                        // 0x0080(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TalkLower;                                         // 0x0088(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TalkMid;                                           // 0x0090(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TalkHigher;                                        // 0x0098(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TalkHighest;                                       // 0x00A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackMessageSoundTagDict>       SETagSoundList;                                    // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	class USoundBase*                             CountNumber;                                       // 0x00B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SyougouAcquisition;                                // 0x00C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MapOpen;                                           // 0x00C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MapClose;                                          // 0x00D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MapSend;                                           // 0x00D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MapChangeFloor;                                    // 0x00E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DouguSyousaiOpen;                                  // 0x00E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DouguSyousaiClose;                                 // 0x00F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DouguSyousaiPage;                                  // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ManualSave;                                        // 0x0100(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AutoSave;                                          // 0x0108(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             ItemGet;                                           // 0x0110(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             GoldGet;                                           // 0x0118(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TiisanaMedalGet;                                   // 0x0120(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             FukidasiOpen;                                      // 0x0128(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Eisyo;                                             // 0x0130(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class USoundBase*>                     FieldActionSE;                                     // 0x0138(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	class USoundBase*                             AttachEquipment;                                   // 0x0148(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             DetachEquipment;                                   // 0x0150(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EquipmentDefault;                                  // 0x0158(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EquipmentMetal;                                    // 0x0160(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             EquipmentCloth;                                    // 0x0168(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             TuyosaPageChange;                                  // 0x0170(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             AactivateBattleMenu;                               // 0x0178(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MdlStampS;                                         // 0x0180(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MdlStampM;                                         // 0x0188(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MdlStampL;                                         // 0x0190(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MdlStampComp;                                      // 0x0198(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             MdlTakarabako;                                     // 0x01A0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             QstClrStamp;                                       // 0x01A8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel2;                                       // 0x01B0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel3;                                       // 0x01B8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel4;                                       // 0x01C0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel5;                                       // 0x01C8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel6;                                       // 0x01D0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel7;                                       // 0x01D8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel11;                                      // 0x01E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanel14;                                      // 0x01E8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SendSkillpanel;                                    // 0x01F0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             SkillPanelPageChange;                              // 0x01F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             RenkeiSyutoku;                                     // 0x0200(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void CancelUISound();
	class USoundBase* GetEquipmentSound(EJackItem_EquipmentSE InEquipmentSEType);
	class USoundBase* GetUISoundById(class FName SoundId);
	void PlayEquipmentActionSound();
	void PlayFieldActionSE(EJackUMGFieldActionSoundType InSoundtype);
	void PlayUISound(class USoundBase* InSoundBase, int32 MonophonicId);
	void PlayUISoundWithParam(class USoundBase* InSoundBase, int32 MonophonicId, float InVolume, float InPitch, float InStartTime);
	void StopUISound(class USoundBase* InSoundBase);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGSoundSet">();
	}
	static class UJackUMGSoundSet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGSoundSet>();
	}
};
static_assert(alignof(UJackUMGSoundSet) == 0x000008, "Wrong alignment on UJackUMGSoundSet");
static_assert(sizeof(UJackUMGSoundSet) == 0x000208, "Wrong size on UJackUMGSoundSet");
static_assert(offsetof(UJackUMGSoundSet, BasicEnter) == 0x000058, "Member 'UJackUMGSoundSet::BasicEnter' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, BasicCancel) == 0x000060, "Member 'UJackUMGSoundSet::BasicCancel' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, WindowOpen) == 0x000068, "Member 'UJackUMGSoundSet::WindowOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, WindowClose) == 0x000070, "Member 'UJackUMGSoundSet::WindowClose' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MsgOpenSelector) == 0x000078, "Member 'UJackUMGSoundSet::MsgOpenSelector' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TalkLowest) == 0x000080, "Member 'UJackUMGSoundSet::TalkLowest' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TalkLower) == 0x000088, "Member 'UJackUMGSoundSet::TalkLower' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TalkMid) == 0x000090, "Member 'UJackUMGSoundSet::TalkMid' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TalkHigher) == 0x000098, "Member 'UJackUMGSoundSet::TalkHigher' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TalkHighest) == 0x0000A0, "Member 'UJackUMGSoundSet::TalkHighest' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SETagSoundList) == 0x0000A8, "Member 'UJackUMGSoundSet::SETagSoundList' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, CountNumber) == 0x0000B8, "Member 'UJackUMGSoundSet::CountNumber' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SyougouAcquisition) == 0x0000C0, "Member 'UJackUMGSoundSet::SyougouAcquisition' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MapOpen) == 0x0000C8, "Member 'UJackUMGSoundSet::MapOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MapClose) == 0x0000D0, "Member 'UJackUMGSoundSet::MapClose' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MapSend) == 0x0000D8, "Member 'UJackUMGSoundSet::MapSend' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MapChangeFloor) == 0x0000E0, "Member 'UJackUMGSoundSet::MapChangeFloor' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, DouguSyousaiOpen) == 0x0000E8, "Member 'UJackUMGSoundSet::DouguSyousaiOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, DouguSyousaiClose) == 0x0000F0, "Member 'UJackUMGSoundSet::DouguSyousaiClose' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, DouguSyousaiPage) == 0x0000F8, "Member 'UJackUMGSoundSet::DouguSyousaiPage' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, ManualSave) == 0x000100, "Member 'UJackUMGSoundSet::ManualSave' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, AutoSave) == 0x000108, "Member 'UJackUMGSoundSet::AutoSave' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, ItemGet) == 0x000110, "Member 'UJackUMGSoundSet::ItemGet' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, GoldGet) == 0x000118, "Member 'UJackUMGSoundSet::GoldGet' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TiisanaMedalGet) == 0x000120, "Member 'UJackUMGSoundSet::TiisanaMedalGet' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, FukidasiOpen) == 0x000128, "Member 'UJackUMGSoundSet::FukidasiOpen' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, Eisyo) == 0x000130, "Member 'UJackUMGSoundSet::Eisyo' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, FieldActionSE) == 0x000138, "Member 'UJackUMGSoundSet::FieldActionSE' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, AttachEquipment) == 0x000148, "Member 'UJackUMGSoundSet::AttachEquipment' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, DetachEquipment) == 0x000150, "Member 'UJackUMGSoundSet::DetachEquipment' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, EquipmentDefault) == 0x000158, "Member 'UJackUMGSoundSet::EquipmentDefault' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, EquipmentMetal) == 0x000160, "Member 'UJackUMGSoundSet::EquipmentMetal' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, EquipmentCloth) == 0x000168, "Member 'UJackUMGSoundSet::EquipmentCloth' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, TuyosaPageChange) == 0x000170, "Member 'UJackUMGSoundSet::TuyosaPageChange' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, AactivateBattleMenu) == 0x000178, "Member 'UJackUMGSoundSet::AactivateBattleMenu' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MdlStampS) == 0x000180, "Member 'UJackUMGSoundSet::MdlStampS' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MdlStampM) == 0x000188, "Member 'UJackUMGSoundSet::MdlStampM' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MdlStampL) == 0x000190, "Member 'UJackUMGSoundSet::MdlStampL' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MdlStampComp) == 0x000198, "Member 'UJackUMGSoundSet::MdlStampComp' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, MdlTakarabako) == 0x0001A0, "Member 'UJackUMGSoundSet::MdlTakarabako' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, QstClrStamp) == 0x0001A8, "Member 'UJackUMGSoundSet::QstClrStamp' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel2) == 0x0001B0, "Member 'UJackUMGSoundSet::SkillPanel2' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel3) == 0x0001B8, "Member 'UJackUMGSoundSet::SkillPanel3' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel4) == 0x0001C0, "Member 'UJackUMGSoundSet::SkillPanel4' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel5) == 0x0001C8, "Member 'UJackUMGSoundSet::SkillPanel5' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel6) == 0x0001D0, "Member 'UJackUMGSoundSet::SkillPanel6' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel7) == 0x0001D8, "Member 'UJackUMGSoundSet::SkillPanel7' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel11) == 0x0001E0, "Member 'UJackUMGSoundSet::SkillPanel11' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanel14) == 0x0001E8, "Member 'UJackUMGSoundSet::SkillPanel14' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SendSkillpanel) == 0x0001F0, "Member 'UJackUMGSoundSet::SendSkillpanel' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, SkillPanelPageChange) == 0x0001F8, "Member 'UJackUMGSoundSet::SkillPanelPageChange' has a wrong offset!");
static_assert(offsetof(UJackUMGSoundSet, RenkeiSyutoku) == 0x000200, "Member 'UJackUMGSoundSet::RenkeiSyutoku' has a wrong offset!");

// Class JackGame.JackUMGTokugiFlash006
// 0x0048 (0x0228 - 0x01E0)
class UJackUMGTokugiFlash006 final : public UJackUMGTokugiParts
{
public:
	uint8                                         Pad_1E0[0x28];                                     // 0x01E0(0x0028)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     StarMaterial;                                      // 0x0208(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         PosExp;                                            // 0x0210(0x0004)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_214[0x14];                                     // 0x0214(0x0014)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void PlayNativeAnim();
	void SetElements(class UCanvasPanel* InRootPanel);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiFlash006">();
	}
	static class UJackUMGTokugiFlash006* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiFlash006>();
	}
};
static_assert(alignof(UJackUMGTokugiFlash006) == 0x000008, "Wrong alignment on UJackUMGTokugiFlash006");
static_assert(sizeof(UJackUMGTokugiFlash006) == 0x000228, "Wrong size on UJackUMGTokugiFlash006");
static_assert(offsetof(UJackUMGTokugiFlash006, StarMaterial) == 0x000208, "Member 'UJackUMGTokugiFlash006::StarMaterial' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiFlash006, PosExp) == 0x000210, "Member 'UJackUMGTokugiFlash006::PosExp' has a wrong offset!");

// Class JackGame.JackUMGTokugiPanel
// 0x00C8 (0x04C8 - 0x0400)
class UJackUMGTokugiPanel : public UJackUMGWindowBase
{
public:
	EJackTokugiPanelWindowMode                    Mode;                                              // 0x0400(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackTokugiPanelScenario                      ScenarioFlag;                                      // 0x0401(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_402[0x16];                                     // 0x0402(0x0016)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class UJackUMGTokugiPanelData*>        PanelDataList;                                     // 0x0418(0x0010)(BlueprintVisible, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	EJackCharacter                                SelectedCharacter;                                 // 0x0428(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_429[0x27];                                     // 0x0429(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	class UJackUMGTokugiPanelWindow*              TokugiPanel;                                       // 0x0450(0x0008)(BlueprintVisible, ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UJackUMGTokugiPanelData*                AtariPanelData;                                    // 0x0458(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TArray<int32>                                 EffectiveSkillLineIndexList;                       // 0x0460(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	TSubclassOf<class UJackUMGTokugiPanelData>    TokugiPanelDataClassAsset;                         // 0x0470(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfAfterHideCursorInReleaseLockPanel;           // 0x0478(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfAfterHideCursorInMaster;                     // 0x047C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeAdjoinPanelOpenAtLearn;                // 0x0480(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalOfAdjoinPanelOpenAtLearn;                  // 0x0484(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeDisplayLearnMessage;                   // 0x0488(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfAfterHideSkillLineEffectInMultiMaster;       // 0x048C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         IntervalOfMasterEffectInMultiMaster;               // 0x0490(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfAfterShowSkillLineEffectInMultiLearn;        // 0x0494(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeAatariEffectAtLearn;                   // 0x0498(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeAatariEffectAtMultiLearn;              // 0x049C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfAfterAatariEffect;                           // 0x04A0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeNotifyLearnedRenkeiAtLearn;            // 0x04A4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeNotifyLearnedRenkeiAtMultiLearn;       // 0x04A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeDisplayAchievementAtLearn;             // 0x04AC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         WaitOfBeforeDisplayAchievementAtMultiLearn;        // 0x04B0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         BaseStartTimeInReset;                              // 0x04B4(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         TimingOfListUpdateEffectInReset;                   // 0x04B8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         EndTimeInReset;                                    // 0x04BC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bTestModeOfExecuteMultipleLearning;                // 0x04C0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	EJackTokugiPanelAdjoinPanelOpenTiming         AdjoinPanelOpenTiming;                             // 0x04C1(0x0001)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_4C2[0x6];                                      // 0x04C2(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AcquireAtariSkillPoint();
	TArray<struct FJackUMGTokugiPanelAnimData> CancelMultiMaster();
	void CheckRenkeiLearningFlag(bool bInBattleResult);
	void ConstructMultiMasterData();
	void ConstructPanelData();
	TArray<class UJackUMGItemData*> ConstructSkillLineData(bool bInSkillReset);
	void ConstructTokugiPanelScenarioData(EJackCharacter CharacterType, bool bSyncLoadTexture, class UTexture2D** BackgroundTexture, TSoftObjectPtr<class UTexture>* BackgroundTextureAsset);
	void EndAtariMode();
	TArray<struct FJackUMGTokugiPanelAnimData> ExecuteMaster(class UJackUMGTokugiPanelData* PanelData);
	TArray<struct FJackUMGTokugiPanelAnimData> ExecuteMultiMaster();
	TArray<struct FJackUMGTokugiPanelAnimData> ExecuteReleaseLockPanel(class UJackUMGTokugiPanelData* PanelData);
	TArray<struct FJackUMGTokugiPanelAnimData> ExecuteResetSkillLine(class UJackUMGTokugiPanelSkillLineData* SkillLineData);
	int32 GetAtariSkillPoint();
	TArray<class UJackUMGTokugiPanelData*> GetOpenedPanelDataList();
	bool IsAtariMode();
	class UJackUMGSerifuWindowController* NotifyLearnedRenkei();
	TArray<struct FJackUMGTokugiPanelAnimData> ResumeMultiMasterWorkData();
	TArray<struct FJackUMGTokugiPanelAnimData> ToggleProvMaster(class UJackUMGTokugiPanelData* PanelData);

	bool ExistsLearnedRenkeiNotification() const;
	int32 GetTotleUseSkillPointInMultiMaster() const;
	bool HasProvMasterCheckedPanelData() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGTokugiPanel">();
	}
	static class UJackUMGTokugiPanel* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGTokugiPanel>();
	}
};
static_assert(alignof(UJackUMGTokugiPanel) == 0x000008, "Wrong alignment on UJackUMGTokugiPanel");
static_assert(sizeof(UJackUMGTokugiPanel) == 0x0004C8, "Wrong size on UJackUMGTokugiPanel");
static_assert(offsetof(UJackUMGTokugiPanel, Mode) == 0x000400, "Member 'UJackUMGTokugiPanel::Mode' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, ScenarioFlag) == 0x000401, "Member 'UJackUMGTokugiPanel::ScenarioFlag' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, PanelDataList) == 0x000418, "Member 'UJackUMGTokugiPanel::PanelDataList' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, SelectedCharacter) == 0x000428, "Member 'UJackUMGTokugiPanel::SelectedCharacter' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, TokugiPanel) == 0x000450, "Member 'UJackUMGTokugiPanel::TokugiPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, AtariPanelData) == 0x000458, "Member 'UJackUMGTokugiPanel::AtariPanelData' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, EffectiveSkillLineIndexList) == 0x000460, "Member 'UJackUMGTokugiPanel::EffectiveSkillLineIndexList' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, TokugiPanelDataClassAsset) == 0x000470, "Member 'UJackUMGTokugiPanel::TokugiPanelDataClassAsset' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfAfterHideCursorInReleaseLockPanel) == 0x000478, "Member 'UJackUMGTokugiPanel::WaitOfAfterHideCursorInReleaseLockPanel' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfAfterHideCursorInMaster) == 0x00047C, "Member 'UJackUMGTokugiPanel::WaitOfAfterHideCursorInMaster' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeAdjoinPanelOpenAtLearn) == 0x000480, "Member 'UJackUMGTokugiPanel::WaitOfBeforeAdjoinPanelOpenAtLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, IntervalOfAdjoinPanelOpenAtLearn) == 0x000484, "Member 'UJackUMGTokugiPanel::IntervalOfAdjoinPanelOpenAtLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeDisplayLearnMessage) == 0x000488, "Member 'UJackUMGTokugiPanel::WaitOfBeforeDisplayLearnMessage' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfAfterHideSkillLineEffectInMultiMaster) == 0x00048C, "Member 'UJackUMGTokugiPanel::WaitOfAfterHideSkillLineEffectInMultiMaster' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, IntervalOfMasterEffectInMultiMaster) == 0x000490, "Member 'UJackUMGTokugiPanel::IntervalOfMasterEffectInMultiMaster' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfAfterShowSkillLineEffectInMultiLearn) == 0x000494, "Member 'UJackUMGTokugiPanel::WaitOfAfterShowSkillLineEffectInMultiLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeAatariEffectAtLearn) == 0x000498, "Member 'UJackUMGTokugiPanel::WaitOfBeforeAatariEffectAtLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeAatariEffectAtMultiLearn) == 0x00049C, "Member 'UJackUMGTokugiPanel::WaitOfBeforeAatariEffectAtMultiLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfAfterAatariEffect) == 0x0004A0, "Member 'UJackUMGTokugiPanel::WaitOfAfterAatariEffect' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeNotifyLearnedRenkeiAtLearn) == 0x0004A4, "Member 'UJackUMGTokugiPanel::WaitOfBeforeNotifyLearnedRenkeiAtLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeNotifyLearnedRenkeiAtMultiLearn) == 0x0004A8, "Member 'UJackUMGTokugiPanel::WaitOfBeforeNotifyLearnedRenkeiAtMultiLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeDisplayAchievementAtLearn) == 0x0004AC, "Member 'UJackUMGTokugiPanel::WaitOfBeforeDisplayAchievementAtLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, WaitOfBeforeDisplayAchievementAtMultiLearn) == 0x0004B0, "Member 'UJackUMGTokugiPanel::WaitOfBeforeDisplayAchievementAtMultiLearn' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, BaseStartTimeInReset) == 0x0004B4, "Member 'UJackUMGTokugiPanel::BaseStartTimeInReset' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, TimingOfListUpdateEffectInReset) == 0x0004B8, "Member 'UJackUMGTokugiPanel::TimingOfListUpdateEffectInReset' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, EndTimeInReset) == 0x0004BC, "Member 'UJackUMGTokugiPanel::EndTimeInReset' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, bTestModeOfExecuteMultipleLearning) == 0x0004C0, "Member 'UJackUMGTokugiPanel::bTestModeOfExecuteMultipleLearning' has a wrong offset!");
static_assert(offsetof(UJackUMGTokugiPanel, AdjoinPanelOpenTiming) == 0x0004C1, "Member 'UJackUMGTokugiPanel::AdjoinPanelOpenTiming' has a wrong offset!");

// Class JackGame.JackPafuPafuVoiceManager
// 0x0020 (0x0058 - 0x0038)
class UJackPafuPafuVoiceManager final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        PlayingAudioComponent;                             // 0x0040(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	struct FVector                                VoiceSpawnPos;                                     // 0x0048(0x000C)(IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackPafuPafuVoiceManager">();
	}
	static class UJackPafuPafuVoiceManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackPafuPafuVoiceManager>();
	}
};
static_assert(alignof(UJackPafuPafuVoiceManager) == 0x000008, "Wrong alignment on UJackPafuPafuVoiceManager");
static_assert(sizeof(UJackPafuPafuVoiceManager) == 0x000058, "Wrong size on UJackPafuPafuVoiceManager");
static_assert(offsetof(UJackPafuPafuVoiceManager, PlayingAudioComponent) == 0x000040, "Member 'UJackPafuPafuVoiceManager::PlayingAudioComponent' has a wrong offset!");
static_assert(offsetof(UJackPafuPafuVoiceManager, VoiceSpawnPos) == 0x000048, "Member 'UJackPafuPafuVoiceManager::VoiceSpawnPos' has a wrong offset!");

// Class JackGame.JackUMGVoiceDramaSelectEShop
// 0x0008 (0x0378 - 0x0370)
class UJackUMGVoiceDramaSelectEShop final : public UJackUMGWidgetBase
{
public:
	uint8                                         Pad_370[0x8];                                      // 0x0370(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	class UJackUMGVoiceDramaSelect* GetVoiceDramaSelect();
	void SetVoiceDramaSelect(class UJackUMGVoiceDramaSelect* InVoiceDramaSelect);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGVoiceDramaSelectEShop">();
	}
	static class UJackUMGVoiceDramaSelectEShop* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGVoiceDramaSelectEShop>();
	}
};
static_assert(alignof(UJackUMGVoiceDramaSelectEShop) == 0x000008, "Wrong alignment on UJackUMGVoiceDramaSelectEShop");
static_assert(sizeof(UJackUMGVoiceDramaSelectEShop) == 0x000378, "Wrong size on UJackUMGVoiceDramaSelectEShop");

// Class JackGame.JackUMGWebBrowser
// 0x0008 (0x0438 - 0x0430)
class UJackUMGWebBrowser : public UJackUMGBrowserBase
{
public:
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CloseWebBrowser();
	bool OpenWebBrowser();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUMGWebBrowser">();
	}
	static class UJackUMGWebBrowser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUMGWebBrowser>();
	}
};
static_assert(alignof(UJackUMGWebBrowser) == 0x000008, "Wrong alignment on UJackUMGWebBrowser");
static_assert(sizeof(UJackUMGWebBrowser) == 0x000438, "Wrong size on UJackUMGWebBrowser");

// Class JackGame.JackUpdateWhenNotRenderedForTagTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackUpdateWhenNotRenderedForTagTrack final : public UJackToggleBaseTrack
{
public:
	class FName                                   TargetActorTag;                                    // 0x00A8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackUpdateWhenNotRenderedForTagTrack">();
	}
	static class UJackUpdateWhenNotRenderedForTagTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackUpdateWhenNotRenderedForTagTrack>();
	}
};
static_assert(alignof(UJackUpdateWhenNotRenderedForTagTrack) == 0x000008, "Wrong alignment on UJackUpdateWhenNotRenderedForTagTrack");
static_assert(sizeof(UJackUpdateWhenNotRenderedForTagTrack) == 0x0000B0, "Wrong size on UJackUpdateWhenNotRenderedForTagTrack");
static_assert(offsetof(UJackUpdateWhenNotRenderedForTagTrack, TargetActorTag) == 0x0000A8, "Member 'UJackUpdateWhenNotRenderedForTagTrack::TargetActorTag' has a wrong offset!");

// Class JackGame.JackVector4PropertyTrack
// 0x0008 (0x00B8 - 0x00B0)
class UJackVector4PropertyTrack final : public UInterpTrackVector4Base
{
public:
	class FName                                   PropertyName;                                      // 0x00B0(0x0008)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVector4PropertyTrack">();
	}
	static class UJackVector4PropertyTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVector4PropertyTrack>();
	}
};
static_assert(alignof(UJackVector4PropertyTrack) == 0x000008, "Wrong alignment on UJackVector4PropertyTrack");
static_assert(sizeof(UJackVector4PropertyTrack) == 0x0000B8, "Wrong size on UJackVector4PropertyTrack");
static_assert(offsetof(UJackVector4PropertyTrack, PropertyName) == 0x0000B0, "Member 'UJackVector4PropertyTrack::PropertyName' has a wrong offset!");

// Class JackGame.JackVectorMaterialParameterTrack
// 0x0008 (0x00D0 - 0x00C8)
class UJackVectorMaterialParameterTrack final : public UInterpTrackVectorMaterialParam
{
public:
	bool                                          bApplyToAllMaterial;                               // 0x00C8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVectorMaterialParameterTrack">();
	}
	static class UJackVectorMaterialParameterTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVectorMaterialParameterTrack>();
	}
};
static_assert(alignof(UJackVectorMaterialParameterTrack) == 0x000008, "Wrong alignment on UJackVectorMaterialParameterTrack");
static_assert(sizeof(UJackVectorMaterialParameterTrack) == 0x0000D0, "Wrong size on UJackVectorMaterialParameterTrack");
static_assert(offsetof(UJackVectorMaterialParameterTrack, bApplyToAllMaterial) == 0x0000C8, "Member 'UJackVectorMaterialParameterTrack::bApplyToAllMaterial' has a wrong offset!");

// Class JackGame.JackVectorMaterialParameterTrackInst
// 0x0030 (0x00A0 - 0x0070)
class UJackVectorMaterialParameterTrackInst final : public UInterpTrackInstVectorMaterialParam
{
public:
	TArray<class UMaterialInstanceDynamic*>       MaterialInstancesToAll;                            // 0x0070(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        ResetVectorsToAll;                                 // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimitiveMaterialRef>          PrimitiveMaterialRefsToAll;                        // 0x0090(0x0010)(ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVectorMaterialParameterTrackInst">();
	}
	static class UJackVectorMaterialParameterTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVectorMaterialParameterTrackInst>();
	}
};
static_assert(alignof(UJackVectorMaterialParameterTrackInst) == 0x000008, "Wrong alignment on UJackVectorMaterialParameterTrackInst");
static_assert(sizeof(UJackVectorMaterialParameterTrackInst) == 0x0000A0, "Wrong size on UJackVectorMaterialParameterTrackInst");
static_assert(offsetof(UJackVectorMaterialParameterTrackInst, MaterialInstancesToAll) == 0x000070, "Member 'UJackVectorMaterialParameterTrackInst::MaterialInstancesToAll' has a wrong offset!");
static_assert(offsetof(UJackVectorMaterialParameterTrackInst, ResetVectorsToAll) == 0x000080, "Member 'UJackVectorMaterialParameterTrackInst::ResetVectorsToAll' has a wrong offset!");
static_assert(offsetof(UJackVectorMaterialParameterTrackInst, PrimitiveMaterialRefsToAll) == 0x000090, "Member 'UJackVectorMaterialParameterTrackInst::PrimitiveMaterialRefsToAll' has a wrong offset!");

// Class JackGame.JackVehicleFakeForceTrackInst
// 0x0000 (0x0040 - 0x0040)
class UJackVehicleFakeForceTrackInst final : public UJackToggleBaseTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleFakeForceTrackInst">();
	}
	static class UJackVehicleFakeForceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleFakeForceTrackInst>();
	}
};
static_assert(alignof(UJackVehicleFakeForceTrackInst) == 0x000008, "Wrong alignment on UJackVehicleFakeForceTrackInst");
static_assert(sizeof(UJackVehicleFakeForceTrackInst) == 0x000040, "Wrong size on UJackVehicleFakeForceTrackInst");

// Class JackGame.JackVehicleHasBackMovementComponent
// 0x0040 (0x0F60 - 0x0F20)
class UJackVehicleHasBackMovementComponent final : public UJackVehicleMovementComponent
{
public:
	uint8                                         Pad_F20[0x20];                                     // 0x0F20(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ContinueSteeringForwardMin;                        // 0x0F40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ContinueSteeringForwardMax;                        // 0x0F44(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F48[0x8];                                      // 0x0F48(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSpeed;                                          // 0x0F50(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSpeedRate;                                   // 0x0F54(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         ChangeSteeringSpeedRate;                           // 0x0F58(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_F5C[0x4];                                      // 0x0F5C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleHasBackMovementComponent">();
	}
	static class UJackVehicleHasBackMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVehicleHasBackMovementComponent>();
	}
};
static_assert(alignof(UJackVehicleHasBackMovementComponent) == 0x000010, "Wrong alignment on UJackVehicleHasBackMovementComponent");
static_assert(sizeof(UJackVehicleHasBackMovementComponent) == 0x000F60, "Wrong size on UJackVehicleHasBackMovementComponent");
static_assert(offsetof(UJackVehicleHasBackMovementComponent, ContinueSteeringForwardMin) == 0x000F40, "Member 'UJackVehicleHasBackMovementComponent::ContinueSteeringForwardMin' has a wrong offset!");
static_assert(offsetof(UJackVehicleHasBackMovementComponent, ContinueSteeringForwardMax) == 0x000F44, "Member 'UJackVehicleHasBackMovementComponent::ContinueSteeringForwardMax' has a wrong offset!");
static_assert(offsetof(UJackVehicleHasBackMovementComponent, MaxSpeed) == 0x000F50, "Member 'UJackVehicleHasBackMovementComponent::MaxSpeed' has a wrong offset!");
static_assert(offsetof(UJackVehicleHasBackMovementComponent, ChangeSpeedRate) == 0x000F54, "Member 'UJackVehicleHasBackMovementComponent::ChangeSpeedRate' has a wrong offset!");
static_assert(offsetof(UJackVehicleHasBackMovementComponent, ChangeSteeringSpeedRate) == 0x000F58, "Member 'UJackVehicleHasBackMovementComponent::ChangeSteeringSpeedRate' has a wrong offset!");

// Class JackGame.JackVehicleV101
// 0x00B0 (0x1BE0 - 0x1B30)
class AJackVehicleV101 final : public AJackVehicleMonster
{
public:
	float                                         ForceFallSec;                                      // 0x1B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B34[0x4];                                     // 0x1B34(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JumpCheckOffset;                                   // 0x1B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MaxJumpZ;                                          // 0x1B3C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         MinJumpZ;                                          // 0x1B40(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAttitudeRotationSpeed;                         // 0x1B44(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	struct FRotator                               JumpAddAttitudeRotation;                           // 0x1B50(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, Protected, NativeAccessSpecifierProtected)
	float                                         JumpMaxVelocity;                                   // 0x1B5C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMaxVelocity;                        // 0x1B60(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         JumpStartMotionMinAnimationRate;                   // 0x1B64(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B68[0x78];                                    // 0x1B68(0x0078)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV101">();
	}
	static class AJackVehicleV101* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV101>();
	}
};
static_assert(alignof(AJackVehicleV101) == 0x000010, "Wrong alignment on AJackVehicleV101");
static_assert(sizeof(AJackVehicleV101) == 0x001BE0, "Wrong size on AJackVehicleV101");
static_assert(offsetof(AJackVehicleV101, ForceFallSec) == 0x001B30, "Member 'AJackVehicleV101::ForceFallSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpCheckOffset) == 0x001B38, "Member 'AJackVehicleV101::JumpCheckOffset' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, MaxJumpZ) == 0x001B3C, "Member 'AJackVehicleV101::MaxJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, MinJumpZ) == 0x001B40, "Member 'AJackVehicleV101::MinJumpZ' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpAttitudeRotationSpeed) == 0x001B44, "Member 'AJackVehicleV101::JumpAttitudeRotationSpeed' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpAddAttitudeRotation) == 0x001B50, "Member 'AJackVehicleV101::JumpAddAttitudeRotation' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpMaxVelocity) == 0x001B5C, "Member 'AJackVehicleV101::JumpMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpStartMotionMaxVelocity) == 0x001B60, "Member 'AJackVehicleV101::JumpStartMotionMaxVelocity' has a wrong offset!");
static_assert(offsetof(AJackVehicleV101, JumpStartMotionMinAnimationRate) == 0x001B64, "Member 'AJackVehicleV101::JumpStartMotionMinAnimationRate' has a wrong offset!");

// Class JackGame.JackVehicleV105
// 0x00D0 (0x1C00 - 0x1B30)
class AJackVehicleV105 : public AJackVehicleMonster
{
public:
	float                                         ToGrideSpeed2D;                                    // 0x1B30(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         GrideGravityScale;                                 // 0x1B34(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	float                                         CallUpIntervalSec;                                 // 0x1B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	bool                                          bSyncOffAdditionalPitch;                           // 0x1B3C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_1B3D[0xC3];                                    // 0x1B3D(0x00C3)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallUpV105();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV105">();
	}
	static class AJackVehicleV105* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV105>();
	}
};
static_assert(alignof(AJackVehicleV105) == 0x000010, "Wrong alignment on AJackVehicleV105");
static_assert(sizeof(AJackVehicleV105) == 0x001C00, "Wrong size on AJackVehicleV105");
static_assert(offsetof(AJackVehicleV105, ToGrideSpeed2D) == 0x001B30, "Member 'AJackVehicleV105::ToGrideSpeed2D' has a wrong offset!");
static_assert(offsetof(AJackVehicleV105, GrideGravityScale) == 0x001B34, "Member 'AJackVehicleV105::GrideGravityScale' has a wrong offset!");
static_assert(offsetof(AJackVehicleV105, CallUpIntervalSec) == 0x001B38, "Member 'AJackVehicleV105::CallUpIntervalSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleV105, bSyncOffAdditionalPitch) == 0x001B3C, "Member 'AJackVehicleV105::bSyncOffAdditionalPitch' has a wrong offset!");

// Class JackGame.JackVehicleV201
// 0x0000 (0x1C00 - 0x1C00)
class AJackVehicleV201 final : public AJackVehicleV105
{
public:
	void SetSplashEnable(bool bSplashEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV201">();
	}
	static class AJackVehicleV201* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV201>();
	}
};
static_assert(alignof(AJackVehicleV201) == 0x000010, "Wrong alignment on AJackVehicleV201");
static_assert(sizeof(AJackVehicleV201) == 0x001C00, "Wrong size on AJackVehicleV201");

// Class JackGame.JackVehicleV202
// 0x0000 (0x1B30 - 0x1B30)
class AJackVehicleV202 final : public AJackVehicleMonster
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV202">();
	}
	static class AJackVehicleV202* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV202>();
	}
};
static_assert(alignof(AJackVehicleV202) == 0x000010, "Wrong alignment on AJackVehicleV202");
static_assert(sizeof(AJackVehicleV202) == 0x001B30, "Wrong size on AJackVehicleV202");

// Class JackGame.JackVehicleV203
// 0x00B0 (0x1BE0 - 0x1B30)
class AJackVehicleV203 final : public AJackVehicleMonster
{
public:
	uint8                                         Pad_1B30[0x4];                                     // 0x1B30(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bNoWaiterMontage;                                  // 0x1B34(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B35[0x3];                                     // 0x1B35(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         KeepFallStartSpeedSec;                             // 0x1B38(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B3C[0x4];                                     // 0x1B3C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   MountDelegate;                                     // 0x1B40(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   UnmounDelegate;                                    // 0x1B50(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B60[0x80];                                    // 0x1B60(0x0080)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BroadCastMountUnmountDelegate(bool bMount);
	void ClearMountUnmountDelegate();
	void JackVehicleV203MountUnmountDelegate__DelegateSignature(class AJackVehicleV203* Sender);
	void SetAnimMontageWait(const TArray<class UAnimMontage*>& AnimMontages);
	void SetWaitMotionSetting(class AJackCharacter* Character);
	void StartAnimMontageWait();
	void StopAnimMontageWait();
	void UnSetWaitMotionSetting(class AJackCharacter* Character);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV203">();
	}
	static class AJackVehicleV203* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV203>();
	}
};
static_assert(alignof(AJackVehicleV203) == 0x000010, "Wrong alignment on AJackVehicleV203");
static_assert(sizeof(AJackVehicleV203) == 0x001BE0, "Wrong size on AJackVehicleV203");
static_assert(offsetof(AJackVehicleV203, bNoWaiterMontage) == 0x001B34, "Member 'AJackVehicleV203::bNoWaiterMontage' has a wrong offset!");
static_assert(offsetof(AJackVehicleV203, KeepFallStartSpeedSec) == 0x001B38, "Member 'AJackVehicleV203::KeepFallStartSpeedSec' has a wrong offset!");
static_assert(offsetof(AJackVehicleV203, MountDelegate) == 0x001B40, "Member 'AJackVehicleV203::MountDelegate' has a wrong offset!");
static_assert(offsetof(AJackVehicleV203, UnmounDelegate) == 0x001B50, "Member 'AJackVehicleV203::UnmounDelegate' has a wrong offset!");

// Class JackGame.JackVehicleV204
// 0x0000 (0x1B30 - 0x1B30)
class AJackVehicleV204 final : public AJackVehicleMonster
{
public:
	void SetRiderEquipmentHidden(bool bEquipmentHidden);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVehicleV204">();
	}
	static class AJackVehicleV204* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackVehicleV204>();
	}
};
static_assert(alignof(AJackVehicleV204) == 0x000010, "Wrong alignment on AJackVehicleV204");
static_assert(sizeof(AJackVehicleV204) == 0x001B30, "Wrong size on AJackVehicleV204");

// Class JackGame.JackVibrationManager
// 0x0008 (0x0040 - 0x0038)
class UJackVibrationManager final : public UObject
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVibrationManager">();
	}
	static class UJackVibrationManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVibrationManager>();
	}
};
static_assert(alignof(UJackVibrationManager) == 0x000008, "Wrong alignment on UJackVibrationManager");
static_assert(sizeof(UJackVibrationManager) == 0x000040, "Wrong size on UJackVibrationManager");

// Class JackGame.JackVisibilityTrack
// 0x0008 (0x00B0 - 0x00A8)
class UJackVisibilityTrack final : public UInterpTrackVisibility
{
public:
	EJackCharacterHiddenPurpose                   VisibilityType;                                    // 0x00A8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVisibilityTrack">();
	}
	static class UJackVisibilityTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVisibilityTrack>();
	}
};
static_assert(alignof(UJackVisibilityTrack) == 0x000008, "Wrong alignment on UJackVisibilityTrack");
static_assert(sizeof(UJackVisibilityTrack) == 0x0000B0, "Wrong size on UJackVisibilityTrack");
static_assert(offsetof(UJackVisibilityTrack, VisibilityType) == 0x0000A8, "Member 'UJackVisibilityTrack::VisibilityType' has a wrong offset!");

// Class JackGame.JackVoiceTimelineTrackBlinkEnable
// 0x0010 (0x0048 - 0x0038)
class UJackVoiceTimelineTrackBlinkEnable final : public UJackVoiceTimelineTrack
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrackBlinkEnable">();
	}
	static class UJackVoiceTimelineTrackBlinkEnable* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrackBlinkEnable>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrackBlinkEnable) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrackBlinkEnable");
static_assert(sizeof(UJackVoiceTimelineTrackBlinkEnable) == 0x000048, "Wrong size on UJackVoiceTimelineTrackBlinkEnable");

// Class JackGame.JackVoiceTimelineTrackEmotion
// 0x0018 (0x0050 - 0x0038)
class UJackVoiceTimelineTrackEmotion final : public UJackVoiceTimelineTrack
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrackEmotion">();
	}
	static class UJackVoiceTimelineTrackEmotion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrackEmotion>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrackEmotion) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrackEmotion");
static_assert(sizeof(UJackVoiceTimelineTrackEmotion) == 0x000050, "Wrong size on UJackVoiceTimelineTrackEmotion");

// Class JackGame.JackVoiceTimelineTrackTone
// 0x0018 (0x0050 - 0x0038)
class UJackVoiceTimelineTrackTone final : public UJackVoiceTimelineTrack
{
public:
	uint8                                         Pad_38[0x18];                                      // 0x0038(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrackTone">();
	}
	static class UJackVoiceTimelineTrackTone* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrackTone>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrackTone) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrackTone");
static_assert(sizeof(UJackVoiceTimelineTrackTone) == 0x000050, "Wrong size on UJackVoiceTimelineTrackTone");

// Class JackGame.JackVoiceTimelineTrackUpperFace
// 0x0010 (0x0048 - 0x0038)
class UJackVoiceTimelineTrackUpperFace final : public UJackVoiceTimelineTrack
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTimelineTrackUpperFace">();
	}
	static class UJackVoiceTimelineTrackUpperFace* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTimelineTrackUpperFace>();
	}
};
static_assert(alignof(UJackVoiceTimelineTrackUpperFace) == 0x000008, "Wrong alignment on UJackVoiceTimelineTrackUpperFace");
static_assert(sizeof(UJackVoiceTimelineTrackUpperFace) == 0x000048, "Wrong size on UJackVoiceTimelineTrackUpperFace");

// Class JackGame.JackVoiceTrack
// 0x00E8 (0x01C8 - 0x00E0)
class UJackVoiceTrack final : public USQEXSEADInterpTrackSound
{
public:
	struct FSoftObjectPath                        Asset;                                             // 0x00E0(0x0008)(Edit, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LipSyncGroupName;                                  // 0x00E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FJackVoiceTrackInfo>            VoiceTrackInfos;                                   // 0x00F0(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UDataTable*                             LipDataTable;                                      // 0x0100(0x0008)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0xC0];                                     // 0x0108(0x00C0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTrack">();
	}
	static class UJackVoiceTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTrack>();
	}
};
static_assert(alignof(UJackVoiceTrack) == 0x000008, "Wrong alignment on UJackVoiceTrack");
static_assert(sizeof(UJackVoiceTrack) == 0x0001C8, "Wrong size on UJackVoiceTrack");
static_assert(offsetof(UJackVoiceTrack, Asset) == 0x0000E0, "Member 'UJackVoiceTrack::Asset' has a wrong offset!");
static_assert(offsetof(UJackVoiceTrack, LipSyncGroupName) == 0x0000E8, "Member 'UJackVoiceTrack::LipSyncGroupName' has a wrong offset!");
static_assert(offsetof(UJackVoiceTrack, VoiceTrackInfos) == 0x0000F0, "Member 'UJackVoiceTrack::VoiceTrackInfos' has a wrong offset!");
static_assert(offsetof(UJackVoiceTrack, LipDataTable) == 0x000100, "Member 'UJackVoiceTrack::LipDataTable' has a wrong offset!");

// Class JackGame.JackVoiceTrackInst
// 0x0010 (0x0070 - 0x0060)
class UJackVoiceTrackInst final : public USQEXSEADInterpTrackInstSound
{
public:
	uint8                                         Pad_60[0x10];                                      // 0x0060(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackVoiceTrackInst">();
	}
	static class UJackVoiceTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackVoiceTrackInst>();
	}
};
static_assert(alignof(UJackVoiceTrackInst) == 0x000008, "Wrong alignment on UJackVoiceTrackInst");
static_assert(sizeof(UJackVoiceTrackInst) == 0x000070, "Wrong size on UJackVoiceTrackInst");

// Class JackGame.JackWeaponProjectile
// 0x0020 (0x0428 - 0x0408)
class AJackWeaponProjectile final : public AJackWeaponSK
{
public:
	class FName                                   MuzzleSocket;                                      // 0x0408(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackProjectile>            DefaultProjectileClass;                            // 0x0410(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UParticleSystemComponent*               FirePSC;                                           // 0x0418(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	class UAudioComponent*                        FireAudioComp;                                     // 0x0420(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	void SpawnProjectile(TSubclassOf<class AJackProjectile> ProjectileClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponProjectile">();
	}
	static class AJackWeaponProjectile* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponProjectile>();
	}
};
static_assert(alignof(AJackWeaponProjectile) == 0x000008, "Wrong alignment on AJackWeaponProjectile");
static_assert(sizeof(AJackWeaponProjectile) == 0x000428, "Wrong size on AJackWeaponProjectile");
static_assert(offsetof(AJackWeaponProjectile, MuzzleSocket) == 0x000408, "Member 'AJackWeaponProjectile::MuzzleSocket' has a wrong offset!");
static_assert(offsetof(AJackWeaponProjectile, DefaultProjectileClass) == 0x000410, "Member 'AJackWeaponProjectile::DefaultProjectileClass' has a wrong offset!");
static_assert(offsetof(AJackWeaponProjectile, FirePSC) == 0x000418, "Member 'AJackWeaponProjectile::FirePSC' has a wrong offset!");
static_assert(offsetof(AJackWeaponProjectile, FireAudioComp) == 0x000420, "Member 'AJackWeaponProjectile::FireAudioComp' has a wrong offset!");

// Class JackGame.JackWeaponPropActor
// 0x0020 (0x03D0 - 0x03B0)
class AJackWeaponPropActor : public AJackPropActor
{
public:
	class USkeletalMeshComponent*                 WeaponMeshComponent;                               // 0x03B0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAnimationAsset*                        FireAnimAsset;                                     // 0x03B8(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	TSubclassOf<class AJackActionEffect>          ActionEffectClass;                                 // 0x03C0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_3C8[0x8];                                      // 0x03C8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void OnSpawnHitEffectDelegate();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponPropActor">();
	}
	static class AJackWeaponPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponPropActor>();
	}
};
static_assert(alignof(AJackWeaponPropActor) == 0x000008, "Wrong alignment on AJackWeaponPropActor");
static_assert(sizeof(AJackWeaponPropActor) == 0x0003D0, "Wrong size on AJackWeaponPropActor");
static_assert(offsetof(AJackWeaponPropActor, WeaponMeshComponent) == 0x0003B0, "Member 'AJackWeaponPropActor::WeaponMeshComponent' has a wrong offset!");
static_assert(offsetof(AJackWeaponPropActor, FireAnimAsset) == 0x0003B8, "Member 'AJackWeaponPropActor::FireAnimAsset' has a wrong offset!");
static_assert(offsetof(AJackWeaponPropActor, ActionEffectClass) == 0x0003C0, "Member 'AJackWeaponPropActor::ActionEffectClass' has a wrong offset!");

// Class JackGame.JackBowgunPropActor
// 0x0008 (0x03D8 - 0x03D0)
class AJackBowgunPropActor : public AJackWeaponPropActor
{
public:
	TSubclassOf<class AJackActionEffect>          ActionEffectClassForMonster;                       // 0x03D0(0x0008)(Edit, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, Protected, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackBowgunPropActor">();
	}
	static class AJackBowgunPropActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackBowgunPropActor>();
	}
};
static_assert(alignof(AJackBowgunPropActor) == 0x000008, "Wrong alignment on AJackBowgunPropActor");
static_assert(sizeof(AJackBowgunPropActor) == 0x0003D8, "Wrong size on AJackBowgunPropActor");
static_assert(offsetof(AJackBowgunPropActor, ActionEffectClassForMonster) == 0x0003D0, "Member 'AJackBowgunPropActor::ActionEffectClassForMonster' has a wrong offset!");

// Class JackGame.JackWeaponSM
// 0x0008 (0x03E8 - 0x03E0)
class AJackWeaponSM : public AJackWeaponBase
{
public:
	class UStaticMeshComponent*                   WeaponMeshComp;                                    // 0x03E0(0x0008)(Edit, ExportObject, ZeroConstructor, DisableEditOnInstance, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class UStaticMeshComponent* GetWeaponMeshComponent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeaponSM">();
	}
	static class AJackWeaponSM* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWeaponSM>();
	}
};
static_assert(alignof(AJackWeaponSM) == 0x000008, "Wrong alignment on AJackWeaponSM");
static_assert(sizeof(AJackWeaponSM) == 0x0003E8, "Wrong size on AJackWeaponSM");
static_assert(offsetof(AJackWeaponSM, WeaponMeshComp) == 0x0003E0, "Member 'AJackWeaponSM::WeaponMeshComp' has a wrong offset!");

// Class JackGame.JackWeatherTrack
// 0x0010 (0x00C0 - 0x00B0)
class UJackWeatherTrack final : public UInterpTrackFloatBase
{
public:
	class FName                                   VolumeID;                                          // 0x00B0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSetDefaultWeather;                                // 0x00B8(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B9[0x7];                                       // 0x00B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeatherTrack">();
	}
	static class UJackWeatherTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWeatherTrack>();
	}
};
static_assert(alignof(UJackWeatherTrack) == 0x000008, "Wrong alignment on UJackWeatherTrack");
static_assert(sizeof(UJackWeatherTrack) == 0x0000C0, "Wrong size on UJackWeatherTrack");
static_assert(offsetof(UJackWeatherTrack, VolumeID) == 0x0000B0, "Member 'UJackWeatherTrack::VolumeID' has a wrong offset!");
static_assert(offsetof(UJackWeatherTrack, bSetDefaultWeather) == 0x0000B8, "Member 'UJackWeatherTrack::bSetDefaultWeather' has a wrong offset!");

// Class JackGame.JackWeatherTrackInst
// 0x0008 (0x0040 - 0x0038)
class UJackWeatherTrackInst final : public UInterpTrackInst
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWeatherTrackInst">();
	}
	static class UJackWeatherTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWeatherTrackInst>();
	}
};
static_assert(alignof(UJackWeatherTrackInst) == 0x000008, "Wrong alignment on UJackWeatherTrackInst");
static_assert(sizeof(UJackWeatherTrackInst) == 0x000040, "Wrong size on UJackWeatherTrackInst");

// Class JackGame.JackWindApplyRateTrack
// 0x0000 (0x00B0 - 0x00B0)
class UJackWindApplyRateTrack final : public UInterpTrackFloatBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWindApplyRateTrack">();
	}
	static class UJackWindApplyRateTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWindApplyRateTrack>();
	}
};
static_assert(alignof(UJackWindApplyRateTrack) == 0x000008, "Wrong alignment on UJackWindApplyRateTrack");
static_assert(sizeof(UJackWindApplyRateTrack) == 0x0000B0, "Wrong size on UJackWindApplyRateTrack");

// Class JackGame.JackWindApplyRateTrackInst
// 0x0000 (0x0038 - 0x0038)
class UJackWindApplyRateTrackInst final : public UInterpTrackInst
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWindApplyRateTrackInst">();
	}
	static class UJackWindApplyRateTrackInst* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWindApplyRateTrackInst>();
	}
};
static_assert(alignof(UJackWindApplyRateTrackInst) == 0x000008, "Wrong alignment on UJackWindApplyRateTrackInst");
static_assert(sizeof(UJackWindApplyRateTrackInst) == 0x000038, "Wrong size on UJackWindApplyRateTrackInst");

// Class JackGame.JackWorldWeather
// 0x00A0 (0x00D8 - 0x0038)
class UJackWorldWeather : public UObject
{
public:
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	EJackWorldWeather                             DefaultWeather;                                    // 0x0048(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EJackWorldWindLevel                           DefaultWindLevel;                                  // 0x0049(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DefaultWindAngle;                                  // 0x004C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultWindAngleChangeMinute;                      // 0x0050(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FJackCorrectWeatherForWeatherReport> CorrectWeatherForWeatherReportTable;               // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x70];                                      // 0x0068(0x0070)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ChangeOfDateCallback();
	void ForceSetTodayPatternNo(class FName WeatherVolumeID, int32 Pattern, bool bSetDefaultWeather);
	EJackWorldWeather GetNextChangeWeather(class FName WeatherVolumeID, EJackTimeZone* OutTimeZone, bool* bOutTomorrow);
	EJackWorldWeather GetNowWeather(class FName WeatherVolumeID);
	float GetNowWindAngle(class FName WeatherVolumeID);
	int32 GetNowWindAngleChangeMinute(class FName WeatherVolumeID);
	EJackWorldWindLevel GetNowWindLevel(class FName WeatherVolumeID);
	EJackWorldWeather GetPatternWeather(class FName WeatherVolumeID, int32 Pattern, EJackTimeZone Timezone);
	float GetPatternWindAngle(class FName WeatherVolumeID, int32 Pattern, EJackTimeZone Timezone);
	int32 GetPatternWindAngleChangeMinute(class FName WeatherVolumeID, int32 Pattern, EJackTimeZone Timezone);
	EJackWorldWindLevel GetPatternWindLevel(class FName WeatherVolumeID, int32 Pattern, EJackTimeZone Timezone);
	EJackWorldWeather GetTomorrowWeather(class FName WeatherVolumeID, EJackTimeZone Timezone);
	float GetTomorrowWindAngle(class FName WeatherVolumeID, EJackTimeZone Timezone);
	EJackWorldWindLevel GetTomorrowWindLevel(class FName WeatherVolumeID, EJackTimeZone Timezone);
	void OnTokugiWeatherReport();
	void WeatherReportMessage(class UObject* WorldContextObject, const struct FLatentActionInfo& LatentInfo, class FName PreTextID, class FName MainTextID, const TArray<struct FJackMessageArgumentData>& TagValueList);
	void WorldWeatherChangeEnd();
	void WorldWeatherChangeStart(EJackWorldWeather InOldWorldWeather, EJackWorldWeather InNewWorldWeather);
	void WorldWindAngleChangeEnd();
	void WorldWindAngleChangeStart(float OldWindAngle, float NewWindAngle);
	void WorldWindLevelChangeEnd();
	void WorldWindLevelChangeStart(EJackWorldWindLevel OldWorldWindLevel, EJackWorldWindLevel NewWorldWindLevel);

	EJackWorldWeather CorrectWeatherForWeatherReport(EJackWorldWeather Weather) const;
	int32 GetTodayPatternNo(class FName WeatherVolumeID) const;
	int32 GetTomorrowPatternNo(class FName WeatherVolumeID) const;
	bool IsReadyWeatherVolume(class FName WeatherVolumeID) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWorldWeather">();
	}
	static class UJackWorldWeather* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackWorldWeather>();
	}
};
static_assert(alignof(UJackWorldWeather) == 0x000008, "Wrong alignment on UJackWorldWeather");
static_assert(sizeof(UJackWorldWeather) == 0x0000D8, "Wrong size on UJackWorldWeather");
static_assert(offsetof(UJackWorldWeather, DefaultWeather) == 0x000048, "Member 'UJackWorldWeather::DefaultWeather' has a wrong offset!");
static_assert(offsetof(UJackWorldWeather, DefaultWindLevel) == 0x000049, "Member 'UJackWorldWeather::DefaultWindLevel' has a wrong offset!");
static_assert(offsetof(UJackWorldWeather, DefaultWindAngle) == 0x00004C, "Member 'UJackWorldWeather::DefaultWindAngle' has a wrong offset!");
static_assert(offsetof(UJackWorldWeather, DefaultWindAngleChangeMinute) == 0x000050, "Member 'UJackWorldWeather::DefaultWindAngleChangeMinute' has a wrong offset!");
static_assert(offsetof(UJackWorldWeather, CorrectWeatherForWeatherReportTable) == 0x000058, "Member 'UJackWorldWeather::CorrectWeatherForWeatherReportTable' has a wrong offset!");

// Class JackGame.JackWorldWeatherVolume
// 0x0018 (0x03E8 - 0x03D0)
class AJackWorldWeatherVolume : public AVolume
{
public:
	uint8                                         Pad_3D0[0x10];                                     // 0x03D0(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   WeatherVolumeID;                                   // 0x03E0(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWorldWeatherVolume">();
	}
	static class AJackWorldWeatherVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWorldWeatherVolume>();
	}
};
static_assert(alignof(AJackWorldWeatherVolume) == 0x000008, "Wrong alignment on AJackWorldWeatherVolume");
static_assert(sizeof(AJackWorldWeatherVolume) == 0x0003E8, "Wrong size on AJackWorldWeatherVolume");
static_assert(offsetof(AJackWorldWeatherVolume, WeatherVolumeID) == 0x0003E0, "Member 'AJackWorldWeatherVolume::WeatherVolumeID' has a wrong offset!");

// Class JackGame.JackWorldWeatherWindOverrideVolume
// 0x0018 (0x03E8 - 0x03D0)
class AJackWorldWeatherWindOverrideVolume final : public AVolume
{
public:
	uint8                                         Pad_3D0[0x8];                                      // 0x03D0(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	EJackWorldWindLevel                           WindLevel;                                         // 0x03D8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         WindAngle;                                         // 0x03DC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WindAngleChangeMinute;                             // 0x03E0(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackWorldWeatherWindOverrideVolume">();
	}
	static class AJackWorldWeatherWindOverrideVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AJackWorldWeatherWindOverrideVolume>();
	}
};
static_assert(alignof(AJackWorldWeatherWindOverrideVolume) == 0x000008, "Wrong alignment on AJackWorldWeatherWindOverrideVolume");
static_assert(sizeof(AJackWorldWeatherWindOverrideVolume) == 0x0003E8, "Wrong size on AJackWorldWeatherWindOverrideVolume");
static_assert(offsetof(AJackWorldWeatherWindOverrideVolume, WindLevel) == 0x0003D8, "Member 'AJackWorldWeatherWindOverrideVolume::WindLevel' has a wrong offset!");
static_assert(offsetof(AJackWorldWeatherWindOverrideVolume, WindAngle) == 0x0003DC, "Member 'AJackWorldWeatherWindOverrideVolume::WindAngle' has a wrong offset!");
static_assert(offsetof(AJackWorldWeatherWindOverrideVolume, WindAngleChangeMinute) == 0x0003E0, "Member 'AJackWorldWeatherWindOverrideVolume::WindAngleChangeMinute' has a wrong offset!");

// Class JackGame.JackZonePointControl
// 0x0008 (0x0040 - 0x0038)
class UJackZonePointControl final : public UObject
{
public:
	float                                         ZonePoint;                                         // 0x0038(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"JackZonePointControl">();
	}
	static class UJackZonePointControl* GetDefaultObj()
	{
		return GetDefaultObjImpl<UJackZonePointControl>();
	}
};
static_assert(alignof(UJackZonePointControl) == 0x000008, "Wrong alignment on UJackZonePointControl");
static_assert(sizeof(UJackZonePointControl) == 0x000040, "Wrong size on UJackZonePointControl");
static_assert(offsetof(UJackZonePointControl, ZonePoint) == 0x000038, "Member 'UJackZonePointControl::ZonePoint' has a wrong offset!");

}

