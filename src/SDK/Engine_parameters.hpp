#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: Engine

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "InputCore_structs.hpp"
#include "Slate_structs.hpp"
#include "SlateCore_structs.hpp"


namespace SDK::Params
{

// Function Engine.Actor.AddComponent
// 0x0050 (0x0050 - 0x0000)
struct Actor_AddComponent final
{
public:
	class FName                                   TemplateName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bManualAttachment;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RelativeTransform;                                 // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	const class UObject*                          ComponentTemplateContext;                          // 0x0040(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_AddComponent) == 0x000010, "Wrong alignment on Actor_AddComponent");
static_assert(sizeof(Actor_AddComponent) == 0x000050, "Wrong size on Actor_AddComponent");
static_assert(offsetof(Actor_AddComponent, TemplateName) == 0x000000, "Member 'Actor_AddComponent::TemplateName' has a wrong offset!");
static_assert(offsetof(Actor_AddComponent, bManualAttachment) == 0x000008, "Member 'Actor_AddComponent::bManualAttachment' has a wrong offset!");
static_assert(offsetof(Actor_AddComponent, RelativeTransform) == 0x000010, "Member 'Actor_AddComponent::RelativeTransform' has a wrong offset!");
static_assert(offsetof(Actor_AddComponent, ComponentTemplateContext) == 0x000040, "Member 'Actor_AddComponent::ComponentTemplateContext' has a wrong offset!");
static_assert(offsetof(Actor_AddComponent, ReturnValue) == 0x000048, "Member 'Actor_AddComponent::ReturnValue' has a wrong offset!");

// Function Engine.Actor.AddTickPrerequisiteActor
// 0x0008 (0x0008 - 0x0000)
struct Actor_AddTickPrerequisiteActor final
{
public:
	class AActor*                                 PrerequisiteActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_AddTickPrerequisiteActor) == 0x000008, "Wrong alignment on Actor_AddTickPrerequisiteActor");
static_assert(sizeof(Actor_AddTickPrerequisiteActor) == 0x000008, "Wrong size on Actor_AddTickPrerequisiteActor");
static_assert(offsetof(Actor_AddTickPrerequisiteActor, PrerequisiteActor) == 0x000000, "Member 'Actor_AddTickPrerequisiteActor::PrerequisiteActor' has a wrong offset!");

// Function Engine.Actor.AddTickPrerequisiteComponent
// 0x0008 (0x0008 - 0x0000)
struct Actor_AddTickPrerequisiteComponent final
{
public:
	class UActorComponent*                        PrerequisiteComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_AddTickPrerequisiteComponent) == 0x000008, "Wrong alignment on Actor_AddTickPrerequisiteComponent");
static_assert(sizeof(Actor_AddTickPrerequisiteComponent) == 0x000008, "Wrong size on Actor_AddTickPrerequisiteComponent");
static_assert(offsetof(Actor_AddTickPrerequisiteComponent, PrerequisiteComponent) == 0x000000, "Member 'Actor_AddTickPrerequisiteComponent::PrerequisiteComponent' has a wrong offset!");

// Function Engine.Actor.DetachRootComponentFromParent
// 0x0001 (0x0001 - 0x0000)
struct Actor_DetachRootComponentFromParent final
{
public:
	bool                                          bMaintainWorldPosition;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_DetachRootComponentFromParent) == 0x000001, "Wrong alignment on Actor_DetachRootComponentFromParent");
static_assert(sizeof(Actor_DetachRootComponentFromParent) == 0x000001, "Wrong size on Actor_DetachRootComponentFromParent");
static_assert(offsetof(Actor_DetachRootComponentFromParent, bMaintainWorldPosition) == 0x000000, "Member 'Actor_DetachRootComponentFromParent::bMaintainWorldPosition' has a wrong offset!");

// Function Engine.Actor.DisableInput
// 0x0008 (0x0008 - 0x0000)
struct Actor_DisableInput final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_DisableInput) == 0x000008, "Wrong alignment on Actor_DisableInput");
static_assert(sizeof(Actor_DisableInput) == 0x000008, "Wrong size on Actor_DisableInput");
static_assert(offsetof(Actor_DisableInput, PlayerController) == 0x000000, "Member 'Actor_DisableInput::PlayerController' has a wrong offset!");

// Function Engine.Actor.EnableInput
// 0x0008 (0x0008 - 0x0000)
struct Actor_EnableInput final
{
public:
	class APlayerController*                      PlayerController;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_EnableInput) == 0x000008, "Wrong alignment on Actor_EnableInput");
static_assert(sizeof(Actor_EnableInput) == 0x000008, "Wrong size on Actor_EnableInput");
static_assert(offsetof(Actor_EnableInput, PlayerController) == 0x000000, "Member 'Actor_EnableInput::PlayerController' has a wrong offset!");

// Function Engine.Actor.GetGameTimeSinceCreation
// 0x0004 (0x0004 - 0x0000)
struct Actor_GetGameTimeSinceCreation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetGameTimeSinceCreation) == 0x000004, "Wrong alignment on Actor_GetGameTimeSinceCreation");
static_assert(sizeof(Actor_GetGameTimeSinceCreation) == 0x000004, "Wrong size on Actor_GetGameTimeSinceCreation");
static_assert(offsetof(Actor_GetGameTimeSinceCreation, ReturnValue) == 0x000000, "Member 'Actor_GetGameTimeSinceCreation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetTickableWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct Actor_GetTickableWhenPaused final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetTickableWhenPaused) == 0x000001, "Wrong alignment on Actor_GetTickableWhenPaused");
static_assert(sizeof(Actor_GetTickableWhenPaused) == 0x000001, "Wrong size on Actor_GetTickableWhenPaused");
static_assert(offsetof(Actor_GetTickableWhenPaused, ReturnValue) == 0x000000, "Member 'Actor_GetTickableWhenPaused::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_AddActorLocalOffset
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_AddActorLocalOffset final
{
public:
	struct FVector                                DeltaLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorLocalOffset) == 0x000008, "Wrong alignment on Actor_K2_AddActorLocalOffset");
static_assert(sizeof(Actor_K2_AddActorLocalOffset) == 0x0000A0, "Wrong size on Actor_K2_AddActorLocalOffset");
static_assert(offsetof(Actor_K2_AddActorLocalOffset, DeltaLocation) == 0x000000, "Member 'Actor_K2_AddActorLocalOffset::DeltaLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalOffset, bSweep) == 0x00000C, "Member 'Actor_K2_AddActorLocalOffset::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalOffset, SweepHitResult) == 0x000010, "Member 'Actor_K2_AddActorLocalOffset::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalOffset, bTeleport) == 0x000098, "Member 'Actor_K2_AddActorLocalOffset::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AddActorLocalRotation
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_AddActorLocalRotation final
{
public:
	struct FRotator                               DeltaRotation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorLocalRotation) == 0x000008, "Wrong alignment on Actor_K2_AddActorLocalRotation");
static_assert(sizeof(Actor_K2_AddActorLocalRotation) == 0x0000A0, "Wrong size on Actor_K2_AddActorLocalRotation");
static_assert(offsetof(Actor_K2_AddActorLocalRotation, DeltaRotation) == 0x000000, "Member 'Actor_K2_AddActorLocalRotation::DeltaRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalRotation, bSweep) == 0x00000C, "Member 'Actor_K2_AddActorLocalRotation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalRotation, SweepHitResult) == 0x000010, "Member 'Actor_K2_AddActorLocalRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalRotation, bTeleport) == 0x000098, "Member 'Actor_K2_AddActorLocalRotation::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AddActorLocalTransform
// 0x00D0 (0x00D0 - 0x0000)
struct Actor_K2_AddActorLocalTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorLocalTransform) == 0x000010, "Wrong alignment on Actor_K2_AddActorLocalTransform");
static_assert(sizeof(Actor_K2_AddActorLocalTransform) == 0x0000D0, "Wrong size on Actor_K2_AddActorLocalTransform");
static_assert(offsetof(Actor_K2_AddActorLocalTransform, NewTransform) == 0x000000, "Member 'Actor_K2_AddActorLocalTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalTransform, bSweep) == 0x000030, "Member 'Actor_K2_AddActorLocalTransform::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalTransform, SweepHitResult) == 0x000038, "Member 'Actor_K2_AddActorLocalTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorLocalTransform, bTeleport) == 0x0000C0, "Member 'Actor_K2_AddActorLocalTransform::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AddActorWorldOffset
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_AddActorWorldOffset final
{
public:
	struct FVector                                DeltaLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorWorldOffset) == 0x000008, "Wrong alignment on Actor_K2_AddActorWorldOffset");
static_assert(sizeof(Actor_K2_AddActorWorldOffset) == 0x0000A0, "Wrong size on Actor_K2_AddActorWorldOffset");
static_assert(offsetof(Actor_K2_AddActorWorldOffset, DeltaLocation) == 0x000000, "Member 'Actor_K2_AddActorWorldOffset::DeltaLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldOffset, bSweep) == 0x00000C, "Member 'Actor_K2_AddActorWorldOffset::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldOffset, SweepHitResult) == 0x000010, "Member 'Actor_K2_AddActorWorldOffset::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldOffset, bTeleport) == 0x000098, "Member 'Actor_K2_AddActorWorldOffset::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AddActorWorldRotation
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_AddActorWorldRotation final
{
public:
	struct FRotator                               DeltaRotation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorWorldRotation) == 0x000008, "Wrong alignment on Actor_K2_AddActorWorldRotation");
static_assert(sizeof(Actor_K2_AddActorWorldRotation) == 0x0000A0, "Wrong size on Actor_K2_AddActorWorldRotation");
static_assert(offsetof(Actor_K2_AddActorWorldRotation, DeltaRotation) == 0x000000, "Member 'Actor_K2_AddActorWorldRotation::DeltaRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldRotation, bSweep) == 0x00000C, "Member 'Actor_K2_AddActorWorldRotation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldRotation, SweepHitResult) == 0x000010, "Member 'Actor_K2_AddActorWorldRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldRotation, bTeleport) == 0x000098, "Member 'Actor_K2_AddActorWorldRotation::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AddActorWorldTransform
// 0x00D0 (0x00D0 - 0x0000)
struct Actor_K2_AddActorWorldTransform final
{
public:
	struct FTransform                             DeltaTransform;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AddActorWorldTransform) == 0x000010, "Wrong alignment on Actor_K2_AddActorWorldTransform");
static_assert(sizeof(Actor_K2_AddActorWorldTransform) == 0x0000D0, "Wrong size on Actor_K2_AddActorWorldTransform");
static_assert(offsetof(Actor_K2_AddActorWorldTransform, DeltaTransform) == 0x000000, "Member 'Actor_K2_AddActorWorldTransform::DeltaTransform' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldTransform, bSweep) == 0x000030, "Member 'Actor_K2_AddActorWorldTransform::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldTransform, SweepHitResult) == 0x000038, "Member 'Actor_K2_AddActorWorldTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_AddActorWorldTransform, bTeleport) == 0x0000C0, "Member 'Actor_K2_AddActorWorldTransform::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_AttachRootComponentTo
// 0x0018 (0x0018 - 0x0000)
struct Actor_K2_AttachRootComponentTo final
{
public:
	class USceneComponent*                        InParent;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachLocationType;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AttachRootComponentTo) == 0x000008, "Wrong alignment on Actor_K2_AttachRootComponentTo");
static_assert(sizeof(Actor_K2_AttachRootComponentTo) == 0x000018, "Wrong size on Actor_K2_AttachRootComponentTo");
static_assert(offsetof(Actor_K2_AttachRootComponentTo, InParent) == 0x000000, "Member 'Actor_K2_AttachRootComponentTo::InParent' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentTo, InSocketName) == 0x000008, "Member 'Actor_K2_AttachRootComponentTo::InSocketName' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentTo, AttachLocationType) == 0x000010, "Member 'Actor_K2_AttachRootComponentTo::AttachLocationType' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentTo, bWeldSimulatedBodies) == 0x000011, "Member 'Actor_K2_AttachRootComponentTo::bWeldSimulatedBodies' has a wrong offset!");

// Function Engine.Actor.K2_AttachRootComponentToActor
// 0x0018 (0x0018 - 0x0000)
struct Actor_K2_AttachRootComponentToActor final
{
public:
	class AActor*                                 InParentActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachLocationType;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AttachRootComponentToActor) == 0x000008, "Wrong alignment on Actor_K2_AttachRootComponentToActor");
static_assert(sizeof(Actor_K2_AttachRootComponentToActor) == 0x000018, "Wrong size on Actor_K2_AttachRootComponentToActor");
static_assert(offsetof(Actor_K2_AttachRootComponentToActor, InParentActor) == 0x000000, "Member 'Actor_K2_AttachRootComponentToActor::InParentActor' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentToActor, InSocketName) == 0x000008, "Member 'Actor_K2_AttachRootComponentToActor::InSocketName' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentToActor, AttachLocationType) == 0x000010, "Member 'Actor_K2_AttachRootComponentToActor::AttachLocationType' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachRootComponentToActor, bWeldSimulatedBodies) == 0x000011, "Member 'Actor_K2_AttachRootComponentToActor::bWeldSimulatedBodies' has a wrong offset!");

// Function Engine.Actor.K2_AttachToActor
// 0x0018 (0x0018 - 0x0000)
struct Actor_K2_AttachToActor final
{
public:
	class AActor*                                 ParentActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AttachToActor) == 0x000008, "Wrong alignment on Actor_K2_AttachToActor");
static_assert(sizeof(Actor_K2_AttachToActor) == 0x000018, "Wrong size on Actor_K2_AttachToActor");
static_assert(offsetof(Actor_K2_AttachToActor, ParentActor) == 0x000000, "Member 'Actor_K2_AttachToActor::ParentActor' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToActor, SocketName) == 0x000008, "Member 'Actor_K2_AttachToActor::SocketName' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToActor, LocationRule) == 0x000010, "Member 'Actor_K2_AttachToActor::LocationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToActor, RotationRule) == 0x000011, "Member 'Actor_K2_AttachToActor::RotationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToActor, ScaleRule) == 0x000012, "Member 'Actor_K2_AttachToActor::ScaleRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToActor, bWeldSimulatedBodies) == 0x000013, "Member 'Actor_K2_AttachToActor::bWeldSimulatedBodies' has a wrong offset!");

// Function Engine.Actor.K2_AttachToComponent
// 0x0018 (0x0018 - 0x0000)
struct Actor_K2_AttachToComponent final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_AttachToComponent) == 0x000008, "Wrong alignment on Actor_K2_AttachToComponent");
static_assert(sizeof(Actor_K2_AttachToComponent) == 0x000018, "Wrong size on Actor_K2_AttachToComponent");
static_assert(offsetof(Actor_K2_AttachToComponent, Parent) == 0x000000, "Member 'Actor_K2_AttachToComponent::Parent' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToComponent, SocketName) == 0x000008, "Member 'Actor_K2_AttachToComponent::SocketName' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToComponent, LocationRule) == 0x000010, "Member 'Actor_K2_AttachToComponent::LocationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToComponent, RotationRule) == 0x000011, "Member 'Actor_K2_AttachToComponent::RotationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToComponent, ScaleRule) == 0x000012, "Member 'Actor_K2_AttachToComponent::ScaleRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_AttachToComponent, bWeldSimulatedBodies) == 0x000013, "Member 'Actor_K2_AttachToComponent::bWeldSimulatedBodies' has a wrong offset!");

// Function Engine.Actor.K2_DestroyComponent
// 0x0008 (0x0008 - 0x0000)
struct Actor_K2_DestroyComponent final
{
public:
	class UActorComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_DestroyComponent) == 0x000008, "Wrong alignment on Actor_K2_DestroyComponent");
static_assert(sizeof(Actor_K2_DestroyComponent) == 0x000008, "Wrong size on Actor_K2_DestroyComponent");
static_assert(offsetof(Actor_K2_DestroyComponent, Component) == 0x000000, "Member 'Actor_K2_DestroyComponent::Component' has a wrong offset!");

// Function Engine.Actor.K2_DetachFromActor
// 0x0003 (0x0003 - 0x0000)
struct Actor_K2_DetachFromActor final
{
public:
	EDetachmentRule                               LocationRule;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               RotationRule;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               ScaleRule;                                         // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_DetachFromActor) == 0x000001, "Wrong alignment on Actor_K2_DetachFromActor");
static_assert(sizeof(Actor_K2_DetachFromActor) == 0x000003, "Wrong size on Actor_K2_DetachFromActor");
static_assert(offsetof(Actor_K2_DetachFromActor, LocationRule) == 0x000000, "Member 'Actor_K2_DetachFromActor::LocationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_DetachFromActor, RotationRule) == 0x000001, "Member 'Actor_K2_DetachFromActor::RotationRule' has a wrong offset!");
static_assert(offsetof(Actor_K2_DetachFromActor, ScaleRule) == 0x000002, "Member 'Actor_K2_DetachFromActor::ScaleRule' has a wrong offset!");

// Function Engine.Actor.K2_OnBecomeViewTarget
// 0x0008 (0x0008 - 0x0000)
struct Actor_K2_OnBecomeViewTarget final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_OnBecomeViewTarget) == 0x000008, "Wrong alignment on Actor_K2_OnBecomeViewTarget");
static_assert(sizeof(Actor_K2_OnBecomeViewTarget) == 0x000008, "Wrong size on Actor_K2_OnBecomeViewTarget");
static_assert(offsetof(Actor_K2_OnBecomeViewTarget, PC) == 0x000000, "Member 'Actor_K2_OnBecomeViewTarget::PC' has a wrong offset!");

// Function Engine.Actor.K2_OnEndViewTarget
// 0x0008 (0x0008 - 0x0000)
struct Actor_K2_OnEndViewTarget final
{
public:
	class APlayerController*                      PC;                                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_OnEndViewTarget) == 0x000008, "Wrong alignment on Actor_K2_OnEndViewTarget");
static_assert(sizeof(Actor_K2_OnEndViewTarget) == 0x000008, "Wrong size on Actor_K2_OnEndViewTarget");
static_assert(offsetof(Actor_K2_OnEndViewTarget, PC) == 0x000000, "Member 'Actor_K2_OnEndViewTarget::PC' has a wrong offset!");

// Function Engine.Actor.K2_SetActorLocation
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_SetActorLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0099(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9A[0x6];                                       // 0x009A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorLocation) == 0x000008, "Wrong alignment on Actor_K2_SetActorLocation");
static_assert(sizeof(Actor_K2_SetActorLocation) == 0x0000A0, "Wrong size on Actor_K2_SetActorLocation");
static_assert(offsetof(Actor_K2_SetActorLocation, NewLocation) == 0x000000, "Member 'Actor_K2_SetActorLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocation, bSweep) == 0x00000C, "Member 'Actor_K2_SetActorLocation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocation, SweepHitResult) == 0x000010, "Member 'Actor_K2_SetActorLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocation, bTeleport) == 0x000098, "Member 'Actor_K2_SetActorLocation::bTeleport' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocation, ReturnValue) == 0x000099, "Member 'Actor_K2_SetActorLocation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_SetActorLocationAndRotation
// 0x00B0 (0x00B0 - 0x0000)
struct Actor_K2_SetActorLocationAndRotation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0020(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A9(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_AA[0x6];                                       // 0x00AA(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorLocationAndRotation) == 0x000008, "Wrong alignment on Actor_K2_SetActorLocationAndRotation");
static_assert(sizeof(Actor_K2_SetActorLocationAndRotation) == 0x0000B0, "Wrong size on Actor_K2_SetActorLocationAndRotation");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, NewLocation) == 0x000000, "Member 'Actor_K2_SetActorLocationAndRotation::NewLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, NewRotation) == 0x00000C, "Member 'Actor_K2_SetActorLocationAndRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, bSweep) == 0x000018, "Member 'Actor_K2_SetActorLocationAndRotation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, SweepHitResult) == 0x000020, "Member 'Actor_K2_SetActorLocationAndRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, bTeleport) == 0x0000A8, "Member 'Actor_K2_SetActorLocationAndRotation::bTeleport' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorLocationAndRotation, ReturnValue) == 0x0000A9, "Member 'Actor_K2_SetActorLocationAndRotation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_SetActorRelativeLocation
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_SetActorRelativeLocation final
{
public:
	struct FVector                                NewRelativeLocation;                               // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorRelativeLocation) == 0x000008, "Wrong alignment on Actor_K2_SetActorRelativeLocation");
static_assert(sizeof(Actor_K2_SetActorRelativeLocation) == 0x0000A0, "Wrong size on Actor_K2_SetActorRelativeLocation");
static_assert(offsetof(Actor_K2_SetActorRelativeLocation, NewRelativeLocation) == 0x000000, "Member 'Actor_K2_SetActorRelativeLocation::NewRelativeLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeLocation, bSweep) == 0x00000C, "Member 'Actor_K2_SetActorRelativeLocation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeLocation, SweepHitResult) == 0x000010, "Member 'Actor_K2_SetActorRelativeLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeLocation, bTeleport) == 0x000098, "Member 'Actor_K2_SetActorRelativeLocation::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_SetActorRelativeRotation
// 0x00A0 (0x00A0 - 0x0000)
struct Actor_K2_SetActorRelativeRotation final
{
public:
	struct FRotator                               NewRelativeRotation;                               // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorRelativeRotation) == 0x000008, "Wrong alignment on Actor_K2_SetActorRelativeRotation");
static_assert(sizeof(Actor_K2_SetActorRelativeRotation) == 0x0000A0, "Wrong size on Actor_K2_SetActorRelativeRotation");
static_assert(offsetof(Actor_K2_SetActorRelativeRotation, NewRelativeRotation) == 0x000000, "Member 'Actor_K2_SetActorRelativeRotation::NewRelativeRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeRotation, bSweep) == 0x00000C, "Member 'Actor_K2_SetActorRelativeRotation::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeRotation, SweepHitResult) == 0x000010, "Member 'Actor_K2_SetActorRelativeRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeRotation, bTeleport) == 0x000098, "Member 'Actor_K2_SetActorRelativeRotation::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_SetActorRelativeTransform
// 0x00D0 (0x00D0 - 0x0000)
struct Actor_K2_SetActorRelativeTransform final
{
public:
	struct FTransform                             NewRelativeTransform;                              // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorRelativeTransform) == 0x000010, "Wrong alignment on Actor_K2_SetActorRelativeTransform");
static_assert(sizeof(Actor_K2_SetActorRelativeTransform) == 0x0000D0, "Wrong size on Actor_K2_SetActorRelativeTransform");
static_assert(offsetof(Actor_K2_SetActorRelativeTransform, NewRelativeTransform) == 0x000000, "Member 'Actor_K2_SetActorRelativeTransform::NewRelativeTransform' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeTransform, bSweep) == 0x000030, "Member 'Actor_K2_SetActorRelativeTransform::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeTransform, SweepHitResult) == 0x000038, "Member 'Actor_K2_SetActorRelativeTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRelativeTransform, bTeleport) == 0x0000C0, "Member 'Actor_K2_SetActorRelativeTransform::bTeleport' has a wrong offset!");

// Function Engine.Actor.K2_SetActorRotation
// 0x0010 (0x0010 - 0x0000)
struct Actor_K2_SetActorRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bTeleportPhysics;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorRotation) == 0x000004, "Wrong alignment on Actor_K2_SetActorRotation");
static_assert(sizeof(Actor_K2_SetActorRotation) == 0x000010, "Wrong size on Actor_K2_SetActorRotation");
static_assert(offsetof(Actor_K2_SetActorRotation, NewRotation) == 0x000000, "Member 'Actor_K2_SetActorRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRotation, bTeleportPhysics) == 0x00000C, "Member 'Actor_K2_SetActorRotation::bTeleportPhysics' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorRotation, ReturnValue) == 0x00000D, "Member 'Actor_K2_SetActorRotation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_SetActorTransform
// 0x00D0 (0x00D0 - 0x0000)
struct Actor_K2_SetActorTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C1(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C2[0xE];                                       // 0x00C2(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_SetActorTransform) == 0x000010, "Wrong alignment on Actor_K2_SetActorTransform");
static_assert(sizeof(Actor_K2_SetActorTransform) == 0x0000D0, "Wrong size on Actor_K2_SetActorTransform");
static_assert(offsetof(Actor_K2_SetActorTransform, NewTransform) == 0x000000, "Member 'Actor_K2_SetActorTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorTransform, bSweep) == 0x000030, "Member 'Actor_K2_SetActorTransform::bSweep' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorTransform, SweepHitResult) == 0x000038, "Member 'Actor_K2_SetActorTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorTransform, bTeleport) == 0x0000C0, "Member 'Actor_K2_SetActorTransform::bTeleport' has a wrong offset!");
static_assert(offsetof(Actor_K2_SetActorTransform, ReturnValue) == 0x0000C1, "Member 'Actor_K2_SetActorTransform::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_TeleportTo
// 0x001C (0x001C - 0x0000)
struct Actor_K2_TeleportTo final
{
public:
	struct FVector                                DestLocation;                                      // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               DestRotation;                                      // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_K2_TeleportTo) == 0x000004, "Wrong alignment on Actor_K2_TeleportTo");
static_assert(sizeof(Actor_K2_TeleportTo) == 0x00001C, "Wrong size on Actor_K2_TeleportTo");
static_assert(offsetof(Actor_K2_TeleportTo, DestLocation) == 0x000000, "Member 'Actor_K2_TeleportTo::DestLocation' has a wrong offset!");
static_assert(offsetof(Actor_K2_TeleportTo, DestRotation) == 0x00000C, "Member 'Actor_K2_TeleportTo::DestRotation' has a wrong offset!");
static_assert(offsetof(Actor_K2_TeleportTo, ReturnValue) == 0x000018, "Member 'Actor_K2_TeleportTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.MakeMIDForMaterial
// 0x0010 (0x0010 - 0x0000)
struct Actor_MakeMIDForMaterial final
{
public:
	class UMaterialInterface*                     Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_MakeMIDForMaterial) == 0x000008, "Wrong alignment on Actor_MakeMIDForMaterial");
static_assert(sizeof(Actor_MakeMIDForMaterial) == 0x000010, "Wrong size on Actor_MakeMIDForMaterial");
static_assert(offsetof(Actor_MakeMIDForMaterial, Parent) == 0x000000, "Member 'Actor_MakeMIDForMaterial::Parent' has a wrong offset!");
static_assert(offsetof(Actor_MakeMIDForMaterial, ReturnValue) == 0x000008, "Member 'Actor_MakeMIDForMaterial::ReturnValue' has a wrong offset!");

// Function Engine.Actor.MakeNoise
// 0x0028 (0x0028 - 0x0000)
struct Actor_MakeNoise final
{
public:
	float                                         Loudness;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  NoiseInstigator;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NoiseLocation;                                     // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxRange;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_MakeNoise) == 0x000008, "Wrong alignment on Actor_MakeNoise");
static_assert(sizeof(Actor_MakeNoise) == 0x000028, "Wrong size on Actor_MakeNoise");
static_assert(offsetof(Actor_MakeNoise, Loudness) == 0x000000, "Member 'Actor_MakeNoise::Loudness' has a wrong offset!");
static_assert(offsetof(Actor_MakeNoise, NoiseInstigator) == 0x000008, "Member 'Actor_MakeNoise::NoiseInstigator' has a wrong offset!");
static_assert(offsetof(Actor_MakeNoise, NoiseLocation) == 0x000010, "Member 'Actor_MakeNoise::NoiseLocation' has a wrong offset!");
static_assert(offsetof(Actor_MakeNoise, MaxRange) == 0x00001C, "Member 'Actor_MakeNoise::MaxRange' has a wrong offset!");
static_assert(offsetof(Actor_MakeNoise, Tag) == 0x000020, "Member 'Actor_MakeNoise::Tag' has a wrong offset!");

// Function Engine.Actor.PrestreamTextures
// 0x000C (0x000C - 0x0000)
struct Actor_PrestreamTextures final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStreaming;                                  // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CinematicTextureGroups;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_PrestreamTextures) == 0x000004, "Wrong alignment on Actor_PrestreamTextures");
static_assert(sizeof(Actor_PrestreamTextures) == 0x00000C, "Wrong size on Actor_PrestreamTextures");
static_assert(offsetof(Actor_PrestreamTextures, Seconds) == 0x000000, "Member 'Actor_PrestreamTextures::Seconds' has a wrong offset!");
static_assert(offsetof(Actor_PrestreamTextures, bEnableStreaming) == 0x000004, "Member 'Actor_PrestreamTextures::bEnableStreaming' has a wrong offset!");
static_assert(offsetof(Actor_PrestreamTextures, CinematicTextureGroups) == 0x000008, "Member 'Actor_PrestreamTextures::CinematicTextureGroups' has a wrong offset!");

// Function Engine.Actor.ReceiveActorBeginOverlap
// 0x0008 (0x0008 - 0x0000)
struct Actor_ReceiveActorBeginOverlap final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorBeginOverlap) == 0x000008, "Wrong alignment on Actor_ReceiveActorBeginOverlap");
static_assert(sizeof(Actor_ReceiveActorBeginOverlap) == 0x000008, "Wrong size on Actor_ReceiveActorBeginOverlap");
static_assert(offsetof(Actor_ReceiveActorBeginOverlap, OtherActor) == 0x000000, "Member 'Actor_ReceiveActorBeginOverlap::OtherActor' has a wrong offset!");

// Function Engine.Actor.ReceiveActorEndOverlap
// 0x0008 (0x0008 - 0x0000)
struct Actor_ReceiveActorEndOverlap final
{
public:
	class AActor*                                 OtherActor;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorEndOverlap) == 0x000008, "Wrong alignment on Actor_ReceiveActorEndOverlap");
static_assert(sizeof(Actor_ReceiveActorEndOverlap) == 0x000008, "Wrong size on Actor_ReceiveActorEndOverlap");
static_assert(offsetof(Actor_ReceiveActorEndOverlap, OtherActor) == 0x000000, "Member 'Actor_ReceiveActorEndOverlap::OtherActor' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnClicked
// 0x0018 (0x0018 - 0x0000)
struct Actor_ReceiveActorOnClicked final
{
public:
	struct FKey                                   ButtonPressed;                                     // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnClicked) == 0x000008, "Wrong alignment on Actor_ReceiveActorOnClicked");
static_assert(sizeof(Actor_ReceiveActorOnClicked) == 0x000018, "Wrong size on Actor_ReceiveActorOnClicked");
static_assert(offsetof(Actor_ReceiveActorOnClicked, ButtonPressed) == 0x000000, "Member 'Actor_ReceiveActorOnClicked::ButtonPressed' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnInputTouchBegin
// 0x0001 (0x0001 - 0x0000)
struct Actor_ReceiveActorOnInputTouchBegin final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnInputTouchBegin) == 0x000001, "Wrong alignment on Actor_ReceiveActorOnInputTouchBegin");
static_assert(sizeof(Actor_ReceiveActorOnInputTouchBegin) == 0x000001, "Wrong size on Actor_ReceiveActorOnInputTouchBegin");
static_assert(offsetof(Actor_ReceiveActorOnInputTouchBegin, FingerIndex) == 0x000000, "Member 'Actor_ReceiveActorOnInputTouchBegin::FingerIndex' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnInputTouchEnd
// 0x0001 (0x0001 - 0x0000)
struct Actor_ReceiveActorOnInputTouchEnd final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnInputTouchEnd) == 0x000001, "Wrong alignment on Actor_ReceiveActorOnInputTouchEnd");
static_assert(sizeof(Actor_ReceiveActorOnInputTouchEnd) == 0x000001, "Wrong size on Actor_ReceiveActorOnInputTouchEnd");
static_assert(offsetof(Actor_ReceiveActorOnInputTouchEnd, FingerIndex) == 0x000000, "Member 'Actor_ReceiveActorOnInputTouchEnd::FingerIndex' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnInputTouchEnter
// 0x0001 (0x0001 - 0x0000)
struct Actor_ReceiveActorOnInputTouchEnter final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnInputTouchEnter) == 0x000001, "Wrong alignment on Actor_ReceiveActorOnInputTouchEnter");
static_assert(sizeof(Actor_ReceiveActorOnInputTouchEnter) == 0x000001, "Wrong size on Actor_ReceiveActorOnInputTouchEnter");
static_assert(offsetof(Actor_ReceiveActorOnInputTouchEnter, FingerIndex) == 0x000000, "Member 'Actor_ReceiveActorOnInputTouchEnter::FingerIndex' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnInputTouchLeave
// 0x0001 (0x0001 - 0x0000)
struct Actor_ReceiveActorOnInputTouchLeave final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnInputTouchLeave) == 0x000001, "Wrong alignment on Actor_ReceiveActorOnInputTouchLeave");
static_assert(sizeof(Actor_ReceiveActorOnInputTouchLeave) == 0x000001, "Wrong size on Actor_ReceiveActorOnInputTouchLeave");
static_assert(offsetof(Actor_ReceiveActorOnInputTouchLeave, FingerIndex) == 0x000000, "Member 'Actor_ReceiveActorOnInputTouchLeave::FingerIndex' has a wrong offset!");

// Function Engine.Actor.ReceiveActorOnReleased
// 0x0018 (0x0018 - 0x0000)
struct Actor_ReceiveActorOnReleased final
{
public:
	struct FKey                                   ButtonReleased;                                    // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveActorOnReleased) == 0x000008, "Wrong alignment on Actor_ReceiveActorOnReleased");
static_assert(sizeof(Actor_ReceiveActorOnReleased) == 0x000018, "Wrong size on Actor_ReceiveActorOnReleased");
static_assert(offsetof(Actor_ReceiveActorOnReleased, ButtonReleased) == 0x000000, "Member 'Actor_ReceiveActorOnReleased::ButtonReleased' has a wrong offset!");

// Function Engine.Actor.ReceiveAnyDamage
// 0x0020 (0x0020 - 0x0000)
struct Actor_ReceiveAnyDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveAnyDamage) == 0x000008, "Wrong alignment on Actor_ReceiveAnyDamage");
static_assert(sizeof(Actor_ReceiveAnyDamage) == 0x000020, "Wrong size on Actor_ReceiveAnyDamage");
static_assert(offsetof(Actor_ReceiveAnyDamage, Damage) == 0x000000, "Member 'Actor_ReceiveAnyDamage::Damage' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveAnyDamage, DamageType) == 0x000008, "Member 'Actor_ReceiveAnyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveAnyDamage, InstigatedBy) == 0x000010, "Member 'Actor_ReceiveAnyDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveAnyDamage, DamageCauser) == 0x000018, "Member 'Actor_ReceiveAnyDamage::DamageCauser' has a wrong offset!");

// Function Engine.Actor.ReceiveEndPlay
// 0x0001 (0x0001 - 0x0000)
struct Actor_ReceiveEndPlay final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveEndPlay) == 0x000001, "Wrong alignment on Actor_ReceiveEndPlay");
static_assert(sizeof(Actor_ReceiveEndPlay) == 0x000001, "Wrong size on Actor_ReceiveEndPlay");
static_assert(offsetof(Actor_ReceiveEndPlay, EndPlayReason) == 0x000000, "Member 'Actor_ReceiveEndPlay::EndPlayReason' has a wrong offset!");

// Function Engine.Actor.ReceiveHit
// 0x00C8 (0x00C8 - 0x0000)
struct Actor_ReceiveHit final
{
public:
	class UPrimitiveComponent*                    MyComp;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelfMoved;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NormalImpulse;                                     // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0040(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveHit) == 0x000008, "Wrong alignment on Actor_ReceiveHit");
static_assert(sizeof(Actor_ReceiveHit) == 0x0000C8, "Wrong size on Actor_ReceiveHit");
static_assert(offsetof(Actor_ReceiveHit, MyComp) == 0x000000, "Member 'Actor_ReceiveHit::MyComp' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, Other) == 0x000008, "Member 'Actor_ReceiveHit::Other' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, OtherComp) == 0x000010, "Member 'Actor_ReceiveHit::OtherComp' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, bSelfMoved) == 0x000018, "Member 'Actor_ReceiveHit::bSelfMoved' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, HitLocation) == 0x00001C, "Member 'Actor_ReceiveHit::HitLocation' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, HitNormal) == 0x000028, "Member 'Actor_ReceiveHit::HitNormal' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, NormalImpulse) == 0x000034, "Member 'Actor_ReceiveHit::NormalImpulse' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveHit, Hit) == 0x000040, "Member 'Actor_ReceiveHit::Hit' has a wrong offset!");

// Function Engine.Actor.ReceivePointDamage
// 0x00E0 (0x00E0 - 0x0000)
struct Actor_ReceivePointDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ShotFromDirection;                                 // 0x0038(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            InstigatedBy;                                      // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0058(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceivePointDamage) == 0x000008, "Wrong alignment on Actor_ReceivePointDamage");
static_assert(sizeof(Actor_ReceivePointDamage) == 0x0000E0, "Wrong size on Actor_ReceivePointDamage");
static_assert(offsetof(Actor_ReceivePointDamage, Damage) == 0x000000, "Member 'Actor_ReceivePointDamage::Damage' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, DamageType) == 0x000008, "Member 'Actor_ReceivePointDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, HitLocation) == 0x000010, "Member 'Actor_ReceivePointDamage::HitLocation' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, HitNormal) == 0x00001C, "Member 'Actor_ReceivePointDamage::HitNormal' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, HitComponent) == 0x000028, "Member 'Actor_ReceivePointDamage::HitComponent' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, BoneName) == 0x000030, "Member 'Actor_ReceivePointDamage::BoneName' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, ShotFromDirection) == 0x000038, "Member 'Actor_ReceivePointDamage::ShotFromDirection' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, InstigatedBy) == 0x000048, "Member 'Actor_ReceivePointDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, DamageCauser) == 0x000050, "Member 'Actor_ReceivePointDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(Actor_ReceivePointDamage, HitInfo) == 0x000058, "Member 'Actor_ReceivePointDamage::HitInfo' has a wrong offset!");

// Function Engine.Actor.ReceiveRadialDamage
// 0x00B8 (0x00B8 - 0x0000)
struct Actor_ReceiveRadialDamage final
{
public:
	float                                         DamageReceived;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitInfo;                                           // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AController*                            InstigatedBy;                                      // 0x00A8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveRadialDamage) == 0x000008, "Wrong alignment on Actor_ReceiveRadialDamage");
static_assert(sizeof(Actor_ReceiveRadialDamage) == 0x0000B8, "Wrong size on Actor_ReceiveRadialDamage");
static_assert(offsetof(Actor_ReceiveRadialDamage, DamageReceived) == 0x000000, "Member 'Actor_ReceiveRadialDamage::DamageReceived' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveRadialDamage, DamageType) == 0x000008, "Member 'Actor_ReceiveRadialDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveRadialDamage, Origin) == 0x000010, "Member 'Actor_ReceiveRadialDamage::Origin' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveRadialDamage, HitInfo) == 0x000020, "Member 'Actor_ReceiveRadialDamage::HitInfo' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveRadialDamage, InstigatedBy) == 0x0000A8, "Member 'Actor_ReceiveRadialDamage::InstigatedBy' has a wrong offset!");
static_assert(offsetof(Actor_ReceiveRadialDamage, DamageCauser) == 0x0000B0, "Member 'Actor_ReceiveRadialDamage::DamageCauser' has a wrong offset!");

// Function Engine.Actor.ReceiveTick
// 0x0004 (0x0004 - 0x0000)
struct Actor_ReceiveTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_ReceiveTick) == 0x000004, "Wrong alignment on Actor_ReceiveTick");
static_assert(sizeof(Actor_ReceiveTick) == 0x000004, "Wrong size on Actor_ReceiveTick");
static_assert(offsetof(Actor_ReceiveTick, DeltaSeconds) == 0x000000, "Member 'Actor_ReceiveTick::DeltaSeconds' has a wrong offset!");

// Function Engine.Actor.RemoveTickPrerequisiteActor
// 0x0008 (0x0008 - 0x0000)
struct Actor_RemoveTickPrerequisiteActor final
{
public:
	class AActor*                                 PrerequisiteActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_RemoveTickPrerequisiteActor) == 0x000008, "Wrong alignment on Actor_RemoveTickPrerequisiteActor");
static_assert(sizeof(Actor_RemoveTickPrerequisiteActor) == 0x000008, "Wrong size on Actor_RemoveTickPrerequisiteActor");
static_assert(offsetof(Actor_RemoveTickPrerequisiteActor, PrerequisiteActor) == 0x000000, "Member 'Actor_RemoveTickPrerequisiteActor::PrerequisiteActor' has a wrong offset!");

// Function Engine.Actor.RemoveTickPrerequisiteComponent
// 0x0008 (0x0008 - 0x0000)
struct Actor_RemoveTickPrerequisiteComponent final
{
public:
	class UActorComponent*                        PrerequisiteComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_RemoveTickPrerequisiteComponent) == 0x000008, "Wrong alignment on Actor_RemoveTickPrerequisiteComponent");
static_assert(sizeof(Actor_RemoveTickPrerequisiteComponent) == 0x000008, "Wrong size on Actor_RemoveTickPrerequisiteComponent");
static_assert(offsetof(Actor_RemoveTickPrerequisiteComponent, PrerequisiteComponent) == 0x000000, "Member 'Actor_RemoveTickPrerequisiteComponent::PrerequisiteComponent' has a wrong offset!");

// Function Engine.Actor.SetActorAffectCullDistanceVolume
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetActorAffectCullDistanceVolume final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorAffectCullDistanceVolume) == 0x000001, "Wrong alignment on Actor_SetActorAffectCullDistanceVolume");
static_assert(sizeof(Actor_SetActorAffectCullDistanceVolume) == 0x000001, "Wrong size on Actor_SetActorAffectCullDistanceVolume");
static_assert(offsetof(Actor_SetActorAffectCullDistanceVolume, bEnabled) == 0x000000, "Member 'Actor_SetActorAffectCullDistanceVolume::bEnabled' has a wrong offset!");

// Function Engine.Actor.SetActorEnableCollision
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetActorEnableCollision final
{
public:
	bool                                          bNewActorEnableCollision;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorEnableCollision) == 0x000001, "Wrong alignment on Actor_SetActorEnableCollision");
static_assert(sizeof(Actor_SetActorEnableCollision) == 0x000001, "Wrong size on Actor_SetActorEnableCollision");
static_assert(offsetof(Actor_SetActorEnableCollision, bNewActorEnableCollision) == 0x000000, "Member 'Actor_SetActorEnableCollision::bNewActorEnableCollision' has a wrong offset!");

// Function Engine.Actor.SetActorHiddenInGame
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetActorHiddenInGame final
{
public:
	bool                                          bNewHidden;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorHiddenInGame) == 0x000001, "Wrong alignment on Actor_SetActorHiddenInGame");
static_assert(sizeof(Actor_SetActorHiddenInGame) == 0x000001, "Wrong size on Actor_SetActorHiddenInGame");
static_assert(offsetof(Actor_SetActorHiddenInGame, bNewHidden) == 0x000000, "Member 'Actor_SetActorHiddenInGame::bNewHidden' has a wrong offset!");

// Function Engine.Actor.SetActorRelativeScale3D
// 0x000C (0x000C - 0x0000)
struct Actor_SetActorRelativeScale3D final
{
public:
	struct FVector                                NewRelativeScale;                                  // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorRelativeScale3D) == 0x000004, "Wrong alignment on Actor_SetActorRelativeScale3D");
static_assert(sizeof(Actor_SetActorRelativeScale3D) == 0x00000C, "Wrong size on Actor_SetActorRelativeScale3D");
static_assert(offsetof(Actor_SetActorRelativeScale3D, NewRelativeScale) == 0x000000, "Member 'Actor_SetActorRelativeScale3D::NewRelativeScale' has a wrong offset!");

// Function Engine.Actor.SetActorScale3D
// 0x000C (0x000C - 0x0000)
struct Actor_SetActorScale3D final
{
public:
	struct FVector                                NewScale3D;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorScale3D) == 0x000004, "Wrong alignment on Actor_SetActorScale3D");
static_assert(sizeof(Actor_SetActorScale3D) == 0x00000C, "Wrong size on Actor_SetActorScale3D");
static_assert(offsetof(Actor_SetActorScale3D, NewScale3D) == 0x000000, "Member 'Actor_SetActorScale3D::NewScale3D' has a wrong offset!");

// Function Engine.Actor.SetActorTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetActorTickEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorTickEnabled) == 0x000001, "Wrong alignment on Actor_SetActorTickEnabled");
static_assert(sizeof(Actor_SetActorTickEnabled) == 0x000001, "Wrong size on Actor_SetActorTickEnabled");
static_assert(offsetof(Actor_SetActorTickEnabled, bEnabled) == 0x000000, "Member 'Actor_SetActorTickEnabled::bEnabled' has a wrong offset!");

// Function Engine.Actor.SetActorTickInterval
// 0x0004 (0x0004 - 0x0000)
struct Actor_SetActorTickInterval final
{
public:
	float                                         TickInterval;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetActorTickInterval) == 0x000004, "Wrong alignment on Actor_SetActorTickInterval");
static_assert(sizeof(Actor_SetActorTickInterval) == 0x000004, "Wrong size on Actor_SetActorTickInterval");
static_assert(offsetof(Actor_SetActorTickInterval, TickInterval) == 0x000000, "Member 'Actor_SetActorTickInterval::TickInterval' has a wrong offset!");

// Function Engine.Actor.SetLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct Actor_SetLifeSpan final
{
public:
	float                                         InLifespan;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetLifeSpan) == 0x000004, "Wrong alignment on Actor_SetLifeSpan");
static_assert(sizeof(Actor_SetLifeSpan) == 0x000004, "Wrong size on Actor_SetLifeSpan");
static_assert(offsetof(Actor_SetLifeSpan, InLifespan) == 0x000000, "Member 'Actor_SetLifeSpan::InLifespan' has a wrong offset!");

// Function Engine.Actor.SetNetDormancy
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetNetDormancy final
{
public:
	ENetDormancy                                  NewDormancy;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetNetDormancy) == 0x000001, "Wrong alignment on Actor_SetNetDormancy");
static_assert(sizeof(Actor_SetNetDormancy) == 0x000001, "Wrong size on Actor_SetNetDormancy");
static_assert(offsetof(Actor_SetNetDormancy, NewDormancy) == 0x000000, "Member 'Actor_SetNetDormancy::NewDormancy' has a wrong offset!");

// Function Engine.Actor.SetOwner
// 0x0008 (0x0008 - 0x0000)
struct Actor_SetOwner final
{
public:
	class AActor*                                 NewOwner;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetOwner) == 0x000008, "Wrong alignment on Actor_SetOwner");
static_assert(sizeof(Actor_SetOwner) == 0x000008, "Wrong size on Actor_SetOwner");
static_assert(offsetof(Actor_SetOwner, NewOwner) == 0x000000, "Member 'Actor_SetOwner::NewOwner' has a wrong offset!");

// Function Engine.Actor.SetReplicateMovement
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetReplicateMovement final
{
public:
	bool                                          bInReplicateMovement;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetReplicateMovement) == 0x000001, "Wrong alignment on Actor_SetReplicateMovement");
static_assert(sizeof(Actor_SetReplicateMovement) == 0x000001, "Wrong size on Actor_SetReplicateMovement");
static_assert(offsetof(Actor_SetReplicateMovement, bInReplicateMovement) == 0x000000, "Member 'Actor_SetReplicateMovement::bInReplicateMovement' has a wrong offset!");

// Function Engine.Actor.SetReplicates
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetReplicates final
{
public:
	bool                                          bInReplicates;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetReplicates) == 0x000001, "Wrong alignment on Actor_SetReplicates");
static_assert(sizeof(Actor_SetReplicates) == 0x000001, "Wrong size on Actor_SetReplicates");
static_assert(offsetof(Actor_SetReplicates, bInReplicates) == 0x000000, "Member 'Actor_SetReplicates::bInReplicates' has a wrong offset!");

// Function Engine.Actor.SetTickableWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetTickableWhenPaused final
{
public:
	bool                                          bTickableWhenPaused;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetTickableWhenPaused) == 0x000001, "Wrong alignment on Actor_SetTickableWhenPaused");
static_assert(sizeof(Actor_SetTickableWhenPaused) == 0x000001, "Wrong size on Actor_SetTickableWhenPaused");
static_assert(offsetof(Actor_SetTickableWhenPaused, bTickableWhenPaused) == 0x000000, "Member 'Actor_SetTickableWhenPaused::bTickableWhenPaused' has a wrong offset!");

// Function Engine.Actor.SetTickGroup
// 0x0001 (0x0001 - 0x0000)
struct Actor_SetTickGroup final
{
public:
	ETickingGroup                                 NewTickGroup;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SetTickGroup) == 0x000001, "Wrong alignment on Actor_SetTickGroup");
static_assert(sizeof(Actor_SetTickGroup) == 0x000001, "Wrong size on Actor_SetTickGroup");
static_assert(offsetof(Actor_SetTickGroup, NewTickGroup) == 0x000000, "Member 'Actor_SetTickGroup::NewTickGroup' has a wrong offset!");

// Function Engine.Actor.SnapRootComponentTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_SnapRootComponentTo final
{
public:
	class AActor*                                 InParentActor;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_SnapRootComponentTo) == 0x000008, "Wrong alignment on Actor_SnapRootComponentTo");
static_assert(sizeof(Actor_SnapRootComponentTo) == 0x000010, "Wrong size on Actor_SnapRootComponentTo");
static_assert(offsetof(Actor_SnapRootComponentTo, InParentActor) == 0x000000, "Member 'Actor_SnapRootComponentTo::InParentActor' has a wrong offset!");
static_assert(offsetof(Actor_SnapRootComponentTo, InSocketName) == 0x000008, "Member 'Actor_SnapRootComponentTo::InSocketName' has a wrong offset!");

// Function Engine.Actor.ActorHasTag
// 0x0010 (0x0010 - 0x0000)
struct Actor_ActorHasTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_ActorHasTag) == 0x000004, "Wrong alignment on Actor_ActorHasTag");
static_assert(sizeof(Actor_ActorHasTag) == 0x000010, "Wrong size on Actor_ActorHasTag");
static_assert(offsetof(Actor_ActorHasTag, Tag) == 0x000000, "Member 'Actor_ActorHasTag::Tag' has a wrong offset!");
static_assert(offsetof(Actor_ActorHasTag, ReturnValue) == 0x000008, "Member 'Actor_ActorHasTag::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorBounds
// 0x001C (0x001C - 0x0000)
struct Actor_GetActorBounds final
{
public:
	bool                                          bOnlyCollidingComponents;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Origin;                                            // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorBounds) == 0x000004, "Wrong alignment on Actor_GetActorBounds");
static_assert(sizeof(Actor_GetActorBounds) == 0x00001C, "Wrong size on Actor_GetActorBounds");
static_assert(offsetof(Actor_GetActorBounds, bOnlyCollidingComponents) == 0x000000, "Member 'Actor_GetActorBounds::bOnlyCollidingComponents' has a wrong offset!");
static_assert(offsetof(Actor_GetActorBounds, Origin) == 0x000004, "Member 'Actor_GetActorBounds::Origin' has a wrong offset!");
static_assert(offsetof(Actor_GetActorBounds, BoxExtent) == 0x000010, "Member 'Actor_GetActorBounds::BoxExtent' has a wrong offset!");

// Function Engine.Actor.GetActorEnableCollision
// 0x0001 (0x0001 - 0x0000)
struct Actor_GetActorEnableCollision final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorEnableCollision) == 0x000001, "Wrong alignment on Actor_GetActorEnableCollision");
static_assert(sizeof(Actor_GetActorEnableCollision) == 0x000001, "Wrong size on Actor_GetActorEnableCollision");
static_assert(offsetof(Actor_GetActorEnableCollision, ReturnValue) == 0x000000, "Member 'Actor_GetActorEnableCollision::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorEyesViewPoint
// 0x0018 (0x0018 - 0x0000)
struct Actor_GetActorEyesViewPoint final
{
public:
	struct FVector                                OutLocation;                                       // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorEyesViewPoint) == 0x000004, "Wrong alignment on Actor_GetActorEyesViewPoint");
static_assert(sizeof(Actor_GetActorEyesViewPoint) == 0x000018, "Wrong size on Actor_GetActorEyesViewPoint");
static_assert(offsetof(Actor_GetActorEyesViewPoint, OutLocation) == 0x000000, "Member 'Actor_GetActorEyesViewPoint::OutLocation' has a wrong offset!");
static_assert(offsetof(Actor_GetActorEyesViewPoint, OutRotation) == 0x00000C, "Member 'Actor_GetActorEyesViewPoint::OutRotation' has a wrong offset!");

// Function Engine.Actor.GetActorForwardVector
// 0x000C (0x000C - 0x0000)
struct Actor_GetActorForwardVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorForwardVector) == 0x000004, "Wrong alignment on Actor_GetActorForwardVector");
static_assert(sizeof(Actor_GetActorForwardVector) == 0x00000C, "Wrong size on Actor_GetActorForwardVector");
static_assert(offsetof(Actor_GetActorForwardVector, ReturnValue) == 0x000000, "Member 'Actor_GetActorForwardVector::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorRelativeScale3D
// 0x000C (0x000C - 0x0000)
struct Actor_GetActorRelativeScale3D final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorRelativeScale3D) == 0x000004, "Wrong alignment on Actor_GetActorRelativeScale3D");
static_assert(sizeof(Actor_GetActorRelativeScale3D) == 0x00000C, "Wrong size on Actor_GetActorRelativeScale3D");
static_assert(offsetof(Actor_GetActorRelativeScale3D, ReturnValue) == 0x000000, "Member 'Actor_GetActorRelativeScale3D::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorRightVector
// 0x000C (0x000C - 0x0000)
struct Actor_GetActorRightVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorRightVector) == 0x000004, "Wrong alignment on Actor_GetActorRightVector");
static_assert(sizeof(Actor_GetActorRightVector) == 0x00000C, "Wrong size on Actor_GetActorRightVector");
static_assert(offsetof(Actor_GetActorRightVector, ReturnValue) == 0x000000, "Member 'Actor_GetActorRightVector::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorScale3D
// 0x000C (0x000C - 0x0000)
struct Actor_GetActorScale3D final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorScale3D) == 0x000004, "Wrong alignment on Actor_GetActorScale3D");
static_assert(sizeof(Actor_GetActorScale3D) == 0x00000C, "Wrong size on Actor_GetActorScale3D");
static_assert(offsetof(Actor_GetActorScale3D, ReturnValue) == 0x000000, "Member 'Actor_GetActorScale3D::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorTickInterval
// 0x0004 (0x0004 - 0x0000)
struct Actor_GetActorTickInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorTickInterval) == 0x000004, "Wrong alignment on Actor_GetActorTickInterval");
static_assert(sizeof(Actor_GetActorTickInterval) == 0x000004, "Wrong size on Actor_GetActorTickInterval");
static_assert(offsetof(Actor_GetActorTickInterval, ReturnValue) == 0x000000, "Member 'Actor_GetActorTickInterval::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorTimeDilation
// 0x0004 (0x0004 - 0x0000)
struct Actor_GetActorTimeDilation final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorTimeDilation) == 0x000004, "Wrong alignment on Actor_GetActorTimeDilation");
static_assert(sizeof(Actor_GetActorTimeDilation) == 0x000004, "Wrong size on Actor_GetActorTimeDilation");
static_assert(offsetof(Actor_GetActorTimeDilation, ReturnValue) == 0x000000, "Member 'Actor_GetActorTimeDilation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetActorUpVector
// 0x000C (0x000C - 0x0000)
struct Actor_GetActorUpVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetActorUpVector) == 0x000004, "Wrong alignment on Actor_GetActorUpVector");
static_assert(sizeof(Actor_GetActorUpVector) == 0x00000C, "Wrong size on Actor_GetActorUpVector");
static_assert(offsetof(Actor_GetActorUpVector, ReturnValue) == 0x000000, "Member 'Actor_GetActorUpVector::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetAllChildActors
// 0x0018 (0x0018 - 0x0000)
struct Actor_GetAllChildActors final
{
public:
	TArray<class AActor*>                         ChildActors;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeDescendants;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetAllChildActors) == 0x000008, "Wrong alignment on Actor_GetAllChildActors");
static_assert(sizeof(Actor_GetAllChildActors) == 0x000018, "Wrong size on Actor_GetAllChildActors");
static_assert(offsetof(Actor_GetAllChildActors, ChildActors) == 0x000000, "Member 'Actor_GetAllChildActors::ChildActors' has a wrong offset!");
static_assert(offsetof(Actor_GetAllChildActors, bIncludeDescendants) == 0x000010, "Member 'Actor_GetAllChildActors::bIncludeDescendants' has a wrong offset!");

// Function Engine.Actor.GetAttachedActors
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetAttachedActors final
{
public:
	TArray<class AActor*>                         OutActors;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetAttachedActors) == 0x000008, "Wrong alignment on Actor_GetAttachedActors");
static_assert(sizeof(Actor_GetAttachedActors) == 0x000010, "Wrong size on Actor_GetAttachedActors");
static_assert(offsetof(Actor_GetAttachedActors, OutActors) == 0x000000, "Member 'Actor_GetAttachedActors::OutActors' has a wrong offset!");

// Function Engine.Actor.GetAttachParentActor
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetAttachParentActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetAttachParentActor) == 0x000008, "Wrong alignment on Actor_GetAttachParentActor");
static_assert(sizeof(Actor_GetAttachParentActor) == 0x000008, "Wrong size on Actor_GetAttachParentActor");
static_assert(offsetof(Actor_GetAttachParentActor, ReturnValue) == 0x000000, "Member 'Actor_GetAttachParentActor::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetAttachParentSocketName
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetAttachParentSocketName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetAttachParentSocketName) == 0x000004, "Wrong alignment on Actor_GetAttachParentSocketName");
static_assert(sizeof(Actor_GetAttachParentSocketName) == 0x000008, "Wrong size on Actor_GetAttachParentSocketName");
static_assert(offsetof(Actor_GetAttachParentSocketName, ReturnValue) == 0x000000, "Member 'Actor_GetAttachParentSocketName::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetComponentByClass
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetComponentByClass final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetComponentByClass) == 0x000008, "Wrong alignment on Actor_GetComponentByClass");
static_assert(sizeof(Actor_GetComponentByClass) == 0x000010, "Wrong size on Actor_GetComponentByClass");
static_assert(offsetof(Actor_GetComponentByClass, ComponentClass) == 0x000000, "Member 'Actor_GetComponentByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(Actor_GetComponentByClass, ReturnValue) == 0x000008, "Member 'Actor_GetComponentByClass::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetComponentsByClass
// 0x0018 (0x0018 - 0x0000)
struct Actor_GetComponentsByClass final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetComponentsByClass) == 0x000008, "Wrong alignment on Actor_GetComponentsByClass");
static_assert(sizeof(Actor_GetComponentsByClass) == 0x000018, "Wrong size on Actor_GetComponentsByClass");
static_assert(offsetof(Actor_GetComponentsByClass, ComponentClass) == 0x000000, "Member 'Actor_GetComponentsByClass::ComponentClass' has a wrong offset!");
static_assert(offsetof(Actor_GetComponentsByClass, ReturnValue) == 0x000008, "Member 'Actor_GetComponentsByClass::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetComponentsByTag
// 0x0020 (0x0020 - 0x0000)
struct Actor_GetComponentsByTag final
{
public:
	TSubclassOf<class UActorComponent>            ComponentClass;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponent*>                ReturnValue;                                       // 0x0010(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetComponentsByTag) == 0x000008, "Wrong alignment on Actor_GetComponentsByTag");
static_assert(sizeof(Actor_GetComponentsByTag) == 0x000020, "Wrong size on Actor_GetComponentsByTag");
static_assert(offsetof(Actor_GetComponentsByTag, ComponentClass) == 0x000000, "Member 'Actor_GetComponentsByTag::ComponentClass' has a wrong offset!");
static_assert(offsetof(Actor_GetComponentsByTag, Tag) == 0x000008, "Member 'Actor_GetComponentsByTag::Tag' has a wrong offset!");
static_assert(offsetof(Actor_GetComponentsByTag, ReturnValue) == 0x000010, "Member 'Actor_GetComponentsByTag::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetDistanceTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetDistanceTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetDistanceTo) == 0x000008, "Wrong alignment on Actor_GetDistanceTo");
static_assert(sizeof(Actor_GetDistanceTo) == 0x000010, "Wrong size on Actor_GetDistanceTo");
static_assert(offsetof(Actor_GetDistanceTo, OtherActor) == 0x000000, "Member 'Actor_GetDistanceTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetDistanceTo, ReturnValue) == 0x000008, "Member 'Actor_GetDistanceTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetDotProductTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetDotProductTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetDotProductTo) == 0x000008, "Wrong alignment on Actor_GetDotProductTo");
static_assert(sizeof(Actor_GetDotProductTo) == 0x000010, "Wrong size on Actor_GetDotProductTo");
static_assert(offsetof(Actor_GetDotProductTo, OtherActor) == 0x000000, "Member 'Actor_GetDotProductTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetDotProductTo, ReturnValue) == 0x000008, "Member 'Actor_GetDotProductTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetHorizontalDistanceTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetHorizontalDistanceTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetHorizontalDistanceTo) == 0x000008, "Wrong alignment on Actor_GetHorizontalDistanceTo");
static_assert(sizeof(Actor_GetHorizontalDistanceTo) == 0x000010, "Wrong size on Actor_GetHorizontalDistanceTo");
static_assert(offsetof(Actor_GetHorizontalDistanceTo, OtherActor) == 0x000000, "Member 'Actor_GetHorizontalDistanceTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetHorizontalDistanceTo, ReturnValue) == 0x000008, "Member 'Actor_GetHorizontalDistanceTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetHorizontalDotProductTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetHorizontalDotProductTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetHorizontalDotProductTo) == 0x000008, "Wrong alignment on Actor_GetHorizontalDotProductTo");
static_assert(sizeof(Actor_GetHorizontalDotProductTo) == 0x000010, "Wrong size on Actor_GetHorizontalDotProductTo");
static_assert(offsetof(Actor_GetHorizontalDotProductTo, OtherActor) == 0x000000, "Member 'Actor_GetHorizontalDotProductTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetHorizontalDotProductTo, ReturnValue) == 0x000008, "Member 'Actor_GetHorizontalDotProductTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetInputAxisKeyValue
// 0x0020 (0x0020 - 0x0000)
struct Actor_GetInputAxisKeyValue final
{
public:
	struct FKey                                   InputAxisKey;                                      // 0x0000(0x0018)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetInputAxisKeyValue) == 0x000008, "Wrong alignment on Actor_GetInputAxisKeyValue");
static_assert(sizeof(Actor_GetInputAxisKeyValue) == 0x000020, "Wrong size on Actor_GetInputAxisKeyValue");
static_assert(offsetof(Actor_GetInputAxisKeyValue, InputAxisKey) == 0x000000, "Member 'Actor_GetInputAxisKeyValue::InputAxisKey' has a wrong offset!");
static_assert(offsetof(Actor_GetInputAxisKeyValue, ReturnValue) == 0x000018, "Member 'Actor_GetInputAxisKeyValue::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetInputAxisValue
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetInputAxisValue final
{
public:
	class FName                                   InputAxisName;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetInputAxisValue) == 0x000004, "Wrong alignment on Actor_GetInputAxisValue");
static_assert(sizeof(Actor_GetInputAxisValue) == 0x000010, "Wrong size on Actor_GetInputAxisValue");
static_assert(offsetof(Actor_GetInputAxisValue, InputAxisName) == 0x000000, "Member 'Actor_GetInputAxisValue::InputAxisName' has a wrong offset!");
static_assert(offsetof(Actor_GetInputAxisValue, ReturnValue) == 0x000008, "Member 'Actor_GetInputAxisValue::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetInputVectorAxisValue
// 0x0028 (0x0028 - 0x0000)
struct Actor_GetInputVectorAxisValue final
{
public:
	struct FKey                                   InputAxisKey;                                      // 0x0000(0x0018)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetInputVectorAxisValue) == 0x000008, "Wrong alignment on Actor_GetInputVectorAxisValue");
static_assert(sizeof(Actor_GetInputVectorAxisValue) == 0x000028, "Wrong size on Actor_GetInputVectorAxisValue");
static_assert(offsetof(Actor_GetInputVectorAxisValue, InputAxisKey) == 0x000000, "Member 'Actor_GetInputVectorAxisValue::InputAxisKey' has a wrong offset!");
static_assert(offsetof(Actor_GetInputVectorAxisValue, ReturnValue) == 0x000018, "Member 'Actor_GetInputVectorAxisValue::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetInstigator
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetInstigator final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetInstigator) == 0x000008, "Wrong alignment on Actor_GetInstigator");
static_assert(sizeof(Actor_GetInstigator) == 0x000008, "Wrong size on Actor_GetInstigator");
static_assert(offsetof(Actor_GetInstigator, ReturnValue) == 0x000000, "Member 'Actor_GetInstigator::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetInstigatorController
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetInstigatorController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetInstigatorController) == 0x000008, "Wrong alignment on Actor_GetInstigatorController");
static_assert(sizeof(Actor_GetInstigatorController) == 0x000008, "Wrong size on Actor_GetInstigatorController");
static_assert(offsetof(Actor_GetInstigatorController, ReturnValue) == 0x000000, "Member 'Actor_GetInstigatorController::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetLifeSpan
// 0x0004 (0x0004 - 0x0000)
struct Actor_GetLifeSpan final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetLifeSpan) == 0x000004, "Wrong alignment on Actor_GetLifeSpan");
static_assert(sizeof(Actor_GetLifeSpan) == 0x000004, "Wrong size on Actor_GetLifeSpan");
static_assert(offsetof(Actor_GetLifeSpan, ReturnValue) == 0x000000, "Member 'Actor_GetLifeSpan::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetOverlappingActors
// 0x0018 (0x0018 - 0x0000)
struct Actor_GetOverlappingActors final
{
public:
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetOverlappingActors) == 0x000008, "Wrong alignment on Actor_GetOverlappingActors");
static_assert(sizeof(Actor_GetOverlappingActors) == 0x000018, "Wrong size on Actor_GetOverlappingActors");
static_assert(offsetof(Actor_GetOverlappingActors, OverlappingActors) == 0x000000, "Member 'Actor_GetOverlappingActors::OverlappingActors' has a wrong offset!");
static_assert(offsetof(Actor_GetOverlappingActors, ClassFilter) == 0x000010, "Member 'Actor_GetOverlappingActors::ClassFilter' has a wrong offset!");

// Function Engine.Actor.GetOverlappingComponents
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetOverlappingComponents final
{
public:
	TArray<class UPrimitiveComponent*>            OverlappingComponents;                             // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetOverlappingComponents) == 0x000008, "Wrong alignment on Actor_GetOverlappingComponents");
static_assert(sizeof(Actor_GetOverlappingComponents) == 0x000010, "Wrong size on Actor_GetOverlappingComponents");
static_assert(offsetof(Actor_GetOverlappingComponents, OverlappingComponents) == 0x000000, "Member 'Actor_GetOverlappingComponents::OverlappingComponents' has a wrong offset!");

// Function Engine.Actor.GetOwner
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetOwner) == 0x000008, "Wrong alignment on Actor_GetOwner");
static_assert(sizeof(Actor_GetOwner) == 0x000008, "Wrong size on Actor_GetOwner");
static_assert(offsetof(Actor_GetOwner, ReturnValue) == 0x000000, "Member 'Actor_GetOwner::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetParentActor
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetParentActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetParentActor) == 0x000008, "Wrong alignment on Actor_GetParentActor");
static_assert(sizeof(Actor_GetParentActor) == 0x000008, "Wrong size on Actor_GetParentActor");
static_assert(offsetof(Actor_GetParentActor, ReturnValue) == 0x000000, "Member 'Actor_GetParentActor::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetParentComponent
// 0x0008 (0x0008 - 0x0000)
struct Actor_GetParentComponent final
{
public:
	class UChildActorComponent*                   ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetParentComponent) == 0x000008, "Wrong alignment on Actor_GetParentComponent");
static_assert(sizeof(Actor_GetParentComponent) == 0x000008, "Wrong size on Actor_GetParentComponent");
static_assert(offsetof(Actor_GetParentComponent, ReturnValue) == 0x000000, "Member 'Actor_GetParentComponent::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetRemoteRole
// 0x0001 (0x0001 - 0x0000)
struct Actor_GetRemoteRole final
{
public:
	ENetRole                                      ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetRemoteRole) == 0x000001, "Wrong alignment on Actor_GetRemoteRole");
static_assert(sizeof(Actor_GetRemoteRole) == 0x000001, "Wrong size on Actor_GetRemoteRole");
static_assert(offsetof(Actor_GetRemoteRole, ReturnValue) == 0x000000, "Member 'Actor_GetRemoteRole::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetSquaredDistanceTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetSquaredDistanceTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetSquaredDistanceTo) == 0x000008, "Wrong alignment on Actor_GetSquaredDistanceTo");
static_assert(sizeof(Actor_GetSquaredDistanceTo) == 0x000010, "Wrong size on Actor_GetSquaredDistanceTo");
static_assert(offsetof(Actor_GetSquaredDistanceTo, OtherActor) == 0x000000, "Member 'Actor_GetSquaredDistanceTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetSquaredDistanceTo, ReturnValue) == 0x000008, "Member 'Actor_GetSquaredDistanceTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetTransform
// 0x0030 (0x0030 - 0x0000)
struct Actor_GetTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetTransform) == 0x000010, "Wrong alignment on Actor_GetTransform");
static_assert(sizeof(Actor_GetTransform) == 0x000030, "Wrong size on Actor_GetTransform");
static_assert(offsetof(Actor_GetTransform, ReturnValue) == 0x000000, "Member 'Actor_GetTransform::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetVelocity
// 0x000C (0x000C - 0x0000)
struct Actor_GetVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_GetVelocity) == 0x000004, "Wrong alignment on Actor_GetVelocity");
static_assert(sizeof(Actor_GetVelocity) == 0x00000C, "Wrong size on Actor_GetVelocity");
static_assert(offsetof(Actor_GetVelocity, ReturnValue) == 0x000000, "Member 'Actor_GetVelocity::ReturnValue' has a wrong offset!");

// Function Engine.Actor.GetVerticalDistanceTo
// 0x0010 (0x0010 - 0x0000)
struct Actor_GetVerticalDistanceTo final
{
public:
	const class AActor*                           OtherActor;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_GetVerticalDistanceTo) == 0x000008, "Wrong alignment on Actor_GetVerticalDistanceTo");
static_assert(sizeof(Actor_GetVerticalDistanceTo) == 0x000010, "Wrong size on Actor_GetVerticalDistanceTo");
static_assert(offsetof(Actor_GetVerticalDistanceTo, OtherActor) == 0x000000, "Member 'Actor_GetVerticalDistanceTo::OtherActor' has a wrong offset!");
static_assert(offsetof(Actor_GetVerticalDistanceTo, ReturnValue) == 0x000008, "Member 'Actor_GetVerticalDistanceTo::ReturnValue' has a wrong offset!");

// Function Engine.Actor.HasAuthority
// 0x0001 (0x0001 - 0x0000)
struct Actor_HasAuthority final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_HasAuthority) == 0x000001, "Wrong alignment on Actor_HasAuthority");
static_assert(sizeof(Actor_HasAuthority) == 0x000001, "Wrong size on Actor_HasAuthority");
static_assert(offsetof(Actor_HasAuthority, ReturnValue) == 0x000000, "Member 'Actor_HasAuthority::ReturnValue' has a wrong offset!");

// Function Engine.Actor.IsActorBeingDestroyed
// 0x0001 (0x0001 - 0x0000)
struct Actor_IsActorBeingDestroyed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_IsActorBeingDestroyed) == 0x000001, "Wrong alignment on Actor_IsActorBeingDestroyed");
static_assert(sizeof(Actor_IsActorBeingDestroyed) == 0x000001, "Wrong size on Actor_IsActorBeingDestroyed");
static_assert(offsetof(Actor_IsActorBeingDestroyed, ReturnValue) == 0x000000, "Member 'Actor_IsActorBeingDestroyed::ReturnValue' has a wrong offset!");

// Function Engine.Actor.IsActorTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct Actor_IsActorTickEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_IsActorTickEnabled) == 0x000001, "Wrong alignment on Actor_IsActorTickEnabled");
static_assert(sizeof(Actor_IsActorTickEnabled) == 0x000001, "Wrong size on Actor_IsActorTickEnabled");
static_assert(offsetof(Actor_IsActorTickEnabled, ReturnValue) == 0x000000, "Member 'Actor_IsActorTickEnabled::ReturnValue' has a wrong offset!");

// Function Engine.Actor.IsChildActor
// 0x0001 (0x0001 - 0x0000)
struct Actor_IsChildActor final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_IsChildActor) == 0x000001, "Wrong alignment on Actor_IsChildActor");
static_assert(sizeof(Actor_IsChildActor) == 0x000001, "Wrong size on Actor_IsChildActor");
static_assert(offsetof(Actor_IsChildActor, ReturnValue) == 0x000000, "Member 'Actor_IsChildActor::ReturnValue' has a wrong offset!");

// Function Engine.Actor.IsOverlappingActor
// 0x0010 (0x0010 - 0x0000)
struct Actor_IsOverlappingActor final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_IsOverlappingActor) == 0x000008, "Wrong alignment on Actor_IsOverlappingActor");
static_assert(sizeof(Actor_IsOverlappingActor) == 0x000010, "Wrong size on Actor_IsOverlappingActor");
static_assert(offsetof(Actor_IsOverlappingActor, Other) == 0x000000, "Member 'Actor_IsOverlappingActor::Other' has a wrong offset!");
static_assert(offsetof(Actor_IsOverlappingActor, ReturnValue) == 0x000008, "Member 'Actor_IsOverlappingActor::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_GetActorLocation
// 0x000C (0x000C - 0x0000)
struct Actor_K2_GetActorLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_GetActorLocation) == 0x000004, "Wrong alignment on Actor_K2_GetActorLocation");
static_assert(sizeof(Actor_K2_GetActorLocation) == 0x00000C, "Wrong size on Actor_K2_GetActorLocation");
static_assert(offsetof(Actor_K2_GetActorLocation, ReturnValue) == 0x000000, "Member 'Actor_K2_GetActorLocation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_GetActorRotation
// 0x000C (0x000C - 0x0000)
struct Actor_K2_GetActorRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_GetActorRotation) == 0x000004, "Wrong alignment on Actor_K2_GetActorRotation");
static_assert(sizeof(Actor_K2_GetActorRotation) == 0x00000C, "Wrong size on Actor_K2_GetActorRotation");
static_assert(offsetof(Actor_K2_GetActorRotation, ReturnValue) == 0x000000, "Member 'Actor_K2_GetActorRotation::ReturnValue' has a wrong offset!");

// Function Engine.Actor.K2_GetRootComponent
// 0x0008 (0x0008 - 0x0000)
struct Actor_K2_GetRootComponent final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Actor_K2_GetRootComponent) == 0x000008, "Wrong alignment on Actor_K2_GetRootComponent");
static_assert(sizeof(Actor_K2_GetRootComponent) == 0x000008, "Wrong size on Actor_K2_GetRootComponent");
static_assert(offsetof(Actor_K2_GetRootComponent, ReturnValue) == 0x000000, "Member 'Actor_K2_GetRootComponent::ReturnValue' has a wrong offset!");

// Function Engine.Actor.WasRecentlyRendered
// 0x0008 (0x0008 - 0x0000)
struct Actor_WasRecentlyRendered final
{
public:
	float                                         Tolerance;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Actor_WasRecentlyRendered) == 0x000004, "Wrong alignment on Actor_WasRecentlyRendered");
static_assert(sizeof(Actor_WasRecentlyRendered) == 0x000008, "Wrong size on Actor_WasRecentlyRendered");
static_assert(offsetof(Actor_WasRecentlyRendered, Tolerance) == 0x000000, "Member 'Actor_WasRecentlyRendered::Tolerance' has a wrong offset!");
static_assert(offsetof(Actor_WasRecentlyRendered, ReturnValue) == 0x000004, "Member 'Actor_WasRecentlyRendered::ReturnValue' has a wrong offset!");

// Function Engine.CameraActor.GetAutoActivatePlayerIndex
// 0x0004 (0x0004 - 0x0000)
struct CameraActor_GetAutoActivatePlayerIndex final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraActor_GetAutoActivatePlayerIndex) == 0x000004, "Wrong alignment on CameraActor_GetAutoActivatePlayerIndex");
static_assert(sizeof(CameraActor_GetAutoActivatePlayerIndex) == 0x000004, "Wrong size on CameraActor_GetAutoActivatePlayerIndex");
static_assert(offsetof(CameraActor_GetAutoActivatePlayerIndex, ReturnValue) == 0x000000, "Member 'CameraActor_GetAutoActivatePlayerIndex::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.Activate
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_Activate final
{
public:
	bool                                          bReset;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_Activate) == 0x000001, "Wrong alignment on ActorComponent_Activate");
static_assert(sizeof(ActorComponent_Activate) == 0x000001, "Wrong size on ActorComponent_Activate");
static_assert(offsetof(ActorComponent_Activate, bReset) == 0x000000, "Member 'ActorComponent_Activate::bReset' has a wrong offset!");

// Function Engine.ActorComponent.AddTickPrerequisiteActor
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_AddTickPrerequisiteActor final
{
public:
	class AActor*                                 PrerequisiteActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_AddTickPrerequisiteActor) == 0x000008, "Wrong alignment on ActorComponent_AddTickPrerequisiteActor");
static_assert(sizeof(ActorComponent_AddTickPrerequisiteActor) == 0x000008, "Wrong size on ActorComponent_AddTickPrerequisiteActor");
static_assert(offsetof(ActorComponent_AddTickPrerequisiteActor, PrerequisiteActor) == 0x000000, "Member 'ActorComponent_AddTickPrerequisiteActor::PrerequisiteActor' has a wrong offset!");

// Function Engine.ActorComponent.AddTickPrerequisiteComponent
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_AddTickPrerequisiteComponent final
{
public:
	class UActorComponent*                        PrerequisiteComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_AddTickPrerequisiteComponent) == 0x000008, "Wrong alignment on ActorComponent_AddTickPrerequisiteComponent");
static_assert(sizeof(ActorComponent_AddTickPrerequisiteComponent) == 0x000008, "Wrong size on ActorComponent_AddTickPrerequisiteComponent");
static_assert(offsetof(ActorComponent_AddTickPrerequisiteComponent, PrerequisiteComponent) == 0x000000, "Member 'ActorComponent_AddTickPrerequisiteComponent::PrerequisiteComponent' has a wrong offset!");

// Function Engine.ActorComponent.GetActorComponentUserDataByClass
// 0x0010 (0x0010 - 0x0000)
struct ActorComponent_GetActorComponentUserDataByClass final
{
public:
	TSubclassOf<class UActorComponentUserData>    InActorComponentUserDataClass;                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UActorComponentUserData*                ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_GetActorComponentUserDataByClass) == 0x000008, "Wrong alignment on ActorComponent_GetActorComponentUserDataByClass");
static_assert(sizeof(ActorComponent_GetActorComponentUserDataByClass) == 0x000010, "Wrong size on ActorComponent_GetActorComponentUserDataByClass");
static_assert(offsetof(ActorComponent_GetActorComponentUserDataByClass, InActorComponentUserDataClass) == 0x000000, "Member 'ActorComponent_GetActorComponentUserDataByClass::InActorComponentUserDataClass' has a wrong offset!");
static_assert(offsetof(ActorComponent_GetActorComponentUserDataByClass, ReturnValue) == 0x000008, "Member 'ActorComponent_GetActorComponentUserDataByClass::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.K2_DestroyComponent
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_K2_DestroyComponent final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_K2_DestroyComponent) == 0x000008, "Wrong alignment on ActorComponent_K2_DestroyComponent");
static_assert(sizeof(ActorComponent_K2_DestroyComponent) == 0x000008, "Wrong size on ActorComponent_K2_DestroyComponent");
static_assert(offsetof(ActorComponent_K2_DestroyComponent, Object) == 0x000000, "Member 'ActorComponent_K2_DestroyComponent::Object' has a wrong offset!");

// Function Engine.ActorComponent.ReceiveEndPlay
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_ReceiveEndPlay final
{
public:
	EEndPlayReason                                EndPlayReason;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_ReceiveEndPlay) == 0x000001, "Wrong alignment on ActorComponent_ReceiveEndPlay");
static_assert(sizeof(ActorComponent_ReceiveEndPlay) == 0x000001, "Wrong size on ActorComponent_ReceiveEndPlay");
static_assert(offsetof(ActorComponent_ReceiveEndPlay, EndPlayReason) == 0x000000, "Member 'ActorComponent_ReceiveEndPlay::EndPlayReason' has a wrong offset!");

// Function Engine.ActorComponent.ReceiveTick
// 0x0004 (0x0004 - 0x0000)
struct ActorComponent_ReceiveTick final
{
public:
	float                                         DeltaSeconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_ReceiveTick) == 0x000004, "Wrong alignment on ActorComponent_ReceiveTick");
static_assert(sizeof(ActorComponent_ReceiveTick) == 0x000004, "Wrong size on ActorComponent_ReceiveTick");
static_assert(offsetof(ActorComponent_ReceiveTick, DeltaSeconds) == 0x000000, "Member 'ActorComponent_ReceiveTick::DeltaSeconds' has a wrong offset!");

// Function Engine.ActorComponent.RemoveTickPrerequisiteActor
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_RemoveTickPrerequisiteActor final
{
public:
	class AActor*                                 PrerequisiteActor;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_RemoveTickPrerequisiteActor) == 0x000008, "Wrong alignment on ActorComponent_RemoveTickPrerequisiteActor");
static_assert(sizeof(ActorComponent_RemoveTickPrerequisiteActor) == 0x000008, "Wrong size on ActorComponent_RemoveTickPrerequisiteActor");
static_assert(offsetof(ActorComponent_RemoveTickPrerequisiteActor, PrerequisiteActor) == 0x000000, "Member 'ActorComponent_RemoveTickPrerequisiteActor::PrerequisiteActor' has a wrong offset!");

// Function Engine.ActorComponent.RemoveTickPrerequisiteComponent
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_RemoveTickPrerequisiteComponent final
{
public:
	class UActorComponent*                        PrerequisiteComponent;                             // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_RemoveTickPrerequisiteComponent) == 0x000008, "Wrong alignment on ActorComponent_RemoveTickPrerequisiteComponent");
static_assert(sizeof(ActorComponent_RemoveTickPrerequisiteComponent) == 0x000008, "Wrong size on ActorComponent_RemoveTickPrerequisiteComponent");
static_assert(offsetof(ActorComponent_RemoveTickPrerequisiteComponent, PrerequisiteComponent) == 0x000000, "Member 'ActorComponent_RemoveTickPrerequisiteComponent::PrerequisiteComponent' has a wrong offset!");

// Function Engine.ActorComponent.SetActive
// 0x0002 (0x0002 - 0x0000)
struct ActorComponent_SetActive final
{
public:
	bool                                          bNewActive;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReset;                                            // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetActive) == 0x000001, "Wrong alignment on ActorComponent_SetActive");
static_assert(sizeof(ActorComponent_SetActive) == 0x000002, "Wrong size on ActorComponent_SetActive");
static_assert(offsetof(ActorComponent_SetActive, bNewActive) == 0x000000, "Member 'ActorComponent_SetActive::bNewActive' has a wrong offset!");
static_assert(offsetof(ActorComponent_SetActive, bReset) == 0x000001, "Member 'ActorComponent_SetActive::bReset' has a wrong offset!");

// Function Engine.ActorComponent.SetAutoActivate
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_SetAutoActivate final
{
public:
	bool                                          bNewAutoActivate;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetAutoActivate) == 0x000001, "Wrong alignment on ActorComponent_SetAutoActivate");
static_assert(sizeof(ActorComponent_SetAutoActivate) == 0x000001, "Wrong size on ActorComponent_SetAutoActivate");
static_assert(offsetof(ActorComponent_SetAutoActivate, bNewAutoActivate) == 0x000000, "Member 'ActorComponent_SetAutoActivate::bNewAutoActivate' has a wrong offset!");

// Function Engine.ActorComponent.SetComponentTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_SetComponentTickEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetComponentTickEnabled) == 0x000001, "Wrong alignment on ActorComponent_SetComponentTickEnabled");
static_assert(sizeof(ActorComponent_SetComponentTickEnabled) == 0x000001, "Wrong size on ActorComponent_SetComponentTickEnabled");
static_assert(offsetof(ActorComponent_SetComponentTickEnabled, bEnabled) == 0x000000, "Member 'ActorComponent_SetComponentTickEnabled::bEnabled' has a wrong offset!");

// Function Engine.ActorComponent.SetComponentTickInterval
// 0x0004 (0x0004 - 0x0000)
struct ActorComponent_SetComponentTickInterval final
{
public:
	float                                         TickInterval;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetComponentTickInterval) == 0x000004, "Wrong alignment on ActorComponent_SetComponentTickInterval");
static_assert(sizeof(ActorComponent_SetComponentTickInterval) == 0x000004, "Wrong size on ActorComponent_SetComponentTickInterval");
static_assert(offsetof(ActorComponent_SetComponentTickInterval, TickInterval) == 0x000000, "Member 'ActorComponent_SetComponentTickInterval::TickInterval' has a wrong offset!");

// Function Engine.ActorComponent.SetIsReplicated
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_SetIsReplicated final
{
public:
	bool                                          ShouldReplicate;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetIsReplicated) == 0x000001, "Wrong alignment on ActorComponent_SetIsReplicated");
static_assert(sizeof(ActorComponent_SetIsReplicated) == 0x000001, "Wrong size on ActorComponent_SetIsReplicated");
static_assert(offsetof(ActorComponent_SetIsReplicated, ShouldReplicate) == 0x000000, "Member 'ActorComponent_SetIsReplicated::ShouldReplicate' has a wrong offset!");

// Function Engine.ActorComponent.SetTickableWhenPaused
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_SetTickableWhenPaused final
{
public:
	bool                                          bTickableWhenPaused;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetTickableWhenPaused) == 0x000001, "Wrong alignment on ActorComponent_SetTickableWhenPaused");
static_assert(sizeof(ActorComponent_SetTickableWhenPaused) == 0x000001, "Wrong size on ActorComponent_SetTickableWhenPaused");
static_assert(offsetof(ActorComponent_SetTickableWhenPaused, bTickableWhenPaused) == 0x000000, "Member 'ActorComponent_SetTickableWhenPaused::bTickableWhenPaused' has a wrong offset!");

// Function Engine.ActorComponent.SetTickGroup
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_SetTickGroup final
{
public:
	ETickingGroup                                 NewTickGroup;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_SetTickGroup) == 0x000001, "Wrong alignment on ActorComponent_SetTickGroup");
static_assert(sizeof(ActorComponent_SetTickGroup) == 0x000001, "Wrong size on ActorComponent_SetTickGroup");
static_assert(offsetof(ActorComponent_SetTickGroup, NewTickGroup) == 0x000000, "Member 'ActorComponent_SetTickGroup::NewTickGroup' has a wrong offset!");

// Function Engine.ActorComponent.ComponentHasTag
// 0x0010 (0x0010 - 0x0000)
struct ActorComponent_ComponentHasTag final
{
public:
	class FName                                   Tag;                                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ActorComponent_ComponentHasTag) == 0x000004, "Wrong alignment on ActorComponent_ComponentHasTag");
static_assert(sizeof(ActorComponent_ComponentHasTag) == 0x000010, "Wrong size on ActorComponent_ComponentHasTag");
static_assert(offsetof(ActorComponent_ComponentHasTag, Tag) == 0x000000, "Member 'ActorComponent_ComponentHasTag::Tag' has a wrong offset!");
static_assert(offsetof(ActorComponent_ComponentHasTag, ReturnValue) == 0x000008, "Member 'ActorComponent_ComponentHasTag::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.GetActorComponentUserDataArrayByClass
// 0x0018 (0x0018 - 0x0000)
struct ActorComponent_GetActorComponentUserDataArrayByClass final
{
public:
	TSubclassOf<class UActorComponentUserData>    InActorComponentUserDataClass;                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UActorComponentUserData*>        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_GetActorComponentUserDataArrayByClass) == 0x000008, "Wrong alignment on ActorComponent_GetActorComponentUserDataArrayByClass");
static_assert(sizeof(ActorComponent_GetActorComponentUserDataArrayByClass) == 0x000018, "Wrong size on ActorComponent_GetActorComponentUserDataArrayByClass");
static_assert(offsetof(ActorComponent_GetActorComponentUserDataArrayByClass, InActorComponentUserDataClass) == 0x000000, "Member 'ActorComponent_GetActorComponentUserDataArrayByClass::InActorComponentUserDataClass' has a wrong offset!");
static_assert(offsetof(ActorComponent_GetActorComponentUserDataArrayByClass, ReturnValue) == 0x000008, "Member 'ActorComponent_GetActorComponentUserDataArrayByClass::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.GetComponentTickInterval
// 0x0004 (0x0004 - 0x0000)
struct ActorComponent_GetComponentTickInterval final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_GetComponentTickInterval) == 0x000004, "Wrong alignment on ActorComponent_GetComponentTickInterval");
static_assert(sizeof(ActorComponent_GetComponentTickInterval) == 0x000004, "Wrong size on ActorComponent_GetComponentTickInterval");
static_assert(offsetof(ActorComponent_GetComponentTickInterval, ReturnValue) == 0x000000, "Member 'ActorComponent_GetComponentTickInterval::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.GetOwner
// 0x0008 (0x0008 - 0x0000)
struct ActorComponent_GetOwner final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_GetOwner) == 0x000008, "Wrong alignment on ActorComponent_GetOwner");
static_assert(sizeof(ActorComponent_GetOwner) == 0x000008, "Wrong size on ActorComponent_GetOwner");
static_assert(offsetof(ActorComponent_GetOwner, ReturnValue) == 0x000000, "Member 'ActorComponent_GetOwner::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.IsActive
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_IsActive) == 0x000001, "Wrong alignment on ActorComponent_IsActive");
static_assert(sizeof(ActorComponent_IsActive) == 0x000001, "Wrong size on ActorComponent_IsActive");
static_assert(offsetof(ActorComponent_IsActive, ReturnValue) == 0x000000, "Member 'ActorComponent_IsActive::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.IsBeingDestroyed
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_IsBeingDestroyed final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_IsBeingDestroyed) == 0x000001, "Wrong alignment on ActorComponent_IsBeingDestroyed");
static_assert(sizeof(ActorComponent_IsBeingDestroyed) == 0x000001, "Wrong size on ActorComponent_IsBeingDestroyed");
static_assert(offsetof(ActorComponent_IsBeingDestroyed, ReturnValue) == 0x000000, "Member 'ActorComponent_IsBeingDestroyed::ReturnValue' has a wrong offset!");

// Function Engine.ActorComponent.IsComponentTickEnabled
// 0x0001 (0x0001 - 0x0000)
struct ActorComponent_IsComponentTickEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ActorComponent_IsComponentTickEnabled) == 0x000001, "Wrong alignment on ActorComponent_IsComponentTickEnabled");
static_assert(sizeof(ActorComponent_IsComponentTickEnabled) == 0x000001, "Wrong size on ActorComponent_IsComponentTickEnabled");
static_assert(offsetof(ActorComponent_IsComponentTickEnabled, ReturnValue) == 0x000000, "Member 'ActorComponent_IsComponentTickEnabled::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotifyState.GetNotifyName
// 0x0010 (0x0010 - 0x0000)
struct AnimNotifyState_GetNotifyName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_GetNotifyName) == 0x000008, "Wrong alignment on AnimNotifyState_GetNotifyName");
static_assert(sizeof(AnimNotifyState_GetNotifyName) == 0x000010, "Wrong size on AnimNotifyState_GetNotifyName");
static_assert(offsetof(AnimNotifyState_GetNotifyName, ReturnValue) == 0x000000, "Member 'AnimNotifyState_GetNotifyName::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotifyState.Received_NotifyAnimationEnd
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_Received_NotifyAnimationEnd final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_Received_NotifyAnimationEnd) == 0x000008, "Wrong alignment on AnimNotifyState_Received_NotifyAnimationEnd");
static_assert(sizeof(AnimNotifyState_Received_NotifyAnimationEnd) == 0x000018, "Wrong size on AnimNotifyState_Received_NotifyAnimationEnd");
static_assert(offsetof(AnimNotifyState_Received_NotifyAnimationEnd, MeshComp) == 0x000000, "Member 'AnimNotifyState_Received_NotifyAnimationEnd::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyAnimationEnd, Animation) == 0x000008, "Member 'AnimNotifyState_Received_NotifyAnimationEnd::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyAnimationEnd, ReturnValue) == 0x000010, "Member 'AnimNotifyState_Received_NotifyAnimationEnd::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotifyState.Received_NotifyBegin
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_Received_NotifyBegin final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TotalDuration;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_Received_NotifyBegin) == 0x000008, "Wrong alignment on AnimNotifyState_Received_NotifyBegin");
static_assert(sizeof(AnimNotifyState_Received_NotifyBegin) == 0x000018, "Wrong size on AnimNotifyState_Received_NotifyBegin");
static_assert(offsetof(AnimNotifyState_Received_NotifyBegin, MeshComp) == 0x000000, "Member 'AnimNotifyState_Received_NotifyBegin::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyBegin, Animation) == 0x000008, "Member 'AnimNotifyState_Received_NotifyBegin::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyBegin, TotalDuration) == 0x000010, "Member 'AnimNotifyState_Received_NotifyBegin::TotalDuration' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyBegin, ReturnValue) == 0x000014, "Member 'AnimNotifyState_Received_NotifyBegin::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotifyState.Received_NotifyEnd
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_Received_NotifyEnd final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_Received_NotifyEnd) == 0x000008, "Wrong alignment on AnimNotifyState_Received_NotifyEnd");
static_assert(sizeof(AnimNotifyState_Received_NotifyEnd) == 0x000018, "Wrong size on AnimNotifyState_Received_NotifyEnd");
static_assert(offsetof(AnimNotifyState_Received_NotifyEnd, MeshComp) == 0x000000, "Member 'AnimNotifyState_Received_NotifyEnd::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyEnd, Animation) == 0x000008, "Member 'AnimNotifyState_Received_NotifyEnd::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyEnd, ReturnValue) == 0x000010, "Member 'AnimNotifyState_Received_NotifyEnd::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotifyState.Received_NotifyTick
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_Received_NotifyTick final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FrameDeltaTime;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotifyState_Received_NotifyTick) == 0x000008, "Wrong alignment on AnimNotifyState_Received_NotifyTick");
static_assert(sizeof(AnimNotifyState_Received_NotifyTick) == 0x000018, "Wrong size on AnimNotifyState_Received_NotifyTick");
static_assert(offsetof(AnimNotifyState_Received_NotifyTick, MeshComp) == 0x000000, "Member 'AnimNotifyState_Received_NotifyTick::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyTick, Animation) == 0x000008, "Member 'AnimNotifyState_Received_NotifyTick::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyTick, FrameDeltaTime) == 0x000010, "Member 'AnimNotifyState_Received_NotifyTick::FrameDeltaTime' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Received_NotifyTick, ReturnValue) == 0x000014, "Member 'AnimNotifyState_Received_NotifyTick::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.K2_MoveUpdatedComponent
// 0x00A8 (0x00A8 - 0x0000)
struct MovementComponent_K2_MoveUpdatedComponent final
{
public:
	struct FVector                                Delta;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0018(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x00A0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00A1(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A2(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A3[0x5];                                       // 0x00A3(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementComponent_K2_MoveUpdatedComponent) == 0x000008, "Wrong alignment on MovementComponent_K2_MoveUpdatedComponent");
static_assert(sizeof(MovementComponent_K2_MoveUpdatedComponent) == 0x0000A8, "Wrong size on MovementComponent_K2_MoveUpdatedComponent");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, Delta) == 0x000000, "Member 'MovementComponent_K2_MoveUpdatedComponent::Delta' has a wrong offset!");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, NewRotation) == 0x00000C, "Member 'MovementComponent_K2_MoveUpdatedComponent::NewRotation' has a wrong offset!");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, OutHit) == 0x000018, "Member 'MovementComponent_K2_MoveUpdatedComponent::OutHit' has a wrong offset!");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, bSweep) == 0x0000A0, "Member 'MovementComponent_K2_MoveUpdatedComponent::bSweep' has a wrong offset!");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, bTeleport) == 0x0000A1, "Member 'MovementComponent_K2_MoveUpdatedComponent::bTeleport' has a wrong offset!");
static_assert(offsetof(MovementComponent_K2_MoveUpdatedComponent, ReturnValue) == 0x0000A2, "Member 'MovementComponent_K2_MoveUpdatedComponent::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.PhysicsVolumeChanged
// 0x0008 (0x0008 - 0x0000)
struct MovementComponent_PhysicsVolumeChanged final
{
public:
	class APhysicsVolume*                         NewVolume;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_PhysicsVolumeChanged) == 0x000008, "Wrong alignment on MovementComponent_PhysicsVolumeChanged");
static_assert(sizeof(MovementComponent_PhysicsVolumeChanged) == 0x000008, "Wrong size on MovementComponent_PhysicsVolumeChanged");
static_assert(offsetof(MovementComponent_PhysicsVolumeChanged, NewVolume) == 0x000000, "Member 'MovementComponent_PhysicsVolumeChanged::NewVolume' has a wrong offset!");

// Function Engine.MovementComponent.SetPlaneConstraintAxisSetting
// 0x0001 (0x0001 - 0x0000)
struct MovementComponent_SetPlaneConstraintAxisSetting final
{
public:
	EPlaneConstraintAxisSetting                   NewAxisSetting;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetPlaneConstraintAxisSetting) == 0x000001, "Wrong alignment on MovementComponent_SetPlaneConstraintAxisSetting");
static_assert(sizeof(MovementComponent_SetPlaneConstraintAxisSetting) == 0x000001, "Wrong size on MovementComponent_SetPlaneConstraintAxisSetting");
static_assert(offsetof(MovementComponent_SetPlaneConstraintAxisSetting, NewAxisSetting) == 0x000000, "Member 'MovementComponent_SetPlaneConstraintAxisSetting::NewAxisSetting' has a wrong offset!");

// Function Engine.MovementComponent.SetPlaneConstraintEnabled
// 0x0001 (0x0001 - 0x0000)
struct MovementComponent_SetPlaneConstraintEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetPlaneConstraintEnabled) == 0x000001, "Wrong alignment on MovementComponent_SetPlaneConstraintEnabled");
static_assert(sizeof(MovementComponent_SetPlaneConstraintEnabled) == 0x000001, "Wrong size on MovementComponent_SetPlaneConstraintEnabled");
static_assert(offsetof(MovementComponent_SetPlaneConstraintEnabled, bEnabled) == 0x000000, "Member 'MovementComponent_SetPlaneConstraintEnabled::bEnabled' has a wrong offset!");

// Function Engine.MovementComponent.SetPlaneConstraintFromVectors
// 0x0018 (0x0018 - 0x0000)
struct MovementComponent_SetPlaneConstraintFromVectors final
{
public:
	struct FVector                                Forward;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetPlaneConstraintFromVectors) == 0x000004, "Wrong alignment on MovementComponent_SetPlaneConstraintFromVectors");
static_assert(sizeof(MovementComponent_SetPlaneConstraintFromVectors) == 0x000018, "Wrong size on MovementComponent_SetPlaneConstraintFromVectors");
static_assert(offsetof(MovementComponent_SetPlaneConstraintFromVectors, Forward) == 0x000000, "Member 'MovementComponent_SetPlaneConstraintFromVectors::Forward' has a wrong offset!");
static_assert(offsetof(MovementComponent_SetPlaneConstraintFromVectors, Up) == 0x00000C, "Member 'MovementComponent_SetPlaneConstraintFromVectors::Up' has a wrong offset!");

// Function Engine.MovementComponent.SetPlaneConstraintNormal
// 0x000C (0x000C - 0x0000)
struct MovementComponent_SetPlaneConstraintNormal final
{
public:
	struct FVector                                PlaneNormal;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetPlaneConstraintNormal) == 0x000004, "Wrong alignment on MovementComponent_SetPlaneConstraintNormal");
static_assert(sizeof(MovementComponent_SetPlaneConstraintNormal) == 0x00000C, "Wrong size on MovementComponent_SetPlaneConstraintNormal");
static_assert(offsetof(MovementComponent_SetPlaneConstraintNormal, PlaneNormal) == 0x000000, "Member 'MovementComponent_SetPlaneConstraintNormal::PlaneNormal' has a wrong offset!");

// Function Engine.MovementComponent.SetPlaneConstraintOrigin
// 0x000C (0x000C - 0x0000)
struct MovementComponent_SetPlaneConstraintOrigin final
{
public:
	struct FVector                                PlaneOrigin;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetPlaneConstraintOrigin) == 0x000004, "Wrong alignment on MovementComponent_SetPlaneConstraintOrigin");
static_assert(sizeof(MovementComponent_SetPlaneConstraintOrigin) == 0x00000C, "Wrong size on MovementComponent_SetPlaneConstraintOrigin");
static_assert(offsetof(MovementComponent_SetPlaneConstraintOrigin, PlaneOrigin) == 0x000000, "Member 'MovementComponent_SetPlaneConstraintOrigin::PlaneOrigin' has a wrong offset!");

// Function Engine.MovementComponent.SetUpdatedComponent
// 0x0008 (0x0008 - 0x0000)
struct MovementComponent_SetUpdatedComponent final
{
public:
	class USceneComponent*                        NewUpdatedComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_SetUpdatedComponent) == 0x000008, "Wrong alignment on MovementComponent_SetUpdatedComponent");
static_assert(sizeof(MovementComponent_SetUpdatedComponent) == 0x000008, "Wrong size on MovementComponent_SetUpdatedComponent");
static_assert(offsetof(MovementComponent_SetUpdatedComponent, NewUpdatedComponent) == 0x000000, "Member 'MovementComponent_SetUpdatedComponent::NewUpdatedComponent' has a wrong offset!");

// Function Engine.MovementComponent.ConstrainDirectionToPlane
// 0x0018 (0x0018 - 0x0000)
struct MovementComponent_ConstrainDirectionToPlane final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_ConstrainDirectionToPlane) == 0x000004, "Wrong alignment on MovementComponent_ConstrainDirectionToPlane");
static_assert(sizeof(MovementComponent_ConstrainDirectionToPlane) == 0x000018, "Wrong size on MovementComponent_ConstrainDirectionToPlane");
static_assert(offsetof(MovementComponent_ConstrainDirectionToPlane, Direction) == 0x000000, "Member 'MovementComponent_ConstrainDirectionToPlane::Direction' has a wrong offset!");
static_assert(offsetof(MovementComponent_ConstrainDirectionToPlane, ReturnValue) == 0x00000C, "Member 'MovementComponent_ConstrainDirectionToPlane::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.ConstrainLocationToPlane
// 0x0018 (0x0018 - 0x0000)
struct MovementComponent_ConstrainLocationToPlane final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_ConstrainLocationToPlane) == 0x000004, "Wrong alignment on MovementComponent_ConstrainLocationToPlane");
static_assert(sizeof(MovementComponent_ConstrainLocationToPlane) == 0x000018, "Wrong size on MovementComponent_ConstrainLocationToPlane");
static_assert(offsetof(MovementComponent_ConstrainLocationToPlane, Location) == 0x000000, "Member 'MovementComponent_ConstrainLocationToPlane::Location' has a wrong offset!");
static_assert(offsetof(MovementComponent_ConstrainLocationToPlane, ReturnValue) == 0x00000C, "Member 'MovementComponent_ConstrainLocationToPlane::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.ConstrainNormalToPlane
// 0x0018 (0x0018 - 0x0000)
struct MovementComponent_ConstrainNormalToPlane final
{
public:
	struct FVector                                Normal;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_ConstrainNormalToPlane) == 0x000004, "Wrong alignment on MovementComponent_ConstrainNormalToPlane");
static_assert(sizeof(MovementComponent_ConstrainNormalToPlane) == 0x000018, "Wrong size on MovementComponent_ConstrainNormalToPlane");
static_assert(offsetof(MovementComponent_ConstrainNormalToPlane, Normal) == 0x000000, "Member 'MovementComponent_ConstrainNormalToPlane::Normal' has a wrong offset!");
static_assert(offsetof(MovementComponent_ConstrainNormalToPlane, ReturnValue) == 0x00000C, "Member 'MovementComponent_ConstrainNormalToPlane::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetGravityZ
// 0x0004 (0x0004 - 0x0000)
struct MovementComponent_GetGravityZ final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetGravityZ) == 0x000004, "Wrong alignment on MovementComponent_GetGravityZ");
static_assert(sizeof(MovementComponent_GetGravityZ) == 0x000004, "Wrong size on MovementComponent_GetGravityZ");
static_assert(offsetof(MovementComponent_GetGravityZ, ReturnValue) == 0x000000, "Member 'MovementComponent_GetGravityZ::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct MovementComponent_GetMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetMaxSpeed) == 0x000004, "Wrong alignment on MovementComponent_GetMaxSpeed");
static_assert(sizeof(MovementComponent_GetMaxSpeed) == 0x000004, "Wrong size on MovementComponent_GetMaxSpeed");
static_assert(offsetof(MovementComponent_GetMaxSpeed, ReturnValue) == 0x000000, "Member 'MovementComponent_GetMaxSpeed::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetPhysicsVolume
// 0x0008 (0x0008 - 0x0000)
struct MovementComponent_GetPhysicsVolume final
{
public:
	class APhysicsVolume*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetPhysicsVolume) == 0x000008, "Wrong alignment on MovementComponent_GetPhysicsVolume");
static_assert(sizeof(MovementComponent_GetPhysicsVolume) == 0x000008, "Wrong size on MovementComponent_GetPhysicsVolume");
static_assert(offsetof(MovementComponent_GetPhysicsVolume, ReturnValue) == 0x000000, "Member 'MovementComponent_GetPhysicsVolume::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetPlaneConstraintAxisSetting
// 0x0001 (0x0001 - 0x0000)
struct MovementComponent_GetPlaneConstraintAxisSetting final
{
public:
	EPlaneConstraintAxisSetting                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetPlaneConstraintAxisSetting) == 0x000001, "Wrong alignment on MovementComponent_GetPlaneConstraintAxisSetting");
static_assert(sizeof(MovementComponent_GetPlaneConstraintAxisSetting) == 0x000001, "Wrong size on MovementComponent_GetPlaneConstraintAxisSetting");
static_assert(offsetof(MovementComponent_GetPlaneConstraintAxisSetting, ReturnValue) == 0x000000, "Member 'MovementComponent_GetPlaneConstraintAxisSetting::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetPlaneConstraintNormal
// 0x000C (0x000C - 0x0000)
struct MovementComponent_GetPlaneConstraintNormal final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetPlaneConstraintNormal) == 0x000004, "Wrong alignment on MovementComponent_GetPlaneConstraintNormal");
static_assert(sizeof(MovementComponent_GetPlaneConstraintNormal) == 0x00000C, "Wrong size on MovementComponent_GetPlaneConstraintNormal");
static_assert(offsetof(MovementComponent_GetPlaneConstraintNormal, ReturnValue) == 0x000000, "Member 'MovementComponent_GetPlaneConstraintNormal::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.GetPlaneConstraintOrigin
// 0x000C (0x000C - 0x0000)
struct MovementComponent_GetPlaneConstraintOrigin final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_GetPlaneConstraintOrigin) == 0x000004, "Wrong alignment on MovementComponent_GetPlaneConstraintOrigin");
static_assert(sizeof(MovementComponent_GetPlaneConstraintOrigin) == 0x00000C, "Wrong size on MovementComponent_GetPlaneConstraintOrigin");
static_assert(offsetof(MovementComponent_GetPlaneConstraintOrigin, ReturnValue) == 0x000000, "Member 'MovementComponent_GetPlaneConstraintOrigin::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.IsExceedingMaxSpeed
// 0x0008 (0x0008 - 0x0000)
struct MovementComponent_IsExceedingMaxSpeed final
{
public:
	float                                         MaxSpeed;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MovementComponent_IsExceedingMaxSpeed) == 0x000004, "Wrong alignment on MovementComponent_IsExceedingMaxSpeed");
static_assert(sizeof(MovementComponent_IsExceedingMaxSpeed) == 0x000008, "Wrong size on MovementComponent_IsExceedingMaxSpeed");
static_assert(offsetof(MovementComponent_IsExceedingMaxSpeed, MaxSpeed) == 0x000000, "Member 'MovementComponent_IsExceedingMaxSpeed::MaxSpeed' has a wrong offset!");
static_assert(offsetof(MovementComponent_IsExceedingMaxSpeed, ReturnValue) == 0x000004, "Member 'MovementComponent_IsExceedingMaxSpeed::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.K2_GetMaxSpeedModifier
// 0x0004 (0x0004 - 0x0000)
struct MovementComponent_K2_GetMaxSpeedModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_K2_GetMaxSpeedModifier) == 0x000004, "Wrong alignment on MovementComponent_K2_GetMaxSpeedModifier");
static_assert(sizeof(MovementComponent_K2_GetMaxSpeedModifier) == 0x000004, "Wrong size on MovementComponent_K2_GetMaxSpeedModifier");
static_assert(offsetof(MovementComponent_K2_GetMaxSpeedModifier, ReturnValue) == 0x000000, "Member 'MovementComponent_K2_GetMaxSpeedModifier::ReturnValue' has a wrong offset!");

// Function Engine.MovementComponent.K2_GetModifiedMaxSpeed
// 0x0004 (0x0004 - 0x0000)
struct MovementComponent_K2_GetModifiedMaxSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MovementComponent_K2_GetModifiedMaxSpeed) == 0x000004, "Wrong alignment on MovementComponent_K2_GetModifiedMaxSpeed");
static_assert(sizeof(MovementComponent_K2_GetModifiedMaxSpeed) == 0x000004, "Wrong size on MovementComponent_K2_GetModifiedMaxSpeed");
static_assert(offsetof(MovementComponent_K2_GetModifiedMaxSpeed, ReturnValue) == 0x000000, "Member 'MovementComponent_K2_GetModifiedMaxSpeed::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.CanSpectate
// 0x0018 (0x0018 - 0x0000)
struct GameModeBase_CanSpectate final
{
public:
	class APlayerController*                      Viewer;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           ViewTarget;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_CanSpectate) == 0x000008, "Wrong alignment on GameModeBase_CanSpectate");
static_assert(sizeof(GameModeBase_CanSpectate) == 0x000018, "Wrong size on GameModeBase_CanSpectate");
static_assert(offsetof(GameModeBase_CanSpectate, Viewer) == 0x000000, "Member 'GameModeBase_CanSpectate::Viewer' has a wrong offset!");
static_assert(offsetof(GameModeBase_CanSpectate, ViewTarget) == 0x000008, "Member 'GameModeBase_CanSpectate::ViewTarget' has a wrong offset!");
static_assert(offsetof(GameModeBase_CanSpectate, ReturnValue) == 0x000010, "Member 'GameModeBase_CanSpectate::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.ChangeName
// 0x0020 (0x0020 - 0x0000)
struct GameModeBase_ChangeName final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNameChange;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_ChangeName) == 0x000008, "Wrong alignment on GameModeBase_ChangeName");
static_assert(sizeof(GameModeBase_ChangeName) == 0x000020, "Wrong size on GameModeBase_ChangeName");
static_assert(offsetof(GameModeBase_ChangeName, Controller) == 0x000000, "Member 'GameModeBase_ChangeName::Controller' has a wrong offset!");
static_assert(offsetof(GameModeBase_ChangeName, NewName) == 0x000008, "Member 'GameModeBase_ChangeName::NewName' has a wrong offset!");
static_assert(offsetof(GameModeBase_ChangeName, bNameChange) == 0x000018, "Member 'GameModeBase_ChangeName::bNameChange' has a wrong offset!");

// Function Engine.GameModeBase.ChoosePlayerStart
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_ChoosePlayerStart final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_ChoosePlayerStart) == 0x000008, "Wrong alignment on GameModeBase_ChoosePlayerStart");
static_assert(sizeof(GameModeBase_ChoosePlayerStart) == 0x000010, "Wrong size on GameModeBase_ChoosePlayerStart");
static_assert(offsetof(GameModeBase_ChoosePlayerStart, Player) == 0x000000, "Member 'GameModeBase_ChoosePlayerStart::Player' has a wrong offset!");
static_assert(offsetof(GameModeBase_ChoosePlayerStart, ReturnValue) == 0x000008, "Member 'GameModeBase_ChoosePlayerStart::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.FindPlayerStart
// 0x0020 (0x0020 - 0x0000)
struct GameModeBase_FindPlayerStart final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IncomingName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_FindPlayerStart) == 0x000008, "Wrong alignment on GameModeBase_FindPlayerStart");
static_assert(sizeof(GameModeBase_FindPlayerStart) == 0x000020, "Wrong size on GameModeBase_FindPlayerStart");
static_assert(offsetof(GameModeBase_FindPlayerStart, Player) == 0x000000, "Member 'GameModeBase_FindPlayerStart::Player' has a wrong offset!");
static_assert(offsetof(GameModeBase_FindPlayerStart, IncomingName) == 0x000008, "Member 'GameModeBase_FindPlayerStart::IncomingName' has a wrong offset!");
static_assert(offsetof(GameModeBase_FindPlayerStart, ReturnValue) == 0x000018, "Member 'GameModeBase_FindPlayerStart::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.GetDefaultPawnClassForController
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_GetDefaultPawnClassForController final
{
public:
	class AController*                            InController;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_GetDefaultPawnClassForController) == 0x000008, "Wrong alignment on GameModeBase_GetDefaultPawnClassForController");
static_assert(sizeof(GameModeBase_GetDefaultPawnClassForController) == 0x000010, "Wrong size on GameModeBase_GetDefaultPawnClassForController");
static_assert(offsetof(GameModeBase_GetDefaultPawnClassForController, InController) == 0x000000, "Member 'GameModeBase_GetDefaultPawnClassForController::InController' has a wrong offset!");
static_assert(offsetof(GameModeBase_GetDefaultPawnClassForController, ReturnValue) == 0x000008, "Member 'GameModeBase_GetDefaultPawnClassForController::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.GetNumPlayers
// 0x0004 (0x0004 - 0x0000)
struct GameModeBase_GetNumPlayers final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_GetNumPlayers) == 0x000004, "Wrong alignment on GameModeBase_GetNumPlayers");
static_assert(sizeof(GameModeBase_GetNumPlayers) == 0x000004, "Wrong size on GameModeBase_GetNumPlayers");
static_assert(offsetof(GameModeBase_GetNumPlayers, ReturnValue) == 0x000000, "Member 'GameModeBase_GetNumPlayers::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.GetNumSpectators
// 0x0004 (0x0004 - 0x0000)
struct GameModeBase_GetNumSpectators final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_GetNumSpectators) == 0x000004, "Wrong alignment on GameModeBase_GetNumSpectators");
static_assert(sizeof(GameModeBase_GetNumSpectators) == 0x000004, "Wrong size on GameModeBase_GetNumSpectators");
static_assert(offsetof(GameModeBase_GetNumSpectators, ReturnValue) == 0x000000, "Member 'GameModeBase_GetNumSpectators::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.HandleStartingNewPlayer
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_HandleStartingNewPlayer final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_HandleStartingNewPlayer) == 0x000008, "Wrong alignment on GameModeBase_HandleStartingNewPlayer");
static_assert(sizeof(GameModeBase_HandleStartingNewPlayer) == 0x000008, "Wrong size on GameModeBase_HandleStartingNewPlayer");
static_assert(offsetof(GameModeBase_HandleStartingNewPlayer, NewPlayer) == 0x000000, "Member 'GameModeBase_HandleStartingNewPlayer::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.InitializeHUDForPlayer
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_InitializeHUDForPlayer final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_InitializeHUDForPlayer) == 0x000008, "Wrong alignment on GameModeBase_InitializeHUDForPlayer");
static_assert(sizeof(GameModeBase_InitializeHUDForPlayer) == 0x000008, "Wrong size on GameModeBase_InitializeHUDForPlayer");
static_assert(offsetof(GameModeBase_InitializeHUDForPlayer, NewPlayer) == 0x000000, "Member 'GameModeBase_InitializeHUDForPlayer::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.InitStartSpot
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_InitStartSpot final
{
public:
	class AActor*                                 StartSpot;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            NewPlayer;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_InitStartSpot) == 0x000008, "Wrong alignment on GameModeBase_InitStartSpot");
static_assert(sizeof(GameModeBase_InitStartSpot) == 0x000010, "Wrong size on GameModeBase_InitStartSpot");
static_assert(offsetof(GameModeBase_InitStartSpot, StartSpot) == 0x000000, "Member 'GameModeBase_InitStartSpot::StartSpot' has a wrong offset!");
static_assert(offsetof(GameModeBase_InitStartSpot, NewPlayer) == 0x000008, "Member 'GameModeBase_InitStartSpot::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.K2_FindPlayerStart
// 0x0020 (0x0020 - 0x0000)
struct GameModeBase_K2_FindPlayerStart final
{
public:
	class AController*                            Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IncomingName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_K2_FindPlayerStart) == 0x000008, "Wrong alignment on GameModeBase_K2_FindPlayerStart");
static_assert(sizeof(GameModeBase_K2_FindPlayerStart) == 0x000020, "Wrong size on GameModeBase_K2_FindPlayerStart");
static_assert(offsetof(GameModeBase_K2_FindPlayerStart, Player) == 0x000000, "Member 'GameModeBase_K2_FindPlayerStart::Player' has a wrong offset!");
static_assert(offsetof(GameModeBase_K2_FindPlayerStart, IncomingName) == 0x000008, "Member 'GameModeBase_K2_FindPlayerStart::IncomingName' has a wrong offset!");
static_assert(offsetof(GameModeBase_K2_FindPlayerStart, ReturnValue) == 0x000018, "Member 'GameModeBase_K2_FindPlayerStart::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.K2_OnChangeName
// 0x0020 (0x0020 - 0x0000)
struct GameModeBase_K2_OnChangeName final
{
public:
	class AController*                            Other;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NewName;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNameChange;                                       // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_K2_OnChangeName) == 0x000008, "Wrong alignment on GameModeBase_K2_OnChangeName");
static_assert(sizeof(GameModeBase_K2_OnChangeName) == 0x000020, "Wrong size on GameModeBase_K2_OnChangeName");
static_assert(offsetof(GameModeBase_K2_OnChangeName, Other) == 0x000000, "Member 'GameModeBase_K2_OnChangeName::Other' has a wrong offset!");
static_assert(offsetof(GameModeBase_K2_OnChangeName, NewName) == 0x000008, "Member 'GameModeBase_K2_OnChangeName::NewName' has a wrong offset!");
static_assert(offsetof(GameModeBase_K2_OnChangeName, bNameChange) == 0x000018, "Member 'GameModeBase_K2_OnChangeName::bNameChange' has a wrong offset!");

// Function Engine.GameModeBase.K2_OnLogout
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_K2_OnLogout final
{
public:
	class AController*                            ExitingController;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_K2_OnLogout) == 0x000008, "Wrong alignment on GameModeBase_K2_OnLogout");
static_assert(sizeof(GameModeBase_K2_OnLogout) == 0x000008, "Wrong size on GameModeBase_K2_OnLogout");
static_assert(offsetof(GameModeBase_K2_OnLogout, ExitingController) == 0x000000, "Member 'GameModeBase_K2_OnLogout::ExitingController' has a wrong offset!");

// Function Engine.GameModeBase.K2_OnRestartPlayer
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_K2_OnRestartPlayer final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_K2_OnRestartPlayer) == 0x000008, "Wrong alignment on GameModeBase_K2_OnRestartPlayer");
static_assert(sizeof(GameModeBase_K2_OnRestartPlayer) == 0x000008, "Wrong size on GameModeBase_K2_OnRestartPlayer");
static_assert(offsetof(GameModeBase_K2_OnRestartPlayer, NewPlayer) == 0x000000, "Member 'GameModeBase_K2_OnRestartPlayer::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.K2_OnSwapPlayerControllers
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_K2_OnSwapPlayerControllers final
{
public:
	class APlayerController*                      OldPC;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      NewPC;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_K2_OnSwapPlayerControllers) == 0x000008, "Wrong alignment on GameModeBase_K2_OnSwapPlayerControllers");
static_assert(sizeof(GameModeBase_K2_OnSwapPlayerControllers) == 0x000010, "Wrong size on GameModeBase_K2_OnSwapPlayerControllers");
static_assert(offsetof(GameModeBase_K2_OnSwapPlayerControllers, OldPC) == 0x000000, "Member 'GameModeBase_K2_OnSwapPlayerControllers::OldPC' has a wrong offset!");
static_assert(offsetof(GameModeBase_K2_OnSwapPlayerControllers, NewPC) == 0x000008, "Member 'GameModeBase_K2_OnSwapPlayerControllers::NewPC' has a wrong offset!");

// Function Engine.GameModeBase.K2_PostLogin
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_K2_PostLogin final
{
public:
	class APlayerController*                      NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_K2_PostLogin) == 0x000008, "Wrong alignment on GameModeBase_K2_PostLogin");
static_assert(sizeof(GameModeBase_K2_PostLogin) == 0x000008, "Wrong size on GameModeBase_K2_PostLogin");
static_assert(offsetof(GameModeBase_K2_PostLogin, NewPlayer) == 0x000000, "Member 'GameModeBase_K2_PostLogin::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.PlayerCanRestart
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_PlayerCanRestart final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_PlayerCanRestart) == 0x000008, "Wrong alignment on GameModeBase_PlayerCanRestart");
static_assert(sizeof(GameModeBase_PlayerCanRestart) == 0x000010, "Wrong size on GameModeBase_PlayerCanRestart");
static_assert(offsetof(GameModeBase_PlayerCanRestart, Player) == 0x000000, "Member 'GameModeBase_PlayerCanRestart::Player' has a wrong offset!");
static_assert(offsetof(GameModeBase_PlayerCanRestart, ReturnValue) == 0x000008, "Member 'GameModeBase_PlayerCanRestart::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.RestartPlayer
// 0x0008 (0x0008 - 0x0000)
struct GameModeBase_RestartPlayer final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_RestartPlayer) == 0x000008, "Wrong alignment on GameModeBase_RestartPlayer");
static_assert(sizeof(GameModeBase_RestartPlayer) == 0x000008, "Wrong size on GameModeBase_RestartPlayer");
static_assert(offsetof(GameModeBase_RestartPlayer, NewPlayer) == 0x000000, "Member 'GameModeBase_RestartPlayer::NewPlayer' has a wrong offset!");

// Function Engine.GameModeBase.RestartPlayerAtPlayerStart
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_RestartPlayerAtPlayerStart final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartSpot;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_RestartPlayerAtPlayerStart) == 0x000008, "Wrong alignment on GameModeBase_RestartPlayerAtPlayerStart");
static_assert(sizeof(GameModeBase_RestartPlayerAtPlayerStart) == 0x000010, "Wrong size on GameModeBase_RestartPlayerAtPlayerStart");
static_assert(offsetof(GameModeBase_RestartPlayerAtPlayerStart, NewPlayer) == 0x000000, "Member 'GameModeBase_RestartPlayerAtPlayerStart::NewPlayer' has a wrong offset!");
static_assert(offsetof(GameModeBase_RestartPlayerAtPlayerStart, StartSpot) == 0x000008, "Member 'GameModeBase_RestartPlayerAtPlayerStart::StartSpot' has a wrong offset!");

// Function Engine.GameModeBase.RestartPlayerAtTransform
// 0x0040 (0x0040 - 0x0000)
struct GameModeBase_RestartPlayerAtTransform final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_RestartPlayerAtTransform) == 0x000010, "Wrong alignment on GameModeBase_RestartPlayerAtTransform");
static_assert(sizeof(GameModeBase_RestartPlayerAtTransform) == 0x000040, "Wrong size on GameModeBase_RestartPlayerAtTransform");
static_assert(offsetof(GameModeBase_RestartPlayerAtTransform, NewPlayer) == 0x000000, "Member 'GameModeBase_RestartPlayerAtTransform::NewPlayer' has a wrong offset!");
static_assert(offsetof(GameModeBase_RestartPlayerAtTransform, SpawnTransform) == 0x000010, "Member 'GameModeBase_RestartPlayerAtTransform::SpawnTransform' has a wrong offset!");

// Function Engine.GameModeBase.ShouldReset
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_ShouldReset final
{
public:
	class AActor*                                 ActorToReset;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_ShouldReset) == 0x000008, "Wrong alignment on GameModeBase_ShouldReset");
static_assert(sizeof(GameModeBase_ShouldReset) == 0x000010, "Wrong size on GameModeBase_ShouldReset");
static_assert(offsetof(GameModeBase_ShouldReset, ActorToReset) == 0x000000, "Member 'GameModeBase_ShouldReset::ActorToReset' has a wrong offset!");
static_assert(offsetof(GameModeBase_ShouldReset, ReturnValue) == 0x000008, "Member 'GameModeBase_ShouldReset::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.SpawnDefaultPawnAtTransform
// 0x0050 (0x0050 - 0x0000)
struct GameModeBase_SpawnDefaultPawnAtTransform final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_SpawnDefaultPawnAtTransform) == 0x000010, "Wrong alignment on GameModeBase_SpawnDefaultPawnAtTransform");
static_assert(sizeof(GameModeBase_SpawnDefaultPawnAtTransform) == 0x000050, "Wrong size on GameModeBase_SpawnDefaultPawnAtTransform");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnAtTransform, NewPlayer) == 0x000000, "Member 'GameModeBase_SpawnDefaultPawnAtTransform::NewPlayer' has a wrong offset!");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnAtTransform, SpawnTransform) == 0x000010, "Member 'GameModeBase_SpawnDefaultPawnAtTransform::SpawnTransform' has a wrong offset!");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnAtTransform, ReturnValue) == 0x000040, "Member 'GameModeBase_SpawnDefaultPawnAtTransform::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.SpawnDefaultPawnFor
// 0x0018 (0x0018 - 0x0000)
struct GameModeBase_SpawnDefaultPawnFor final
{
public:
	class AController*                            NewPlayer;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 StartSpot;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APawn*                                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_SpawnDefaultPawnFor) == 0x000008, "Wrong alignment on GameModeBase_SpawnDefaultPawnFor");
static_assert(sizeof(GameModeBase_SpawnDefaultPawnFor) == 0x000018, "Wrong size on GameModeBase_SpawnDefaultPawnFor");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnFor, NewPlayer) == 0x000000, "Member 'GameModeBase_SpawnDefaultPawnFor::NewPlayer' has a wrong offset!");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnFor, StartSpot) == 0x000008, "Member 'GameModeBase_SpawnDefaultPawnFor::StartSpot' has a wrong offset!");
static_assert(offsetof(GameModeBase_SpawnDefaultPawnFor, ReturnValue) == 0x000010, "Member 'GameModeBase_SpawnDefaultPawnFor::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.HasMatchStarted
// 0x0001 (0x0001 - 0x0000)
struct GameModeBase_HasMatchStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameModeBase_HasMatchStarted) == 0x000001, "Wrong alignment on GameModeBase_HasMatchStarted");
static_assert(sizeof(GameModeBase_HasMatchStarted) == 0x000001, "Wrong size on GameModeBase_HasMatchStarted");
static_assert(offsetof(GameModeBase_HasMatchStarted, ReturnValue) == 0x000000, "Member 'GameModeBase_HasMatchStarted::ReturnValue' has a wrong offset!");

// Function Engine.GameModeBase.MustSpectate
// 0x0010 (0x0010 - 0x0000)
struct GameModeBase_MustSpectate final
{
public:
	class APlayerController*                      NewPlayerController;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameModeBase_MustSpectate) == 0x000008, "Wrong alignment on GameModeBase_MustSpectate");
static_assert(sizeof(GameModeBase_MustSpectate) == 0x000010, "Wrong size on GameModeBase_MustSpectate");
static_assert(offsetof(GameModeBase_MustSpectate, NewPlayerController) == 0x000000, "Member 'GameModeBase_MustSpectate::NewPlayerController' has a wrong offset!");
static_assert(offsetof(GameModeBase_MustSpectate, ReturnValue) == 0x000008, "Member 'GameModeBase_MustSpectate::ReturnValue' has a wrong offset!");

// Function Engine.GameMode.K2_OnSetMatchState
// 0x0008 (0x0008 - 0x0000)
struct GameMode_K2_OnSetMatchState final
{
public:
	class FName                                   NewState;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_K2_OnSetMatchState) == 0x000004, "Wrong alignment on GameMode_K2_OnSetMatchState");
static_assert(sizeof(GameMode_K2_OnSetMatchState) == 0x000008, "Wrong size on GameMode_K2_OnSetMatchState");
static_assert(offsetof(GameMode_K2_OnSetMatchState, NewState) == 0x000000, "Member 'GameMode_K2_OnSetMatchState::NewState' has a wrong offset!");

// Function Engine.GameMode.ReadyToEndMatch
// 0x0001 (0x0001 - 0x0000)
struct GameMode_ReadyToEndMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_ReadyToEndMatch) == 0x000001, "Wrong alignment on GameMode_ReadyToEndMatch");
static_assert(sizeof(GameMode_ReadyToEndMatch) == 0x000001, "Wrong size on GameMode_ReadyToEndMatch");
static_assert(offsetof(GameMode_ReadyToEndMatch, ReturnValue) == 0x000000, "Member 'GameMode_ReadyToEndMatch::ReturnValue' has a wrong offset!");

// Function Engine.GameMode.ReadyToStartMatch
// 0x0001 (0x0001 - 0x0000)
struct GameMode_ReadyToStartMatch final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_ReadyToStartMatch) == 0x000001, "Wrong alignment on GameMode_ReadyToStartMatch");
static_assert(sizeof(GameMode_ReadyToStartMatch) == 0x000001, "Wrong size on GameMode_ReadyToStartMatch");
static_assert(offsetof(GameMode_ReadyToStartMatch, ReturnValue) == 0x000000, "Member 'GameMode_ReadyToStartMatch::ReturnValue' has a wrong offset!");

// Function Engine.GameMode.Say
// 0x0010 (0x0010 - 0x0000)
struct GameMode_Say final
{
public:
	class FString                                 Msg;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_Say) == 0x000008, "Wrong alignment on GameMode_Say");
static_assert(sizeof(GameMode_Say) == 0x000010, "Wrong size on GameMode_Say");
static_assert(offsetof(GameMode_Say, Msg) == 0x000000, "Member 'GameMode_Say::Msg' has a wrong offset!");

// Function Engine.GameMode.SetBandwidthLimit
// 0x0004 (0x0004 - 0x0000)
struct GameMode_SetBandwidthLimit final
{
public:
	float                                         AsyncIOBandwidthLimit;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_SetBandwidthLimit) == 0x000004, "Wrong alignment on GameMode_SetBandwidthLimit");
static_assert(sizeof(GameMode_SetBandwidthLimit) == 0x000004, "Wrong size on GameMode_SetBandwidthLimit");
static_assert(offsetof(GameMode_SetBandwidthLimit, AsyncIOBandwidthLimit) == 0x000000, "Member 'GameMode_SetBandwidthLimit::AsyncIOBandwidthLimit' has a wrong offset!");

// Function Engine.GameMode.GetMatchState
// 0x0008 (0x0008 - 0x0000)
struct GameMode_GetMatchState final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_GetMatchState) == 0x000004, "Wrong alignment on GameMode_GetMatchState");
static_assert(sizeof(GameMode_GetMatchState) == 0x000008, "Wrong size on GameMode_GetMatchState");
static_assert(offsetof(GameMode_GetMatchState, ReturnValue) == 0x000000, "Member 'GameMode_GetMatchState::ReturnValue' has a wrong offset!");

// Function Engine.GameMode.HasMatchEnded
// 0x0001 (0x0001 - 0x0000)
struct GameMode_HasMatchEnded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_HasMatchEnded) == 0x000001, "Wrong alignment on GameMode_HasMatchEnded");
static_assert(sizeof(GameMode_HasMatchEnded) == 0x000001, "Wrong size on GameMode_HasMatchEnded");
static_assert(offsetof(GameMode_HasMatchEnded, ReturnValue) == 0x000000, "Member 'GameMode_HasMatchEnded::ReturnValue' has a wrong offset!");

// Function Engine.GameMode.IsMatchInProgress
// 0x0001 (0x0001 - 0x0000)
struct GameMode_IsMatchInProgress final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameMode_IsMatchInProgress) == 0x000001, "Wrong alignment on GameMode_IsMatchInProgress");
static_assert(sizeof(GameMode_IsMatchInProgress) == 0x000001, "Wrong size on GameMode_IsMatchInProgress");
static_assert(offsetof(GameMode_IsMatchInProgress, ReturnValue) == 0x000000, "Member 'GameMode_IsMatchInProgress::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.DetachFromParent
// 0x0002 (0x0002 - 0x0000)
struct SceneComponent_DetachFromParent final
{
public:
	bool                                          bMaintainWorldPosition;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCallModify;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_DetachFromParent) == 0x000001, "Wrong alignment on SceneComponent_DetachFromParent");
static_assert(sizeof(SceneComponent_DetachFromParent) == 0x000002, "Wrong size on SceneComponent_DetachFromParent");
static_assert(offsetof(SceneComponent_DetachFromParent, bMaintainWorldPosition) == 0x000000, "Member 'SceneComponent_DetachFromParent::bMaintainWorldPosition' has a wrong offset!");
static_assert(offsetof(SceneComponent_DetachFromParent, bCallModify) == 0x000001, "Member 'SceneComponent_DetachFromParent::bCallModify' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddLocalOffset
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddLocalOffset final
{
public:
	struct FVector                                DeltaLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddLocalOffset) == 0x000008, "Wrong alignment on SceneComponent_K2_AddLocalOffset");
static_assert(sizeof(SceneComponent_K2_AddLocalOffset) == 0x0000A0, "Wrong size on SceneComponent_K2_AddLocalOffset");
static_assert(offsetof(SceneComponent_K2_AddLocalOffset, DeltaLocation) == 0x000000, "Member 'SceneComponent_K2_AddLocalOffset::DeltaLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalOffset, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddLocalOffset::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalOffset, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddLocalOffset::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalOffset, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddLocalOffset::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddLocalRotation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddLocalRotation final
{
public:
	struct FRotator                               DeltaRotation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddLocalRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_AddLocalRotation");
static_assert(sizeof(SceneComponent_K2_AddLocalRotation) == 0x0000A0, "Wrong size on SceneComponent_K2_AddLocalRotation");
static_assert(offsetof(SceneComponent_K2_AddLocalRotation, DeltaRotation) == 0x000000, "Member 'SceneComponent_K2_AddLocalRotation::DeltaRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalRotation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddLocalRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalRotation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddLocalRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalRotation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddLocalRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddLocalTransform
// 0x00D0 (0x00D0 - 0x0000)
struct SceneComponent_K2_AddLocalTransform final
{
public:
	struct FTransform                             DeltaTransform;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddLocalTransform) == 0x000010, "Wrong alignment on SceneComponent_K2_AddLocalTransform");
static_assert(sizeof(SceneComponent_K2_AddLocalTransform) == 0x0000D0, "Wrong size on SceneComponent_K2_AddLocalTransform");
static_assert(offsetof(SceneComponent_K2_AddLocalTransform, DeltaTransform) == 0x000000, "Member 'SceneComponent_K2_AddLocalTransform::DeltaTransform' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalTransform, bSweep) == 0x000030, "Member 'SceneComponent_K2_AddLocalTransform::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalTransform, SweepHitResult) == 0x000038, "Member 'SceneComponent_K2_AddLocalTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddLocalTransform, bTeleport) == 0x0000C0, "Member 'SceneComponent_K2_AddLocalTransform::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddRelativeLocation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddRelativeLocation final
{
public:
	struct FVector                                DeltaLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddRelativeLocation) == 0x000008, "Wrong alignment on SceneComponent_K2_AddRelativeLocation");
static_assert(sizeof(SceneComponent_K2_AddRelativeLocation) == 0x0000A0, "Wrong size on SceneComponent_K2_AddRelativeLocation");
static_assert(offsetof(SceneComponent_K2_AddRelativeLocation, DeltaLocation) == 0x000000, "Member 'SceneComponent_K2_AddRelativeLocation::DeltaLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeLocation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddRelativeLocation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeLocation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddRelativeLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeLocation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddRelativeLocation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddRelativeRotation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddRelativeRotation final
{
public:
	struct FRotator                               DeltaRotation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddRelativeRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_AddRelativeRotation");
static_assert(sizeof(SceneComponent_K2_AddRelativeRotation) == 0x0000A0, "Wrong size on SceneComponent_K2_AddRelativeRotation");
static_assert(offsetof(SceneComponent_K2_AddRelativeRotation, DeltaRotation) == 0x000000, "Member 'SceneComponent_K2_AddRelativeRotation::DeltaRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeRotation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddRelativeRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeRotation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddRelativeRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddRelativeRotation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddRelativeRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddWorldOffset
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddWorldOffset final
{
public:
	struct FVector                                DeltaLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddWorldOffset) == 0x000008, "Wrong alignment on SceneComponent_K2_AddWorldOffset");
static_assert(sizeof(SceneComponent_K2_AddWorldOffset) == 0x0000A0, "Wrong size on SceneComponent_K2_AddWorldOffset");
static_assert(offsetof(SceneComponent_K2_AddWorldOffset, DeltaLocation) == 0x000000, "Member 'SceneComponent_K2_AddWorldOffset::DeltaLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldOffset, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddWorldOffset::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldOffset, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddWorldOffset::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldOffset, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddWorldOffset::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddWorldRotation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_AddWorldRotation final
{
public:
	struct FRotator                               DeltaRotation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddWorldRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_AddWorldRotation");
static_assert(sizeof(SceneComponent_K2_AddWorldRotation) == 0x0000A0, "Wrong size on SceneComponent_K2_AddWorldRotation");
static_assert(offsetof(SceneComponent_K2_AddWorldRotation, DeltaRotation) == 0x000000, "Member 'SceneComponent_K2_AddWorldRotation::DeltaRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldRotation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_AddWorldRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldRotation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_AddWorldRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldRotation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_AddWorldRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AddWorldTransform
// 0x00D0 (0x00D0 - 0x0000)
struct SceneComponent_K2_AddWorldTransform final
{
public:
	struct FTransform                             DeltaTransform;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AddWorldTransform) == 0x000010, "Wrong alignment on SceneComponent_K2_AddWorldTransform");
static_assert(sizeof(SceneComponent_K2_AddWorldTransform) == 0x0000D0, "Wrong size on SceneComponent_K2_AddWorldTransform");
static_assert(offsetof(SceneComponent_K2_AddWorldTransform, DeltaTransform) == 0x000000, "Member 'SceneComponent_K2_AddWorldTransform::DeltaTransform' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldTransform, bSweep) == 0x000030, "Member 'SceneComponent_K2_AddWorldTransform::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldTransform, SweepHitResult) == 0x000038, "Member 'SceneComponent_K2_AddWorldTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AddWorldTransform, bTeleport) == 0x0000C0, "Member 'SceneComponent_K2_AddWorldTransform::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_AttachTo
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_K2_AttachTo final
{
public:
	class USceneComponent*                        InParent;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               AttachType;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0012(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AttachTo) == 0x000008, "Wrong alignment on SceneComponent_K2_AttachTo");
static_assert(sizeof(SceneComponent_K2_AttachTo) == 0x000018, "Wrong size on SceneComponent_K2_AttachTo");
static_assert(offsetof(SceneComponent_K2_AttachTo, InParent) == 0x000000, "Member 'SceneComponent_K2_AttachTo::InParent' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachTo, InSocketName) == 0x000008, "Member 'SceneComponent_K2_AttachTo::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachTo, AttachType) == 0x000010, "Member 'SceneComponent_K2_AttachTo::AttachType' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachTo, bWeldSimulatedBodies) == 0x000011, "Member 'SceneComponent_K2_AttachTo::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachTo, ReturnValue) == 0x000012, "Member 'SceneComponent_K2_AttachTo::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_AttachToComponent
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_K2_AttachToComponent final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bWeldSimulatedBodies;                              // 0x0013(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_AttachToComponent) == 0x000008, "Wrong alignment on SceneComponent_K2_AttachToComponent");
static_assert(sizeof(SceneComponent_K2_AttachToComponent) == 0x000018, "Wrong size on SceneComponent_K2_AttachToComponent");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, Parent) == 0x000000, "Member 'SceneComponent_K2_AttachToComponent::Parent' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, SocketName) == 0x000008, "Member 'SceneComponent_K2_AttachToComponent::SocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, LocationRule) == 0x000010, "Member 'SceneComponent_K2_AttachToComponent::LocationRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, RotationRule) == 0x000011, "Member 'SceneComponent_K2_AttachToComponent::RotationRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, ScaleRule) == 0x000012, "Member 'SceneComponent_K2_AttachToComponent::ScaleRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, bWeldSimulatedBodies) == 0x000013, "Member 'SceneComponent_K2_AttachToComponent::bWeldSimulatedBodies' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_AttachToComponent, ReturnValue) == 0x000014, "Member 'SceneComponent_K2_AttachToComponent::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_DetachFromComponent
// 0x0004 (0x0004 - 0x0000)
struct SceneComponent_K2_DetachFromComponent final
{
public:
	EDetachmentRule                               LocationRule;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               RotationRule;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDetachmentRule                               ScaleRule;                                         // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCallModify;                                       // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_K2_DetachFromComponent) == 0x000001, "Wrong alignment on SceneComponent_K2_DetachFromComponent");
static_assert(sizeof(SceneComponent_K2_DetachFromComponent) == 0x000004, "Wrong size on SceneComponent_K2_DetachFromComponent");
static_assert(offsetof(SceneComponent_K2_DetachFromComponent, LocationRule) == 0x000000, "Member 'SceneComponent_K2_DetachFromComponent::LocationRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_DetachFromComponent, RotationRule) == 0x000001, "Member 'SceneComponent_K2_DetachFromComponent::RotationRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_DetachFromComponent, ScaleRule) == 0x000002, "Member 'SceneComponent_K2_DetachFromComponent::ScaleRule' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_DetachFromComponent, bCallModify) == 0x000003, "Member 'SceneComponent_K2_DetachFromComponent::bCallModify' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetRelativeLocation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_SetRelativeLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetRelativeLocation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetRelativeLocation");
static_assert(sizeof(SceneComponent_K2_SetRelativeLocation) == 0x0000A0, "Wrong size on SceneComponent_K2_SetRelativeLocation");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocation, NewLocation) == 0x000000, "Member 'SceneComponent_K2_SetRelativeLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_SetRelativeLocation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_SetRelativeLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_SetRelativeLocation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetRelativeLocationAndRotation
// 0x00B0 (0x00B0 - 0x0000)
struct SceneComponent_K2_SetRelativeLocationAndRotation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0020(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetRelativeLocationAndRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetRelativeLocationAndRotation");
static_assert(sizeof(SceneComponent_K2_SetRelativeLocationAndRotation) == 0x0000B0, "Wrong size on SceneComponent_K2_SetRelativeLocationAndRotation");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocationAndRotation, NewLocation) == 0x000000, "Member 'SceneComponent_K2_SetRelativeLocationAndRotation::NewLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocationAndRotation, NewRotation) == 0x00000C, "Member 'SceneComponent_K2_SetRelativeLocationAndRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocationAndRotation, bSweep) == 0x000018, "Member 'SceneComponent_K2_SetRelativeLocationAndRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocationAndRotation, SweepHitResult) == 0x000020, "Member 'SceneComponent_K2_SetRelativeLocationAndRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeLocationAndRotation, bTeleport) == 0x0000A8, "Member 'SceneComponent_K2_SetRelativeLocationAndRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetRelativeRotation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_SetRelativeRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetRelativeRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetRelativeRotation");
static_assert(sizeof(SceneComponent_K2_SetRelativeRotation) == 0x0000A0, "Wrong size on SceneComponent_K2_SetRelativeRotation");
static_assert(offsetof(SceneComponent_K2_SetRelativeRotation, NewRotation) == 0x000000, "Member 'SceneComponent_K2_SetRelativeRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeRotation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_SetRelativeRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeRotation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_SetRelativeRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeRotation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_SetRelativeRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetRelativeTransform
// 0x00D0 (0x00D0 - 0x0000)
struct SceneComponent_K2_SetRelativeTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetRelativeTransform) == 0x000010, "Wrong alignment on SceneComponent_K2_SetRelativeTransform");
static_assert(sizeof(SceneComponent_K2_SetRelativeTransform) == 0x0000D0, "Wrong size on SceneComponent_K2_SetRelativeTransform");
static_assert(offsetof(SceneComponent_K2_SetRelativeTransform, NewTransform) == 0x000000, "Member 'SceneComponent_K2_SetRelativeTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeTransform, bSweep) == 0x000030, "Member 'SceneComponent_K2_SetRelativeTransform::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeTransform, SweepHitResult) == 0x000038, "Member 'SceneComponent_K2_SetRelativeTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetRelativeTransform, bTeleport) == 0x0000C0, "Member 'SceneComponent_K2_SetRelativeTransform::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetWorldLocation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_SetWorldLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetWorldLocation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetWorldLocation");
static_assert(sizeof(SceneComponent_K2_SetWorldLocation) == 0x0000A0, "Wrong size on SceneComponent_K2_SetWorldLocation");
static_assert(offsetof(SceneComponent_K2_SetWorldLocation, NewLocation) == 0x000000, "Member 'SceneComponent_K2_SetWorldLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_SetWorldLocation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_SetWorldLocation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_SetWorldLocation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetWorldLocationAndRotation
// 0x00B0 (0x00B0 - 0x0000)
struct SceneComponent_K2_SetWorldLocationAndRotation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0020(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00A8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetWorldLocationAndRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetWorldLocationAndRotation");
static_assert(sizeof(SceneComponent_K2_SetWorldLocationAndRotation) == 0x0000B0, "Wrong size on SceneComponent_K2_SetWorldLocationAndRotation");
static_assert(offsetof(SceneComponent_K2_SetWorldLocationAndRotation, NewLocation) == 0x000000, "Member 'SceneComponent_K2_SetWorldLocationAndRotation::NewLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocationAndRotation, NewRotation) == 0x00000C, "Member 'SceneComponent_K2_SetWorldLocationAndRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocationAndRotation, bSweep) == 0x000018, "Member 'SceneComponent_K2_SetWorldLocationAndRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocationAndRotation, SweepHitResult) == 0x000020, "Member 'SceneComponent_K2_SetWorldLocationAndRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldLocationAndRotation, bTeleport) == 0x0000A8, "Member 'SceneComponent_K2_SetWorldLocationAndRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetWorldRotation
// 0x00A0 (0x00A0 - 0x0000)
struct SceneComponent_K2_SetWorldRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0010(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0098(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetWorldRotation) == 0x000008, "Wrong alignment on SceneComponent_K2_SetWorldRotation");
static_assert(sizeof(SceneComponent_K2_SetWorldRotation) == 0x0000A0, "Wrong size on SceneComponent_K2_SetWorldRotation");
static_assert(offsetof(SceneComponent_K2_SetWorldRotation, NewRotation) == 0x000000, "Member 'SceneComponent_K2_SetWorldRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldRotation, bSweep) == 0x00000C, "Member 'SceneComponent_K2_SetWorldRotation::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldRotation, SweepHitResult) == 0x000010, "Member 'SceneComponent_K2_SetWorldRotation::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldRotation, bTeleport) == 0x000098, "Member 'SceneComponent_K2_SetWorldRotation::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.K2_SetWorldTransform
// 0x00D0 (0x00D0 - 0x0000)
struct SceneComponent_K2_SetWorldTransform final
{
public:
	struct FTransform                             NewTransform;                                      // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bSweep;                                            // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepHitResult;                                    // 0x0038(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x00C0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C1[0xF];                                       // 0x00C1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_K2_SetWorldTransform) == 0x000010, "Wrong alignment on SceneComponent_K2_SetWorldTransform");
static_assert(sizeof(SceneComponent_K2_SetWorldTransform) == 0x0000D0, "Wrong size on SceneComponent_K2_SetWorldTransform");
static_assert(offsetof(SceneComponent_K2_SetWorldTransform, NewTransform) == 0x000000, "Member 'SceneComponent_K2_SetWorldTransform::NewTransform' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldTransform, bSweep) == 0x000030, "Member 'SceneComponent_K2_SetWorldTransform::bSweep' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldTransform, SweepHitResult) == 0x000038, "Member 'SceneComponent_K2_SetWorldTransform::SweepHitResult' has a wrong offset!");
static_assert(offsetof(SceneComponent_K2_SetWorldTransform, bTeleport) == 0x0000C0, "Member 'SceneComponent_K2_SetWorldTransform::bTeleport' has a wrong offset!");

// Function Engine.SceneComponent.OnRep_Visibility
// 0x0001 (0x0001 - 0x0000)
struct SceneComponent_OnRep_Visibility final
{
public:
	bool                                          OldValue;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_OnRep_Visibility) == 0x000001, "Wrong alignment on SceneComponent_OnRep_Visibility");
static_assert(sizeof(SceneComponent_OnRep_Visibility) == 0x000001, "Wrong size on SceneComponent_OnRep_Visibility");
static_assert(offsetof(SceneComponent_OnRep_Visibility, OldValue) == 0x000000, "Member 'SceneComponent_OnRep_Visibility::OldValue' has a wrong offset!");

// Function Engine.SceneComponent.SetAbsolute
// 0x0003 (0x0003 - 0x0000)
struct SceneComponent_SetAbsolute final
{
public:
	bool                                          bNewAbsoluteLocation;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewAbsoluteRotation;                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewAbsoluteScale;                                 // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_SetAbsolute) == 0x000001, "Wrong alignment on SceneComponent_SetAbsolute");
static_assert(sizeof(SceneComponent_SetAbsolute) == 0x000003, "Wrong size on SceneComponent_SetAbsolute");
static_assert(offsetof(SceneComponent_SetAbsolute, bNewAbsoluteLocation) == 0x000000, "Member 'SceneComponent_SetAbsolute::bNewAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(SceneComponent_SetAbsolute, bNewAbsoluteRotation) == 0x000001, "Member 'SceneComponent_SetAbsolute::bNewAbsoluteRotation' has a wrong offset!");
static_assert(offsetof(SceneComponent_SetAbsolute, bNewAbsoluteScale) == 0x000002, "Member 'SceneComponent_SetAbsolute::bNewAbsoluteScale' has a wrong offset!");

// Function Engine.SceneComponent.SetHiddenInGame
// 0x0002 (0x0002 - 0x0000)
struct SceneComponent_SetHiddenInGame final
{
public:
	bool                                          NewHidden;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_SetHiddenInGame) == 0x000001, "Wrong alignment on SceneComponent_SetHiddenInGame");
static_assert(sizeof(SceneComponent_SetHiddenInGame) == 0x000002, "Wrong size on SceneComponent_SetHiddenInGame");
static_assert(offsetof(SceneComponent_SetHiddenInGame, NewHidden) == 0x000000, "Member 'SceneComponent_SetHiddenInGame::NewHidden' has a wrong offset!");
static_assert(offsetof(SceneComponent_SetHiddenInGame, bPropagateToChildren) == 0x000001, "Member 'SceneComponent_SetHiddenInGame::bPropagateToChildren' has a wrong offset!");

// Function Engine.SceneComponent.SetRelativeScale3D
// 0x000C (0x000C - 0x0000)
struct SceneComponent_SetRelativeScale3D final
{
public:
	struct FVector                                NewScale3D;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_SetRelativeScale3D) == 0x000004, "Wrong alignment on SceneComponent_SetRelativeScale3D");
static_assert(sizeof(SceneComponent_SetRelativeScale3D) == 0x00000C, "Wrong size on SceneComponent_SetRelativeScale3D");
static_assert(offsetof(SceneComponent_SetRelativeScale3D, NewScale3D) == 0x000000, "Member 'SceneComponent_SetRelativeScale3D::NewScale3D' has a wrong offset!");

// Function Engine.SceneComponent.SetVisibility
// 0x0003 (0x0003 - 0x0000)
struct SceneComponent_SetVisibility final
{
public:
	bool                                          bNewVisibility;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPropagateToChildren;                              // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeInVisibleIfPossible;                          // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_SetVisibility) == 0x000001, "Wrong alignment on SceneComponent_SetVisibility");
static_assert(sizeof(SceneComponent_SetVisibility) == 0x000003, "Wrong size on SceneComponent_SetVisibility");
static_assert(offsetof(SceneComponent_SetVisibility, bNewVisibility) == 0x000000, "Member 'SceneComponent_SetVisibility::bNewVisibility' has a wrong offset!");
static_assert(offsetof(SceneComponent_SetVisibility, bPropagateToChildren) == 0x000001, "Member 'SceneComponent_SetVisibility::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(SceneComponent_SetVisibility, bFadeInVisibleIfPossible) == 0x000002, "Member 'SceneComponent_SetVisibility::bFadeInVisibleIfPossible' has a wrong offset!");

// Function Engine.SceneComponent.SetWorldScale3D
// 0x000C (0x000C - 0x0000)
struct SceneComponent_SetWorldScale3D final
{
public:
	struct FVector                                NewScale;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_SetWorldScale3D) == 0x000004, "Wrong alignment on SceneComponent_SetWorldScale3D");
static_assert(sizeof(SceneComponent_SetWorldScale3D) == 0x00000C, "Wrong size on SceneComponent_SetWorldScale3D");
static_assert(offsetof(SceneComponent_SetWorldScale3D, NewScale) == 0x000000, "Member 'SceneComponent_SetWorldScale3D::NewScale' has a wrong offset!");

// Function Engine.SceneComponent.SnapTo
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_SnapTo final
{
public:
	class USceneComponent*                        InParent;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSocketName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_SnapTo) == 0x000008, "Wrong alignment on SceneComponent_SnapTo");
static_assert(sizeof(SceneComponent_SnapTo) == 0x000018, "Wrong size on SceneComponent_SnapTo");
static_assert(offsetof(SceneComponent_SnapTo, InParent) == 0x000000, "Member 'SceneComponent_SnapTo::InParent' has a wrong offset!");
static_assert(offsetof(SceneComponent_SnapTo, InSocketName) == 0x000008, "Member 'SceneComponent_SnapTo::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_SnapTo, ReturnValue) == 0x000010, "Member 'SceneComponent_SnapTo::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.ToggleVisibility
// 0x0002 (0x0002 - 0x0000)
struct SceneComponent_ToggleVisibility final
{
public:
	bool                                          bPropagateToChildren;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeInVisibleIfPossible;                          // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_ToggleVisibility) == 0x000001, "Wrong alignment on SceneComponent_ToggleVisibility");
static_assert(sizeof(SceneComponent_ToggleVisibility) == 0x000002, "Wrong size on SceneComponent_ToggleVisibility");
static_assert(offsetof(SceneComponent_ToggleVisibility, bPropagateToChildren) == 0x000000, "Member 'SceneComponent_ToggleVisibility::bPropagateToChildren' has a wrong offset!");
static_assert(offsetof(SceneComponent_ToggleVisibility, bFadeInVisibleIfPossible) == 0x000001, "Member 'SceneComponent_ToggleVisibility::bFadeInVisibleIfPossible' has a wrong offset!");

// Function Engine.SceneComponent.DoesSocketExist
// 0x0010 (0x0010 - 0x0000)
struct SceneComponent_DoesSocketExist final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_DoesSocketExist) == 0x000004, "Wrong alignment on SceneComponent_DoesSocketExist");
static_assert(sizeof(SceneComponent_DoesSocketExist) == 0x000010, "Wrong size on SceneComponent_DoesSocketExist");
static_assert(offsetof(SceneComponent_DoesSocketExist, InSocketName) == 0x000000, "Member 'SceneComponent_DoesSocketExist::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_DoesSocketExist, ReturnValue) == 0x000008, "Member 'SceneComponent_DoesSocketExist::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetAllSocketNames
// 0x0010 (0x0010 - 0x0000)
struct SceneComponent_GetAllSocketNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetAllSocketNames) == 0x000008, "Wrong alignment on SceneComponent_GetAllSocketNames");
static_assert(sizeof(SceneComponent_GetAllSocketNames) == 0x000010, "Wrong size on SceneComponent_GetAllSocketNames");
static_assert(offsetof(SceneComponent_GetAllSocketNames, ReturnValue) == 0x000000, "Member 'SceneComponent_GetAllSocketNames::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetAttachParent
// 0x0008 (0x0008 - 0x0000)
struct SceneComponent_GetAttachParent final
{
public:
	class USceneComponent*                        ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetAttachParent) == 0x000008, "Wrong alignment on SceneComponent_GetAttachParent");
static_assert(sizeof(SceneComponent_GetAttachParent) == 0x000008, "Wrong size on SceneComponent_GetAttachParent");
static_assert(offsetof(SceneComponent_GetAttachParent, ReturnValue) == 0x000000, "Member 'SceneComponent_GetAttachParent::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetAttachSocketName
// 0x0008 (0x0008 - 0x0000)
struct SceneComponent_GetAttachSocketName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetAttachSocketName) == 0x000004, "Wrong alignment on SceneComponent_GetAttachSocketName");
static_assert(sizeof(SceneComponent_GetAttachSocketName) == 0x000008, "Wrong size on SceneComponent_GetAttachSocketName");
static_assert(offsetof(SceneComponent_GetAttachSocketName, ReturnValue) == 0x000000, "Member 'SceneComponent_GetAttachSocketName::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetChildComponent
// 0x0010 (0x0010 - 0x0000)
struct SceneComponent_GetChildComponent final
{
public:
	int32                                         ChildIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        ReturnValue;                                       // 0x0008(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetChildComponent) == 0x000008, "Wrong alignment on SceneComponent_GetChildComponent");
static_assert(sizeof(SceneComponent_GetChildComponent) == 0x000010, "Wrong size on SceneComponent_GetChildComponent");
static_assert(offsetof(SceneComponent_GetChildComponent, ChildIndex) == 0x000000, "Member 'SceneComponent_GetChildComponent::ChildIndex' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetChildComponent, ReturnValue) == 0x000008, "Member 'SceneComponent_GetChildComponent::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetChildrenComponents
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_GetChildrenComponents final
{
public:
	bool                                          bIncludeAllDescendants;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class USceneComponent*>                Children;                                          // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetChildrenComponents) == 0x000008, "Wrong alignment on SceneComponent_GetChildrenComponents");
static_assert(sizeof(SceneComponent_GetChildrenComponents) == 0x000018, "Wrong size on SceneComponent_GetChildrenComponents");
static_assert(offsetof(SceneComponent_GetChildrenComponents, bIncludeAllDescendants) == 0x000000, "Member 'SceneComponent_GetChildrenComponents::bIncludeAllDescendants' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetChildrenComponents, Children) == 0x000008, "Member 'SceneComponent_GetChildrenComponents::Children' has a wrong offset!");

// Function Engine.SceneComponent.GetComponentVelocity
// 0x000C (0x000C - 0x0000)
struct SceneComponent_GetComponentVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetComponentVelocity) == 0x000004, "Wrong alignment on SceneComponent_GetComponentVelocity");
static_assert(sizeof(SceneComponent_GetComponentVelocity) == 0x00000C, "Wrong size on SceneComponent_GetComponentVelocity");
static_assert(offsetof(SceneComponent_GetComponentVelocity, ReturnValue) == 0x000000, "Member 'SceneComponent_GetComponentVelocity::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetForwardVector
// 0x000C (0x000C - 0x0000)
struct SceneComponent_GetForwardVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetForwardVector) == 0x000004, "Wrong alignment on SceneComponent_GetForwardVector");
static_assert(sizeof(SceneComponent_GetForwardVector) == 0x00000C, "Wrong size on SceneComponent_GetForwardVector");
static_assert(offsetof(SceneComponent_GetForwardVector, ReturnValue) == 0x000000, "Member 'SceneComponent_GetForwardVector::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetNumChildrenComponents
// 0x0004 (0x0004 - 0x0000)
struct SceneComponent_GetNumChildrenComponents final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetNumChildrenComponents) == 0x000004, "Wrong alignment on SceneComponent_GetNumChildrenComponents");
static_assert(sizeof(SceneComponent_GetNumChildrenComponents) == 0x000004, "Wrong size on SceneComponent_GetNumChildrenComponents");
static_assert(offsetof(SceneComponent_GetNumChildrenComponents, ReturnValue) == 0x000000, "Member 'SceneComponent_GetNumChildrenComponents::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetParentComponents
// 0x0010 (0x0010 - 0x0000)
struct SceneComponent_GetParentComponents final
{
public:
	TArray<class USceneComponent*>                Parents;                                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetParentComponents) == 0x000008, "Wrong alignment on SceneComponent_GetParentComponents");
static_assert(sizeof(SceneComponent_GetParentComponents) == 0x000010, "Wrong size on SceneComponent_GetParentComponents");
static_assert(offsetof(SceneComponent_GetParentComponents, Parents) == 0x000000, "Member 'SceneComponent_GetParentComponents::Parents' has a wrong offset!");

// Function Engine.SceneComponent.GetPhysicsVolume
// 0x0008 (0x0008 - 0x0000)
struct SceneComponent_GetPhysicsVolume final
{
public:
	class APhysicsVolume*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetPhysicsVolume) == 0x000008, "Wrong alignment on SceneComponent_GetPhysicsVolume");
static_assert(sizeof(SceneComponent_GetPhysicsVolume) == 0x000008, "Wrong size on SceneComponent_GetPhysicsVolume");
static_assert(offsetof(SceneComponent_GetPhysicsVolume, ReturnValue) == 0x000000, "Member 'SceneComponent_GetPhysicsVolume::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetRelativeTransform
// 0x0030 (0x0030 - 0x0000)
struct SceneComponent_GetRelativeTransform final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetRelativeTransform) == 0x000010, "Wrong alignment on SceneComponent_GetRelativeTransform");
static_assert(sizeof(SceneComponent_GetRelativeTransform) == 0x000030, "Wrong size on SceneComponent_GetRelativeTransform");
static_assert(offsetof(SceneComponent_GetRelativeTransform, ReturnValue) == 0x000000, "Member 'SceneComponent_GetRelativeTransform::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetRightVector
// 0x000C (0x000C - 0x0000)
struct SceneComponent_GetRightVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetRightVector) == 0x000004, "Wrong alignment on SceneComponent_GetRightVector");
static_assert(sizeof(SceneComponent_GetRightVector) == 0x00000C, "Wrong size on SceneComponent_GetRightVector");
static_assert(offsetof(SceneComponent_GetRightVector, ReturnValue) == 0x000000, "Member 'SceneComponent_GetRightVector::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetSocketLocation
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_GetSocketLocation final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_GetSocketLocation) == 0x000004, "Wrong alignment on SceneComponent_GetSocketLocation");
static_assert(sizeof(SceneComponent_GetSocketLocation) == 0x000018, "Wrong size on SceneComponent_GetSocketLocation");
static_assert(offsetof(SceneComponent_GetSocketLocation, InSocketName) == 0x000000, "Member 'SceneComponent_GetSocketLocation::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetSocketLocation, ReturnValue) == 0x000008, "Member 'SceneComponent_GetSocketLocation::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetSocketQuaternion
// 0x0020 (0x0020 - 0x0000)
struct SceneComponent_GetSocketQuaternion final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FQuat                                  ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetSocketQuaternion) == 0x000010, "Wrong alignment on SceneComponent_GetSocketQuaternion");
static_assert(sizeof(SceneComponent_GetSocketQuaternion) == 0x000020, "Wrong size on SceneComponent_GetSocketQuaternion");
static_assert(offsetof(SceneComponent_GetSocketQuaternion, InSocketName) == 0x000000, "Member 'SceneComponent_GetSocketQuaternion::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetSocketQuaternion, ReturnValue) == 0x000010, "Member 'SceneComponent_GetSocketQuaternion::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetSocketRotation
// 0x0018 (0x0018 - 0x0000)
struct SceneComponent_GetSocketRotation final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_GetSocketRotation) == 0x000004, "Wrong alignment on SceneComponent_GetSocketRotation");
static_assert(sizeof(SceneComponent_GetSocketRotation) == 0x000018, "Wrong size on SceneComponent_GetSocketRotation");
static_assert(offsetof(SceneComponent_GetSocketRotation, InSocketName) == 0x000000, "Member 'SceneComponent_GetSocketRotation::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetSocketRotation, ReturnValue) == 0x000008, "Member 'SceneComponent_GetSocketRotation::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetSocketTransform
// 0x0040 (0x0040 - 0x0000)
struct SceneComponent_GetSocketTransform final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERelativeTransformSpace                       TransformSpace;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetSocketTransform) == 0x000010, "Wrong alignment on SceneComponent_GetSocketTransform");
static_assert(sizeof(SceneComponent_GetSocketTransform) == 0x000040, "Wrong size on SceneComponent_GetSocketTransform");
static_assert(offsetof(SceneComponent_GetSocketTransform, InSocketName) == 0x000000, "Member 'SceneComponent_GetSocketTransform::InSocketName' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetSocketTransform, TransformSpace) == 0x000008, "Member 'SceneComponent_GetSocketTransform::TransformSpace' has a wrong offset!");
static_assert(offsetof(SceneComponent_GetSocketTransform, ReturnValue) == 0x000010, "Member 'SceneComponent_GetSocketTransform::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.GetUpVector
// 0x000C (0x000C - 0x0000)
struct SceneComponent_GetUpVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_GetUpVector) == 0x000004, "Wrong alignment on SceneComponent_GetUpVector");
static_assert(sizeof(SceneComponent_GetUpVector) == 0x00000C, "Wrong size on SceneComponent_GetUpVector");
static_assert(offsetof(SceneComponent_GetUpVector, ReturnValue) == 0x000000, "Member 'SceneComponent_GetUpVector::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.IsAnySimulatingPhysics
// 0x0001 (0x0001 - 0x0000)
struct SceneComponent_IsAnySimulatingPhysics final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_IsAnySimulatingPhysics) == 0x000001, "Wrong alignment on SceneComponent_IsAnySimulatingPhysics");
static_assert(sizeof(SceneComponent_IsAnySimulatingPhysics) == 0x000001, "Wrong size on SceneComponent_IsAnySimulatingPhysics");
static_assert(offsetof(SceneComponent_IsAnySimulatingPhysics, ReturnValue) == 0x000000, "Member 'SceneComponent_IsAnySimulatingPhysics::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.IsSimulatingPhysics
// 0x0010 (0x0010 - 0x0000)
struct SceneComponent_IsSimulatingPhysics final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneComponent_IsSimulatingPhysics) == 0x000004, "Wrong alignment on SceneComponent_IsSimulatingPhysics");
static_assert(sizeof(SceneComponent_IsSimulatingPhysics) == 0x000010, "Wrong size on SceneComponent_IsSimulatingPhysics");
static_assert(offsetof(SceneComponent_IsSimulatingPhysics, BoneName) == 0x000000, "Member 'SceneComponent_IsSimulatingPhysics::BoneName' has a wrong offset!");
static_assert(offsetof(SceneComponent_IsSimulatingPhysics, ReturnValue) == 0x000008, "Member 'SceneComponent_IsSimulatingPhysics::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.IsVisible
// 0x0001 (0x0001 - 0x0000)
struct SceneComponent_IsVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_IsVisible) == 0x000001, "Wrong alignment on SceneComponent_IsVisible");
static_assert(sizeof(SceneComponent_IsVisible) == 0x000001, "Wrong size on SceneComponent_IsVisible");
static_assert(offsetof(SceneComponent_IsVisible, ReturnValue) == 0x000000, "Member 'SceneComponent_IsVisible::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_GetComponentLocation
// 0x000C (0x000C - 0x0000)
struct SceneComponent_K2_GetComponentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_K2_GetComponentLocation) == 0x000004, "Wrong alignment on SceneComponent_K2_GetComponentLocation");
static_assert(sizeof(SceneComponent_K2_GetComponentLocation) == 0x00000C, "Wrong size on SceneComponent_K2_GetComponentLocation");
static_assert(offsetof(SceneComponent_K2_GetComponentLocation, ReturnValue) == 0x000000, "Member 'SceneComponent_K2_GetComponentLocation::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_GetComponentRotation
// 0x000C (0x000C - 0x0000)
struct SceneComponent_K2_GetComponentRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_K2_GetComponentRotation) == 0x000004, "Wrong alignment on SceneComponent_K2_GetComponentRotation");
static_assert(sizeof(SceneComponent_K2_GetComponentRotation) == 0x00000C, "Wrong size on SceneComponent_K2_GetComponentRotation");
static_assert(offsetof(SceneComponent_K2_GetComponentRotation, ReturnValue) == 0x000000, "Member 'SceneComponent_K2_GetComponentRotation::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_GetComponentScale
// 0x000C (0x000C - 0x0000)
struct SceneComponent_K2_GetComponentScale final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_K2_GetComponentScale) == 0x000004, "Wrong alignment on SceneComponent_K2_GetComponentScale");
static_assert(sizeof(SceneComponent_K2_GetComponentScale) == 0x00000C, "Wrong size on SceneComponent_K2_GetComponentScale");
static_assert(offsetof(SceneComponent_K2_GetComponentScale, ReturnValue) == 0x000000, "Member 'SceneComponent_K2_GetComponentScale::ReturnValue' has a wrong offset!");

// Function Engine.SceneComponent.K2_GetComponentToWorld
// 0x0030 (0x0030 - 0x0000)
struct SceneComponent_K2_GetComponentToWorld final
{
public:
	struct FTransform                             ReturnValue;                                       // 0x0000(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneComponent_K2_GetComponentToWorld) == 0x000010, "Wrong alignment on SceneComponent_K2_GetComponentToWorld");
static_assert(sizeof(SceneComponent_K2_GetComponentToWorld) == 0x000030, "Wrong size on SceneComponent_K2_GetComponentToWorld");
static_assert(offsetof(SceneComponent_K2_GetComponentToWorld, ReturnValue) == 0x000000, "Member 'SceneComponent_K2_GetComponentToWorld::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddAngularImpulse
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddAngularImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddAngularImpulse) == 0x000004, "Wrong alignment on PrimitiveComponent_AddAngularImpulse");
static_assert(sizeof(PrimitiveComponent_AddAngularImpulse) == 0x000020, "Wrong size on PrimitiveComponent_AddAngularImpulse");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulse, Impulse) == 0x000000, "Member 'PrimitiveComponent_AddAngularImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulse, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddAngularImpulse::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulse, bVelChange) == 0x000018, "Member 'PrimitiveComponent_AddAngularImpulse::bVelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddAngularImpulseInDegrees
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddAngularImpulseInDegrees final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddAngularImpulseInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_AddAngularImpulseInDegrees");
static_assert(sizeof(PrimitiveComponent_AddAngularImpulseInDegrees) == 0x000020, "Wrong size on PrimitiveComponent_AddAngularImpulseInDegrees");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInDegrees, Impulse) == 0x000000, "Member 'PrimitiveComponent_AddAngularImpulseInDegrees::Impulse' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInDegrees, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddAngularImpulseInDegrees::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInDegrees, bVelChange) == 0x000018, "Member 'PrimitiveComponent_AddAngularImpulseInDegrees::bVelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddAngularImpulseInRadians
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddAngularImpulseInRadians final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddAngularImpulseInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_AddAngularImpulseInRadians");
static_assert(sizeof(PrimitiveComponent_AddAngularImpulseInRadians) == 0x000020, "Wrong size on PrimitiveComponent_AddAngularImpulseInRadians");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInRadians, Impulse) == 0x000000, "Member 'PrimitiveComponent_AddAngularImpulseInRadians::Impulse' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInRadians, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddAngularImpulseInRadians::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddAngularImpulseInRadians, bVelChange) == 0x000018, "Member 'PrimitiveComponent_AddAngularImpulseInRadians::bVelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddForce
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddForce final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddForce) == 0x000004, "Wrong alignment on PrimitiveComponent_AddForce");
static_assert(sizeof(PrimitiveComponent_AddForce) == 0x000020, "Wrong size on PrimitiveComponent_AddForce");
static_assert(offsetof(PrimitiveComponent_AddForce, Force) == 0x000000, "Member 'PrimitiveComponent_AddForce::Force' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForce, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddForce::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForce, bAccelChange) == 0x000018, "Member 'PrimitiveComponent_AddForce::bAccelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddForceAtLocation
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddForceAtLocation final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_AddForceAtLocation) == 0x000004, "Wrong alignment on PrimitiveComponent_AddForceAtLocation");
static_assert(sizeof(PrimitiveComponent_AddForceAtLocation) == 0x000020, "Wrong size on PrimitiveComponent_AddForceAtLocation");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocation, Force) == 0x000000, "Member 'PrimitiveComponent_AddForceAtLocation::Force' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocation, Location) == 0x00000C, "Member 'PrimitiveComponent_AddForceAtLocation::Location' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocation, BoneName) == 0x000018, "Member 'PrimitiveComponent_AddForceAtLocation::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddForceAtLocationLocal
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddForceAtLocationLocal final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_AddForceAtLocationLocal) == 0x000004, "Wrong alignment on PrimitiveComponent_AddForceAtLocationLocal");
static_assert(sizeof(PrimitiveComponent_AddForceAtLocationLocal) == 0x000020, "Wrong size on PrimitiveComponent_AddForceAtLocationLocal");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocationLocal, Force) == 0x000000, "Member 'PrimitiveComponent_AddForceAtLocationLocal::Force' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocationLocal, Location) == 0x00000C, "Member 'PrimitiveComponent_AddForceAtLocationLocal::Location' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddForceAtLocationLocal, BoneName) == 0x000018, "Member 'PrimitiveComponent_AddForceAtLocationLocal::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddImpulse
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddImpulse) == 0x000004, "Wrong alignment on PrimitiveComponent_AddImpulse");
static_assert(sizeof(PrimitiveComponent_AddImpulse) == 0x000020, "Wrong size on PrimitiveComponent_AddImpulse");
static_assert(offsetof(PrimitiveComponent_AddImpulse, Impulse) == 0x000000, "Member 'PrimitiveComponent_AddImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddImpulse, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddImpulse::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddImpulse, bVelChange) == 0x000018, "Member 'PrimitiveComponent_AddImpulse::bVelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddImpulseAtLocation
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddImpulseAtLocation final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_AddImpulseAtLocation) == 0x000004, "Wrong alignment on PrimitiveComponent_AddImpulseAtLocation");
static_assert(sizeof(PrimitiveComponent_AddImpulseAtLocation) == 0x000020, "Wrong size on PrimitiveComponent_AddImpulseAtLocation");
static_assert(offsetof(PrimitiveComponent_AddImpulseAtLocation, Impulse) == 0x000000, "Member 'PrimitiveComponent_AddImpulseAtLocation::Impulse' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddImpulseAtLocation, Location) == 0x00000C, "Member 'PrimitiveComponent_AddImpulseAtLocation::Location' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddImpulseAtLocation, BoneName) == 0x000018, "Member 'PrimitiveComponent_AddImpulseAtLocation::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddRadialForce
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_AddRadialForce final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERadialImpulseFalloff                         Falloff;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddRadialForce) == 0x000004, "Wrong alignment on PrimitiveComponent_AddRadialForce");
static_assert(sizeof(PrimitiveComponent_AddRadialForce) == 0x000018, "Wrong size on PrimitiveComponent_AddRadialForce");
static_assert(offsetof(PrimitiveComponent_AddRadialForce, Origin) == 0x000000, "Member 'PrimitiveComponent_AddRadialForce::Origin' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialForce, Radius) == 0x00000C, "Member 'PrimitiveComponent_AddRadialForce::Radius' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialForce, Strength) == 0x000010, "Member 'PrimitiveComponent_AddRadialForce::Strength' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialForce, Falloff) == 0x000014, "Member 'PrimitiveComponent_AddRadialForce::Falloff' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialForce, bAccelChange) == 0x000015, "Member 'PrimitiveComponent_AddRadialForce::bAccelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddRadialImpulse
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_AddRadialImpulse final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Strength;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERadialImpulseFalloff                         Falloff;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0015(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddRadialImpulse) == 0x000004, "Wrong alignment on PrimitiveComponent_AddRadialImpulse");
static_assert(sizeof(PrimitiveComponent_AddRadialImpulse) == 0x000018, "Wrong size on PrimitiveComponent_AddRadialImpulse");
static_assert(offsetof(PrimitiveComponent_AddRadialImpulse, Origin) == 0x000000, "Member 'PrimitiveComponent_AddRadialImpulse::Origin' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialImpulse, Radius) == 0x00000C, "Member 'PrimitiveComponent_AddRadialImpulse::Radius' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialImpulse, Strength) == 0x000010, "Member 'PrimitiveComponent_AddRadialImpulse::Strength' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialImpulse, Falloff) == 0x000014, "Member 'PrimitiveComponent_AddRadialImpulse::Falloff' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddRadialImpulse, bVelChange) == 0x000015, "Member 'PrimitiveComponent_AddRadialImpulse::bVelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddTorque
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddTorque final
{
public:
	struct FVector                                Torque;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddTorque) == 0x000004, "Wrong alignment on PrimitiveComponent_AddTorque");
static_assert(sizeof(PrimitiveComponent_AddTorque) == 0x000020, "Wrong size on PrimitiveComponent_AddTorque");
static_assert(offsetof(PrimitiveComponent_AddTorque, Torque) == 0x000000, "Member 'PrimitiveComponent_AddTorque::Torque' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorque, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddTorque::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorque, bAccelChange) == 0x000018, "Member 'PrimitiveComponent_AddTorque::bAccelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddTorqueInDegrees
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddTorqueInDegrees final
{
public:
	struct FVector                                Torque;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddTorqueInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_AddTorqueInDegrees");
static_assert(sizeof(PrimitiveComponent_AddTorqueInDegrees) == 0x000020, "Wrong size on PrimitiveComponent_AddTorqueInDegrees");
static_assert(offsetof(PrimitiveComponent_AddTorqueInDegrees, Torque) == 0x000000, "Member 'PrimitiveComponent_AddTorqueInDegrees::Torque' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorqueInDegrees, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddTorqueInDegrees::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorqueInDegrees, bAccelChange) == 0x000018, "Member 'PrimitiveComponent_AddTorqueInDegrees::bAccelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.AddTorqueInRadians
// 0x0020 (0x0020 - 0x0000)
struct PrimitiveComponent_AddTorqueInRadians final
{
public:
	struct FVector                                Torque;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_AddTorqueInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_AddTorqueInRadians");
static_assert(sizeof(PrimitiveComponent_AddTorqueInRadians) == 0x000020, "Wrong size on PrimitiveComponent_AddTorqueInRadians");
static_assert(offsetof(PrimitiveComponent_AddTorqueInRadians, Torque) == 0x000000, "Member 'PrimitiveComponent_AddTorqueInRadians::Torque' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorqueInRadians, BoneName) == 0x000010, "Member 'PrimitiveComponent_AddTorqueInRadians::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_AddTorqueInRadians, bAccelChange) == 0x000018, "Member 'PrimitiveComponent_AddTorqueInRadians::bAccelChange' has a wrong offset!");

// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreActors
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_CopyArrayOfMoveIgnoreActors final
{
public:
	TArray<class AActor*>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_CopyArrayOfMoveIgnoreActors) == 0x000008, "Wrong alignment on PrimitiveComponent_CopyArrayOfMoveIgnoreActors");
static_assert(sizeof(PrimitiveComponent_CopyArrayOfMoveIgnoreActors) == 0x000010, "Wrong size on PrimitiveComponent_CopyArrayOfMoveIgnoreActors");
static_assert(offsetof(PrimitiveComponent_CopyArrayOfMoveIgnoreActors, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_CopyArrayOfMoveIgnoreActors::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.CopyArrayOfMoveIgnoreComponents
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_CopyArrayOfMoveIgnoreComponents final
{
public:
	TArray<class UPrimitiveComponent*>            ReturnValue;                                       // 0x0000(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_CopyArrayOfMoveIgnoreComponents) == 0x000008, "Wrong alignment on PrimitiveComponent_CopyArrayOfMoveIgnoreComponents");
static_assert(sizeof(PrimitiveComponent_CopyArrayOfMoveIgnoreComponents) == 0x000010, "Wrong size on PrimitiveComponent_CopyArrayOfMoveIgnoreComponents");
static_assert(offsetof(PrimitiveComponent_CopyArrayOfMoveIgnoreComponents, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_CopyArrayOfMoveIgnoreComponents::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamic
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_CreateAndSetMaterialInstanceDynamic final
{
public:
	int32                                         ElementIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamic) == 0x000008, "Wrong alignment on PrimitiveComponent_CreateAndSetMaterialInstanceDynamic");
static_assert(sizeof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamic) == 0x000010, "Wrong size on PrimitiveComponent_CreateAndSetMaterialInstanceDynamic");
static_assert(offsetof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamic, ElementIndex) == 0x000000, "Member 'PrimitiveComponent_CreateAndSetMaterialInstanceDynamic::ElementIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamic, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_CreateAndSetMaterialInstanceDynamic::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.CreateAndSetMaterialInstanceDynamicFromMaterial
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial final
{
public:
	int32                                         ElementIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Parent;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial) == 0x000008, "Wrong alignment on PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial");
static_assert(sizeof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial) == 0x000018, "Wrong size on PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial");
static_assert(offsetof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial, ElementIndex) == 0x000000, "Member 'PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial::ElementIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial, Parent) == 0x000008, "Member 'PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial::Parent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial, ReturnValue) == 0x000010, "Member 'PrimitiveComponent_CreateAndSetMaterialInstanceDynamicFromMaterial::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.CreateDynamicMaterialInstance
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_CreateDynamicMaterialInstance final
{
public:
	int32                                         ElementIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     SourceMaterial;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_CreateDynamicMaterialInstance) == 0x000008, "Wrong alignment on PrimitiveComponent_CreateDynamicMaterialInstance");
static_assert(sizeof(PrimitiveComponent_CreateDynamicMaterialInstance) == 0x000018, "Wrong size on PrimitiveComponent_CreateDynamicMaterialInstance");
static_assert(offsetof(PrimitiveComponent_CreateDynamicMaterialInstance, ElementIndex) == 0x000000, "Member 'PrimitiveComponent_CreateDynamicMaterialInstance::ElementIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CreateDynamicMaterialInstance, SourceMaterial) == 0x000008, "Member 'PrimitiveComponent_CreateDynamicMaterialInstance::SourceMaterial' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CreateDynamicMaterialInstance, ReturnValue) == 0x000010, "Member 'PrimitiveComponent_CreateDynamicMaterialInstance::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocity
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetPhysicsAngularVelocity final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetPhysicsAngularVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_GetPhysicsAngularVelocity");
static_assert(sizeof(PrimitiveComponent_GetPhysicsAngularVelocity) == 0x000018, "Wrong size on PrimitiveComponent_GetPhysicsAngularVelocity");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocity, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetPhysicsAngularVelocity::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocity, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetPhysicsAngularVelocity::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInDegrees
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetPhysicsAngularVelocityInDegrees final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetPhysicsAngularVelocityInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_GetPhysicsAngularVelocityInDegrees");
static_assert(sizeof(PrimitiveComponent_GetPhysicsAngularVelocityInDegrees) == 0x000018, "Wrong size on PrimitiveComponent_GetPhysicsAngularVelocityInDegrees");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocityInDegrees, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetPhysicsAngularVelocityInDegrees::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocityInDegrees, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetPhysicsAngularVelocityInDegrees::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetPhysicsAngularVelocityInRadians
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetPhysicsAngularVelocityInRadians final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetPhysicsAngularVelocityInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_GetPhysicsAngularVelocityInRadians");
static_assert(sizeof(PrimitiveComponent_GetPhysicsAngularVelocityInRadians) == 0x000018, "Wrong size on PrimitiveComponent_GetPhysicsAngularVelocityInRadians");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocityInRadians, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetPhysicsAngularVelocityInRadians::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsAngularVelocityInRadians, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetPhysicsAngularVelocityInRadians::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocity
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetPhysicsLinearVelocity final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetPhysicsLinearVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_GetPhysicsLinearVelocity");
static_assert(sizeof(PrimitiveComponent_GetPhysicsLinearVelocity) == 0x000018, "Wrong size on PrimitiveComponent_GetPhysicsLinearVelocity");
static_assert(offsetof(PrimitiveComponent_GetPhysicsLinearVelocity, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetPhysicsLinearVelocity::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsLinearVelocity, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetPhysicsLinearVelocity::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetPhysicsLinearVelocityAtPoint
// 0x0028 (0x0028 - 0x0000)
struct PrimitiveComponent_GetPhysicsLinearVelocityAtPoint final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetPhysicsLinearVelocityAtPoint) == 0x000004, "Wrong alignment on PrimitiveComponent_GetPhysicsLinearVelocityAtPoint");
static_assert(sizeof(PrimitiveComponent_GetPhysicsLinearVelocityAtPoint) == 0x000028, "Wrong size on PrimitiveComponent_GetPhysicsLinearVelocityAtPoint");
static_assert(offsetof(PrimitiveComponent_GetPhysicsLinearVelocityAtPoint, Point) == 0x000000, "Member 'PrimitiveComponent_GetPhysicsLinearVelocityAtPoint::Point' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsLinearVelocityAtPoint, BoneName) == 0x000010, "Member 'PrimitiveComponent_GetPhysicsLinearVelocityAtPoint::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetPhysicsLinearVelocityAtPoint, ReturnValue) == 0x000018, "Member 'PrimitiveComponent_GetPhysicsLinearVelocityAtPoint::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.IgnoreActorWhenMoving
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_IgnoreActorWhenMoving final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnore;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_IgnoreActorWhenMoving) == 0x000008, "Wrong alignment on PrimitiveComponent_IgnoreActorWhenMoving");
static_assert(sizeof(PrimitiveComponent_IgnoreActorWhenMoving) == 0x000010, "Wrong size on PrimitiveComponent_IgnoreActorWhenMoving");
static_assert(offsetof(PrimitiveComponent_IgnoreActorWhenMoving, Actor) == 0x000000, "Member 'PrimitiveComponent_IgnoreActorWhenMoving::Actor' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_IgnoreActorWhenMoving, bShouldIgnore) == 0x000008, "Member 'PrimitiveComponent_IgnoreActorWhenMoving::bShouldIgnore' has a wrong offset!");

// Function Engine.PrimitiveComponent.IgnoreComponentWhenMoving
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_IgnoreComponentWhenMoving final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldIgnore;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_IgnoreComponentWhenMoving) == 0x000008, "Wrong alignment on PrimitiveComponent_IgnoreComponentWhenMoving");
static_assert(sizeof(PrimitiveComponent_IgnoreComponentWhenMoving) == 0x000010, "Wrong size on PrimitiveComponent_IgnoreComponentWhenMoving");
static_assert(offsetof(PrimitiveComponent_IgnoreComponentWhenMoving, Component) == 0x000000, "Member 'PrimitiveComponent_IgnoreComponentWhenMoving::Component' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_IgnoreComponentWhenMoving, bShouldIgnore) == 0x000008, "Member 'PrimitiveComponent_IgnoreComponentWhenMoving::bShouldIgnore' has a wrong offset!");

// Function Engine.PrimitiveComponent.IsAnyRigidBodyAwake
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_IsAnyRigidBodyAwake final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_IsAnyRigidBodyAwake) == 0x000001, "Wrong alignment on PrimitiveComponent_IsAnyRigidBodyAwake");
static_assert(sizeof(PrimitiveComponent_IsAnyRigidBodyAwake) == 0x000001, "Wrong size on PrimitiveComponent_IsAnyRigidBodyAwake");
static_assert(offsetof(PrimitiveComponent_IsAnyRigidBodyAwake, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_IsAnyRigidBodyAwake::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.K2_LineTraceComponent
// 0x00D0 (0x00D0 - 0x0000)
struct PrimitiveComponent_K2_LineTraceComponent final
{
public:
	struct FVector                                TraceStart;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowTrace;                                        // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                HitLocation;                                       // 0x001C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitNormal;                                         // 0x0028(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0040(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00C8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_K2_LineTraceComponent) == 0x000008, "Wrong alignment on PrimitiveComponent_K2_LineTraceComponent");
static_assert(sizeof(PrimitiveComponent_K2_LineTraceComponent) == 0x0000D0, "Wrong size on PrimitiveComponent_K2_LineTraceComponent");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, TraceStart) == 0x000000, "Member 'PrimitiveComponent_K2_LineTraceComponent::TraceStart' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, TraceEnd) == 0x00000C, "Member 'PrimitiveComponent_K2_LineTraceComponent::TraceEnd' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, bTraceComplex) == 0x000018, "Member 'PrimitiveComponent_K2_LineTraceComponent::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, bShowTrace) == 0x000019, "Member 'PrimitiveComponent_K2_LineTraceComponent::bShowTrace' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, HitLocation) == 0x00001C, "Member 'PrimitiveComponent_K2_LineTraceComponent::HitLocation' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, HitNormal) == 0x000028, "Member 'PrimitiveComponent_K2_LineTraceComponent::HitNormal' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, BoneName) == 0x000038, "Member 'PrimitiveComponent_K2_LineTraceComponent::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, OutHit) == 0x000040, "Member 'PrimitiveComponent_K2_LineTraceComponent::OutHit' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_K2_LineTraceComponent, ReturnValue) == 0x0000C8, "Member 'PrimitiveComponent_K2_LineTraceComponent::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.PutRigidBodyToSleep
// 0x0008 (0x0008 - 0x0000)
struct PrimitiveComponent_PutRigidBodyToSleep final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_PutRigidBodyToSleep) == 0x000004, "Wrong alignment on PrimitiveComponent_PutRigidBodyToSleep");
static_assert(sizeof(PrimitiveComponent_PutRigidBodyToSleep) == 0x000008, "Wrong size on PrimitiveComponent_PutRigidBodyToSleep");
static_assert(offsetof(PrimitiveComponent_PutRigidBodyToSleep, BoneName) == 0x000000, "Member 'PrimitiveComponent_PutRigidBodyToSleep::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAllMassScale
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetAllMassScale final
{
public:
	float                                         InMassScale;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetAllMassScale) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAllMassScale");
static_assert(sizeof(PrimitiveComponent_SetAllMassScale) == 0x000004, "Wrong size on PrimitiveComponent_SetAllMassScale");
static_assert(offsetof(PrimitiveComponent_SetAllMassScale, InMassScale) == 0x000000, "Member 'PrimitiveComponent_SetAllMassScale::InMassScale' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocity
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetAllPhysicsAngularVelocity final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetAllPhysicsAngularVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAllPhysicsAngularVelocity");
static_assert(sizeof(PrimitiveComponent_SetAllPhysicsAngularVelocity) == 0x000010, "Wrong size on PrimitiveComponent_SetAllPhysicsAngularVelocity");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocity, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocity::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocity, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocity::bAddToCurrent' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInDegrees
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees");
static_assert(sizeof(PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees) == 0x000010, "Wrong size on PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocityInDegrees::bAddToCurrent' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAllPhysicsAngularVelocityInRadians
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians");
static_assert(sizeof(PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians) == 0x000010, "Wrong size on PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetAllPhysicsAngularVelocityInRadians::bAddToCurrent' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAllPhysicsLinearVelocity
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetAllPhysicsLinearVelocity final
{
public:
	struct FVector                                NewVel;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetAllPhysicsLinearVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAllPhysicsLinearVelocity");
static_assert(sizeof(PrimitiveComponent_SetAllPhysicsLinearVelocity) == 0x000010, "Wrong size on PrimitiveComponent_SetAllPhysicsLinearVelocity");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsLinearVelocity, NewVel) == 0x000000, "Member 'PrimitiveComponent_SetAllPhysicsLinearVelocity::NewVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetAllPhysicsLinearVelocity, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetAllPhysicsLinearVelocity::bAddToCurrent' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetAngularDamping
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetAngularDamping final
{
public:
	float                                         InDamping;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetAngularDamping) == 0x000004, "Wrong alignment on PrimitiveComponent_SetAngularDamping");
static_assert(sizeof(PrimitiveComponent_SetAngularDamping) == 0x000004, "Wrong size on PrimitiveComponent_SetAngularDamping");
static_assert(offsetof(PrimitiveComponent_SetAngularDamping, InDamping) == 0x000000, "Member 'PrimitiveComponent_SetAngularDamping::InDamping' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetBoundsScale
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetBoundsScale final
{
public:
	float                                         NewBoundsScale;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetBoundsScale) == 0x000004, "Wrong alignment on PrimitiveComponent_SetBoundsScale");
static_assert(sizeof(PrimitiveComponent_SetBoundsScale) == 0x000004, "Wrong size on PrimitiveComponent_SetBoundsScale");
static_assert(offsetof(PrimitiveComponent_SetBoundsScale, NewBoundsScale) == 0x000000, "Member 'PrimitiveComponent_SetBoundsScale::NewBoundsScale' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCastShadow
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetCastShadow final
{
public:
	bool                                          NewCastShadow;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCastShadow) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCastShadow");
static_assert(sizeof(PrimitiveComponent_SetCastShadow) == 0x000001, "Wrong size on PrimitiveComponent_SetCastShadow");
static_assert(offsetof(PrimitiveComponent_SetCastShadow, NewCastShadow) == 0x000000, "Member 'PrimitiveComponent_SetCastShadow::NewCastShadow' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCenterOfMass
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_SetCenterOfMass final
{
public:
	struct FVector                                CenterOfMassOffset;                                // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCenterOfMass) == 0x000004, "Wrong alignment on PrimitiveComponent_SetCenterOfMass");
static_assert(sizeof(PrimitiveComponent_SetCenterOfMass) == 0x000018, "Wrong size on PrimitiveComponent_SetCenterOfMass");
static_assert(offsetof(PrimitiveComponent_SetCenterOfMass, CenterOfMassOffset) == 0x000000, "Member 'PrimitiveComponent_SetCenterOfMass::CenterOfMassOffset' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetCenterOfMass, BoneName) == 0x000010, "Member 'PrimitiveComponent_SetCenterOfMass::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetCollisionEnabled final
{
public:
	ECollisionEnabled                             NewType;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCollisionEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCollisionEnabled");
static_assert(sizeof(PrimitiveComponent_SetCollisionEnabled) == 0x000001, "Wrong size on PrimitiveComponent_SetCollisionEnabled");
static_assert(offsetof(PrimitiveComponent_SetCollisionEnabled, NewType) == 0x000000, "Member 'PrimitiveComponent_SetCollisionEnabled::NewType' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCollisionObjectType
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetCollisionObjectType final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCollisionObjectType) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCollisionObjectType");
static_assert(sizeof(PrimitiveComponent_SetCollisionObjectType) == 0x000001, "Wrong size on PrimitiveComponent_SetCollisionObjectType");
static_assert(offsetof(PrimitiveComponent_SetCollisionObjectType, Channel) == 0x000000, "Member 'PrimitiveComponent_SetCollisionObjectType::Channel' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCollisionProfileName
// 0x0008 (0x0008 - 0x0000)
struct PrimitiveComponent_SetCollisionProfileName final
{
public:
	class FName                                   InCollisionProfileName;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCollisionProfileName) == 0x000004, "Wrong alignment on PrimitiveComponent_SetCollisionProfileName");
static_assert(sizeof(PrimitiveComponent_SetCollisionProfileName) == 0x000008, "Wrong size on PrimitiveComponent_SetCollisionProfileName");
static_assert(offsetof(PrimitiveComponent_SetCollisionProfileName, InCollisionProfileName) == 0x000000, "Member 'PrimitiveComponent_SetCollisionProfileName::InCollisionProfileName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCollisionResponseToAllChannels
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetCollisionResponseToAllChannels final
{
public:
	ECollisionResponse                            NewResponse;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCollisionResponseToAllChannels) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCollisionResponseToAllChannels");
static_assert(sizeof(PrimitiveComponent_SetCollisionResponseToAllChannels) == 0x000001, "Wrong size on PrimitiveComponent_SetCollisionResponseToAllChannels");
static_assert(offsetof(PrimitiveComponent_SetCollisionResponseToAllChannels, NewResponse) == 0x000000, "Member 'PrimitiveComponent_SetCollisionResponseToAllChannels::NewResponse' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCollisionResponseToChannel
// 0x0002 (0x0002 - 0x0000)
struct PrimitiveComponent_SetCollisionResponseToChannel final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            NewResponse;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCollisionResponseToChannel) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCollisionResponseToChannel");
static_assert(sizeof(PrimitiveComponent_SetCollisionResponseToChannel) == 0x000002, "Wrong size on PrimitiveComponent_SetCollisionResponseToChannel");
static_assert(offsetof(PrimitiveComponent_SetCollisionResponseToChannel, Channel) == 0x000000, "Member 'PrimitiveComponent_SetCollisionResponseToChannel::Channel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetCollisionResponseToChannel, NewResponse) == 0x000001, "Member 'PrimitiveComponent_SetCollisionResponseToChannel::NewResponse' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetConstraintMode
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetConstraintMode final
{
public:
	EDOFMode                                      ConstraintMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetConstraintMode) == 0x000001, "Wrong alignment on PrimitiveComponent_SetConstraintMode");
static_assert(sizeof(PrimitiveComponent_SetConstraintMode) == 0x000001, "Wrong size on PrimitiveComponent_SetConstraintMode");
static_assert(offsetof(PrimitiveComponent_SetConstraintMode, ConstraintMode) == 0x000000, "Member 'PrimitiveComponent_SetConstraintMode::ConstraintMode' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCullDistance
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetCullDistance final
{
public:
	float                                         NewCullDistance;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCullDistance) == 0x000004, "Wrong alignment on PrimitiveComponent_SetCullDistance");
static_assert(sizeof(PrimitiveComponent_SetCullDistance) == 0x000004, "Wrong size on PrimitiveComponent_SetCullDistance");
static_assert(offsetof(PrimitiveComponent_SetCullDistance, NewCullDistance) == 0x000000, "Member 'PrimitiveComponent_SetCullDistance::NewCullDistance' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCustomDepthStencilValue
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetCustomDepthStencilValue final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCustomDepthStencilValue) == 0x000004, "Wrong alignment on PrimitiveComponent_SetCustomDepthStencilValue");
static_assert(sizeof(PrimitiveComponent_SetCustomDepthStencilValue) == 0x000004, "Wrong size on PrimitiveComponent_SetCustomDepthStencilValue");
static_assert(offsetof(PrimitiveComponent_SetCustomDepthStencilValue, Value) == 0x000000, "Member 'PrimitiveComponent_SetCustomDepthStencilValue::Value' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetCustomDepthStencilWriteMask
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetCustomDepthStencilWriteMask final
{
public:
	ERendererStencilMask                          WriteMaskBit;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetCustomDepthStencilWriteMask) == 0x000001, "Wrong alignment on PrimitiveComponent_SetCustomDepthStencilWriteMask");
static_assert(sizeof(PrimitiveComponent_SetCustomDepthStencilWriteMask) == 0x000001, "Wrong size on PrimitiveComponent_SetCustomDepthStencilWriteMask");
static_assert(offsetof(PrimitiveComponent_SetCustomDepthStencilWriteMask, WriteMaskBit) == 0x000000, "Member 'PrimitiveComponent_SetCustomDepthStencilWriteMask::WriteMaskBit' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetEnableGravity
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetEnableGravity final
{
public:
	bool                                          bGravityEnabled;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetEnableGravity) == 0x000001, "Wrong alignment on PrimitiveComponent_SetEnableGravity");
static_assert(sizeof(PrimitiveComponent_SetEnableGravity) == 0x000001, "Wrong size on PrimitiveComponent_SetEnableGravity");
static_assert(offsetof(PrimitiveComponent_SetEnableGravity, bGravityEnabled) == 0x000000, "Member 'PrimitiveComponent_SetEnableGravity::bGravityEnabled' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetLightingChannels
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetLightingChannels final
{
public:
	struct FLightingChannels                      InLightingChannels;                                // 0x0000(0x0001)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetLightingChannels) == 0x000001, "Wrong alignment on PrimitiveComponent_SetLightingChannels");
static_assert(sizeof(PrimitiveComponent_SetLightingChannels) == 0x000001, "Wrong size on PrimitiveComponent_SetLightingChannels");
static_assert(offsetof(PrimitiveComponent_SetLightingChannels, InLightingChannels) == 0x000000, "Member 'PrimitiveComponent_SetLightingChannels::InLightingChannels' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetLinearDamping
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetLinearDamping final
{
public:
	float                                         InDamping;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetLinearDamping) == 0x000004, "Wrong alignment on PrimitiveComponent_SetLinearDamping");
static_assert(sizeof(PrimitiveComponent_SetLinearDamping) == 0x000004, "Wrong size on PrimitiveComponent_SetLinearDamping");
static_assert(offsetof(PrimitiveComponent_SetLinearDamping, InDamping) == 0x000000, "Member 'PrimitiveComponent_SetLinearDamping::InDamping' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetLockedAxis
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetLockedAxis final
{
public:
	EDOFMode                                      LockedAxis;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetLockedAxis) == 0x000001, "Wrong alignment on PrimitiveComponent_SetLockedAxis");
static_assert(sizeof(PrimitiveComponent_SetLockedAxis) == 0x000001, "Wrong size on PrimitiveComponent_SetLockedAxis");
static_assert(offsetof(PrimitiveComponent_SetLockedAxis, LockedAxis) == 0x000000, "Member 'PrimitiveComponent_SetLockedAxis::LockedAxis' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetMassOverrideInKg
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetMassOverrideInKg final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MassInKg;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideMass;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetMassOverrideInKg) == 0x000004, "Wrong alignment on PrimitiveComponent_SetMassOverrideInKg");
static_assert(sizeof(PrimitiveComponent_SetMassOverrideInKg) == 0x000010, "Wrong size on PrimitiveComponent_SetMassOverrideInKg");
static_assert(offsetof(PrimitiveComponent_SetMassOverrideInKg, BoneName) == 0x000000, "Member 'PrimitiveComponent_SetMassOverrideInKg::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetMassOverrideInKg, MassInKg) == 0x000008, "Member 'PrimitiveComponent_SetMassOverrideInKg::MassInKg' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetMassOverrideInKg, bOverrideMass) == 0x00000C, "Member 'PrimitiveComponent_SetMassOverrideInKg::bOverrideMass' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetMassScale
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetMassScale final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InMassScale;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_SetMassScale) == 0x000004, "Wrong alignment on PrimitiveComponent_SetMassScale");
static_assert(sizeof(PrimitiveComponent_SetMassScale) == 0x000010, "Wrong size on PrimitiveComponent_SetMassScale");
static_assert(offsetof(PrimitiveComponent_SetMassScale, BoneName) == 0x000000, "Member 'PrimitiveComponent_SetMassScale::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetMassScale, InMassScale) == 0x000008, "Member 'PrimitiveComponent_SetMassScale::InMassScale' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetMaterial
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetMaterial final
{
public:
	int32                                         ElementIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetMaterial) == 0x000008, "Wrong alignment on PrimitiveComponent_SetMaterial");
static_assert(sizeof(PrimitiveComponent_SetMaterial) == 0x000010, "Wrong size on PrimitiveComponent_SetMaterial");
static_assert(offsetof(PrimitiveComponent_SetMaterial, ElementIndex) == 0x000000, "Member 'PrimitiveComponent_SetMaterial::ElementIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetMaterial, Material) == 0x000008, "Member 'PrimitiveComponent_SetMaterial::Material' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetMaterialByName
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetMaterialByName final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetMaterialByName) == 0x000008, "Wrong alignment on PrimitiveComponent_SetMaterialByName");
static_assert(sizeof(PrimitiveComponent_SetMaterialByName) == 0x000010, "Wrong size on PrimitiveComponent_SetMaterialByName");
static_assert(offsetof(PrimitiveComponent_SetMaterialByName, MaterialSlotName) == 0x000000, "Member 'PrimitiveComponent_SetMaterialByName::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetMaterialByName, Material) == 0x000008, "Member 'PrimitiveComponent_SetMaterialByName::Material' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetNotifyRigidBodyCollision
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetNotifyRigidBodyCollision final
{
public:
	bool                                          bNewNotifyRigidBodyCollision;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetNotifyRigidBodyCollision) == 0x000001, "Wrong alignment on PrimitiveComponent_SetNotifyRigidBodyCollision");
static_assert(sizeof(PrimitiveComponent_SetNotifyRigidBodyCollision) == 0x000001, "Wrong size on PrimitiveComponent_SetNotifyRigidBodyCollision");
static_assert(offsetof(PrimitiveComponent_SetNotifyRigidBodyCollision, bNewNotifyRigidBodyCollision) == 0x000000, "Member 'PrimitiveComponent_SetNotifyRigidBodyCollision::bNewNotifyRigidBodyCollision' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetOnlyOwnerSee
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetOnlyOwnerSee final
{
public:
	bool                                          bNewOnlyOwnerSee;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetOnlyOwnerSee) == 0x000001, "Wrong alignment on PrimitiveComponent_SetOnlyOwnerSee");
static_assert(sizeof(PrimitiveComponent_SetOnlyOwnerSee) == 0x000001, "Wrong size on PrimitiveComponent_SetOnlyOwnerSee");
static_assert(offsetof(PrimitiveComponent_SetOnlyOwnerSee, bNewOnlyOwnerSee) == 0x000000, "Member 'PrimitiveComponent_SetOnlyOwnerSee::bNewOnlyOwnerSee' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetOwnerNoSee
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetOwnerNoSee final
{
public:
	bool                                          bNewOwnerNoSee;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetOwnerNoSee) == 0x000001, "Wrong alignment on PrimitiveComponent_SetOwnerNoSee");
static_assert(sizeof(PrimitiveComponent_SetOwnerNoSee) == 0x000001, "Wrong size on PrimitiveComponent_SetOwnerNoSee");
static_assert(offsetof(PrimitiveComponent_SetOwnerNoSee, bNewOwnerNoSee) == 0x000000, "Member 'PrimitiveComponent_SetOwnerNoSee::bNewOwnerNoSee' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocity
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_SetPhysicsAngularVelocity final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsAngularVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsAngularVelocity");
static_assert(sizeof(PrimitiveComponent_SetPhysicsAngularVelocity) == 0x000018, "Wrong size on PrimitiveComponent_SetPhysicsAngularVelocity");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocity, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsAngularVelocity::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocity, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetPhysicsAngularVelocity::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocity, BoneName) == 0x000010, "Member 'PrimitiveComponent_SetPhysicsAngularVelocity::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInDegrees
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_SetPhysicsAngularVelocityInDegrees final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsAngularVelocityInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsAngularVelocityInDegrees");
static_assert(sizeof(PrimitiveComponent_SetPhysicsAngularVelocityInDegrees) == 0x000018, "Wrong size on PrimitiveComponent_SetPhysicsAngularVelocityInDegrees");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInDegrees, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInDegrees::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInDegrees, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInDegrees::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInDegrees, BoneName) == 0x000010, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInDegrees::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsAngularVelocityInRadians
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_SetPhysicsAngularVelocityInRadians final
{
public:
	struct FVector                                NewAngVel;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsAngularVelocityInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsAngularVelocityInRadians");
static_assert(sizeof(PrimitiveComponent_SetPhysicsAngularVelocityInRadians) == 0x000018, "Wrong size on PrimitiveComponent_SetPhysicsAngularVelocityInRadians");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInRadians, NewAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInRadians::NewAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInRadians, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInRadians::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsAngularVelocityInRadians, BoneName) == 0x000010, "Member 'PrimitiveComponent_SetPhysicsAngularVelocityInRadians::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsLinearVelocity
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_SetPhysicsLinearVelocity final
{
public:
	struct FVector                                NewVel;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsLinearVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsLinearVelocity");
static_assert(sizeof(PrimitiveComponent_SetPhysicsLinearVelocity) == 0x000018, "Wrong size on PrimitiveComponent_SetPhysicsLinearVelocity");
static_assert(offsetof(PrimitiveComponent_SetPhysicsLinearVelocity, NewVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsLinearVelocity::NewVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsLinearVelocity, bAddToCurrent) == 0x00000C, "Member 'PrimitiveComponent_SetPhysicsLinearVelocity::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsLinearVelocity, BoneName) == 0x000010, "Member 'PrimitiveComponent_SetPhysicsLinearVelocity::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocity
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetPhysicsMaxAngularVelocity final
{
public:
	float                                         NewMaxAngVel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsMaxAngularVelocity) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsMaxAngularVelocity");
static_assert(sizeof(PrimitiveComponent_SetPhysicsMaxAngularVelocity) == 0x000010, "Wrong size on PrimitiveComponent_SetPhysicsMaxAngularVelocity");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocity, NewMaxAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocity::NewMaxAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocity, bAddToCurrent) == 0x000004, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocity::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocity, BoneName) == 0x000008, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocity::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInDegrees
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees final
{
public:
	float                                         NewMaxAngVel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees");
static_assert(sizeof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees) == 0x000010, "Wrong size on PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees, NewMaxAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees::NewMaxAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees, bAddToCurrent) == 0x000004, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees, BoneName) == 0x000008, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInDegrees::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysicsMaxAngularVelocityInRadians
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians final
{
public:
	float                                         NewMaxAngVel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAddToCurrent;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians) == 0x000004, "Wrong alignment on PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians");
static_assert(sizeof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians) == 0x000010, "Wrong size on PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians, NewMaxAngVel) == 0x000000, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians::NewMaxAngVel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians, bAddToCurrent) == 0x000004, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians::bAddToCurrent' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians, BoneName) == 0x000008, "Member 'PrimitiveComponent_SetPhysicsMaxAngularVelocityInRadians::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetPhysMaterialOverride
// 0x0008 (0x0008 - 0x0000)
struct PrimitiveComponent_SetPhysMaterialOverride final
{
public:
	class UPhysicalMaterial*                      NewPhysMaterial;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetPhysMaterialOverride) == 0x000008, "Wrong alignment on PrimitiveComponent_SetPhysMaterialOverride");
static_assert(sizeof(PrimitiveComponent_SetPhysMaterialOverride) == 0x000008, "Wrong size on PrimitiveComponent_SetPhysMaterialOverride");
static_assert(offsetof(PrimitiveComponent_SetPhysMaterialOverride, NewPhysMaterial) == 0x000000, "Member 'PrimitiveComponent_SetPhysMaterialOverride::NewPhysMaterial' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetReceivesDecals
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetReceivesDecals final
{
public:
	bool                                          bNewReceivesDecals;                                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetReceivesDecals) == 0x000001, "Wrong alignment on PrimitiveComponent_SetReceivesDecals");
static_assert(sizeof(PrimitiveComponent_SetReceivesDecals) == 0x000001, "Wrong size on PrimitiveComponent_SetReceivesDecals");
static_assert(offsetof(PrimitiveComponent_SetReceivesDecals, bNewReceivesDecals) == 0x000000, "Member 'PrimitiveComponent_SetReceivesDecals::bNewReceivesDecals' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetRenderCustomDepth
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetRenderCustomDepth final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetRenderCustomDepth) == 0x000001, "Wrong alignment on PrimitiveComponent_SetRenderCustomDepth");
static_assert(sizeof(PrimitiveComponent_SetRenderCustomDepth) == 0x000001, "Wrong size on PrimitiveComponent_SetRenderCustomDepth");
static_assert(offsetof(PrimitiveComponent_SetRenderCustomDepth, bValue) == 0x000000, "Member 'PrimitiveComponent_SetRenderCustomDepth::bValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetRenderInMainPass
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetRenderInMainPass final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetRenderInMainPass) == 0x000001, "Wrong alignment on PrimitiveComponent_SetRenderInMainPass");
static_assert(sizeof(PrimitiveComponent_SetRenderInMainPass) == 0x000001, "Wrong size on PrimitiveComponent_SetRenderInMainPass");
static_assert(offsetof(PrimitiveComponent_SetRenderInMainPass, bValue) == 0x000000, "Member 'PrimitiveComponent_SetRenderInMainPass::bValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetRenderInMono
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetRenderInMono final
{
public:
	bool                                          bValue;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetRenderInMono) == 0x000001, "Wrong alignment on PrimitiveComponent_SetRenderInMono");
static_assert(sizeof(PrimitiveComponent_SetRenderInMono) == 0x000001, "Wrong size on PrimitiveComponent_SetRenderInMono");
static_assert(offsetof(PrimitiveComponent_SetRenderInMono, bValue) == 0x000000, "Member 'PrimitiveComponent_SetRenderInMono::bValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetSimulatePhysics
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetSimulatePhysics final
{
public:
	bool                                          bSimulate;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetSimulatePhysics) == 0x000001, "Wrong alignment on PrimitiveComponent_SetSimulatePhysics");
static_assert(sizeof(PrimitiveComponent_SetSimulatePhysics) == 0x000001, "Wrong size on PrimitiveComponent_SetSimulatePhysics");
static_assert(offsetof(PrimitiveComponent_SetSimulatePhysics, bSimulate) == 0x000000, "Member 'PrimitiveComponent_SetSimulatePhysics::bSimulate' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetSingleSampleShadowFromStationaryLights
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_SetSingleSampleShadowFromStationaryLights final
{
public:
	bool                                          bNewSingleSampleShadowFromStationaryLights;        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetSingleSampleShadowFromStationaryLights) == 0x000001, "Wrong alignment on PrimitiveComponent_SetSingleSampleShadowFromStationaryLights");
static_assert(sizeof(PrimitiveComponent_SetSingleSampleShadowFromStationaryLights) == 0x000001, "Wrong size on PrimitiveComponent_SetSingleSampleShadowFromStationaryLights");
static_assert(offsetof(PrimitiveComponent_SetSingleSampleShadowFromStationaryLights, bNewSingleSampleShadowFromStationaryLights) == 0x000000, "Member 'PrimitiveComponent_SetSingleSampleShadowFromStationaryLights::bNewSingleSampleShadowFromStationaryLights' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetTranslucentSortPriority
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_SetTranslucentSortPriority final
{
public:
	int32                                         NewTranslucentSortPriority;                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetTranslucentSortPriority) == 0x000004, "Wrong alignment on PrimitiveComponent_SetTranslucentSortPriority");
static_assert(sizeof(PrimitiveComponent_SetTranslucentSortPriority) == 0x000004, "Wrong size on PrimitiveComponent_SetTranslucentSortPriority");
static_assert(offsetof(PrimitiveComponent_SetTranslucentSortPriority, NewTranslucentSortPriority) == 0x000000, "Member 'PrimitiveComponent_SetTranslucentSortPriority::NewTranslucentSortPriority' has a wrong offset!");

// Function Engine.PrimitiveComponent.SetWalkableSlopeOverride
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_SetWalkableSlopeOverride final
{
public:
	struct FWalkableSlopeOverride                 NewOverride;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_SetWalkableSlopeOverride) == 0x000004, "Wrong alignment on PrimitiveComponent_SetWalkableSlopeOverride");
static_assert(sizeof(PrimitiveComponent_SetWalkableSlopeOverride) == 0x000010, "Wrong size on PrimitiveComponent_SetWalkableSlopeOverride");
static_assert(offsetof(PrimitiveComponent_SetWalkableSlopeOverride, NewOverride) == 0x000000, "Member 'PrimitiveComponent_SetWalkableSlopeOverride::NewOverride' has a wrong offset!");

// Function Engine.PrimitiveComponent.WakeRigidBody
// 0x0008 (0x0008 - 0x0000)
struct PrimitiveComponent_WakeRigidBody final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_WakeRigidBody) == 0x000004, "Wrong alignment on PrimitiveComponent_WakeRigidBody");
static_assert(sizeof(PrimitiveComponent_WakeRigidBody) == 0x000008, "Wrong size on PrimitiveComponent_WakeRigidBody");
static_assert(offsetof(PrimitiveComponent_WakeRigidBody, BoneName) == 0x000000, "Member 'PrimitiveComponent_WakeRigidBody::BoneName' has a wrong offset!");

// Function Engine.PrimitiveComponent.CanCharacterStepUp
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_CanCharacterStepUp final
{
public:
	class APawn*                                  Pawn;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_CanCharacterStepUp) == 0x000008, "Wrong alignment on PrimitiveComponent_CanCharacterStepUp");
static_assert(sizeof(PrimitiveComponent_CanCharacterStepUp) == 0x000010, "Wrong size on PrimitiveComponent_CanCharacterStepUp");
static_assert(offsetof(PrimitiveComponent_CanCharacterStepUp, Pawn) == 0x000000, "Member 'PrimitiveComponent_CanCharacterStepUp::Pawn' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_CanCharacterStepUp, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_CanCharacterStepUp::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetAngularDamping
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_GetAngularDamping final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetAngularDamping) == 0x000004, "Wrong alignment on PrimitiveComponent_GetAngularDamping");
static_assert(sizeof(PrimitiveComponent_GetAngularDamping) == 0x000004, "Wrong size on PrimitiveComponent_GetAngularDamping");
static_assert(offsetof(PrimitiveComponent_GetAngularDamping, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetAngularDamping::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetCenterOfMass
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetCenterOfMass final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetCenterOfMass) == 0x000004, "Wrong alignment on PrimitiveComponent_GetCenterOfMass");
static_assert(sizeof(PrimitiveComponent_GetCenterOfMass) == 0x000018, "Wrong size on PrimitiveComponent_GetCenterOfMass");
static_assert(offsetof(PrimitiveComponent_GetCenterOfMass, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetCenterOfMass::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetCenterOfMass, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetCenterOfMass::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetClosestPointOnCollision
// 0x0028 (0x0028 - 0x0000)
struct PrimitiveComponent_GetClosestPointOnCollision final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutPointOnBody;                                    // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName;                                          // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetClosestPointOnCollision) == 0x000004, "Wrong alignment on PrimitiveComponent_GetClosestPointOnCollision");
static_assert(sizeof(PrimitiveComponent_GetClosestPointOnCollision) == 0x000028, "Wrong size on PrimitiveComponent_GetClosestPointOnCollision");
static_assert(offsetof(PrimitiveComponent_GetClosestPointOnCollision, Point) == 0x000000, "Member 'PrimitiveComponent_GetClosestPointOnCollision::Point' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetClosestPointOnCollision, OutPointOnBody) == 0x00000C, "Member 'PrimitiveComponent_GetClosestPointOnCollision::OutPointOnBody' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetClosestPointOnCollision, BoneName) == 0x000018, "Member 'PrimitiveComponent_GetClosestPointOnCollision::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetClosestPointOnCollision, ReturnValue) == 0x000020, "Member 'PrimitiveComponent_GetClosestPointOnCollision::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_GetCollisionEnabled final
{
public:
	ECollisionEnabled                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetCollisionEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_GetCollisionEnabled");
static_assert(sizeof(PrimitiveComponent_GetCollisionEnabled) == 0x000001, "Wrong size on PrimitiveComponent_GetCollisionEnabled");
static_assert(offsetof(PrimitiveComponent_GetCollisionEnabled, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetCollisionEnabled::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetCollisionObjectType
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_GetCollisionObjectType final
{
public:
	ECollisionChannel                             ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetCollisionObjectType) == 0x000001, "Wrong alignment on PrimitiveComponent_GetCollisionObjectType");
static_assert(sizeof(PrimitiveComponent_GetCollisionObjectType) == 0x000001, "Wrong size on PrimitiveComponent_GetCollisionObjectType");
static_assert(offsetof(PrimitiveComponent_GetCollisionObjectType, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetCollisionObjectType::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetCollisionProfileName
// 0x0008 (0x0008 - 0x0000)
struct PrimitiveComponent_GetCollisionProfileName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetCollisionProfileName) == 0x000004, "Wrong alignment on PrimitiveComponent_GetCollisionProfileName");
static_assert(sizeof(PrimitiveComponent_GetCollisionProfileName) == 0x000008, "Wrong size on PrimitiveComponent_GetCollisionProfileName");
static_assert(offsetof(PrimitiveComponent_GetCollisionProfileName, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetCollisionProfileName::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetCollisionResponseToChannel
// 0x0002 (0x0002 - 0x0000)
struct PrimitiveComponent_GetCollisionResponseToChannel final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionResponse                            ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetCollisionResponseToChannel) == 0x000001, "Wrong alignment on PrimitiveComponent_GetCollisionResponseToChannel");
static_assert(sizeof(PrimitiveComponent_GetCollisionResponseToChannel) == 0x000002, "Wrong size on PrimitiveComponent_GetCollisionResponseToChannel");
static_assert(offsetof(PrimitiveComponent_GetCollisionResponseToChannel, Channel) == 0x000000, "Member 'PrimitiveComponent_GetCollisionResponseToChannel::Channel' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetCollisionResponseToChannel, ReturnValue) == 0x000001, "Member 'PrimitiveComponent_GetCollisionResponseToChannel::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetInertiaTensor
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetInertiaTensor final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetInertiaTensor) == 0x000004, "Wrong alignment on PrimitiveComponent_GetInertiaTensor");
static_assert(sizeof(PrimitiveComponent_GetInertiaTensor) == 0x000018, "Wrong size on PrimitiveComponent_GetInertiaTensor");
static_assert(offsetof(PrimitiveComponent_GetInertiaTensor, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetInertiaTensor::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetInertiaTensor, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetInertiaTensor::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetLinearDamping
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_GetLinearDamping final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetLinearDamping) == 0x000004, "Wrong alignment on PrimitiveComponent_GetLinearDamping");
static_assert(sizeof(PrimitiveComponent_GetLinearDamping) == 0x000004, "Wrong size on PrimitiveComponent_GetLinearDamping");
static_assert(offsetof(PrimitiveComponent_GetLinearDamping, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetLinearDamping::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetMass
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_GetMass final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetMass) == 0x000004, "Wrong alignment on PrimitiveComponent_GetMass");
static_assert(sizeof(PrimitiveComponent_GetMass) == 0x000004, "Wrong size on PrimitiveComponent_GetMass");
static_assert(offsetof(PrimitiveComponent_GetMass, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetMass::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetMassScale
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_GetMassScale final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_GetMassScale) == 0x000004, "Wrong alignment on PrimitiveComponent_GetMassScale");
static_assert(sizeof(PrimitiveComponent_GetMassScale) == 0x000010, "Wrong size on PrimitiveComponent_GetMassScale");
static_assert(offsetof(PrimitiveComponent_GetMassScale, BoneName) == 0x000000, "Member 'PrimitiveComponent_GetMassScale::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetMassScale, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetMassScale::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetMaterial
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_GetMaterial final
{
public:
	int32                                         ElementIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetMaterial) == 0x000008, "Wrong alignment on PrimitiveComponent_GetMaterial");
static_assert(sizeof(PrimitiveComponent_GetMaterial) == 0x000010, "Wrong size on PrimitiveComponent_GetMaterial");
static_assert(offsetof(PrimitiveComponent_GetMaterial, ElementIndex) == 0x000000, "Member 'PrimitiveComponent_GetMaterial::ElementIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetMaterial, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetMaterial::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetMaterialFromCollisionFaceIndex
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_GetMaterialFromCollisionFaceIndex final
{
public:
	int32                                         FaceIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SectionIndex;                                      // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetMaterialFromCollisionFaceIndex) == 0x000008, "Wrong alignment on PrimitiveComponent_GetMaterialFromCollisionFaceIndex");
static_assert(sizeof(PrimitiveComponent_GetMaterialFromCollisionFaceIndex) == 0x000010, "Wrong size on PrimitiveComponent_GetMaterialFromCollisionFaceIndex");
static_assert(offsetof(PrimitiveComponent_GetMaterialFromCollisionFaceIndex, FaceIndex) == 0x000000, "Member 'PrimitiveComponent_GetMaterialFromCollisionFaceIndex::FaceIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetMaterialFromCollisionFaceIndex, SectionIndex) == 0x000004, "Member 'PrimitiveComponent_GetMaterialFromCollisionFaceIndex::SectionIndex' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetMaterialFromCollisionFaceIndex, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_GetMaterialFromCollisionFaceIndex::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetNumMaterials
// 0x0004 (0x0004 - 0x0000)
struct PrimitiveComponent_GetNumMaterials final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetNumMaterials) == 0x000004, "Wrong alignment on PrimitiveComponent_GetNumMaterials");
static_assert(sizeof(PrimitiveComponent_GetNumMaterials) == 0x000004, "Wrong size on PrimitiveComponent_GetNumMaterials");
static_assert(offsetof(PrimitiveComponent_GetNumMaterials, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetNumMaterials::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetOverlappingActors
// 0x0018 (0x0018 - 0x0000)
struct PrimitiveComponent_GetOverlappingActors final
{
public:
	TArray<class AActor*>                         OverlappingActors;                                 // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetOverlappingActors) == 0x000008, "Wrong alignment on PrimitiveComponent_GetOverlappingActors");
static_assert(sizeof(PrimitiveComponent_GetOverlappingActors) == 0x000018, "Wrong size on PrimitiveComponent_GetOverlappingActors");
static_assert(offsetof(PrimitiveComponent_GetOverlappingActors, OverlappingActors) == 0x000000, "Member 'PrimitiveComponent_GetOverlappingActors::OverlappingActors' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_GetOverlappingActors, ClassFilter) == 0x000010, "Member 'PrimitiveComponent_GetOverlappingActors::ClassFilter' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetOverlappingComponents
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_GetOverlappingComponents final
{
public:
	TArray<class UPrimitiveComponent*>            InOverlappingComponents;                           // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetOverlappingComponents) == 0x000008, "Wrong alignment on PrimitiveComponent_GetOverlappingComponents");
static_assert(sizeof(PrimitiveComponent_GetOverlappingComponents) == 0x000010, "Wrong size on PrimitiveComponent_GetOverlappingComponents");
static_assert(offsetof(PrimitiveComponent_GetOverlappingComponents, InOverlappingComponents) == 0x000000, "Member 'PrimitiveComponent_GetOverlappingComponents::InOverlappingComponents' has a wrong offset!");

// Function Engine.PrimitiveComponent.GetWalkableSlopeOverride
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_GetWalkableSlopeOverride final
{
public:
	struct FWalkableSlopeOverride                 ReturnValue;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReturnParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_GetWalkableSlopeOverride) == 0x000004, "Wrong alignment on PrimitiveComponent_GetWalkableSlopeOverride");
static_assert(sizeof(PrimitiveComponent_GetWalkableSlopeOverride) == 0x000010, "Wrong size on PrimitiveComponent_GetWalkableSlopeOverride");
static_assert(offsetof(PrimitiveComponent_GetWalkableSlopeOverride, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_GetWalkableSlopeOverride::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.IsGravityEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_IsGravityEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_IsGravityEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_IsGravityEnabled");
static_assert(sizeof(PrimitiveComponent_IsGravityEnabled) == 0x000001, "Wrong size on PrimitiveComponent_IsGravityEnabled");
static_assert(offsetof(PrimitiveComponent_IsGravityEnabled, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_IsGravityEnabled::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.IsOverlappingActor
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_IsOverlappingActor final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_IsOverlappingActor) == 0x000008, "Wrong alignment on PrimitiveComponent_IsOverlappingActor");
static_assert(sizeof(PrimitiveComponent_IsOverlappingActor) == 0x000010, "Wrong size on PrimitiveComponent_IsOverlappingActor");
static_assert(offsetof(PrimitiveComponent_IsOverlappingActor, Other) == 0x000000, "Member 'PrimitiveComponent_IsOverlappingActor::Other' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_IsOverlappingActor, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_IsOverlappingActor::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.IsOverlappingComponent
// 0x0010 (0x0010 - 0x0000)
struct PrimitiveComponent_IsOverlappingComponent final
{
public:
	const class UPrimitiveComponent*              OtherComp;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_IsOverlappingComponent) == 0x000008, "Wrong alignment on PrimitiveComponent_IsOverlappingComponent");
static_assert(sizeof(PrimitiveComponent_IsOverlappingComponent) == 0x000010, "Wrong size on PrimitiveComponent_IsOverlappingComponent");
static_assert(offsetof(PrimitiveComponent_IsOverlappingComponent, OtherComp) == 0x000000, "Member 'PrimitiveComponent_IsOverlappingComponent::OtherComp' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_IsOverlappingComponent, ReturnValue) == 0x000008, "Member 'PrimitiveComponent_IsOverlappingComponent::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.K2_IsCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_K2_IsCollisionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_K2_IsCollisionEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_K2_IsCollisionEnabled");
static_assert(sizeof(PrimitiveComponent_K2_IsCollisionEnabled) == 0x000001, "Wrong size on PrimitiveComponent_K2_IsCollisionEnabled");
static_assert(offsetof(PrimitiveComponent_K2_IsCollisionEnabled, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_K2_IsCollisionEnabled::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.K2_IsPhysicsCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_K2_IsPhysicsCollisionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_K2_IsPhysicsCollisionEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_K2_IsPhysicsCollisionEnabled");
static_assert(sizeof(PrimitiveComponent_K2_IsPhysicsCollisionEnabled) == 0x000001, "Wrong size on PrimitiveComponent_K2_IsPhysicsCollisionEnabled");
static_assert(offsetof(PrimitiveComponent_K2_IsPhysicsCollisionEnabled, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_K2_IsPhysicsCollisionEnabled::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.K2_IsQueryCollisionEnabled
// 0x0001 (0x0001 - 0x0000)
struct PrimitiveComponent_K2_IsQueryCollisionEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PrimitiveComponent_K2_IsQueryCollisionEnabled) == 0x000001, "Wrong alignment on PrimitiveComponent_K2_IsQueryCollisionEnabled");
static_assert(sizeof(PrimitiveComponent_K2_IsQueryCollisionEnabled) == 0x000001, "Wrong size on PrimitiveComponent_K2_IsQueryCollisionEnabled");
static_assert(offsetof(PrimitiveComponent_K2_IsQueryCollisionEnabled, ReturnValue) == 0x000000, "Member 'PrimitiveComponent_K2_IsQueryCollisionEnabled::ReturnValue' has a wrong offset!");

// Function Engine.PrimitiveComponent.ScaleByMomentOfInertia
// 0x0028 (0x0028 - 0x0000)
struct PrimitiveComponent_ScaleByMomentOfInertia final
{
public:
	struct FVector                                InputVector;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PrimitiveComponent_ScaleByMomentOfInertia) == 0x000004, "Wrong alignment on PrimitiveComponent_ScaleByMomentOfInertia");
static_assert(sizeof(PrimitiveComponent_ScaleByMomentOfInertia) == 0x000028, "Wrong size on PrimitiveComponent_ScaleByMomentOfInertia");
static_assert(offsetof(PrimitiveComponent_ScaleByMomentOfInertia, InputVector) == 0x000000, "Member 'PrimitiveComponent_ScaleByMomentOfInertia::InputVector' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_ScaleByMomentOfInertia, BoneName) == 0x000010, "Member 'PrimitiveComponent_ScaleByMomentOfInertia::BoneName' has a wrong offset!");
static_assert(offsetof(PrimitiveComponent_ScaleByMomentOfInertia, ReturnValue) == 0x000018, "Member 'PrimitiveComponent_ScaleByMomentOfInertia::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.BeginTrails
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_BeginTrails final
{
public:
	class FName                                   InFirstSocketName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSecondSocketName;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               InWidthMode;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InWidth;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_BeginTrails) == 0x000004, "Wrong alignment on ParticleSystemComponent_BeginTrails");
static_assert(sizeof(ParticleSystemComponent_BeginTrails) == 0x000018, "Wrong size on ParticleSystemComponent_BeginTrails");
static_assert(offsetof(ParticleSystemComponent_BeginTrails, InFirstSocketName) == 0x000000, "Member 'ParticleSystemComponent_BeginTrails::InFirstSocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_BeginTrails, InSecondSocketName) == 0x000008, "Member 'ParticleSystemComponent_BeginTrails::InSecondSocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_BeginTrails, InWidthMode) == 0x000010, "Member 'ParticleSystemComponent_BeginTrails::InWidthMode' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_BeginTrails, InWidth) == 0x000014, "Member 'ParticleSystemComponent_BeginTrails::InWidth' has a wrong offset!");

// Function Engine.ParticleSystemComponent.CreateNamedDynamicMaterialInstance
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_CreateNamedDynamicMaterialInstance final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     SourceMaterial;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_CreateNamedDynamicMaterialInstance) == 0x000008, "Wrong alignment on ParticleSystemComponent_CreateNamedDynamicMaterialInstance");
static_assert(sizeof(ParticleSystemComponent_CreateNamedDynamicMaterialInstance) == 0x000018, "Wrong size on ParticleSystemComponent_CreateNamedDynamicMaterialInstance");
static_assert(offsetof(ParticleSystemComponent_CreateNamedDynamicMaterialInstance, InName) == 0x000000, "Member 'ParticleSystemComponent_CreateNamedDynamicMaterialInstance::InName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_CreateNamedDynamicMaterialInstance, SourceMaterial) == 0x000008, "Member 'ParticleSystemComponent_CreateNamedDynamicMaterialInstance::SourceMaterial' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_CreateNamedDynamicMaterialInstance, ReturnValue) == 0x000010, "Member 'ParticleSystemComponent_CreateNamedDynamicMaterialInstance::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GenerateParticleEvent
// 0x0030 (0x0030 - 0x0000)
struct ParticleSystemComponent_GenerateParticleEvent final
{
public:
	class FName                                   InEventName;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InEmitterTime;                                     // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x000C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InDirection;                                       // 0x0018(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InVelocity;                                        // 0x0024(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_GenerateParticleEvent) == 0x000004, "Wrong alignment on ParticleSystemComponent_GenerateParticleEvent");
static_assert(sizeof(ParticleSystemComponent_GenerateParticleEvent) == 0x000030, "Wrong size on ParticleSystemComponent_GenerateParticleEvent");
static_assert(offsetof(ParticleSystemComponent_GenerateParticleEvent, InEventName) == 0x000000, "Member 'ParticleSystemComponent_GenerateParticleEvent::InEventName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GenerateParticleEvent, InEmitterTime) == 0x000008, "Member 'ParticleSystemComponent_GenerateParticleEvent::InEmitterTime' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GenerateParticleEvent, InLocation) == 0x00000C, "Member 'ParticleSystemComponent_GenerateParticleEvent::InLocation' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GenerateParticleEvent, InDirection) == 0x000018, "Member 'ParticleSystemComponent_GenerateParticleEvent::InDirection' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GenerateParticleEvent, InVelocity) == 0x000024, "Member 'ParticleSystemComponent_GenerateParticleEvent::InVelocity' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetActorParameter
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_SetActorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Param;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetActorParameter) == 0x000008, "Wrong alignment on ParticleSystemComponent_SetActorParameter");
static_assert(sizeof(ParticleSystemComponent_SetActorParameter) == 0x000010, "Wrong size on ParticleSystemComponent_SetActorParameter");
static_assert(offsetof(ParticleSystemComponent_SetActorParameter, ParameterName) == 0x000000, "Member 'ParticleSystemComponent_SetActorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetActorParameter, Param) == 0x000008, "Member 'ParticleSystemComponent_SetActorParameter::Param' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetAutoAttachmentParameters
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_SetAutoAttachmentParameters final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               LocationRule;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               RotationRule;                                      // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachmentRule                               ScaleRule;                                         // 0x0012(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_13[0x5];                                       // 0x0013(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_SetAutoAttachmentParameters) == 0x000008, "Wrong alignment on ParticleSystemComponent_SetAutoAttachmentParameters");
static_assert(sizeof(ParticleSystemComponent_SetAutoAttachmentParameters) == 0x000018, "Wrong size on ParticleSystemComponent_SetAutoAttachmentParameters");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachmentParameters, Parent) == 0x000000, "Member 'ParticleSystemComponent_SetAutoAttachmentParameters::Parent' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachmentParameters, SocketName) == 0x000008, "Member 'ParticleSystemComponent_SetAutoAttachmentParameters::SocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachmentParameters, LocationRule) == 0x000010, "Member 'ParticleSystemComponent_SetAutoAttachmentParameters::LocationRule' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachmentParameters, RotationRule) == 0x000011, "Member 'ParticleSystemComponent_SetAutoAttachmentParameters::RotationRule' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachmentParameters, ScaleRule) == 0x000012, "Member 'ParticleSystemComponent_SetAutoAttachmentParameters::ScaleRule' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetAutoAttachParams
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_SetAutoAttachParams final
{
public:
	class USceneComponent*                        Parent;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SocketName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_SetAutoAttachParams) == 0x000008, "Wrong alignment on ParticleSystemComponent_SetAutoAttachParams");
static_assert(sizeof(ParticleSystemComponent_SetAutoAttachParams) == 0x000018, "Wrong size on ParticleSystemComponent_SetAutoAttachParams");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachParams, Parent) == 0x000000, "Member 'ParticleSystemComponent_SetAutoAttachParams::Parent' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachParams, SocketName) == 0x000008, "Member 'ParticleSystemComponent_SetAutoAttachParams::SocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetAutoAttachParams, LocationType) == 0x000010, "Member 'ParticleSystemComponent_SetAutoAttachParams::LocationType' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamEndPoint
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_SetBeamEndPoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewEndPoint;                                       // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamEndPoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamEndPoint");
static_assert(sizeof(ParticleSystemComponent_SetBeamEndPoint) == 0x000010, "Wrong size on ParticleSystemComponent_SetBeamEndPoint");
static_assert(offsetof(ParticleSystemComponent_SetBeamEndPoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamEndPoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamEndPoint, NewEndPoint) == 0x000004, "Member 'ParticleSystemComponent_SetBeamEndPoint::NewEndPoint' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamSourcePoint
// 0x0014 (0x0014 - 0x0000)
struct ParticleSystemComponent_SetBeamSourcePoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewSourcePoint;                                    // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamSourcePoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamSourcePoint");
static_assert(sizeof(ParticleSystemComponent_SetBeamSourcePoint) == 0x000014, "Wrong size on ParticleSystemComponent_SetBeamSourcePoint");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourcePoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamSourcePoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourcePoint, NewSourcePoint) == 0x000004, "Member 'ParticleSystemComponent_SetBeamSourcePoint::NewSourcePoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourcePoint, SourceIndex) == 0x000010, "Member 'ParticleSystemComponent_SetBeamSourcePoint::SourceIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamSourceStrength
// 0x000C (0x000C - 0x0000)
struct ParticleSystemComponent_SetBeamSourceStrength final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewSourceStrength;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamSourceStrength) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamSourceStrength");
static_assert(sizeof(ParticleSystemComponent_SetBeamSourceStrength) == 0x00000C, "Wrong size on ParticleSystemComponent_SetBeamSourceStrength");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceStrength, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamSourceStrength::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceStrength, NewSourceStrength) == 0x000004, "Member 'ParticleSystemComponent_SetBeamSourceStrength::NewSourceStrength' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceStrength, SourceIndex) == 0x000008, "Member 'ParticleSystemComponent_SetBeamSourceStrength::SourceIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamSourceTangent
// 0x0014 (0x0014 - 0x0000)
struct ParticleSystemComponent_SetBeamSourceTangent final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTangentPoint;                                   // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamSourceTangent) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamSourceTangent");
static_assert(sizeof(ParticleSystemComponent_SetBeamSourceTangent) == 0x000014, "Wrong size on ParticleSystemComponent_SetBeamSourceTangent");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceTangent, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamSourceTangent::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceTangent, NewTangentPoint) == 0x000004, "Member 'ParticleSystemComponent_SetBeamSourceTangent::NewTangentPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamSourceTangent, SourceIndex) == 0x000010, "Member 'ParticleSystemComponent_SetBeamSourceTangent::SourceIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamTargetPoint
// 0x0014 (0x0014 - 0x0000)
struct ParticleSystemComponent_SetBeamTargetPoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTargetPoint;                                    // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamTargetPoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamTargetPoint");
static_assert(sizeof(ParticleSystemComponent_SetBeamTargetPoint) == 0x000014, "Wrong size on ParticleSystemComponent_SetBeamTargetPoint");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetPoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamTargetPoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetPoint, NewTargetPoint) == 0x000004, "Member 'ParticleSystemComponent_SetBeamTargetPoint::NewTargetPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetPoint, TargetIndex) == 0x000010, "Member 'ParticleSystemComponent_SetBeamTargetPoint::TargetIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamTargetStrength
// 0x000C (0x000C - 0x0000)
struct ParticleSystemComponent_SetBeamTargetStrength final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewTargetStrength;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamTargetStrength) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamTargetStrength");
static_assert(sizeof(ParticleSystemComponent_SetBeamTargetStrength) == 0x00000C, "Wrong size on ParticleSystemComponent_SetBeamTargetStrength");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetStrength, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamTargetStrength::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetStrength, NewTargetStrength) == 0x000004, "Member 'ParticleSystemComponent_SetBeamTargetStrength::NewTargetStrength' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetStrength, TargetIndex) == 0x000008, "Member 'ParticleSystemComponent_SetBeamTargetStrength::TargetIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetBeamTargetTangent
// 0x0014 (0x0014 - 0x0000)
struct ParticleSystemComponent_SetBeamTargetTangent final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewTangentPoint;                                   // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetBeamTargetTangent) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetBeamTargetTangent");
static_assert(sizeof(ParticleSystemComponent_SetBeamTargetTangent) == 0x000014, "Wrong size on ParticleSystemComponent_SetBeamTargetTangent");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetTangent, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_SetBeamTargetTangent::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetTangent, NewTangentPoint) == 0x000004, "Member 'ParticleSystemComponent_SetBeamTargetTangent::NewTangentPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetBeamTargetTangent, TargetIndex) == 0x000010, "Member 'ParticleSystemComponent_SetBeamTargetTangent::TargetIndex' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetColorParameter
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_SetColorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Param;                                             // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetColorParameter) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetColorParameter");
static_assert(sizeof(ParticleSystemComponent_SetColorParameter) == 0x000018, "Wrong size on ParticleSystemComponent_SetColorParameter");
static_assert(offsetof(ParticleSystemComponent_SetColorParameter, ParameterName) == 0x000000, "Member 'ParticleSystemComponent_SetColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetColorParameter, Param) == 0x000008, "Member 'ParticleSystemComponent_SetColorParameter::Param' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetEmitterEnable
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_SetEmitterEnable final
{
public:
	class FName                                   EmitterName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewEnableState;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_SetEmitterEnable) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetEmitterEnable");
static_assert(sizeof(ParticleSystemComponent_SetEmitterEnable) == 0x000010, "Wrong size on ParticleSystemComponent_SetEmitterEnable");
static_assert(offsetof(ParticleSystemComponent_SetEmitterEnable, EmitterName) == 0x000000, "Member 'ParticleSystemComponent_SetEmitterEnable::EmitterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetEmitterEnable, bNewEnableState) == 0x000008, "Member 'ParticleSystemComponent_SetEmitterEnable::bNewEnableState' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetFloatParameter
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_SetFloatParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_SetFloatParameter) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetFloatParameter");
static_assert(sizeof(ParticleSystemComponent_SetFloatParameter) == 0x000010, "Wrong size on ParticleSystemComponent_SetFloatParameter");
static_assert(offsetof(ParticleSystemComponent_SetFloatParameter, ParameterName) == 0x000000, "Member 'ParticleSystemComponent_SetFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetFloatParameter, Param) == 0x000008, "Member 'ParticleSystemComponent_SetFloatParameter::Param' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetMaterialParameter
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_SetMaterialParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Param;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetMaterialParameter) == 0x000008, "Wrong alignment on ParticleSystemComponent_SetMaterialParameter");
static_assert(sizeof(ParticleSystemComponent_SetMaterialParameter) == 0x000010, "Wrong size on ParticleSystemComponent_SetMaterialParameter");
static_assert(offsetof(ParticleSystemComponent_SetMaterialParameter, ParameterName) == 0x000000, "Member 'ParticleSystemComponent_SetMaterialParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetMaterialParameter, Param) == 0x000008, "Member 'ParticleSystemComponent_SetMaterialParameter::Param' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetTemplate
// 0x0008 (0x0008 - 0x0000)
struct ParticleSystemComponent_SetTemplate final
{
public:
	class UParticleSystem*                        NewTemplate;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetTemplate) == 0x000008, "Wrong alignment on ParticleSystemComponent_SetTemplate");
static_assert(sizeof(ParticleSystemComponent_SetTemplate) == 0x000008, "Wrong size on ParticleSystemComponent_SetTemplate");
static_assert(offsetof(ParticleSystemComponent_SetTemplate, NewTemplate) == 0x000000, "Member 'ParticleSystemComponent_SetTemplate::NewTemplate' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetTrailSourceData
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_SetTrailSourceData final
{
public:
	class FName                                   InFirstSocketName;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InSecondSocketName;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETrailWidthMode                               InWidthMode;                                       // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InWidth;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_SetTrailSourceData) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetTrailSourceData");
static_assert(sizeof(ParticleSystemComponent_SetTrailSourceData) == 0x000018, "Wrong size on ParticleSystemComponent_SetTrailSourceData");
static_assert(offsetof(ParticleSystemComponent_SetTrailSourceData, InFirstSocketName) == 0x000000, "Member 'ParticleSystemComponent_SetTrailSourceData::InFirstSocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetTrailSourceData, InSecondSocketName) == 0x000008, "Member 'ParticleSystemComponent_SetTrailSourceData::InSecondSocketName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetTrailSourceData, InWidthMode) == 0x000010, "Member 'ParticleSystemComponent_SetTrailSourceData::InWidthMode' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetTrailSourceData, InWidth) == 0x000014, "Member 'ParticleSystemComponent_SetTrailSourceData::InWidth' has a wrong offset!");

// Function Engine.ParticleSystemComponent.SetVectorParameter
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_SetVectorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Param;                                             // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_SetVectorParameter) == 0x000004, "Wrong alignment on ParticleSystemComponent_SetVectorParameter");
static_assert(sizeof(ParticleSystemComponent_SetVectorParameter) == 0x000018, "Wrong size on ParticleSystemComponent_SetVectorParameter");
static_assert(offsetof(ParticleSystemComponent_SetVectorParameter, ParameterName) == 0x000000, "Member 'ParticleSystemComponent_SetVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_SetVectorParameter, Param) == 0x000008, "Member 'ParticleSystemComponent_SetVectorParameter::Param' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamEndPoint
// 0x0014 (0x0014 - 0x0000)
struct ParticleSystemComponent_GetBeamEndPoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutEndPoint;                                       // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamEndPoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamEndPoint");
static_assert(sizeof(ParticleSystemComponent_GetBeamEndPoint) == 0x000014, "Wrong size on ParticleSystemComponent_GetBeamEndPoint");
static_assert(offsetof(ParticleSystemComponent_GetBeamEndPoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamEndPoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamEndPoint, OutEndPoint) == 0x000004, "Member 'ParticleSystemComponent_GetBeamEndPoint::OutEndPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamEndPoint, ReturnValue) == 0x000010, "Member 'ParticleSystemComponent_GetBeamEndPoint::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamSourcePoint
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_GetBeamSourcePoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutSourcePoint;                                    // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamSourcePoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamSourcePoint");
static_assert(sizeof(ParticleSystemComponent_GetBeamSourcePoint) == 0x000018, "Wrong size on ParticleSystemComponent_GetBeamSourcePoint");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourcePoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamSourcePoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourcePoint, SourceIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamSourcePoint::SourceIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourcePoint, OutSourcePoint) == 0x000008, "Member 'ParticleSystemComponent_GetBeamSourcePoint::OutSourcePoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourcePoint, ReturnValue) == 0x000014, "Member 'ParticleSystemComponent_GetBeamSourcePoint::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamSourceStrength
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_GetBeamSourceStrength final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutSourceStrength;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamSourceStrength) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamSourceStrength");
static_assert(sizeof(ParticleSystemComponent_GetBeamSourceStrength) == 0x000010, "Wrong size on ParticleSystemComponent_GetBeamSourceStrength");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceStrength, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamSourceStrength::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceStrength, SourceIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamSourceStrength::SourceIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceStrength, OutSourceStrength) == 0x000008, "Member 'ParticleSystemComponent_GetBeamSourceStrength::OutSourceStrength' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceStrength, ReturnValue) == 0x00000C, "Member 'ParticleSystemComponent_GetBeamSourceStrength::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamSourceTangent
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_GetBeamSourceTangent final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SourceIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutTangentPoint;                                   // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamSourceTangent) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamSourceTangent");
static_assert(sizeof(ParticleSystemComponent_GetBeamSourceTangent) == 0x000018, "Wrong size on ParticleSystemComponent_GetBeamSourceTangent");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceTangent, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamSourceTangent::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceTangent, SourceIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamSourceTangent::SourceIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceTangent, OutTangentPoint) == 0x000008, "Member 'ParticleSystemComponent_GetBeamSourceTangent::OutTangentPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamSourceTangent, ReturnValue) == 0x000014, "Member 'ParticleSystemComponent_GetBeamSourceTangent::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamTargetPoint
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_GetBeamTargetPoint final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutTargetPoint;                                    // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamTargetPoint) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamTargetPoint");
static_assert(sizeof(ParticleSystemComponent_GetBeamTargetPoint) == 0x000018, "Wrong size on ParticleSystemComponent_GetBeamTargetPoint");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetPoint, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamTargetPoint::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetPoint, TargetIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamTargetPoint::TargetIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetPoint, OutTargetPoint) == 0x000008, "Member 'ParticleSystemComponent_GetBeamTargetPoint::OutTargetPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetPoint, ReturnValue) == 0x000014, "Member 'ParticleSystemComponent_GetBeamTargetPoint::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamTargetStrength
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_GetBeamTargetStrength final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutTargetStrength;                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamTargetStrength) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamTargetStrength");
static_assert(sizeof(ParticleSystemComponent_GetBeamTargetStrength) == 0x000010, "Wrong size on ParticleSystemComponent_GetBeamTargetStrength");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetStrength, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamTargetStrength::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetStrength, TargetIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamTargetStrength::TargetIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetStrength, OutTargetStrength) == 0x000008, "Member 'ParticleSystemComponent_GetBeamTargetStrength::OutTargetStrength' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetStrength, ReturnValue) == 0x00000C, "Member 'ParticleSystemComponent_GetBeamTargetStrength::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetBeamTargetTangent
// 0x0018 (0x0018 - 0x0000)
struct ParticleSystemComponent_GetBeamTargetTangent final
{
public:
	int32                                         EmitterIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetIndex;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutTangentPoint;                                   // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystemComponent_GetBeamTargetTangent) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetBeamTargetTangent");
static_assert(sizeof(ParticleSystemComponent_GetBeamTargetTangent) == 0x000018, "Wrong size on ParticleSystemComponent_GetBeamTargetTangent");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetTangent, EmitterIndex) == 0x000000, "Member 'ParticleSystemComponent_GetBeamTargetTangent::EmitterIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetTangent, TargetIndex) == 0x000004, "Member 'ParticleSystemComponent_GetBeamTargetTangent::TargetIndex' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetTangent, OutTangentPoint) == 0x000008, "Member 'ParticleSystemComponent_GetBeamTargetTangent::OutTangentPoint' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetBeamTargetTangent, ReturnValue) == 0x000014, "Member 'ParticleSystemComponent_GetBeamTargetTangent::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetNamedMaterial
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystemComponent_GetNamedMaterial final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_GetNamedMaterial) == 0x000008, "Wrong alignment on ParticleSystemComponent_GetNamedMaterial");
static_assert(sizeof(ParticleSystemComponent_GetNamedMaterial) == 0x000010, "Wrong size on ParticleSystemComponent_GetNamedMaterial");
static_assert(offsetof(ParticleSystemComponent_GetNamedMaterial, InName) == 0x000000, "Member 'ParticleSystemComponent_GetNamedMaterial::InName' has a wrong offset!");
static_assert(offsetof(ParticleSystemComponent_GetNamedMaterial, ReturnValue) == 0x000008, "Member 'ParticleSystemComponent_GetNamedMaterial::ReturnValue' has a wrong offset!");

// Function Engine.ParticleSystemComponent.GetNumActiveParticles
// 0x0004 (0x0004 - 0x0000)
struct ParticleSystemComponent_GetNumActiveParticles final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ParticleSystemComponent_GetNumActiveParticles) == 0x000004, "Wrong alignment on ParticleSystemComponent_GetNumActiveParticles");
static_assert(sizeof(ParticleSystemComponent_GetNumActiveParticles) == 0x000004, "Wrong size on ParticleSystemComponent_GetNumActiveParticles");
static_assert(offsetof(ParticleSystemComponent_GetNumActiveParticles, ReturnValue) == 0x000000, "Member 'ParticleSystemComponent_GetNumActiveParticles::ReturnValue' has a wrong offset!");

// Function Engine.Controller.CastToPlayerController
// 0x0008 (0x0008 - 0x0000)
struct Controller_CastToPlayerController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_CastToPlayerController) == 0x000008, "Wrong alignment on Controller_CastToPlayerController");
static_assert(sizeof(Controller_CastToPlayerController) == 0x000008, "Wrong size on Controller_CastToPlayerController");
static_assert(offsetof(Controller_CastToPlayerController, ReturnValue) == 0x000000, "Member 'Controller_CastToPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.Controller.ClientSetLocation
// 0x0018 (0x0018 - 0x0000)
struct Controller_ClientSetLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_ClientSetLocation) == 0x000004, "Wrong alignment on Controller_ClientSetLocation");
static_assert(sizeof(Controller_ClientSetLocation) == 0x000018, "Wrong size on Controller_ClientSetLocation");
static_assert(offsetof(Controller_ClientSetLocation, NewLocation) == 0x000000, "Member 'Controller_ClientSetLocation::NewLocation' has a wrong offset!");
static_assert(offsetof(Controller_ClientSetLocation, NewRotation) == 0x00000C, "Member 'Controller_ClientSetLocation::NewRotation' has a wrong offset!");

// Function Engine.Controller.ClientSetRotation
// 0x0010 (0x0010 - 0x0000)
struct Controller_ClientSetRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bResetCamera;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Controller_ClientSetRotation) == 0x000004, "Wrong alignment on Controller_ClientSetRotation");
static_assert(sizeof(Controller_ClientSetRotation) == 0x000010, "Wrong size on Controller_ClientSetRotation");
static_assert(offsetof(Controller_ClientSetRotation, NewRotation) == 0x000000, "Member 'Controller_ClientSetRotation::NewRotation' has a wrong offset!");
static_assert(offsetof(Controller_ClientSetRotation, bResetCamera) == 0x00000C, "Member 'Controller_ClientSetRotation::bResetCamera' has a wrong offset!");

// Function Engine.Controller.Possess
// 0x0008 (0x0008 - 0x0000)
struct Controller_Possess final
{
public:
	class APawn*                                  InPawn;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_Possess) == 0x000008, "Wrong alignment on Controller_Possess");
static_assert(sizeof(Controller_Possess) == 0x000008, "Wrong size on Controller_Possess");
static_assert(offsetof(Controller_Possess, InPawn) == 0x000000, "Member 'Controller_Possess::InPawn' has a wrong offset!");

// Function Engine.Controller.ReceiveInstigatedAnyDamage
// 0x0020 (0x0020 - 0x0000)
struct Controller_ReceiveInstigatedAnyDamage final
{
public:
	float                                         Damage;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UDamageType*                      DamageType;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamagedActor;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_ReceiveInstigatedAnyDamage) == 0x000008, "Wrong alignment on Controller_ReceiveInstigatedAnyDamage");
static_assert(sizeof(Controller_ReceiveInstigatedAnyDamage) == 0x000020, "Wrong size on Controller_ReceiveInstigatedAnyDamage");
static_assert(offsetof(Controller_ReceiveInstigatedAnyDamage, Damage) == 0x000000, "Member 'Controller_ReceiveInstigatedAnyDamage::Damage' has a wrong offset!");
static_assert(offsetof(Controller_ReceiveInstigatedAnyDamage, DamageType) == 0x000008, "Member 'Controller_ReceiveInstigatedAnyDamage::DamageType' has a wrong offset!");
static_assert(offsetof(Controller_ReceiveInstigatedAnyDamage, DamagedActor) == 0x000010, "Member 'Controller_ReceiveInstigatedAnyDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(Controller_ReceiveInstigatedAnyDamage, DamageCauser) == 0x000018, "Member 'Controller_ReceiveInstigatedAnyDamage::DamageCauser' has a wrong offset!");

// Function Engine.Controller.SetControlRotation
// 0x000C (0x000C - 0x0000)
struct Controller_SetControlRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_SetControlRotation) == 0x000004, "Wrong alignment on Controller_SetControlRotation");
static_assert(sizeof(Controller_SetControlRotation) == 0x00000C, "Wrong size on Controller_SetControlRotation");
static_assert(offsetof(Controller_SetControlRotation, NewRotation) == 0x000000, "Member 'Controller_SetControlRotation::NewRotation' has a wrong offset!");

// Function Engine.Controller.SetIgnoreLookInput
// 0x0001 (0x0001 - 0x0000)
struct Controller_SetIgnoreLookInput final
{
public:
	bool                                          bNewLookInput;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_SetIgnoreLookInput) == 0x000001, "Wrong alignment on Controller_SetIgnoreLookInput");
static_assert(sizeof(Controller_SetIgnoreLookInput) == 0x000001, "Wrong size on Controller_SetIgnoreLookInput");
static_assert(offsetof(Controller_SetIgnoreLookInput, bNewLookInput) == 0x000000, "Member 'Controller_SetIgnoreLookInput::bNewLookInput' has a wrong offset!");

// Function Engine.Controller.SetIgnoreMoveInput
// 0x0001 (0x0001 - 0x0000)
struct Controller_SetIgnoreMoveInput final
{
public:
	bool                                          bNewMoveInput;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_SetIgnoreMoveInput) == 0x000001, "Wrong alignment on Controller_SetIgnoreMoveInput");
static_assert(sizeof(Controller_SetIgnoreMoveInput) == 0x000001, "Wrong size on Controller_SetIgnoreMoveInput");
static_assert(offsetof(Controller_SetIgnoreMoveInput, bNewMoveInput) == 0x000000, "Member 'Controller_SetIgnoreMoveInput::bNewMoveInput' has a wrong offset!");

// Function Engine.Controller.SetInitialLocationAndRotation
// 0x0018 (0x0018 - 0x0000)
struct Controller_SetInitialLocationAndRotation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_SetInitialLocationAndRotation) == 0x000004, "Wrong alignment on Controller_SetInitialLocationAndRotation");
static_assert(sizeof(Controller_SetInitialLocationAndRotation) == 0x000018, "Wrong size on Controller_SetInitialLocationAndRotation");
static_assert(offsetof(Controller_SetInitialLocationAndRotation, NewLocation) == 0x000000, "Member 'Controller_SetInitialLocationAndRotation::NewLocation' has a wrong offset!");
static_assert(offsetof(Controller_SetInitialLocationAndRotation, NewRotation) == 0x00000C, "Member 'Controller_SetInitialLocationAndRotation::NewRotation' has a wrong offset!");

// Function Engine.Controller.GetControlRotation
// 0x000C (0x000C - 0x0000)
struct Controller_GetControlRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_GetControlRotation) == 0x000004, "Wrong alignment on Controller_GetControlRotation");
static_assert(sizeof(Controller_GetControlRotation) == 0x00000C, "Wrong size on Controller_GetControlRotation");
static_assert(offsetof(Controller_GetControlRotation, ReturnValue) == 0x000000, "Member 'Controller_GetControlRotation::ReturnValue' has a wrong offset!");

// Function Engine.Controller.GetDesiredRotation
// 0x000C (0x000C - 0x0000)
struct Controller_GetDesiredRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_GetDesiredRotation) == 0x000004, "Wrong alignment on Controller_GetDesiredRotation");
static_assert(sizeof(Controller_GetDesiredRotation) == 0x00000C, "Wrong size on Controller_GetDesiredRotation");
static_assert(offsetof(Controller_GetDesiredRotation, ReturnValue) == 0x000000, "Member 'Controller_GetDesiredRotation::ReturnValue' has a wrong offset!");

// Function Engine.Controller.GetViewTarget
// 0x0008 (0x0008 - 0x0000)
struct Controller_GetViewTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_GetViewTarget) == 0x000008, "Wrong alignment on Controller_GetViewTarget");
static_assert(sizeof(Controller_GetViewTarget) == 0x000008, "Wrong size on Controller_GetViewTarget");
static_assert(offsetof(Controller_GetViewTarget, ReturnValue) == 0x000000, "Member 'Controller_GetViewTarget::ReturnValue' has a wrong offset!");

// Function Engine.Controller.IsLocalController
// 0x0001 (0x0001 - 0x0000)
struct Controller_IsLocalController final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_IsLocalController) == 0x000001, "Wrong alignment on Controller_IsLocalController");
static_assert(sizeof(Controller_IsLocalController) == 0x000001, "Wrong size on Controller_IsLocalController");
static_assert(offsetof(Controller_IsLocalController, ReturnValue) == 0x000000, "Member 'Controller_IsLocalController::ReturnValue' has a wrong offset!");

// Function Engine.Controller.IsLocalPlayerController
// 0x0001 (0x0001 - 0x0000)
struct Controller_IsLocalPlayerController final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_IsLocalPlayerController) == 0x000001, "Wrong alignment on Controller_IsLocalPlayerController");
static_assert(sizeof(Controller_IsLocalPlayerController) == 0x000001, "Wrong size on Controller_IsLocalPlayerController");
static_assert(offsetof(Controller_IsLocalPlayerController, ReturnValue) == 0x000000, "Member 'Controller_IsLocalPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.Controller.IsLookInputIgnored
// 0x0001 (0x0001 - 0x0000)
struct Controller_IsLookInputIgnored final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_IsLookInputIgnored) == 0x000001, "Wrong alignment on Controller_IsLookInputIgnored");
static_assert(sizeof(Controller_IsLookInputIgnored) == 0x000001, "Wrong size on Controller_IsLookInputIgnored");
static_assert(offsetof(Controller_IsLookInputIgnored, ReturnValue) == 0x000000, "Member 'Controller_IsLookInputIgnored::ReturnValue' has a wrong offset!");

// Function Engine.Controller.IsMoveInputIgnored
// 0x0001 (0x0001 - 0x0000)
struct Controller_IsMoveInputIgnored final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_IsMoveInputIgnored) == 0x000001, "Wrong alignment on Controller_IsMoveInputIgnored");
static_assert(sizeof(Controller_IsMoveInputIgnored) == 0x000001, "Wrong size on Controller_IsMoveInputIgnored");
static_assert(offsetof(Controller_IsMoveInputIgnored, ReturnValue) == 0x000000, "Member 'Controller_IsMoveInputIgnored::ReturnValue' has a wrong offset!");

// Function Engine.Controller.IsPlayerController
// 0x0001 (0x0001 - 0x0000)
struct Controller_IsPlayerController final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_IsPlayerController) == 0x000001, "Wrong alignment on Controller_IsPlayerController");
static_assert(sizeof(Controller_IsPlayerController) == 0x000001, "Wrong size on Controller_IsPlayerController");
static_assert(offsetof(Controller_IsPlayerController, ReturnValue) == 0x000000, "Member 'Controller_IsPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.Controller.K2_GetPawn
// 0x0008 (0x0008 - 0x0000)
struct Controller_K2_GetPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Controller_K2_GetPawn) == 0x000008, "Wrong alignment on Controller_K2_GetPawn");
static_assert(sizeof(Controller_K2_GetPawn) == 0x000008, "Wrong size on Controller_K2_GetPawn");
static_assert(offsetof(Controller_K2_GetPawn, ReturnValue) == 0x000000, "Member 'Controller_K2_GetPawn::ReturnValue' has a wrong offset!");

// Function Engine.Controller.LineOfSightTo
// 0x0018 (0x0018 - 0x0000)
struct Controller_LineOfSightTo final
{
public:
	const class AActor*                           Other;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewPoint;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAlternateChecks;                                  // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Controller_LineOfSightTo) == 0x000008, "Wrong alignment on Controller_LineOfSightTo");
static_assert(sizeof(Controller_LineOfSightTo) == 0x000018, "Wrong size on Controller_LineOfSightTo");
static_assert(offsetof(Controller_LineOfSightTo, Other) == 0x000000, "Member 'Controller_LineOfSightTo::Other' has a wrong offset!");
static_assert(offsetof(Controller_LineOfSightTo, ViewPoint) == 0x000008, "Member 'Controller_LineOfSightTo::ViewPoint' has a wrong offset!");
static_assert(offsetof(Controller_LineOfSightTo, bAlternateChecks) == 0x000014, "Member 'Controller_LineOfSightTo::bAlternateChecks' has a wrong offset!");
static_assert(offsetof(Controller_LineOfSightTo, ReturnValue) == 0x000015, "Member 'Controller_LineOfSightTo::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.ActivateTouchInterface
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ActivateTouchInterface final
{
public:
	class UTouchInterface*                        NewTouchInterface;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ActivateTouchInterface) == 0x000008, "Wrong alignment on PlayerController_ActivateTouchInterface");
static_assert(sizeof(PlayerController_ActivateTouchInterface) == 0x000008, "Wrong size on PlayerController_ActivateTouchInterface");
static_assert(offsetof(PlayerController_ActivateTouchInterface, NewTouchInterface) == 0x000000, "Member 'PlayerController_ActivateTouchInterface::NewTouchInterface' has a wrong offset!");

// Function Engine.PlayerController.AddPitchInput
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_AddPitchInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_AddPitchInput) == 0x000004, "Wrong alignment on PlayerController_AddPitchInput");
static_assert(sizeof(PlayerController_AddPitchInput) == 0x000004, "Wrong size on PlayerController_AddPitchInput");
static_assert(offsetof(PlayerController_AddPitchInput, Val) == 0x000000, "Member 'PlayerController_AddPitchInput::Val' has a wrong offset!");

// Function Engine.PlayerController.AddRollInput
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_AddRollInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_AddRollInput) == 0x000004, "Wrong alignment on PlayerController_AddRollInput");
static_assert(sizeof(PlayerController_AddRollInput) == 0x000004, "Wrong size on PlayerController_AddRollInput");
static_assert(offsetof(PlayerController_AddRollInput, Val) == 0x000000, "Member 'PlayerController_AddRollInput::Val' has a wrong offset!");

// Function Engine.PlayerController.AddYawInput
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_AddYawInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_AddYawInput) == 0x000004, "Wrong alignment on PlayerController_AddYawInput");
static_assert(sizeof(PlayerController_AddYawInput) == 0x000004, "Wrong size on PlayerController_AddYawInput");
static_assert(offsetof(PlayerController_AddYawInput, Val) == 0x000000, "Member 'PlayerController_AddYawInput::Val' has a wrong offset!");

// Function Engine.PlayerController.Camera
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_Camera final
{
public:
	class FName                                   NewMode;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_Camera) == 0x000004, "Wrong alignment on PlayerController_Camera");
static_assert(sizeof(PlayerController_Camera) == 0x000008, "Wrong size on PlayerController_Camera");
static_assert(offsetof(PlayerController_Camera, NewMode) == 0x000000, "Member 'PlayerController_Camera::NewMode' has a wrong offset!");

// Function Engine.PlayerController.ClientAddTextureStreamingLoc
// 0x0014 (0x0014 - 0x0000)
struct PlayerController_ClientAddTextureStreamingLoc final
{
public:
	struct FVector                                InLoc;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOverrideLocation;                                 // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientAddTextureStreamingLoc) == 0x000004, "Wrong alignment on PlayerController_ClientAddTextureStreamingLoc");
static_assert(sizeof(PlayerController_ClientAddTextureStreamingLoc) == 0x000014, "Wrong size on PlayerController_ClientAddTextureStreamingLoc");
static_assert(offsetof(PlayerController_ClientAddTextureStreamingLoc, InLoc) == 0x000000, "Member 'PlayerController_ClientAddTextureStreamingLoc::InLoc' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientAddTextureStreamingLoc, Duration) == 0x00000C, "Member 'PlayerController_ClientAddTextureStreamingLoc::Duration' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientAddTextureStreamingLoc, bOverrideLocation) == 0x000010, "Member 'PlayerController_ClientAddTextureStreamingLoc::bOverrideLocation' has a wrong offset!");

// Function Engine.PlayerController.ClientCapBandwidth
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_ClientCapBandwidth final
{
public:
	int32                                         Cap;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientCapBandwidth) == 0x000004, "Wrong alignment on PlayerController_ClientCapBandwidth");
static_assert(sizeof(PlayerController_ClientCapBandwidth) == 0x000004, "Wrong size on PlayerController_ClientCapBandwidth");
static_assert(offsetof(PlayerController_ClientCapBandwidth, Cap) == 0x000000, "Member 'PlayerController_ClientCapBandwidth::Cap' has a wrong offset!");

// Function Engine.PlayerController.ClientEnableNetworkVoice
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ClientEnableNetworkVoice final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientEnableNetworkVoice) == 0x000001, "Wrong alignment on PlayerController_ClientEnableNetworkVoice");
static_assert(sizeof(PlayerController_ClientEnableNetworkVoice) == 0x000001, "Wrong size on PlayerController_ClientEnableNetworkVoice");
static_assert(offsetof(PlayerController_ClientEnableNetworkVoice, bEnable) == 0x000000, "Member 'PlayerController_ClientEnableNetworkVoice::bEnable' has a wrong offset!");

// Function Engine.PlayerController.ClientGameEnded
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientGameEnded final
{
public:
	class AActor*                                 EndGameFocus;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWinner;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientGameEnded) == 0x000008, "Wrong alignment on PlayerController_ClientGameEnded");
static_assert(sizeof(PlayerController_ClientGameEnded) == 0x000010, "Wrong size on PlayerController_ClientGameEnded");
static_assert(offsetof(PlayerController_ClientGameEnded, EndGameFocus) == 0x000000, "Member 'PlayerController_ClientGameEnded::EndGameFocus' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientGameEnded, bIsWinner) == 0x000008, "Member 'PlayerController_ClientGameEnded::bIsWinner' has a wrong offset!");

// Function Engine.PlayerController.ClientGotoState
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientGotoState final
{
public:
	class FName                                   NewState;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientGotoState) == 0x000004, "Wrong alignment on PlayerController_ClientGotoState");
static_assert(sizeof(PlayerController_ClientGotoState) == 0x000008, "Wrong size on PlayerController_ClientGotoState");
static_assert(offsetof(PlayerController_ClientGotoState, NewState) == 0x000000, "Member 'PlayerController_ClientGotoState::NewState' has a wrong offset!");

// Function Engine.PlayerController.ClientIgnoreLookInput
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ClientIgnoreLookInput final
{
public:
	bool                                          bIgnore;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientIgnoreLookInput) == 0x000001, "Wrong alignment on PlayerController_ClientIgnoreLookInput");
static_assert(sizeof(PlayerController_ClientIgnoreLookInput) == 0x000001, "Wrong size on PlayerController_ClientIgnoreLookInput");
static_assert(offsetof(PlayerController_ClientIgnoreLookInput, bIgnore) == 0x000000, "Member 'PlayerController_ClientIgnoreLookInput::bIgnore' has a wrong offset!");

// Function Engine.PlayerController.ClientIgnoreMoveInput
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ClientIgnoreMoveInput final
{
public:
	bool                                          bIgnore;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientIgnoreMoveInput) == 0x000001, "Wrong alignment on PlayerController_ClientIgnoreMoveInput");
static_assert(sizeof(PlayerController_ClientIgnoreMoveInput) == 0x000001, "Wrong size on PlayerController_ClientIgnoreMoveInput");
static_assert(offsetof(PlayerController_ClientIgnoreMoveInput, bIgnore) == 0x000000, "Member 'PlayerController_ClientIgnoreMoveInput::bIgnore' has a wrong offset!");

// Function Engine.PlayerController.ClientMessage
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_ClientMessage final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Type;                                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MsgLifeTime;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientMessage) == 0x000008, "Wrong alignment on PlayerController_ClientMessage");
static_assert(sizeof(PlayerController_ClientMessage) == 0x000020, "Wrong size on PlayerController_ClientMessage");
static_assert(offsetof(PlayerController_ClientMessage, S) == 0x000000, "Member 'PlayerController_ClientMessage::S' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientMessage, Type) == 0x000010, "Member 'PlayerController_ClientMessage::Type' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientMessage, MsgLifeTime) == 0x000018, "Member 'PlayerController_ClientMessage::MsgLifeTime' has a wrong offset!");

// Function Engine.PlayerController.ClientMutePlayer
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientMutePlayer final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientMutePlayer) == 0x000008, "Wrong alignment on PlayerController_ClientMutePlayer");
static_assert(sizeof(PlayerController_ClientMutePlayer) == 0x000018, "Wrong size on PlayerController_ClientMutePlayer");
static_assert(offsetof(PlayerController_ClientMutePlayer, PlayerId) == 0x000000, "Member 'PlayerController_ClientMutePlayer::PlayerId' has a wrong offset!");

// Function Engine.PlayerController.ClientPlayCameraAnim
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_ClientPlayCameraAnim final
{
public:
	class UCameraAnim*                            AnimToPlay;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomStartTime;                                  // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          Space;                                             // 0x001A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B[0x1];                                       // 0x001B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               CustomPlaySpace;                                   // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientPlayCameraAnim) == 0x000008, "Wrong alignment on PlayerController_ClientPlayCameraAnim");
static_assert(sizeof(PlayerController_ClientPlayCameraAnim) == 0x000028, "Wrong size on PlayerController_ClientPlayCameraAnim");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, AnimToPlay) == 0x000000, "Member 'PlayerController_ClientPlayCameraAnim::AnimToPlay' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, Scale) == 0x000008, "Member 'PlayerController_ClientPlayCameraAnim::Scale' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, Rate) == 0x00000C, "Member 'PlayerController_ClientPlayCameraAnim::Rate' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, BlendInTime) == 0x000010, "Member 'PlayerController_ClientPlayCameraAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, BlendOutTime) == 0x000014, "Member 'PlayerController_ClientPlayCameraAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, bLoop) == 0x000018, "Member 'PlayerController_ClientPlayCameraAnim::bLoop' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, bRandomStartTime) == 0x000019, "Member 'PlayerController_ClientPlayCameraAnim::bRandomStartTime' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, Space) == 0x00001A, "Member 'PlayerController_ClientPlayCameraAnim::Space' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraAnim, CustomPlaySpace) == 0x00001C, "Member 'PlayerController_ClientPlayCameraAnim::CustomPlaySpace' has a wrong offset!");

// Function Engine.PlayerController.ClientPlayCameraShake
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_ClientPlayCameraShake final
{
public:
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRot;                                  // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientPlayCameraShake) == 0x000008, "Wrong alignment on PlayerController_ClientPlayCameraShake");
static_assert(sizeof(PlayerController_ClientPlayCameraShake) == 0x000020, "Wrong size on PlayerController_ClientPlayCameraShake");
static_assert(offsetof(PlayerController_ClientPlayCameraShake, Shake) == 0x000000, "Member 'PlayerController_ClientPlayCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraShake, Scale) == 0x000008, "Member 'PlayerController_ClientPlayCameraShake::Scale' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraShake, PlaySpace) == 0x00000C, "Member 'PlayerController_ClientPlayCameraShake::PlaySpace' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayCameraShake, UserPlaySpaceRot) == 0x000010, "Member 'PlayerController_ClientPlayCameraShake::UserPlaySpaceRot' has a wrong offset!");

// Function Engine.PlayerController.ClientPlayForceFeedback
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientPlayForceFeedback final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreTimeDilation;                               // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   Tag;                                               // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientPlayForceFeedback) == 0x000008, "Wrong alignment on PlayerController_ClientPlayForceFeedback");
static_assert(sizeof(PlayerController_ClientPlayForceFeedback) == 0x000018, "Wrong size on PlayerController_ClientPlayForceFeedback");
static_assert(offsetof(PlayerController_ClientPlayForceFeedback, ForceFeedbackEffect) == 0x000000, "Member 'PlayerController_ClientPlayForceFeedback::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayForceFeedback, bLooping) == 0x000008, "Member 'PlayerController_ClientPlayForceFeedback::bLooping' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayForceFeedback, bIgnoreTimeDilation) == 0x000009, "Member 'PlayerController_ClientPlayForceFeedback::bIgnoreTimeDilation' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlayForceFeedback, Tag) == 0x000010, "Member 'PlayerController_ClientPlayForceFeedback::Tag' has a wrong offset!");

// Function Engine.PlayerController.ClientPlaySound
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientPlaySound final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientPlaySound) == 0x000008, "Wrong alignment on PlayerController_ClientPlaySound");
static_assert(sizeof(PlayerController_ClientPlaySound) == 0x000010, "Wrong size on PlayerController_ClientPlaySound");
static_assert(offsetof(PlayerController_ClientPlaySound, Sound) == 0x000000, "Member 'PlayerController_ClientPlaySound::Sound' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlaySound, VolumeMultiplier) == 0x000008, "Member 'PlayerController_ClientPlaySound::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlaySound, PitchMultiplier) == 0x00000C, "Member 'PlayerController_ClientPlaySound::PitchMultiplier' has a wrong offset!");

// Function Engine.PlayerController.ClientPlaySoundAtLocation
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_ClientPlaySoundAtLocation final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientPlaySoundAtLocation) == 0x000008, "Wrong alignment on PlayerController_ClientPlaySoundAtLocation");
static_assert(sizeof(PlayerController_ClientPlaySoundAtLocation) == 0x000020, "Wrong size on PlayerController_ClientPlaySoundAtLocation");
static_assert(offsetof(PlayerController_ClientPlaySoundAtLocation, Sound) == 0x000000, "Member 'PlayerController_ClientPlaySoundAtLocation::Sound' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlaySoundAtLocation, Location) == 0x000008, "Member 'PlayerController_ClientPlaySoundAtLocation::Location' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlaySoundAtLocation, VolumeMultiplier) == 0x000014, "Member 'PlayerController_ClientPlaySoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPlaySoundAtLocation, PitchMultiplier) == 0x000018, "Member 'PlayerController_ClientPlaySoundAtLocation::PitchMultiplier' has a wrong offset!");

// Function Engine.PlayerController.ClientPrepareMapChange
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientPrepareMapChange final
{
public:
	class FName                                   LevelName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFirst;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLast;                                             // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientPrepareMapChange) == 0x000004, "Wrong alignment on PlayerController_ClientPrepareMapChange");
static_assert(sizeof(PlayerController_ClientPrepareMapChange) == 0x000010, "Wrong size on PlayerController_ClientPrepareMapChange");
static_assert(offsetof(PlayerController_ClientPrepareMapChange, LevelName) == 0x000000, "Member 'PlayerController_ClientPrepareMapChange::LevelName' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPrepareMapChange, bFirst) == 0x000008, "Member 'PlayerController_ClientPrepareMapChange::bFirst' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPrepareMapChange, bLast) == 0x000009, "Member 'PlayerController_ClientPrepareMapChange::bLast' has a wrong offset!");

// Function Engine.PlayerController.ClientPrestreamTextures
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientPrestreamTextures final
{
public:
	class AActor*                                 ForcedActor;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceDuration;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableStreaming;                                  // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CinematicTextureGroups;                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientPrestreamTextures) == 0x000008, "Wrong alignment on PlayerController_ClientPrestreamTextures");
static_assert(sizeof(PlayerController_ClientPrestreamTextures) == 0x000018, "Wrong size on PlayerController_ClientPrestreamTextures");
static_assert(offsetof(PlayerController_ClientPrestreamTextures, ForcedActor) == 0x000000, "Member 'PlayerController_ClientPrestreamTextures::ForcedActor' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPrestreamTextures, ForceDuration) == 0x000008, "Member 'PlayerController_ClientPrestreamTextures::ForceDuration' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPrestreamTextures, bEnableStreaming) == 0x00000C, "Member 'PlayerController_ClientPrestreamTextures::bEnableStreaming' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientPrestreamTextures, CinematicTextureGroups) == 0x000010, "Member 'PlayerController_ClientPrestreamTextures::CinematicTextureGroups' has a wrong offset!");

// Function Engine.PlayerController.ClientReceiveLocalizedMessage
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_ClientReceiveLocalizedMessage final
{
public:
	TSubclassOf<class ULocalMessage>              Message;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Switch;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerState*                           RelatedPlayerState_1;                              // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerState*                           RelatedPlayerState_2;                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                OptionalObject;                                    // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientReceiveLocalizedMessage) == 0x000008, "Wrong alignment on PlayerController_ClientReceiveLocalizedMessage");
static_assert(sizeof(PlayerController_ClientReceiveLocalizedMessage) == 0x000028, "Wrong size on PlayerController_ClientReceiveLocalizedMessage");
static_assert(offsetof(PlayerController_ClientReceiveLocalizedMessage, Message) == 0x000000, "Member 'PlayerController_ClientReceiveLocalizedMessage::Message' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientReceiveLocalizedMessage, Switch) == 0x000008, "Member 'PlayerController_ClientReceiveLocalizedMessage::Switch' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientReceiveLocalizedMessage, RelatedPlayerState_1) == 0x000010, "Member 'PlayerController_ClientReceiveLocalizedMessage::RelatedPlayerState_1' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientReceiveLocalizedMessage, RelatedPlayerState_2) == 0x000018, "Member 'PlayerController_ClientReceiveLocalizedMessage::RelatedPlayerState_2' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientReceiveLocalizedMessage, OptionalObject) == 0x000020, "Member 'PlayerController_ClientReceiveLocalizedMessage::OptionalObject' has a wrong offset!");

// Function Engine.PlayerController.ClientRepObjRef
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientRepObjRef final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientRepObjRef) == 0x000008, "Wrong alignment on PlayerController_ClientRepObjRef");
static_assert(sizeof(PlayerController_ClientRepObjRef) == 0x000008, "Wrong size on PlayerController_ClientRepObjRef");
static_assert(offsetof(PlayerController_ClientRepObjRef, Object) == 0x000000, "Member 'PlayerController_ClientRepObjRef::Object' has a wrong offset!");

// Function Engine.PlayerController.ClientRestart
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientRestart final
{
public:
	class APawn*                                  NewPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientRestart) == 0x000008, "Wrong alignment on PlayerController_ClientRestart");
static_assert(sizeof(PlayerController_ClientRestart) == 0x000008, "Wrong size on PlayerController_ClientRestart");
static_assert(offsetof(PlayerController_ClientRestart, NewPawn) == 0x000000, "Member 'PlayerController_ClientRestart::NewPawn' has a wrong offset!");

// Function Engine.PlayerController.ClientRetryClientRestart
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientRetryClientRestart final
{
public:
	class APawn*                                  NewPawn;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientRetryClientRestart) == 0x000008, "Wrong alignment on PlayerController_ClientRetryClientRestart");
static_assert(sizeof(PlayerController_ClientRetryClientRestart) == 0x000008, "Wrong size on PlayerController_ClientRetryClientRestart");
static_assert(offsetof(PlayerController_ClientRetryClientRestart, NewPawn) == 0x000000, "Member 'PlayerController_ClientRetryClientRestart::NewPawn' has a wrong offset!");

// Function Engine.PlayerController.ClientReturnToMainMenu
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientReturnToMainMenu final
{
public:
	class FString                                 ReturnReason;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientReturnToMainMenu) == 0x000008, "Wrong alignment on PlayerController_ClientReturnToMainMenu");
static_assert(sizeof(PlayerController_ClientReturnToMainMenu) == 0x000010, "Wrong size on PlayerController_ClientReturnToMainMenu");
static_assert(offsetof(PlayerController_ClientReturnToMainMenu, ReturnReason) == 0x000000, "Member 'PlayerController_ClientReturnToMainMenu::ReturnReason' has a wrong offset!");

// Function Engine.PlayerController.ClientSetCameraFade
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientSetCameraFade final
{
public:
	bool                                          bEnableFading;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FColor                                 FadeColor;                                         // 0x0004(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FadeAlpha;                                         // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFadeAudio;                                        // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientSetCameraFade) == 0x000004, "Wrong alignment on PlayerController_ClientSetCameraFade");
static_assert(sizeof(PlayerController_ClientSetCameraFade) == 0x000018, "Wrong size on PlayerController_ClientSetCameraFade");
static_assert(offsetof(PlayerController_ClientSetCameraFade, bEnableFading) == 0x000000, "Member 'PlayerController_ClientSetCameraFade::bEnableFading' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCameraFade, FadeColor) == 0x000004, "Member 'PlayerController_ClientSetCameraFade::FadeColor' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCameraFade, FadeAlpha) == 0x000008, "Member 'PlayerController_ClientSetCameraFade::FadeAlpha' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCameraFade, FadeTime) == 0x000010, "Member 'PlayerController_ClientSetCameraFade::FadeTime' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCameraFade, bFadeAudio) == 0x000014, "Member 'PlayerController_ClientSetCameraFade::bFadeAudio' has a wrong offset!");

// Function Engine.PlayerController.ClientSetCameraMode
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientSetCameraMode final
{
public:
	class FName                                   NewCamMode;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetCameraMode) == 0x000004, "Wrong alignment on PlayerController_ClientSetCameraMode");
static_assert(sizeof(PlayerController_ClientSetCameraMode) == 0x000008, "Wrong size on PlayerController_ClientSetCameraMode");
static_assert(offsetof(PlayerController_ClientSetCameraMode, NewCamMode) == 0x000000, "Member 'PlayerController_ClientSetCameraMode::NewCamMode' has a wrong offset!");

// Function Engine.PlayerController.ClientSetCinematicMode
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_ClientSetCinematicMode final
{
public:
	bool                                          bInCinematicMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsMovement;                                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsTurning;                                   // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHUD;                                       // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetCinematicMode) == 0x000001, "Wrong alignment on PlayerController_ClientSetCinematicMode");
static_assert(sizeof(PlayerController_ClientSetCinematicMode) == 0x000004, "Wrong size on PlayerController_ClientSetCinematicMode");
static_assert(offsetof(PlayerController_ClientSetCinematicMode, bInCinematicMode) == 0x000000, "Member 'PlayerController_ClientSetCinematicMode::bInCinematicMode' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCinematicMode, bAffectsMovement) == 0x000001, "Member 'PlayerController_ClientSetCinematicMode::bAffectsMovement' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCinematicMode, bAffectsTurning) == 0x000002, "Member 'PlayerController_ClientSetCinematicMode::bAffectsTurning' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetCinematicMode, bAffectsHUD) == 0x000003, "Member 'PlayerController_ClientSetCinematicMode::bAffectsHUD' has a wrong offset!");

// Function Engine.PlayerController.ClientSetForceMipLevelsToBeResident
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientSetForceMipLevelsToBeResident final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ForceDuration;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CinematicTextureGroups;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetForceMipLevelsToBeResident) == 0x000008, "Wrong alignment on PlayerController_ClientSetForceMipLevelsToBeResident");
static_assert(sizeof(PlayerController_ClientSetForceMipLevelsToBeResident) == 0x000010, "Wrong size on PlayerController_ClientSetForceMipLevelsToBeResident");
static_assert(offsetof(PlayerController_ClientSetForceMipLevelsToBeResident, Material) == 0x000000, "Member 'PlayerController_ClientSetForceMipLevelsToBeResident::Material' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetForceMipLevelsToBeResident, ForceDuration) == 0x000008, "Member 'PlayerController_ClientSetForceMipLevelsToBeResident::ForceDuration' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetForceMipLevelsToBeResident, CinematicTextureGroups) == 0x00000C, "Member 'PlayerController_ClientSetForceMipLevelsToBeResident::CinematicTextureGroups' has a wrong offset!");

// Function Engine.PlayerController.ClientSetHUD
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientSetHUD final
{
public:
	TSubclassOf<class AHUD>                       NewHUDClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetHUD) == 0x000008, "Wrong alignment on PlayerController_ClientSetHUD");
static_assert(sizeof(PlayerController_ClientSetHUD) == 0x000008, "Wrong size on PlayerController_ClientSetHUD");
static_assert(offsetof(PlayerController_ClientSetHUD, NewHUDClass) == 0x000000, "Member 'PlayerController_ClientSetHUD::NewHUDClass' has a wrong offset!");

// Function Engine.PlayerController.ClientSetSpectatorWaiting
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ClientSetSpectatorWaiting final
{
public:
	bool                                          bWaiting;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetSpectatorWaiting) == 0x000001, "Wrong alignment on PlayerController_ClientSetSpectatorWaiting");
static_assert(sizeof(PlayerController_ClientSetSpectatorWaiting) == 0x000001, "Wrong size on PlayerController_ClientSetSpectatorWaiting");
static_assert(offsetof(PlayerController_ClientSetSpectatorWaiting, bWaiting) == 0x000000, "Member 'PlayerController_ClientSetSpectatorWaiting::bWaiting' has a wrong offset!");

// Function Engine.PlayerController.ClientSetViewTarget
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientSetViewTarget final
{
public:
	class AActor*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0008(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSetViewTarget) == 0x000008, "Wrong alignment on PlayerController_ClientSetViewTarget");
static_assert(sizeof(PlayerController_ClientSetViewTarget) == 0x000018, "Wrong size on PlayerController_ClientSetViewTarget");
static_assert(offsetof(PlayerController_ClientSetViewTarget, A) == 0x000000, "Member 'PlayerController_ClientSetViewTarget::A' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientSetViewTarget, TransitionParams) == 0x000008, "Member 'PlayerController_ClientSetViewTarget::TransitionParams' has a wrong offset!");

// Function Engine.PlayerController.ClientSpawnCameraLensEffect
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientSpawnCameraLensEffect final
{
public:
	TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientSpawnCameraLensEffect) == 0x000008, "Wrong alignment on PlayerController_ClientSpawnCameraLensEffect");
static_assert(sizeof(PlayerController_ClientSpawnCameraLensEffect) == 0x000008, "Wrong size on PlayerController_ClientSpawnCameraLensEffect");
static_assert(offsetof(PlayerController_ClientSpawnCameraLensEffect, LensEffectEmitterClass) == 0x000000, "Member 'PlayerController_ClientSpawnCameraLensEffect::LensEffectEmitterClass' has a wrong offset!");

// Function Engine.PlayerController.ClientStopCameraAnim
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ClientStopCameraAnim final
{
public:
	class UCameraAnim*                            AnimToStop;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientStopCameraAnim) == 0x000008, "Wrong alignment on PlayerController_ClientStopCameraAnim");
static_assert(sizeof(PlayerController_ClientStopCameraAnim) == 0x000008, "Wrong size on PlayerController_ClientStopCameraAnim");
static_assert(offsetof(PlayerController_ClientStopCameraAnim, AnimToStop) == 0x000000, "Member 'PlayerController_ClientStopCameraAnim::AnimToStop' has a wrong offset!");

// Function Engine.PlayerController.ClientStopCameraShake
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientStopCameraShake final
{
public:
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientStopCameraShake) == 0x000008, "Wrong alignment on PlayerController_ClientStopCameraShake");
static_assert(sizeof(PlayerController_ClientStopCameraShake) == 0x000010, "Wrong size on PlayerController_ClientStopCameraShake");
static_assert(offsetof(PlayerController_ClientStopCameraShake, Shake) == 0x000000, "Member 'PlayerController_ClientStopCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientStopCameraShake, bImmediately) == 0x000008, "Member 'PlayerController_ClientStopCameraShake::bImmediately' has a wrong offset!");

// Function Engine.PlayerController.ClientStopForceFeedback
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientStopForceFeedback final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientStopForceFeedback) == 0x000008, "Wrong alignment on PlayerController_ClientStopForceFeedback");
static_assert(sizeof(PlayerController_ClientStopForceFeedback) == 0x000010, "Wrong size on PlayerController_ClientStopForceFeedback");
static_assert(offsetof(PlayerController_ClientStopForceFeedback, ForceFeedbackEffect) == 0x000000, "Member 'PlayerController_ClientStopForceFeedback::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientStopForceFeedback, Tag) == 0x000008, "Member 'PlayerController_ClientStopForceFeedback::Tag' has a wrong offset!");

// Function Engine.PlayerController.ClientTeamMessage
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_ClientTeamMessage final
{
public:
	class APlayerState*                           SenderPlayerState;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 S;                                                 // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Type;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MsgLifeTime;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientTeamMessage) == 0x000008, "Wrong alignment on PlayerController_ClientTeamMessage");
static_assert(sizeof(PlayerController_ClientTeamMessage) == 0x000028, "Wrong size on PlayerController_ClientTeamMessage");
static_assert(offsetof(PlayerController_ClientTeamMessage, SenderPlayerState) == 0x000000, "Member 'PlayerController_ClientTeamMessage::SenderPlayerState' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTeamMessage, S) == 0x000008, "Member 'PlayerController_ClientTeamMessage::S' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTeamMessage, Type) == 0x000018, "Member 'PlayerController_ClientTeamMessage::Type' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTeamMessage, MsgLifeTime) == 0x000020, "Member 'PlayerController_ClientTeamMessage::MsgLifeTime' has a wrong offset!");

// Function Engine.PlayerController.ClientTravel
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_ClientTravel final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelType                                   TravelType;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeamless;                                         // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MapPackageGuid;                                    // 0x0014(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientTravel) == 0x000008, "Wrong alignment on PlayerController_ClientTravel");
static_assert(sizeof(PlayerController_ClientTravel) == 0x000028, "Wrong size on PlayerController_ClientTravel");
static_assert(offsetof(PlayerController_ClientTravel, URL) == 0x000000, "Member 'PlayerController_ClientTravel::URL' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravel, TravelType) == 0x000010, "Member 'PlayerController_ClientTravel::TravelType' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravel, bSeamless) == 0x000011, "Member 'PlayerController_ClientTravel::bSeamless' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravel, MapPackageGuid) == 0x000014, "Member 'PlayerController_ClientTravel::MapPackageGuid' has a wrong offset!");

// Function Engine.PlayerController.ClientTravelInternal
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_ClientTravelInternal final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETravelType                                   TravelType;                                        // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSeamless;                                         // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGuid                                  MapPackageGuid;                                    // 0x0014(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ClientTravelInternal) == 0x000008, "Wrong alignment on PlayerController_ClientTravelInternal");
static_assert(sizeof(PlayerController_ClientTravelInternal) == 0x000028, "Wrong size on PlayerController_ClientTravelInternal");
static_assert(offsetof(PlayerController_ClientTravelInternal, URL) == 0x000000, "Member 'PlayerController_ClientTravelInternal::URL' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravelInternal, TravelType) == 0x000010, "Member 'PlayerController_ClientTravelInternal::TravelType' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravelInternal, bSeamless) == 0x000011, "Member 'PlayerController_ClientTravelInternal::bSeamless' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientTravelInternal, MapPackageGuid) == 0x000014, "Member 'PlayerController_ClientTravelInternal::MapPackageGuid' has a wrong offset!");

// Function Engine.PlayerController.ClientUnmutePlayer
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientUnmutePlayer final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientUnmutePlayer) == 0x000008, "Wrong alignment on PlayerController_ClientUnmutePlayer");
static_assert(sizeof(PlayerController_ClientUnmutePlayer) == 0x000018, "Wrong size on PlayerController_ClientUnmutePlayer");
static_assert(offsetof(PlayerController_ClientUnmutePlayer, PlayerId) == 0x000000, "Member 'PlayerController_ClientUnmutePlayer::PlayerId' has a wrong offset!");

// Function Engine.PlayerController.ClientUpdateLevelStreamingStatus
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ClientUpdateLevelStreamingStatus final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBeLoaded;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBeVisible;                               // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewShouldBlockOnLoad;                             // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_B[0x1];                                        // 0x000B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LODIndex;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientUpdateLevelStreamingStatus) == 0x000004, "Wrong alignment on PlayerController_ClientUpdateLevelStreamingStatus");
static_assert(sizeof(PlayerController_ClientUpdateLevelStreamingStatus) == 0x000010, "Wrong size on PlayerController_ClientUpdateLevelStreamingStatus");
static_assert(offsetof(PlayerController_ClientUpdateLevelStreamingStatus, PackageName) == 0x000000, "Member 'PlayerController_ClientUpdateLevelStreamingStatus::PackageName' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientUpdateLevelStreamingStatus, bNewShouldBeLoaded) == 0x000008, "Member 'PlayerController_ClientUpdateLevelStreamingStatus::bNewShouldBeLoaded' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientUpdateLevelStreamingStatus, bNewShouldBeVisible) == 0x000009, "Member 'PlayerController_ClientUpdateLevelStreamingStatus::bNewShouldBeVisible' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientUpdateLevelStreamingStatus, bNewShouldBlockOnLoad) == 0x00000A, "Member 'PlayerController_ClientUpdateLevelStreamingStatus::bNewShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(PlayerController_ClientUpdateLevelStreamingStatus, LODIndex) == 0x00000C, "Member 'PlayerController_ClientUpdateLevelStreamingStatus::LODIndex' has a wrong offset!");

// Function Engine.PlayerController.ClientWasKicked
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ClientWasKicked final
{
public:
	class FText                                   KickReason;                                        // 0x0000(0x0018)(ConstParm, Parm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ClientWasKicked) == 0x000008, "Wrong alignment on PlayerController_ClientWasKicked");
static_assert(sizeof(PlayerController_ClientWasKicked) == 0x000018, "Wrong size on PlayerController_ClientWasKicked");
static_assert(offsetof(PlayerController_ClientWasKicked, KickReason) == 0x000000, "Member 'PlayerController_ClientWasKicked::KickReason' has a wrong offset!");

// Function Engine.PlayerController.ConsoleKey
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ConsoleKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ConsoleKey) == 0x000008, "Wrong alignment on PlayerController_ConsoleKey");
static_assert(sizeof(PlayerController_ConsoleKey) == 0x000018, "Wrong size on PlayerController_ConsoleKey");
static_assert(offsetof(PlayerController_ConsoleKey, Key) == 0x000000, "Member 'PlayerController_ConsoleKey::Key' has a wrong offset!");

// Function Engine.PlayerController.FOV
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_FOV final
{
public:
	float                                         NewFOV;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_FOV) == 0x000004, "Wrong alignment on PlayerController_FOV");
static_assert(sizeof(PlayerController_FOV) == 0x000004, "Wrong size on PlayerController_FOV");
static_assert(offsetof(PlayerController_FOV, NewFOV) == 0x000000, "Member 'PlayerController_FOV::NewFOV' has a wrong offset!");

// Function Engine.PlayerController.LocalTravel
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_LocalTravel final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_LocalTravel) == 0x000008, "Wrong alignment on PlayerController_LocalTravel");
static_assert(sizeof(PlayerController_LocalTravel) == 0x000010, "Wrong size on PlayerController_LocalTravel");
static_assert(offsetof(PlayerController_LocalTravel, URL) == 0x000000, "Member 'PlayerController_LocalTravel::URL' has a wrong offset!");

// Function Engine.PlayerController.OnServerStartedVisualLogger
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_OnServerStartedVisualLogger final
{
public:
	bool                                          bIsLogging;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_OnServerStartedVisualLogger) == 0x000001, "Wrong alignment on PlayerController_OnServerStartedVisualLogger");
static_assert(sizeof(PlayerController_OnServerStartedVisualLogger) == 0x000001, "Wrong size on PlayerController_OnServerStartedVisualLogger");
static_assert(offsetof(PlayerController_OnServerStartedVisualLogger, bIsLogging) == 0x000000, "Member 'PlayerController_OnServerStartedVisualLogger::bIsLogging' has a wrong offset!");

// Function Engine.PlayerController.PlayDynamicForceFeedback
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_PlayDynamicForceFeedback final
{
public:
	float                                         Intensity;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsLeftLarge;                                 // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsLeftSmall;                                 // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsRightLarge;                                // 0x000A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsRightSmall;                                // 0x000B(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EDynamicForceFeedbackAction                   Action;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_PlayDynamicForceFeedback) == 0x000008, "Wrong alignment on PlayerController_PlayDynamicForceFeedback");
static_assert(sizeof(PlayerController_PlayDynamicForceFeedback) == 0x000028, "Wrong size on PlayerController_PlayDynamicForceFeedback");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, Intensity) == 0x000000, "Member 'PlayerController_PlayDynamicForceFeedback::Intensity' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, Duration) == 0x000004, "Member 'PlayerController_PlayDynamicForceFeedback::Duration' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, bAffectsLeftLarge) == 0x000008, "Member 'PlayerController_PlayDynamicForceFeedback::bAffectsLeftLarge' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, bAffectsLeftSmall) == 0x000009, "Member 'PlayerController_PlayDynamicForceFeedback::bAffectsLeftSmall' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, bAffectsRightLarge) == 0x00000A, "Member 'PlayerController_PlayDynamicForceFeedback::bAffectsRightLarge' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, bAffectsRightSmall) == 0x00000B, "Member 'PlayerController_PlayDynamicForceFeedback::bAffectsRightSmall' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, Action) == 0x00000C, "Member 'PlayerController_PlayDynamicForceFeedback::Action' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayDynamicForceFeedback, LatentInfo) == 0x000010, "Member 'PlayerController_PlayDynamicForceFeedback::LatentInfo' has a wrong offset!");

// Function Engine.PlayerController.PlayHapticEffect
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_PlayHapticEffect final
{
public:
	class UHapticFeedbackEffect_Base*             HapticEffect;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControllerHand                               Hand;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_PlayHapticEffect) == 0x000008, "Wrong alignment on PlayerController_PlayHapticEffect");
static_assert(sizeof(PlayerController_PlayHapticEffect) == 0x000018, "Wrong size on PlayerController_PlayHapticEffect");
static_assert(offsetof(PlayerController_PlayHapticEffect, HapticEffect) == 0x000000, "Member 'PlayerController_PlayHapticEffect::HapticEffect' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayHapticEffect, Hand) == 0x000008, "Member 'PlayerController_PlayHapticEffect::Hand' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayHapticEffect, Scale) == 0x00000C, "Member 'PlayerController_PlayHapticEffect::Scale' has a wrong offset!");
static_assert(offsetof(PlayerController_PlayHapticEffect, bLoop) == 0x000010, "Member 'PlayerController_PlayHapticEffect::bLoop' has a wrong offset!");

// Function Engine.PlayerController.SendToConsole
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_SendToConsole final
{
public:
	class FString                                 Command;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SendToConsole) == 0x000008, "Wrong alignment on PlayerController_SendToConsole");
static_assert(sizeof(PlayerController_SendToConsole) == 0x000010, "Wrong size on PlayerController_SendToConsole");
static_assert(offsetof(PlayerController_SendToConsole, Command) == 0x000000, "Member 'PlayerController_SendToConsole::Command' has a wrong offset!");

// Function Engine.PlayerController.ServerAcknowledgePossession
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ServerAcknowledgePossession final
{
public:
	class APawn*                                  P;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerAcknowledgePossession) == 0x000008, "Wrong alignment on PlayerController_ServerAcknowledgePossession");
static_assert(sizeof(PlayerController_ServerAcknowledgePossession) == 0x000008, "Wrong size on PlayerController_ServerAcknowledgePossession");
static_assert(offsetof(PlayerController_ServerAcknowledgePossession, P) == 0x000000, "Member 'PlayerController_ServerAcknowledgePossession::P' has a wrong offset!");

// Function Engine.PlayerController.ServerCamera
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ServerCamera final
{
public:
	class FName                                   NewMode;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerCamera) == 0x000004, "Wrong alignment on PlayerController_ServerCamera");
static_assert(sizeof(PlayerController_ServerCamera) == 0x000008, "Wrong size on PlayerController_ServerCamera");
static_assert(offsetof(PlayerController_ServerCamera, NewMode) == 0x000000, "Member 'PlayerController_ServerCamera::NewMode' has a wrong offset!");

// Function Engine.PlayerController.ServerChangeName
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ServerChangeName final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerChangeName) == 0x000008, "Wrong alignment on PlayerController_ServerChangeName");
static_assert(sizeof(PlayerController_ServerChangeName) == 0x000010, "Wrong size on PlayerController_ServerChangeName");
static_assert(offsetof(PlayerController_ServerChangeName, S) == 0x000000, "Member 'PlayerController_ServerChangeName::S' has a wrong offset!");

// Function Engine.PlayerController.ServerMutePlayer
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ServerMutePlayer final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerMutePlayer) == 0x000008, "Wrong alignment on PlayerController_ServerMutePlayer");
static_assert(sizeof(PlayerController_ServerMutePlayer) == 0x000018, "Wrong size on PlayerController_ServerMutePlayer");
static_assert(offsetof(PlayerController_ServerMutePlayer, PlayerId) == 0x000000, "Member 'PlayerController_ServerMutePlayer::PlayerId' has a wrong offset!");

// Function Engine.PlayerController.ServerNotifyLoadedWorld
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_ServerNotifyLoadedWorld final
{
public:
	class FName                                   WorldPackageName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerNotifyLoadedWorld) == 0x000004, "Wrong alignment on PlayerController_ServerNotifyLoadedWorld");
static_assert(sizeof(PlayerController_ServerNotifyLoadedWorld) == 0x000008, "Wrong size on PlayerController_ServerNotifyLoadedWorld");
static_assert(offsetof(PlayerController_ServerNotifyLoadedWorld, WorldPackageName) == 0x000000, "Member 'PlayerController_ServerNotifyLoadedWorld::WorldPackageName' has a wrong offset!");

// Function Engine.PlayerController.ServerSetSpectatorLocation
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ServerSetSpectatorLocation final
{
public:
	struct FVector                                NewLoc;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRot;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerSetSpectatorLocation) == 0x000004, "Wrong alignment on PlayerController_ServerSetSpectatorLocation");
static_assert(sizeof(PlayerController_ServerSetSpectatorLocation) == 0x000018, "Wrong size on PlayerController_ServerSetSpectatorLocation");
static_assert(offsetof(PlayerController_ServerSetSpectatorLocation, NewLoc) == 0x000000, "Member 'PlayerController_ServerSetSpectatorLocation::NewLoc' has a wrong offset!");
static_assert(offsetof(PlayerController_ServerSetSpectatorLocation, NewRot) == 0x00000C, "Member 'PlayerController_ServerSetSpectatorLocation::NewRot' has a wrong offset!");

// Function Engine.PlayerController.ServerSetSpectatorWaiting
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ServerSetSpectatorWaiting final
{
public:
	bool                                          bWaiting;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerSetSpectatorWaiting) == 0x000001, "Wrong alignment on PlayerController_ServerSetSpectatorWaiting");
static_assert(sizeof(PlayerController_ServerSetSpectatorWaiting) == 0x000001, "Wrong size on PlayerController_ServerSetSpectatorWaiting");
static_assert(offsetof(PlayerController_ServerSetSpectatorWaiting, bWaiting) == 0x000000, "Member 'PlayerController_ServerSetSpectatorWaiting::bWaiting' has a wrong offset!");

// Function Engine.PlayerController.ServerUnmutePlayer
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ServerUnmutePlayer final
{
public:
	struct FUniqueNetIdRepl                       PlayerId;                                          // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerUnmutePlayer) == 0x000008, "Wrong alignment on PlayerController_ServerUnmutePlayer");
static_assert(sizeof(PlayerController_ServerUnmutePlayer) == 0x000018, "Wrong size on PlayerController_ServerUnmutePlayer");
static_assert(offsetof(PlayerController_ServerUnmutePlayer, PlayerId) == 0x000000, "Member 'PlayerController_ServerUnmutePlayer::PlayerId' has a wrong offset!");

// Function Engine.PlayerController.ServerUpdateCamera
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ServerUpdateCamera final
{
public:
	struct FVector_NetQuantize                    CamLoc;                                            // 0x0000(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         CamPitchAndYaw;                                    // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerUpdateCamera) == 0x000004, "Wrong alignment on PlayerController_ServerUpdateCamera");
static_assert(sizeof(PlayerController_ServerUpdateCamera) == 0x000010, "Wrong size on PlayerController_ServerUpdateCamera");
static_assert(offsetof(PlayerController_ServerUpdateCamera, CamLoc) == 0x000000, "Member 'PlayerController_ServerUpdateCamera::CamLoc' has a wrong offset!");
static_assert(offsetof(PlayerController_ServerUpdateCamera, CamPitchAndYaw) == 0x00000C, "Member 'PlayerController_ServerUpdateCamera::CamPitchAndYaw' has a wrong offset!");

// Function Engine.PlayerController.ServerUpdateLevelVisibility
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ServerUpdateLevelVisibility final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsVisible;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ServerUpdateLevelVisibility) == 0x000004, "Wrong alignment on PlayerController_ServerUpdateLevelVisibility");
static_assert(sizeof(PlayerController_ServerUpdateLevelVisibility) == 0x000010, "Wrong size on PlayerController_ServerUpdateLevelVisibility");
static_assert(offsetof(PlayerController_ServerUpdateLevelVisibility, PackageName) == 0x000000, "Member 'PlayerController_ServerUpdateLevelVisibility::PackageName' has a wrong offset!");
static_assert(offsetof(PlayerController_ServerUpdateLevelVisibility, bIsVisible) == 0x000008, "Member 'PlayerController_ServerUpdateLevelVisibility::bIsVisible' has a wrong offset!");

// Function Engine.PlayerController.ServerViewSelf
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_ServerViewSelf final
{
public:
	struct FViewTargetTransitionParams            TransitionParams;                                  // 0x0000(0x0010)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ServerViewSelf) == 0x000004, "Wrong alignment on PlayerController_ServerViewSelf");
static_assert(sizeof(PlayerController_ServerViewSelf) == 0x000010, "Wrong size on PlayerController_ServerViewSelf");
static_assert(offsetof(PlayerController_ServerViewSelf, TransitionParams) == 0x000000, "Member 'PlayerController_ServerViewSelf::TransitionParams' has a wrong offset!");

// Function Engine.PlayerController.SetAudioListenerOverride
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_SetAudioListenerOverride final
{
public:
	class USceneComponent*                        AttachToComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetAudioListenerOverride) == 0x000008, "Wrong alignment on PlayerController_SetAudioListenerOverride");
static_assert(sizeof(PlayerController_SetAudioListenerOverride) == 0x000020, "Wrong size on PlayerController_SetAudioListenerOverride");
static_assert(offsetof(PlayerController_SetAudioListenerOverride, AttachToComponent) == 0x000000, "Member 'PlayerController_SetAudioListenerOverride::AttachToComponent' has a wrong offset!");
static_assert(offsetof(PlayerController_SetAudioListenerOverride, Location) == 0x000008, "Member 'PlayerController_SetAudioListenerOverride::Location' has a wrong offset!");
static_assert(offsetof(PlayerController_SetAudioListenerOverride, Rotation) == 0x000014, "Member 'PlayerController_SetAudioListenerOverride::Rotation' has a wrong offset!");

// Function Engine.PlayerController.SetCinematicMode
// 0x0005 (0x0005 - 0x0000)
struct PlayerController_SetCinematicMode final
{
public:
	bool                                          bInCinematicMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayer;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHUD;                                       // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsMovement;                                  // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsTurning;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetCinematicMode) == 0x000001, "Wrong alignment on PlayerController_SetCinematicMode");
static_assert(sizeof(PlayerController_SetCinematicMode) == 0x000005, "Wrong size on PlayerController_SetCinematicMode");
static_assert(offsetof(PlayerController_SetCinematicMode, bInCinematicMode) == 0x000000, "Member 'PlayerController_SetCinematicMode::bInCinematicMode' has a wrong offset!");
static_assert(offsetof(PlayerController_SetCinematicMode, bHidePlayer) == 0x000001, "Member 'PlayerController_SetCinematicMode::bHidePlayer' has a wrong offset!");
static_assert(offsetof(PlayerController_SetCinematicMode, bAffectsHUD) == 0x000002, "Member 'PlayerController_SetCinematicMode::bAffectsHUD' has a wrong offset!");
static_assert(offsetof(PlayerController_SetCinematicMode, bAffectsMovement) == 0x000003, "Member 'PlayerController_SetCinematicMode::bAffectsMovement' has a wrong offset!");
static_assert(offsetof(PlayerController_SetCinematicMode, bAffectsTurning) == 0x000004, "Member 'PlayerController_SetCinematicMode::bAffectsTurning' has a wrong offset!");

// Function Engine.PlayerController.SetControllerLightColor
// 0x0004 (0x0004 - 0x0000)
struct PlayerController_SetControllerLightColor final
{
public:
	struct FColor                                 Color;                                             // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetControllerLightColor) == 0x000004, "Wrong alignment on PlayerController_SetControllerLightColor");
static_assert(sizeof(PlayerController_SetControllerLightColor) == 0x000004, "Wrong size on PlayerController_SetControllerLightColor");
static_assert(offsetof(PlayerController_SetControllerLightColor, Color) == 0x000000, "Member 'PlayerController_SetControllerLightColor::Color' has a wrong offset!");

// Function Engine.PlayerController.SetHapticsByValue
// 0x000C (0x000C - 0x0000)
struct PlayerController_SetHapticsByValue final
{
public:
	float                                         Frequency;                                         // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Amplitude;                                         // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EControllerHand                               Hand;                                              // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_SetHapticsByValue) == 0x000004, "Wrong alignment on PlayerController_SetHapticsByValue");
static_assert(sizeof(PlayerController_SetHapticsByValue) == 0x00000C, "Wrong size on PlayerController_SetHapticsByValue");
static_assert(offsetof(PlayerController_SetHapticsByValue, Frequency) == 0x000000, "Member 'PlayerController_SetHapticsByValue::Frequency' has a wrong offset!");
static_assert(offsetof(PlayerController_SetHapticsByValue, Amplitude) == 0x000004, "Member 'PlayerController_SetHapticsByValue::Amplitude' has a wrong offset!");
static_assert(offsetof(PlayerController_SetHapticsByValue, Hand) == 0x000008, "Member 'PlayerController_SetHapticsByValue::Hand' has a wrong offset!");

// Function Engine.PlayerController.SetMouseCursorWidget
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_SetMouseCursorWidget final
{
public:
	EMouseCursor                                  Cursor;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            CursorWidget;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetMouseCursorWidget) == 0x000008, "Wrong alignment on PlayerController_SetMouseCursorWidget");
static_assert(sizeof(PlayerController_SetMouseCursorWidget) == 0x000010, "Wrong size on PlayerController_SetMouseCursorWidget");
static_assert(offsetof(PlayerController_SetMouseCursorWidget, Cursor) == 0x000000, "Member 'PlayerController_SetMouseCursorWidget::Cursor' has a wrong offset!");
static_assert(offsetof(PlayerController_SetMouseCursorWidget, CursorWidget) == 0x000008, "Member 'PlayerController_SetMouseCursorWidget::CursorWidget' has a wrong offset!");

// Function Engine.PlayerController.SetMouseLocation
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_SetMouseLocation final
{
public:
	int32                                         X;                                                 // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Y;                                                 // 0x0004(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetMouseLocation) == 0x000004, "Wrong alignment on PlayerController_SetMouseLocation");
static_assert(sizeof(PlayerController_SetMouseLocation) == 0x000008, "Wrong size on PlayerController_SetMouseLocation");
static_assert(offsetof(PlayerController_SetMouseLocation, X) == 0x000000, "Member 'PlayerController_SetMouseLocation::X' has a wrong offset!");
static_assert(offsetof(PlayerController_SetMouseLocation, Y) == 0x000004, "Member 'PlayerController_SetMouseLocation::Y' has a wrong offset!");

// Function Engine.PlayerController.SetName
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_SetName final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetName) == 0x000008, "Wrong alignment on PlayerController_SetName");
static_assert(sizeof(PlayerController_SetName) == 0x000010, "Wrong size on PlayerController_SetName");
static_assert(offsetof(PlayerController_SetName, S) == 0x000000, "Member 'PlayerController_SetName::S' has a wrong offset!");

// Function Engine.PlayerController.SetViewTargetWithBlend
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_SetViewTargetWithBlend final
{
public:
	class AActor*                                 NewViewTarget;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EViewTargetBlendFunction                      BlendFunc;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLockOutgoing;                                     // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_SetViewTargetWithBlend) == 0x000008, "Wrong alignment on PlayerController_SetViewTargetWithBlend");
static_assert(sizeof(PlayerController_SetViewTargetWithBlend) == 0x000018, "Wrong size on PlayerController_SetViewTargetWithBlend");
static_assert(offsetof(PlayerController_SetViewTargetWithBlend, NewViewTarget) == 0x000000, "Member 'PlayerController_SetViewTargetWithBlend::NewViewTarget' has a wrong offset!");
static_assert(offsetof(PlayerController_SetViewTargetWithBlend, BlendTime) == 0x000008, "Member 'PlayerController_SetViewTargetWithBlend::BlendTime' has a wrong offset!");
static_assert(offsetof(PlayerController_SetViewTargetWithBlend, BlendFunc) == 0x00000C, "Member 'PlayerController_SetViewTargetWithBlend::BlendFunc' has a wrong offset!");
static_assert(offsetof(PlayerController_SetViewTargetWithBlend, BlendExp) == 0x000010, "Member 'PlayerController_SetViewTargetWithBlend::BlendExp' has a wrong offset!");
static_assert(offsetof(PlayerController_SetViewTargetWithBlend, bLockOutgoing) == 0x000014, "Member 'PlayerController_SetViewTargetWithBlend::bLockOutgoing' has a wrong offset!");

// Function Engine.PlayerController.SetVirtualJoystickVisibility
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_SetVirtualJoystickVisibility final
{
public:
	bool                                          bVisible;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SetVirtualJoystickVisibility) == 0x000001, "Wrong alignment on PlayerController_SetVirtualJoystickVisibility");
static_assert(sizeof(PlayerController_SetVirtualJoystickVisibility) == 0x000001, "Wrong size on PlayerController_SetVirtualJoystickVisibility");
static_assert(offsetof(PlayerController_SetVirtualJoystickVisibility, bVisible) == 0x000000, "Member 'PlayerController_SetVirtualJoystickVisibility::bVisible' has a wrong offset!");

// Function Engine.PlayerController.StartFire
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_StartFire final
{
public:
	uint8                                         FireModeNum;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_StartFire) == 0x000001, "Wrong alignment on PlayerController_StartFire");
static_assert(sizeof(PlayerController_StartFire) == 0x000001, "Wrong size on PlayerController_StartFire");
static_assert(offsetof(PlayerController_StartFire, FireModeNum) == 0x000000, "Member 'PlayerController_StartFire::FireModeNum' has a wrong offset!");

// Function Engine.PlayerController.StopHapticEffect
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_StopHapticEffect final
{
public:
	EControllerHand                               Hand;                                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_StopHapticEffect) == 0x000001, "Wrong alignment on PlayerController_StopHapticEffect");
static_assert(sizeof(PlayerController_StopHapticEffect) == 0x000001, "Wrong size on PlayerController_StopHapticEffect");
static_assert(offsetof(PlayerController_StopHapticEffect, Hand) == 0x000000, "Member 'PlayerController_StopHapticEffect::Hand' has a wrong offset!");

// Function Engine.PlayerController.SwitchLevel
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_SwitchLevel final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_SwitchLevel) == 0x000008, "Wrong alignment on PlayerController_SwitchLevel");
static_assert(sizeof(PlayerController_SwitchLevel) == 0x000010, "Wrong size on PlayerController_SwitchLevel");
static_assert(offsetof(PlayerController_SwitchLevel, URL) == 0x000000, "Member 'PlayerController_SwitchLevel::URL' has a wrong offset!");

// Function Engine.PlayerController.ToggleSpeaking
// 0x0001 (0x0001 - 0x0000)
struct PlayerController_ToggleSpeaking final
{
public:
	bool                                          bInSpeaking;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_ToggleSpeaking) == 0x000001, "Wrong alignment on PlayerController_ToggleSpeaking");
static_assert(sizeof(PlayerController_ToggleSpeaking) == 0x000001, "Wrong size on PlayerController_ToggleSpeaking");
static_assert(offsetof(PlayerController_ToggleSpeaking, bInSpeaking) == 0x000000, "Member 'PlayerController_ToggleSpeaking::bInSpeaking' has a wrong offset!");

// Function Engine.PlayerController.DeprojectMousePositionToWorld
// 0x001C (0x001C - 0x0000)
struct PlayerController_DeprojectMousePositionToWorld final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_DeprojectMousePositionToWorld) == 0x000004, "Wrong alignment on PlayerController_DeprojectMousePositionToWorld");
static_assert(sizeof(PlayerController_DeprojectMousePositionToWorld) == 0x00001C, "Wrong size on PlayerController_DeprojectMousePositionToWorld");
static_assert(offsetof(PlayerController_DeprojectMousePositionToWorld, WorldLocation) == 0x000000, "Member 'PlayerController_DeprojectMousePositionToWorld::WorldLocation' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectMousePositionToWorld, WorldDirection) == 0x00000C, "Member 'PlayerController_DeprojectMousePositionToWorld::WorldDirection' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectMousePositionToWorld, ReturnValue) == 0x000018, "Member 'PlayerController_DeprojectMousePositionToWorld::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.DeprojectScreenPositionToWorld
// 0x0024 (0x0024 - 0x0000)
struct PlayerController_DeprojectScreenPositionToWorld final
{
public:
	float                                         ScreenX;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_DeprojectScreenPositionToWorld) == 0x000004, "Wrong alignment on PlayerController_DeprojectScreenPositionToWorld");
static_assert(sizeof(PlayerController_DeprojectScreenPositionToWorld) == 0x000024, "Wrong size on PlayerController_DeprojectScreenPositionToWorld");
static_assert(offsetof(PlayerController_DeprojectScreenPositionToWorld, ScreenX) == 0x000000, "Member 'PlayerController_DeprojectScreenPositionToWorld::ScreenX' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectScreenPositionToWorld, ScreenY) == 0x000004, "Member 'PlayerController_DeprojectScreenPositionToWorld::ScreenY' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectScreenPositionToWorld, WorldLocation) == 0x000008, "Member 'PlayerController_DeprojectScreenPositionToWorld::WorldLocation' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectScreenPositionToWorld, WorldDirection) == 0x000014, "Member 'PlayerController_DeprojectScreenPositionToWorld::WorldDirection' has a wrong offset!");
static_assert(offsetof(PlayerController_DeprojectScreenPositionToWorld, ReturnValue) == 0x000020, "Member 'PlayerController_DeprojectScreenPositionToWorld::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetFocalLocation
// 0x000C (0x000C - 0x0000)
struct PlayerController_GetFocalLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetFocalLocation) == 0x000004, "Wrong alignment on PlayerController_GetFocalLocation");
static_assert(sizeof(PlayerController_GetFocalLocation) == 0x00000C, "Wrong size on PlayerController_GetFocalLocation");
static_assert(offsetof(PlayerController_GetFocalLocation, ReturnValue) == 0x000000, "Member 'PlayerController_GetFocalLocation::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderCursor
// 0x0098 (0x0098 - 0x0000)
struct PlayerController_GetHitResultUnderCursor final
{
public:
	ECollisionChannel                             TraceChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderCursor) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderCursor");
static_assert(sizeof(PlayerController_GetHitResultUnderCursor) == 0x000098, "Wrong size on PlayerController_GetHitResultUnderCursor");
static_assert(offsetof(PlayerController_GetHitResultUnderCursor, TraceChannel) == 0x000000, "Member 'PlayerController_GetHitResultUnderCursor::TraceChannel' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursor, bTraceComplex) == 0x000001, "Member 'PlayerController_GetHitResultUnderCursor::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursor, HitResult) == 0x000008, "Member 'PlayerController_GetHitResultUnderCursor::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursor, ReturnValue) == 0x000090, "Member 'PlayerController_GetHitResultUnderCursor::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderCursorByChannel
// 0x0098 (0x0098 - 0x0000)
struct PlayerController_GetHitResultUnderCursorByChannel final
{
public:
	ETraceTypeQuery                               TraceChannel;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderCursorByChannel) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderCursorByChannel");
static_assert(sizeof(PlayerController_GetHitResultUnderCursorByChannel) == 0x000098, "Wrong size on PlayerController_GetHitResultUnderCursorByChannel");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorByChannel, TraceChannel) == 0x000000, "Member 'PlayerController_GetHitResultUnderCursorByChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorByChannel, bTraceComplex) == 0x000001, "Member 'PlayerController_GetHitResultUnderCursorByChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorByChannel, HitResult) == 0x000008, "Member 'PlayerController_GetHitResultUnderCursorByChannel::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorByChannel, ReturnValue) == 0x000090, "Member 'PlayerController_GetHitResultUnderCursorByChannel::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderCursorForObjects
// 0x00A8 (0x00A8 - 0x0000)
struct PlayerController_GetHitResultUnderCursorForObjects final
{
public:
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0018(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderCursorForObjects) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderCursorForObjects");
static_assert(sizeof(PlayerController_GetHitResultUnderCursorForObjects) == 0x0000A8, "Wrong size on PlayerController_GetHitResultUnderCursorForObjects");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorForObjects, ObjectTypes) == 0x000000, "Member 'PlayerController_GetHitResultUnderCursorForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorForObjects, bTraceComplex) == 0x000010, "Member 'PlayerController_GetHitResultUnderCursorForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorForObjects, HitResult) == 0x000018, "Member 'PlayerController_GetHitResultUnderCursorForObjects::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderCursorForObjects, ReturnValue) == 0x0000A0, "Member 'PlayerController_GetHitResultUnderCursorForObjects::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderFinger
// 0x0098 (0x0098 - 0x0000)
struct PlayerController_GetHitResultUnderFinger final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderFinger) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderFinger");
static_assert(sizeof(PlayerController_GetHitResultUnderFinger) == 0x000098, "Wrong size on PlayerController_GetHitResultUnderFinger");
static_assert(offsetof(PlayerController_GetHitResultUnderFinger, FingerIndex) == 0x000000, "Member 'PlayerController_GetHitResultUnderFinger::FingerIndex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFinger, TraceChannel) == 0x000001, "Member 'PlayerController_GetHitResultUnderFinger::TraceChannel' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFinger, bTraceComplex) == 0x000002, "Member 'PlayerController_GetHitResultUnderFinger::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFinger, HitResult) == 0x000008, "Member 'PlayerController_GetHitResultUnderFinger::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFinger, ReturnValue) == 0x000090, "Member 'PlayerController_GetHitResultUnderFinger::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderFingerByChannel
// 0x0098 (0x0098 - 0x0000)
struct PlayerController_GetHitResultUnderFingerByChannel final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3[0x5];                                        // 0x0003(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderFingerByChannel) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderFingerByChannel");
static_assert(sizeof(PlayerController_GetHitResultUnderFingerByChannel) == 0x000098, "Wrong size on PlayerController_GetHitResultUnderFingerByChannel");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerByChannel, FingerIndex) == 0x000000, "Member 'PlayerController_GetHitResultUnderFingerByChannel::FingerIndex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerByChannel, TraceChannel) == 0x000001, "Member 'PlayerController_GetHitResultUnderFingerByChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerByChannel, bTraceComplex) == 0x000002, "Member 'PlayerController_GetHitResultUnderFingerByChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerByChannel, HitResult) == 0x000008, "Member 'PlayerController_GetHitResultUnderFingerByChannel::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerByChannel, ReturnValue) == 0x000090, "Member 'PlayerController_GetHitResultUnderFingerByChannel::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHitResultUnderFingerForObjects
// 0x00B0 (0x00B0 - 0x0000)
struct PlayerController_GetHitResultUnderFingerForObjects final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             HitResult;                                         // 0x0020(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetHitResultUnderFingerForObjects) == 0x000008, "Wrong alignment on PlayerController_GetHitResultUnderFingerForObjects");
static_assert(sizeof(PlayerController_GetHitResultUnderFingerForObjects) == 0x0000B0, "Wrong size on PlayerController_GetHitResultUnderFingerForObjects");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerForObjects, FingerIndex) == 0x000000, "Member 'PlayerController_GetHitResultUnderFingerForObjects::FingerIndex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerForObjects, ObjectTypes) == 0x000008, "Member 'PlayerController_GetHitResultUnderFingerForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerForObjects, bTraceComplex) == 0x000018, "Member 'PlayerController_GetHitResultUnderFingerForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerForObjects, HitResult) == 0x000020, "Member 'PlayerController_GetHitResultUnderFingerForObjects::HitResult' has a wrong offset!");
static_assert(offsetof(PlayerController_GetHitResultUnderFingerForObjects, ReturnValue) == 0x0000A8, "Member 'PlayerController_GetHitResultUnderFingerForObjects::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetHUD
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_GetHUD final
{
public:
	class AHUD*                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetHUD) == 0x000008, "Wrong alignment on PlayerController_GetHUD");
static_assert(sizeof(PlayerController_GetHUD) == 0x000008, "Wrong size on PlayerController_GetHUD");
static_assert(offsetof(PlayerController_GetHUD, ReturnValue) == 0x000000, "Member 'PlayerController_GetHUD::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetInputAnalogKeyState
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_GetInputAnalogKeyState final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetInputAnalogKeyState) == 0x000008, "Wrong alignment on PlayerController_GetInputAnalogKeyState");
static_assert(sizeof(PlayerController_GetInputAnalogKeyState) == 0x000020, "Wrong size on PlayerController_GetInputAnalogKeyState");
static_assert(offsetof(PlayerController_GetInputAnalogKeyState, Key) == 0x000000, "Member 'PlayerController_GetInputAnalogKeyState::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputAnalogKeyState, ReturnValue) == 0x000018, "Member 'PlayerController_GetInputAnalogKeyState::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetInputAnalogStickState
// 0x000C (0x000C - 0x0000)
struct PlayerController_GetInputAnalogStickState final
{
public:
	EControllerAnalogStick                        WhichStick;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickX;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickY;                                            // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetInputAnalogStickState) == 0x000004, "Wrong alignment on PlayerController_GetInputAnalogStickState");
static_assert(sizeof(PlayerController_GetInputAnalogStickState) == 0x00000C, "Wrong size on PlayerController_GetInputAnalogStickState");
static_assert(offsetof(PlayerController_GetInputAnalogStickState, WhichStick) == 0x000000, "Member 'PlayerController_GetInputAnalogStickState::WhichStick' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputAnalogStickState, StickX) == 0x000004, "Member 'PlayerController_GetInputAnalogStickState::StickX' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputAnalogStickState, StickY) == 0x000008, "Member 'PlayerController_GetInputAnalogStickState::StickY' has a wrong offset!");

// Function Engine.PlayerController.GetInputKeyTimeDown
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_GetInputKeyTimeDown final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetInputKeyTimeDown) == 0x000008, "Wrong alignment on PlayerController_GetInputKeyTimeDown");
static_assert(sizeof(PlayerController_GetInputKeyTimeDown) == 0x000020, "Wrong size on PlayerController_GetInputKeyTimeDown");
static_assert(offsetof(PlayerController_GetInputKeyTimeDown, Key) == 0x000000, "Member 'PlayerController_GetInputKeyTimeDown::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputKeyTimeDown, ReturnValue) == 0x000018, "Member 'PlayerController_GetInputKeyTimeDown::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetInputMotionState
// 0x0054 (0x0054 - 0x0000)
struct PlayerController_GetInputMotionState final
{
public:
	struct FVector                                Tilt;                                              // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotationRate;                                      // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Gravity;                                           // 0x0018(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Acceleration;                                      // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SubAcceleration;                                   // 0x0030(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RotatoQuat;                                        // 0x003C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SubRotatoQuat;                                     // 0x0048(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetInputMotionState) == 0x000004, "Wrong alignment on PlayerController_GetInputMotionState");
static_assert(sizeof(PlayerController_GetInputMotionState) == 0x000054, "Wrong size on PlayerController_GetInputMotionState");
static_assert(offsetof(PlayerController_GetInputMotionState, Tilt) == 0x000000, "Member 'PlayerController_GetInputMotionState::Tilt' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, RotationRate) == 0x00000C, "Member 'PlayerController_GetInputMotionState::RotationRate' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, Gravity) == 0x000018, "Member 'PlayerController_GetInputMotionState::Gravity' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, Acceleration) == 0x000024, "Member 'PlayerController_GetInputMotionState::Acceleration' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, SubAcceleration) == 0x000030, "Member 'PlayerController_GetInputMotionState::SubAcceleration' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, RotatoQuat) == 0x00003C, "Member 'PlayerController_GetInputMotionState::RotatoQuat' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMotionState, SubRotatoQuat) == 0x000048, "Member 'PlayerController_GetInputMotionState::SubRotatoQuat' has a wrong offset!");

// Function Engine.PlayerController.GetInputMouseDelta
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_GetInputMouseDelta final
{
public:
	float                                         DeltaX;                                            // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaY;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetInputMouseDelta) == 0x000004, "Wrong alignment on PlayerController_GetInputMouseDelta");
static_assert(sizeof(PlayerController_GetInputMouseDelta) == 0x000008, "Wrong size on PlayerController_GetInputMouseDelta");
static_assert(offsetof(PlayerController_GetInputMouseDelta, DeltaX) == 0x000000, "Member 'PlayerController_GetInputMouseDelta::DeltaX' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputMouseDelta, DeltaY) == 0x000004, "Member 'PlayerController_GetInputMouseDelta::DeltaY' has a wrong offset!");

// Function Engine.PlayerController.GetInputTouchState
// 0x0010 (0x0010 - 0x0000)
struct PlayerController_GetInputTouchState final
{
public:
	ETouchIndex                                   FingerIndex;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LocationX;                                         // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY;                                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyPressed;                               // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetInputTouchState) == 0x000004, "Wrong alignment on PlayerController_GetInputTouchState");
static_assert(sizeof(PlayerController_GetInputTouchState) == 0x000010, "Wrong size on PlayerController_GetInputTouchState");
static_assert(offsetof(PlayerController_GetInputTouchState, FingerIndex) == 0x000000, "Member 'PlayerController_GetInputTouchState::FingerIndex' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputTouchState, LocationX) == 0x000004, "Member 'PlayerController_GetInputTouchState::LocationX' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputTouchState, LocationY) == 0x000008, "Member 'PlayerController_GetInputTouchState::LocationY' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputTouchState, bIsCurrentlyPressed) == 0x00000C, "Member 'PlayerController_GetInputTouchState::bIsCurrentlyPressed' has a wrong offset!");

// Function Engine.PlayerController.GetInputVectorKeyState
// 0x0028 (0x0028 - 0x0000)
struct PlayerController_GetInputVectorKeyState final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetInputVectorKeyState) == 0x000008, "Wrong alignment on PlayerController_GetInputVectorKeyState");
static_assert(sizeof(PlayerController_GetInputVectorKeyState) == 0x000028, "Wrong size on PlayerController_GetInputVectorKeyState");
static_assert(offsetof(PlayerController_GetInputVectorKeyState, Key) == 0x000000, "Member 'PlayerController_GetInputVectorKeyState::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_GetInputVectorKeyState, ReturnValue) == 0x000018, "Member 'PlayerController_GetInputVectorKeyState::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetMousePosition
// 0x000C (0x000C - 0x0000)
struct PlayerController_GetMousePosition final
{
public:
	float                                         LocationX;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY;                                         // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_GetMousePosition) == 0x000004, "Wrong alignment on PlayerController_GetMousePosition");
static_assert(sizeof(PlayerController_GetMousePosition) == 0x00000C, "Wrong size on PlayerController_GetMousePosition");
static_assert(offsetof(PlayerController_GetMousePosition, LocationX) == 0x000000, "Member 'PlayerController_GetMousePosition::LocationX' has a wrong offset!");
static_assert(offsetof(PlayerController_GetMousePosition, LocationY) == 0x000004, "Member 'PlayerController_GetMousePosition::LocationY' has a wrong offset!");
static_assert(offsetof(PlayerController_GetMousePosition, ReturnValue) == 0x000008, "Member 'PlayerController_GetMousePosition::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetSpectatorPawn
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_GetSpectatorPawn final
{
public:
	class ASpectatorPawn*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetSpectatorPawn) == 0x000008, "Wrong alignment on PlayerController_GetSpectatorPawn");
static_assert(sizeof(PlayerController_GetSpectatorPawn) == 0x000008, "Wrong size on PlayerController_GetSpectatorPawn");
static_assert(offsetof(PlayerController_GetSpectatorPawn, ReturnValue) == 0x000000, "Member 'PlayerController_GetSpectatorPawn::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.GetViewportSize
// 0x0008 (0x0008 - 0x0000)
struct PlayerController_GetViewportSize final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerController_GetViewportSize) == 0x000004, "Wrong alignment on PlayerController_GetViewportSize");
static_assert(sizeof(PlayerController_GetViewportSize) == 0x000008, "Wrong size on PlayerController_GetViewportSize");
static_assert(offsetof(PlayerController_GetViewportSize, SizeX) == 0x000000, "Member 'PlayerController_GetViewportSize::SizeX' has a wrong offset!");
static_assert(offsetof(PlayerController_GetViewportSize, SizeY) == 0x000004, "Member 'PlayerController_GetViewportSize::SizeY' has a wrong offset!");

// Function Engine.PlayerController.IsInputKeyDown
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_IsInputKeyDown final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_IsInputKeyDown) == 0x000008, "Wrong alignment on PlayerController_IsInputKeyDown");
static_assert(sizeof(PlayerController_IsInputKeyDown) == 0x000020, "Wrong size on PlayerController_IsInputKeyDown");
static_assert(offsetof(PlayerController_IsInputKeyDown, Key) == 0x000000, "Member 'PlayerController_IsInputKeyDown::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_IsInputKeyDown, ReturnValue) == 0x000018, "Member 'PlayerController_IsInputKeyDown::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.ProjectWorldLocationToScreen
// 0x0018 (0x0018 - 0x0000)
struct PlayerController_ProjectWorldLocationToScreen final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenLocation;                                    // 0x000C(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerViewportRelative;                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0015(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_16[0x2];                                       // 0x0016(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_ProjectWorldLocationToScreen) == 0x000004, "Wrong alignment on PlayerController_ProjectWorldLocationToScreen");
static_assert(sizeof(PlayerController_ProjectWorldLocationToScreen) == 0x000018, "Wrong size on PlayerController_ProjectWorldLocationToScreen");
static_assert(offsetof(PlayerController_ProjectWorldLocationToScreen, WorldLocation) == 0x000000, "Member 'PlayerController_ProjectWorldLocationToScreen::WorldLocation' has a wrong offset!");
static_assert(offsetof(PlayerController_ProjectWorldLocationToScreen, ScreenLocation) == 0x00000C, "Member 'PlayerController_ProjectWorldLocationToScreen::ScreenLocation' has a wrong offset!");
static_assert(offsetof(PlayerController_ProjectWorldLocationToScreen, bPlayerViewportRelative) == 0x000014, "Member 'PlayerController_ProjectWorldLocationToScreen::bPlayerViewportRelative' has a wrong offset!");
static_assert(offsetof(PlayerController_ProjectWorldLocationToScreen, ReturnValue) == 0x000015, "Member 'PlayerController_ProjectWorldLocationToScreen::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.WasInputKeyJustPressed
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_WasInputKeyJustPressed final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_WasInputKeyJustPressed) == 0x000008, "Wrong alignment on PlayerController_WasInputKeyJustPressed");
static_assert(sizeof(PlayerController_WasInputKeyJustPressed) == 0x000020, "Wrong size on PlayerController_WasInputKeyJustPressed");
static_assert(offsetof(PlayerController_WasInputKeyJustPressed, Key) == 0x000000, "Member 'PlayerController_WasInputKeyJustPressed::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_WasInputKeyJustPressed, ReturnValue) == 0x000018, "Member 'PlayerController_WasInputKeyJustPressed::ReturnValue' has a wrong offset!");

// Function Engine.PlayerController.WasInputKeyJustReleased
// 0x0020 (0x0020 - 0x0000)
struct PlayerController_WasInputKeyJustReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerController_WasInputKeyJustReleased) == 0x000008, "Wrong alignment on PlayerController_WasInputKeyJustReleased");
static_assert(sizeof(PlayerController_WasInputKeyJustReleased) == 0x000020, "Wrong size on PlayerController_WasInputKeyJustReleased");
static_assert(offsetof(PlayerController_WasInputKeyJustReleased, Key) == 0x000000, "Member 'PlayerController_WasInputKeyJustReleased::Key' has a wrong offset!");
static_assert(offsetof(PlayerController_WasInputKeyJustReleased, ReturnValue) == 0x000018, "Member 'PlayerController_WasInputKeyJustReleased::ReturnValue' has a wrong offset!");

// Function Engine.DebugCameraController.ReceiveOnActivate
// 0x0008 (0x0008 - 0x0000)
struct DebugCameraController_ReceiveOnActivate final
{
public:
	class APlayerController*                      OriginalPC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugCameraController_ReceiveOnActivate) == 0x000008, "Wrong alignment on DebugCameraController_ReceiveOnActivate");
static_assert(sizeof(DebugCameraController_ReceiveOnActivate) == 0x000008, "Wrong size on DebugCameraController_ReceiveOnActivate");
static_assert(offsetof(DebugCameraController_ReceiveOnActivate, OriginalPC) == 0x000000, "Member 'DebugCameraController_ReceiveOnActivate::OriginalPC' has a wrong offset!");

// Function Engine.DebugCameraController.ReceiveOnActorSelected
// 0x00A8 (0x00A8 - 0x0000)
struct DebugCameraController_ReceiveOnActorSelected final
{
public:
	class AActor*                                 NewSelectedActor;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SelectHitLocation;                                 // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SelectHitNormal;                                   // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             Hit;                                               // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugCameraController_ReceiveOnActorSelected) == 0x000008, "Wrong alignment on DebugCameraController_ReceiveOnActorSelected");
static_assert(sizeof(DebugCameraController_ReceiveOnActorSelected) == 0x0000A8, "Wrong size on DebugCameraController_ReceiveOnActorSelected");
static_assert(offsetof(DebugCameraController_ReceiveOnActorSelected, NewSelectedActor) == 0x000000, "Member 'DebugCameraController_ReceiveOnActorSelected::NewSelectedActor' has a wrong offset!");
static_assert(offsetof(DebugCameraController_ReceiveOnActorSelected, SelectHitLocation) == 0x000008, "Member 'DebugCameraController_ReceiveOnActorSelected::SelectHitLocation' has a wrong offset!");
static_assert(offsetof(DebugCameraController_ReceiveOnActorSelected, SelectHitNormal) == 0x000014, "Member 'DebugCameraController_ReceiveOnActorSelected::SelectHitNormal' has a wrong offset!");
static_assert(offsetof(DebugCameraController_ReceiveOnActorSelected, Hit) == 0x000020, "Member 'DebugCameraController_ReceiveOnActorSelected::Hit' has a wrong offset!");

// Function Engine.DebugCameraController.ReceiveOnDeactivate
// 0x0008 (0x0008 - 0x0000)
struct DebugCameraController_ReceiveOnDeactivate final
{
public:
	class APlayerController*                      RestoredPC;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugCameraController_ReceiveOnDeactivate) == 0x000008, "Wrong alignment on DebugCameraController_ReceiveOnDeactivate");
static_assert(sizeof(DebugCameraController_ReceiveOnDeactivate) == 0x000008, "Wrong size on DebugCameraController_ReceiveOnDeactivate");
static_assert(offsetof(DebugCameraController_ReceiveOnDeactivate, RestoredPC) == 0x000000, "Member 'DebugCameraController_ReceiveOnDeactivate::RestoredPC' has a wrong offset!");

// Function Engine.DebugCameraController.SetPawnMovementSpeedScale
// 0x0004 (0x0004 - 0x0000)
struct DebugCameraController_SetPawnMovementSpeedScale final
{
public:
	float                                         NewSpeedScale;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugCameraController_SetPawnMovementSpeedScale) == 0x000004, "Wrong alignment on DebugCameraController_SetPawnMovementSpeedScale");
static_assert(sizeof(DebugCameraController_SetPawnMovementSpeedScale) == 0x000004, "Wrong size on DebugCameraController_SetPawnMovementSpeedScale");
static_assert(offsetof(DebugCameraController_SetPawnMovementSpeedScale, NewSpeedScale) == 0x000000, "Member 'DebugCameraController_SetPawnMovementSpeedScale::NewSpeedScale' has a wrong offset!");

// Function Engine.DebugCameraController.GetSelectedActor
// 0x0008 (0x0008 - 0x0000)
struct DebugCameraController_GetSelectedActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DebugCameraController_GetSelectedActor) == 0x000008, "Wrong alignment on DebugCameraController_GetSelectedActor");
static_assert(sizeof(DebugCameraController_GetSelectedActor) == 0x000008, "Wrong size on DebugCameraController_GetSelectedActor");
static_assert(offsetof(DebugCameraController_GetSelectedActor, ReturnValue) == 0x000000, "Member 'DebugCameraController_GetSelectedActor::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetMovementBaseActor
// 0x0010 (0x0010 - 0x0000)
struct Pawn_GetMovementBaseActor final
{
public:
	const class APawn*                            Pawn;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetMovementBaseActor) == 0x000008, "Wrong alignment on Pawn_GetMovementBaseActor");
static_assert(sizeof(Pawn_GetMovementBaseActor) == 0x000010, "Wrong size on Pawn_GetMovementBaseActor");
static_assert(offsetof(Pawn_GetMovementBaseActor, Pawn) == 0x000000, "Member 'Pawn_GetMovementBaseActor::Pawn' has a wrong offset!");
static_assert(offsetof(Pawn_GetMovementBaseActor, ReturnValue) == 0x000008, "Member 'Pawn_GetMovementBaseActor::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.AddControllerPitchInput
// 0x0004 (0x0004 - 0x0000)
struct Pawn_AddControllerPitchInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_AddControllerPitchInput) == 0x000004, "Wrong alignment on Pawn_AddControllerPitchInput");
static_assert(sizeof(Pawn_AddControllerPitchInput) == 0x000004, "Wrong size on Pawn_AddControllerPitchInput");
static_assert(offsetof(Pawn_AddControllerPitchInput, Val) == 0x000000, "Member 'Pawn_AddControllerPitchInput::Val' has a wrong offset!");

// Function Engine.Pawn.AddControllerRollInput
// 0x0004 (0x0004 - 0x0000)
struct Pawn_AddControllerRollInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_AddControllerRollInput) == 0x000004, "Wrong alignment on Pawn_AddControllerRollInput");
static_assert(sizeof(Pawn_AddControllerRollInput) == 0x000004, "Wrong size on Pawn_AddControllerRollInput");
static_assert(offsetof(Pawn_AddControllerRollInput, Val) == 0x000000, "Member 'Pawn_AddControllerRollInput::Val' has a wrong offset!");

// Function Engine.Pawn.AddControllerYawInput
// 0x0004 (0x0004 - 0x0000)
struct Pawn_AddControllerYawInput final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_AddControllerYawInput) == 0x000004, "Wrong alignment on Pawn_AddControllerYawInput");
static_assert(sizeof(Pawn_AddControllerYawInput) == 0x000004, "Wrong size on Pawn_AddControllerYawInput");
static_assert(offsetof(Pawn_AddControllerYawInput, Val) == 0x000000, "Member 'Pawn_AddControllerYawInput::Val' has a wrong offset!");

// Function Engine.Pawn.AddMovementInput
// 0x0014 (0x0014 - 0x0000)
struct Pawn_AddMovementInput final
{
public:
	struct FVector                                WorldDirection;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaleValue;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Pawn_AddMovementInput) == 0x000004, "Wrong alignment on Pawn_AddMovementInput");
static_assert(sizeof(Pawn_AddMovementInput) == 0x000014, "Wrong size on Pawn_AddMovementInput");
static_assert(offsetof(Pawn_AddMovementInput, WorldDirection) == 0x000000, "Member 'Pawn_AddMovementInput::WorldDirection' has a wrong offset!");
static_assert(offsetof(Pawn_AddMovementInput, ScaleValue) == 0x00000C, "Member 'Pawn_AddMovementInput::ScaleValue' has a wrong offset!");
static_assert(offsetof(Pawn_AddMovementInput, bForce) == 0x000010, "Member 'Pawn_AddMovementInput::bForce' has a wrong offset!");

// Function Engine.Pawn.ConsumeMovementInputVector
// 0x000C (0x000C - 0x0000)
struct Pawn_ConsumeMovementInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_ConsumeMovementInputVector) == 0x000004, "Wrong alignment on Pawn_ConsumeMovementInputVector");
static_assert(sizeof(Pawn_ConsumeMovementInputVector) == 0x00000C, "Wrong size on Pawn_ConsumeMovementInputVector");
static_assert(offsetof(Pawn_ConsumeMovementInputVector, ReturnValue) == 0x000000, "Member 'Pawn_ConsumeMovementInputVector::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.LaunchPawn
// 0x0010 (0x0010 - 0x0000)
struct Pawn_LaunchPawn final
{
public:
	struct FVector                                LaunchVelocity;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXYOverride;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZOverride;                                        // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Pawn_LaunchPawn) == 0x000004, "Wrong alignment on Pawn_LaunchPawn");
static_assert(sizeof(Pawn_LaunchPawn) == 0x000010, "Wrong size on Pawn_LaunchPawn");
static_assert(offsetof(Pawn_LaunchPawn, LaunchVelocity) == 0x000000, "Member 'Pawn_LaunchPawn::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(Pawn_LaunchPawn, bXYOverride) == 0x00000C, "Member 'Pawn_LaunchPawn::bXYOverride' has a wrong offset!");
static_assert(offsetof(Pawn_LaunchPawn, bZOverride) == 0x00000D, "Member 'Pawn_LaunchPawn::bZOverride' has a wrong offset!");

// Function Engine.Pawn.PawnMakeNoise
// 0x0020 (0x0020 - 0x0000)
struct Pawn_PawnMakeNoise final
{
public:
	float                                         Loudness;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NoiseLocation;                                     // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNoiseMakerLocation;                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 NoiseMaker;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_PawnMakeNoise) == 0x000008, "Wrong alignment on Pawn_PawnMakeNoise");
static_assert(sizeof(Pawn_PawnMakeNoise) == 0x000020, "Wrong size on Pawn_PawnMakeNoise");
static_assert(offsetof(Pawn_PawnMakeNoise, Loudness) == 0x000000, "Member 'Pawn_PawnMakeNoise::Loudness' has a wrong offset!");
static_assert(offsetof(Pawn_PawnMakeNoise, NoiseLocation) == 0x000004, "Member 'Pawn_PawnMakeNoise::NoiseLocation' has a wrong offset!");
static_assert(offsetof(Pawn_PawnMakeNoise, bUseNoiseMakerLocation) == 0x000010, "Member 'Pawn_PawnMakeNoise::bUseNoiseMakerLocation' has a wrong offset!");
static_assert(offsetof(Pawn_PawnMakeNoise, NoiseMaker) == 0x000018, "Member 'Pawn_PawnMakeNoise::NoiseMaker' has a wrong offset!");

// Function Engine.Pawn.ReceivePossessed
// 0x0008 (0x0008 - 0x0000)
struct Pawn_ReceivePossessed final
{
public:
	class AController*                            NewController;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_ReceivePossessed) == 0x000008, "Wrong alignment on Pawn_ReceivePossessed");
static_assert(sizeof(Pawn_ReceivePossessed) == 0x000008, "Wrong size on Pawn_ReceivePossessed");
static_assert(offsetof(Pawn_ReceivePossessed, NewController) == 0x000000, "Member 'Pawn_ReceivePossessed::NewController' has a wrong offset!");

// Function Engine.Pawn.ReceiveUnpossessed
// 0x0008 (0x0008 - 0x0000)
struct Pawn_ReceiveUnpossessed final
{
public:
	class AController*                            OldController;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_ReceiveUnpossessed) == 0x000008, "Wrong alignment on Pawn_ReceiveUnpossessed");
static_assert(sizeof(Pawn_ReceiveUnpossessed) == 0x000008, "Wrong size on Pawn_ReceiveUnpossessed");
static_assert(offsetof(Pawn_ReceiveUnpossessed, OldController) == 0x000000, "Member 'Pawn_ReceiveUnpossessed::OldController' has a wrong offset!");

// Function Engine.Pawn.SetCanAffectNavigationGeneration
// 0x0002 (0x0002 - 0x0000)
struct Pawn_SetCanAffectNavigationGeneration final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceUpdate;                                      // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_SetCanAffectNavigationGeneration) == 0x000001, "Wrong alignment on Pawn_SetCanAffectNavigationGeneration");
static_assert(sizeof(Pawn_SetCanAffectNavigationGeneration) == 0x000002, "Wrong size on Pawn_SetCanAffectNavigationGeneration");
static_assert(offsetof(Pawn_SetCanAffectNavigationGeneration, bNewValue) == 0x000000, "Member 'Pawn_SetCanAffectNavigationGeneration::bNewValue' has a wrong offset!");
static_assert(offsetof(Pawn_SetCanAffectNavigationGeneration, bForceUpdate) == 0x000001, "Member 'Pawn_SetCanAffectNavigationGeneration::bForceUpdate' has a wrong offset!");

// Function Engine.Pawn.GetBaseAimRotation
// 0x000C (0x000C - 0x0000)
struct Pawn_GetBaseAimRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetBaseAimRotation) == 0x000004, "Wrong alignment on Pawn_GetBaseAimRotation");
static_assert(sizeof(Pawn_GetBaseAimRotation) == 0x00000C, "Wrong size on Pawn_GetBaseAimRotation");
static_assert(offsetof(Pawn_GetBaseAimRotation, ReturnValue) == 0x000000, "Member 'Pawn_GetBaseAimRotation::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetController
// 0x0008 (0x0008 - 0x0000)
struct Pawn_GetController final
{
public:
	class AController*                            ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetController) == 0x000008, "Wrong alignment on Pawn_GetController");
static_assert(sizeof(Pawn_GetController) == 0x000008, "Wrong size on Pawn_GetController");
static_assert(offsetof(Pawn_GetController, ReturnValue) == 0x000000, "Member 'Pawn_GetController::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetControlRotation
// 0x000C (0x000C - 0x0000)
struct Pawn_GetControlRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetControlRotation) == 0x000004, "Wrong alignment on Pawn_GetControlRotation");
static_assert(sizeof(Pawn_GetControlRotation) == 0x00000C, "Wrong size on Pawn_GetControlRotation");
static_assert(offsetof(Pawn_GetControlRotation, ReturnValue) == 0x000000, "Member 'Pawn_GetControlRotation::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetLastMovementInputVector
// 0x000C (0x000C - 0x0000)
struct Pawn_GetLastMovementInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetLastMovementInputVector) == 0x000004, "Wrong alignment on Pawn_GetLastMovementInputVector");
static_assert(sizeof(Pawn_GetLastMovementInputVector) == 0x00000C, "Wrong size on Pawn_GetLastMovementInputVector");
static_assert(offsetof(Pawn_GetLastMovementInputVector, ReturnValue) == 0x000000, "Member 'Pawn_GetLastMovementInputVector::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetMovementComponent
// 0x0008 (0x0008 - 0x0000)
struct Pawn_GetMovementComponent final
{
public:
	class UPawnMovementComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetMovementComponent) == 0x000008, "Wrong alignment on Pawn_GetMovementComponent");
static_assert(sizeof(Pawn_GetMovementComponent) == 0x000008, "Wrong size on Pawn_GetMovementComponent");
static_assert(offsetof(Pawn_GetMovementComponent, ReturnValue) == 0x000000, "Member 'Pawn_GetMovementComponent::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetNavAgentLocation
// 0x000C (0x000C - 0x0000)
struct Pawn_GetNavAgentLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetNavAgentLocation) == 0x000004, "Wrong alignment on Pawn_GetNavAgentLocation");
static_assert(sizeof(Pawn_GetNavAgentLocation) == 0x00000C, "Wrong size on Pawn_GetNavAgentLocation");
static_assert(offsetof(Pawn_GetNavAgentLocation, ReturnValue) == 0x000000, "Member 'Pawn_GetNavAgentLocation::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.GetPendingMovementInputVector
// 0x000C (0x000C - 0x0000)
struct Pawn_GetPendingMovementInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_GetPendingMovementInputVector) == 0x000004, "Wrong alignment on Pawn_GetPendingMovementInputVector");
static_assert(sizeof(Pawn_GetPendingMovementInputVector) == 0x00000C, "Wrong size on Pawn_GetPendingMovementInputVector");
static_assert(offsetof(Pawn_GetPendingMovementInputVector, ReturnValue) == 0x000000, "Member 'Pawn_GetPendingMovementInputVector::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.IsControlled
// 0x0001 (0x0001 - 0x0000)
struct Pawn_IsControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_IsControlled) == 0x000001, "Wrong alignment on Pawn_IsControlled");
static_assert(sizeof(Pawn_IsControlled) == 0x000001, "Wrong size on Pawn_IsControlled");
static_assert(offsetof(Pawn_IsControlled, ReturnValue) == 0x000000, "Member 'Pawn_IsControlled::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.IsLocallyControlled
// 0x0001 (0x0001 - 0x0000)
struct Pawn_IsLocallyControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_IsLocallyControlled) == 0x000001, "Wrong alignment on Pawn_IsLocallyControlled");
static_assert(sizeof(Pawn_IsLocallyControlled) == 0x000001, "Wrong size on Pawn_IsLocallyControlled");
static_assert(offsetof(Pawn_IsLocallyControlled, ReturnValue) == 0x000000, "Member 'Pawn_IsLocallyControlled::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.IsMoveInputIgnored
// 0x0001 (0x0001 - 0x0000)
struct Pawn_IsMoveInputIgnored final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_IsMoveInputIgnored) == 0x000001, "Wrong alignment on Pawn_IsMoveInputIgnored");
static_assert(sizeof(Pawn_IsMoveInputIgnored) == 0x000001, "Wrong size on Pawn_IsMoveInputIgnored");
static_assert(offsetof(Pawn_IsMoveInputIgnored, ReturnValue) == 0x000000, "Member 'Pawn_IsMoveInputIgnored::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.IsPlayerControlled
// 0x0001 (0x0001 - 0x0000)
struct Pawn_IsPlayerControlled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_IsPlayerControlled) == 0x000001, "Wrong alignment on Pawn_IsPlayerControlled");
static_assert(sizeof(Pawn_IsPlayerControlled) == 0x000001, "Wrong size on Pawn_IsPlayerControlled");
static_assert(offsetof(Pawn_IsPlayerControlled, ReturnValue) == 0x000000, "Member 'Pawn_IsPlayerControlled::ReturnValue' has a wrong offset!");

// Function Engine.Pawn.K2_GetMovementInputVector
// 0x000C (0x000C - 0x0000)
struct Pawn_K2_GetMovementInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Pawn_K2_GetMovementInputVector) == 0x000004, "Wrong alignment on Pawn_K2_GetMovementInputVector");
static_assert(sizeof(Pawn_K2_GetMovementInputVector) == 0x00000C, "Wrong size on Pawn_K2_GetMovementInputVector");
static_assert(offsetof(Pawn_K2_GetMovementInputVector, ReturnValue) == 0x000000, "Member 'Pawn_K2_GetMovementInputVector::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.CreateInstance
// 0x0018 (0x0018 - 0x0000)
struct LevelStreaming_CreateInstance final
{
public:
	class FString                                 UniqueInstanceName;                                // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_CreateInstance) == 0x000008, "Wrong alignment on LevelStreaming_CreateInstance");
static_assert(sizeof(LevelStreaming_CreateInstance) == 0x000018, "Wrong size on LevelStreaming_CreateInstance");
static_assert(offsetof(LevelStreaming_CreateInstance, UniqueInstanceName) == 0x000000, "Member 'LevelStreaming_CreateInstance::UniqueInstanceName' has a wrong offset!");
static_assert(offsetof(LevelStreaming_CreateInstance, ReturnValue) == 0x000010, "Member 'LevelStreaming_CreateInstance::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.GetLevelScriptActor
// 0x0008 (0x0008 - 0x0000)
struct LevelStreaming_GetLevelScriptActor final
{
public:
	class ALevelScriptActor*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_GetLevelScriptActor) == 0x000008, "Wrong alignment on LevelStreaming_GetLevelScriptActor");
static_assert(sizeof(LevelStreaming_GetLevelScriptActor) == 0x000008, "Wrong size on LevelStreaming_GetLevelScriptActor");
static_assert(offsetof(LevelStreaming_GetLevelScriptActor, ReturnValue) == 0x000000, "Member 'LevelStreaming_GetLevelScriptActor::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.GetWorldAssetPackageFName
// 0x0008 (0x0008 - 0x0000)
struct LevelStreaming_GetWorldAssetPackageFName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_GetWorldAssetPackageFName) == 0x000004, "Wrong alignment on LevelStreaming_GetWorldAssetPackageFName");
static_assert(sizeof(LevelStreaming_GetWorldAssetPackageFName) == 0x000008, "Wrong size on LevelStreaming_GetWorldAssetPackageFName");
static_assert(offsetof(LevelStreaming_GetWorldAssetPackageFName, ReturnValue) == 0x000000, "Member 'LevelStreaming_GetWorldAssetPackageFName::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.GetWorldAssetPackageShortFName
// 0x0008 (0x0008 - 0x0000)
struct LevelStreaming_GetWorldAssetPackageShortFName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_GetWorldAssetPackageShortFName) == 0x000004, "Wrong alignment on LevelStreaming_GetWorldAssetPackageShortFName");
static_assert(sizeof(LevelStreaming_GetWorldAssetPackageShortFName) == 0x000008, "Wrong size on LevelStreaming_GetWorldAssetPackageShortFName");
static_assert(offsetof(LevelStreaming_GetWorldAssetPackageShortFName, ReturnValue) == 0x000000, "Member 'LevelStreaming_GetWorldAssetPackageShortFName::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.IsLevelLoaded
// 0x0001 (0x0001 - 0x0000)
struct LevelStreaming_IsLevelLoaded final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_IsLevelLoaded) == 0x000001, "Wrong alignment on LevelStreaming_IsLevelLoaded");
static_assert(sizeof(LevelStreaming_IsLevelLoaded) == 0x000001, "Wrong size on LevelStreaming_IsLevelLoaded");
static_assert(offsetof(LevelStreaming_IsLevelLoaded, ReturnValue) == 0x000000, "Member 'LevelStreaming_IsLevelLoaded::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.IsLevelVisible
// 0x0001 (0x0001 - 0x0000)
struct LevelStreaming_IsLevelVisible final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_IsLevelVisible) == 0x000001, "Wrong alignment on LevelStreaming_IsLevelVisible");
static_assert(sizeof(LevelStreaming_IsLevelVisible) == 0x000001, "Wrong size on LevelStreaming_IsLevelVisible");
static_assert(offsetof(LevelStreaming_IsLevelVisible, ReturnValue) == 0x000000, "Member 'LevelStreaming_IsLevelVisible::ReturnValue' has a wrong offset!");

// Function Engine.LevelStreaming.IsStreamingStatePending
// 0x0001 (0x0001 - 0x0000)
struct LevelStreaming_IsStreamingStatePending final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreaming_IsStreamingStatePending) == 0x000001, "Wrong alignment on LevelStreaming_IsStreamingStatePending");
static_assert(sizeof(LevelStreaming_IsStreamingStatePending) == 0x000001, "Wrong size on LevelStreaming_IsStreamingStatePending");
static_assert(offsetof(LevelStreaming_IsStreamingStatePending, ReturnValue) == 0x000000, "Member 'LevelStreaming_IsStreamingStatePending::ReturnValue' has a wrong offset!");

// Function Engine.CurveBase.GetTimeRange
// 0x0008 (0x0008 - 0x0000)
struct CurveBase_GetTimeRange final
{
public:
	float                                         MinTime;                                           // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxTime;                                           // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveBase_GetTimeRange) == 0x000004, "Wrong alignment on CurveBase_GetTimeRange");
static_assert(sizeof(CurveBase_GetTimeRange) == 0x000008, "Wrong size on CurveBase_GetTimeRange");
static_assert(offsetof(CurveBase_GetTimeRange, MinTime) == 0x000000, "Member 'CurveBase_GetTimeRange::MinTime' has a wrong offset!");
static_assert(offsetof(CurveBase_GetTimeRange, MaxTime) == 0x000004, "Member 'CurveBase_GetTimeRange::MaxTime' has a wrong offset!");

// Function Engine.CurveBase.GetValueRange
// 0x0008 (0x0008 - 0x0000)
struct CurveBase_GetValueRange final
{
public:
	float                                         MinValue;                                          // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveBase_GetValueRange) == 0x000004, "Wrong alignment on CurveBase_GetValueRange");
static_assert(sizeof(CurveBase_GetValueRange) == 0x000008, "Wrong size on CurveBase_GetValueRange");
static_assert(offsetof(CurveBase_GetValueRange, MinValue) == 0x000000, "Member 'CurveBase_GetValueRange::MinValue' has a wrong offset!");
static_assert(offsetof(CurveBase_GetValueRange, MaxValue) == 0x000004, "Member 'CurveBase_GetValueRange::MaxValue' has a wrong offset!");

// Function Engine.CurveLinearColor.GetLinearColorValue
// 0x0014 (0x0014 - 0x0000)
struct CurveLinearColor_GetLinearColorValue final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveLinearColor_GetLinearColorValue) == 0x000004, "Wrong alignment on CurveLinearColor_GetLinearColorValue");
static_assert(sizeof(CurveLinearColor_GetLinearColorValue) == 0x000014, "Wrong size on CurveLinearColor_GetLinearColorValue");
static_assert(offsetof(CurveLinearColor_GetLinearColorValue, InTime) == 0x000000, "Member 'CurveLinearColor_GetLinearColorValue::InTime' has a wrong offset!");
static_assert(offsetof(CurveLinearColor_GetLinearColorValue, ReturnValue) == 0x000004, "Member 'CurveLinearColor_GetLinearColorValue::ReturnValue' has a wrong offset!");

// Function Engine.Character.CacheInitialMeshOffset
// 0x0018 (0x0018 - 0x0000)
struct Character_CacheInitialMeshOffset final
{
public:
	struct FVector                                MeshRelativeLocation;                              // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               MeshRelativeRotation;                              // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_CacheInitialMeshOffset) == 0x000004, "Wrong alignment on Character_CacheInitialMeshOffset");
static_assert(sizeof(Character_CacheInitialMeshOffset) == 0x000018, "Wrong size on Character_CacheInitialMeshOffset");
static_assert(offsetof(Character_CacheInitialMeshOffset, MeshRelativeLocation) == 0x000000, "Member 'Character_CacheInitialMeshOffset::MeshRelativeLocation' has a wrong offset!");
static_assert(offsetof(Character_CacheInitialMeshOffset, MeshRelativeRotation) == 0x00000C, "Member 'Character_CacheInitialMeshOffset::MeshRelativeRotation' has a wrong offset!");

// Function Engine.Character.Crouch
// 0x0001 (0x0001 - 0x0000)
struct Character_Crouch final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_Crouch) == 0x000001, "Wrong alignment on Character_Crouch");
static_assert(sizeof(Character_Crouch) == 0x000001, "Wrong size on Character_Crouch");
static_assert(offsetof(Character_Crouch, bClientSimulation) == 0x000000, "Member 'Character_Crouch::bClientSimulation' has a wrong offset!");

// Function Engine.Character.GetCurrentMontage
// 0x0008 (0x0008 - 0x0000)
struct Character_GetCurrentMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_GetCurrentMontage) == 0x000008, "Wrong alignment on Character_GetCurrentMontage");
static_assert(sizeof(Character_GetCurrentMontage) == 0x000008, "Wrong size on Character_GetCurrentMontage");
static_assert(offsetof(Character_GetCurrentMontage, ReturnValue) == 0x000000, "Member 'Character_GetCurrentMontage::ReturnValue' has a wrong offset!");

// Function Engine.Character.K2_OnEndCrouch
// 0x0008 (0x0008 - 0x0000)
struct Character_K2_OnEndCrouch final
{
public:
	float                                         HalfHeightAdjust;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaledHalfHeightAdjust;                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_K2_OnEndCrouch) == 0x000004, "Wrong alignment on Character_K2_OnEndCrouch");
static_assert(sizeof(Character_K2_OnEndCrouch) == 0x000008, "Wrong size on Character_K2_OnEndCrouch");
static_assert(offsetof(Character_K2_OnEndCrouch, HalfHeightAdjust) == 0x000000, "Member 'Character_K2_OnEndCrouch::HalfHeightAdjust' has a wrong offset!");
static_assert(offsetof(Character_K2_OnEndCrouch, ScaledHalfHeightAdjust) == 0x000004, "Member 'Character_K2_OnEndCrouch::ScaledHalfHeightAdjust' has a wrong offset!");

// Function Engine.Character.K2_OnMovementModeChanged
// 0x0004 (0x0004 - 0x0000)
struct Character_K2_OnMovementModeChanged final
{
public:
	EMovementMode                                 PrevMovementMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMovementMode                                 NewMovementMode;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         PrevCustomMode;                                    // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewCustomMode;                                     // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_K2_OnMovementModeChanged) == 0x000001, "Wrong alignment on Character_K2_OnMovementModeChanged");
static_assert(sizeof(Character_K2_OnMovementModeChanged) == 0x000004, "Wrong size on Character_K2_OnMovementModeChanged");
static_assert(offsetof(Character_K2_OnMovementModeChanged, PrevMovementMode) == 0x000000, "Member 'Character_K2_OnMovementModeChanged::PrevMovementMode' has a wrong offset!");
static_assert(offsetof(Character_K2_OnMovementModeChanged, NewMovementMode) == 0x000001, "Member 'Character_K2_OnMovementModeChanged::NewMovementMode' has a wrong offset!");
static_assert(offsetof(Character_K2_OnMovementModeChanged, PrevCustomMode) == 0x000002, "Member 'Character_K2_OnMovementModeChanged::PrevCustomMode' has a wrong offset!");
static_assert(offsetof(Character_K2_OnMovementModeChanged, NewCustomMode) == 0x000003, "Member 'Character_K2_OnMovementModeChanged::NewCustomMode' has a wrong offset!");

// Function Engine.Character.K2_OnStartCrouch
// 0x0008 (0x0008 - 0x0000)
struct Character_K2_OnStartCrouch final
{
public:
	float                                         HalfHeightAdjust;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScaledHalfHeightAdjust;                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_K2_OnStartCrouch) == 0x000004, "Wrong alignment on Character_K2_OnStartCrouch");
static_assert(sizeof(Character_K2_OnStartCrouch) == 0x000008, "Wrong size on Character_K2_OnStartCrouch");
static_assert(offsetof(Character_K2_OnStartCrouch, HalfHeightAdjust) == 0x000000, "Member 'Character_K2_OnStartCrouch::HalfHeightAdjust' has a wrong offset!");
static_assert(offsetof(Character_K2_OnStartCrouch, ScaledHalfHeightAdjust) == 0x000004, "Member 'Character_K2_OnStartCrouch::ScaledHalfHeightAdjust' has a wrong offset!");

// Function Engine.Character.K2_UpdateCustomMovement
// 0x0004 (0x0004 - 0x0000)
struct Character_K2_UpdateCustomMovement final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_K2_UpdateCustomMovement) == 0x000004, "Wrong alignment on Character_K2_UpdateCustomMovement");
static_assert(sizeof(Character_K2_UpdateCustomMovement) == 0x000004, "Wrong size on Character_K2_UpdateCustomMovement");
static_assert(offsetof(Character_K2_UpdateCustomMovement, DeltaTime) == 0x000000, "Member 'Character_K2_UpdateCustomMovement::DeltaTime' has a wrong offset!");

// Function Engine.Character.LaunchCharacter
// 0x0010 (0x0010 - 0x0000)
struct Character_LaunchCharacter final
{
public:
	struct FVector                                LaunchVelocity;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXYOverride;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZOverride;                                        // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Character_LaunchCharacter) == 0x000004, "Wrong alignment on Character_LaunchCharacter");
static_assert(sizeof(Character_LaunchCharacter) == 0x000010, "Wrong size on Character_LaunchCharacter");
static_assert(offsetof(Character_LaunchCharacter, LaunchVelocity) == 0x000000, "Member 'Character_LaunchCharacter::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(Character_LaunchCharacter, bXYOverride) == 0x00000C, "Member 'Character_LaunchCharacter::bXYOverride' has a wrong offset!");
static_assert(offsetof(Character_LaunchCharacter, bZOverride) == 0x00000D, "Member 'Character_LaunchCharacter::bZOverride' has a wrong offset!");

// Function Engine.Character.OnLanded
// 0x0088 (0x0088 - 0x0000)
struct Character_OnLanded final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_OnLanded) == 0x000008, "Wrong alignment on Character_OnLanded");
static_assert(sizeof(Character_OnLanded) == 0x000088, "Wrong size on Character_OnLanded");
static_assert(offsetof(Character_OnLanded, Hit) == 0x000000, "Member 'Character_OnLanded::Hit' has a wrong offset!");

// Function Engine.Character.OnLaunched
// 0x0010 (0x0010 - 0x0000)
struct Character_OnLaunched final
{
public:
	struct FVector                                LaunchVelocity;                                    // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bXYOverride;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bZOverride;                                        // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Character_OnLaunched) == 0x000004, "Wrong alignment on Character_OnLaunched");
static_assert(sizeof(Character_OnLaunched) == 0x000010, "Wrong size on Character_OnLaunched");
static_assert(offsetof(Character_OnLaunched, LaunchVelocity) == 0x000000, "Member 'Character_OnLaunched::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(Character_OnLaunched, bXYOverride) == 0x00000C, "Member 'Character_OnLaunched::bXYOverride' has a wrong offset!");
static_assert(offsetof(Character_OnLaunched, bZOverride) == 0x00000D, "Member 'Character_OnLaunched::bZOverride' has a wrong offset!");

// Function Engine.Character.OnWalkingOffLedge
// 0x0028 (0x0028 - 0x0000)
struct Character_OnWalkingOffLedge final
{
public:
	struct FVector                                PreviousFloorImpactNormal;                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousFloorContactNormal;                        // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousLocation;                                  // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDelta;                                         // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_OnWalkingOffLedge) == 0x000004, "Wrong alignment on Character_OnWalkingOffLedge");
static_assert(sizeof(Character_OnWalkingOffLedge) == 0x000028, "Wrong size on Character_OnWalkingOffLedge");
static_assert(offsetof(Character_OnWalkingOffLedge, PreviousFloorImpactNormal) == 0x000000, "Member 'Character_OnWalkingOffLedge::PreviousFloorImpactNormal' has a wrong offset!");
static_assert(offsetof(Character_OnWalkingOffLedge, PreviousFloorContactNormal) == 0x00000C, "Member 'Character_OnWalkingOffLedge::PreviousFloorContactNormal' has a wrong offset!");
static_assert(offsetof(Character_OnWalkingOffLedge, PreviousLocation) == 0x000018, "Member 'Character_OnWalkingOffLedge::PreviousLocation' has a wrong offset!");
static_assert(offsetof(Character_OnWalkingOffLedge, TimeDelta) == 0x000024, "Member 'Character_OnWalkingOffLedge::TimeDelta' has a wrong offset!");

// Function Engine.Character.PlayAnimMontage
// 0x0020 (0x0020 - 0x0000)
struct Character_PlayAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartSectionName;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Character_PlayAnimMontage) == 0x000008, "Wrong alignment on Character_PlayAnimMontage");
static_assert(sizeof(Character_PlayAnimMontage) == 0x000020, "Wrong size on Character_PlayAnimMontage");
static_assert(offsetof(Character_PlayAnimMontage, AnimMontage) == 0x000000, "Member 'Character_PlayAnimMontage::AnimMontage' has a wrong offset!");
static_assert(offsetof(Character_PlayAnimMontage, InPlayRate) == 0x000008, "Member 'Character_PlayAnimMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(Character_PlayAnimMontage, StartSectionName) == 0x000010, "Member 'Character_PlayAnimMontage::StartSectionName' has a wrong offset!");
static_assert(offsetof(Character_PlayAnimMontage, ReturnValue) == 0x000018, "Member 'Character_PlayAnimMontage::ReturnValue' has a wrong offset!");

// Function Engine.Character.RootMotionDebugClientPrintOnScreen
// 0x0010 (0x0010 - 0x0000)
struct Character_RootMotionDebugClientPrintOnScreen final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_RootMotionDebugClientPrintOnScreen) == 0x000008, "Wrong alignment on Character_RootMotionDebugClientPrintOnScreen");
static_assert(sizeof(Character_RootMotionDebugClientPrintOnScreen) == 0x000010, "Wrong size on Character_RootMotionDebugClientPrintOnScreen");
static_assert(offsetof(Character_RootMotionDebugClientPrintOnScreen, InString) == 0x000000, "Member 'Character_RootMotionDebugClientPrintOnScreen::InString' has a wrong offset!");

// Function Engine.Character.SetReplicateMovement
// 0x0001 (0x0001 - 0x0000)
struct Character_SetReplicateMovement final
{
public:
	bool                                          bInReplicateMovement;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_SetReplicateMovement) == 0x000001, "Wrong alignment on Character_SetReplicateMovement");
static_assert(sizeof(Character_SetReplicateMovement) == 0x000001, "Wrong size on Character_SetReplicateMovement");
static_assert(offsetof(Character_SetReplicateMovement, bInReplicateMovement) == 0x000000, "Member 'Character_SetReplicateMovement::bInReplicateMovement' has a wrong offset!");

// Function Engine.Character.StopAnimMontage
// 0x0008 (0x0008 - 0x0000)
struct Character_StopAnimMontage final
{
public:
	class UAnimMontage*                           AnimMontage;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_StopAnimMontage) == 0x000008, "Wrong alignment on Character_StopAnimMontage");
static_assert(sizeof(Character_StopAnimMontage) == 0x000008, "Wrong size on Character_StopAnimMontage");
static_assert(offsetof(Character_StopAnimMontage, AnimMontage) == 0x000000, "Member 'Character_StopAnimMontage::AnimMontage' has a wrong offset!");

// Function Engine.Character.UnCrouch
// 0x0001 (0x0001 - 0x0000)
struct Character_UnCrouch final
{
public:
	bool                                          bClientSimulation;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_UnCrouch) == 0x000001, "Wrong alignment on Character_UnCrouch");
static_assert(sizeof(Character_UnCrouch) == 0x000001, "Wrong size on Character_UnCrouch");
static_assert(offsetof(Character_UnCrouch, bClientSimulation) == 0x000000, "Member 'Character_UnCrouch::bClientSimulation' has a wrong offset!");

// Function Engine.Character.CanJump
// 0x0001 (0x0001 - 0x0000)
struct Character_CanJump final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_CanJump) == 0x000001, "Wrong alignment on Character_CanJump");
static_assert(sizeof(Character_CanJump) == 0x000001, "Wrong size on Character_CanJump");
static_assert(offsetof(Character_CanJump, ReturnValue) == 0x000000, "Member 'Character_CanJump::ReturnValue' has a wrong offset!");

// Function Engine.Character.CanJumpInternal
// 0x0001 (0x0001 - 0x0000)
struct Character_CanJumpInternal final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_CanJumpInternal) == 0x000001, "Wrong alignment on Character_CanJumpInternal");
static_assert(sizeof(Character_CanJumpInternal) == 0x000001, "Wrong size on Character_CanJumpInternal");
static_assert(offsetof(Character_CanJumpInternal, ReturnValue) == 0x000000, "Member 'Character_CanJumpInternal::ReturnValue' has a wrong offset!");

// Function Engine.Character.GetAnimRootMotionTranslationScale
// 0x0004 (0x0004 - 0x0000)
struct Character_GetAnimRootMotionTranslationScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_GetAnimRootMotionTranslationScale) == 0x000004, "Wrong alignment on Character_GetAnimRootMotionTranslationScale");
static_assert(sizeof(Character_GetAnimRootMotionTranslationScale) == 0x000004, "Wrong size on Character_GetAnimRootMotionTranslationScale");
static_assert(offsetof(Character_GetAnimRootMotionTranslationScale, ReturnValue) == 0x000000, "Member 'Character_GetAnimRootMotionTranslationScale::ReturnValue' has a wrong offset!");

// Function Engine.Character.GetBaseRotationOffsetRotator
// 0x000C (0x000C - 0x0000)
struct Character_GetBaseRotationOffsetRotator final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_GetBaseRotationOffsetRotator) == 0x000004, "Wrong alignment on Character_GetBaseRotationOffsetRotator");
static_assert(sizeof(Character_GetBaseRotationOffsetRotator) == 0x00000C, "Wrong size on Character_GetBaseRotationOffsetRotator");
static_assert(offsetof(Character_GetBaseRotationOffsetRotator, ReturnValue) == 0x000000, "Member 'Character_GetBaseRotationOffsetRotator::ReturnValue' has a wrong offset!");

// Function Engine.Character.GetBaseTranslationOffset
// 0x000C (0x000C - 0x0000)
struct Character_GetBaseTranslationOffset final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_GetBaseTranslationOffset) == 0x000004, "Wrong alignment on Character_GetBaseTranslationOffset");
static_assert(sizeof(Character_GetBaseTranslationOffset) == 0x00000C, "Wrong size on Character_GetBaseTranslationOffset");
static_assert(offsetof(Character_GetBaseTranslationOffset, ReturnValue) == 0x000000, "Member 'Character_GetBaseTranslationOffset::ReturnValue' has a wrong offset!");

// Function Engine.Character.IsJumpProvidingForce
// 0x0001 (0x0001 - 0x0000)
struct Character_IsJumpProvidingForce final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_IsJumpProvidingForce) == 0x000001, "Wrong alignment on Character_IsJumpProvidingForce");
static_assert(sizeof(Character_IsJumpProvidingForce) == 0x000001, "Wrong size on Character_IsJumpProvidingForce");
static_assert(offsetof(Character_IsJumpProvidingForce, ReturnValue) == 0x000000, "Member 'Character_IsJumpProvidingForce::ReturnValue' has a wrong offset!");

// Function Engine.Character.IsPlayingNetworkedRootMotionMontage
// 0x0001 (0x0001 - 0x0000)
struct Character_IsPlayingNetworkedRootMotionMontage final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_IsPlayingNetworkedRootMotionMontage) == 0x000001, "Wrong alignment on Character_IsPlayingNetworkedRootMotionMontage");
static_assert(sizeof(Character_IsPlayingNetworkedRootMotionMontage) == 0x000001, "Wrong size on Character_IsPlayingNetworkedRootMotionMontage");
static_assert(offsetof(Character_IsPlayingNetworkedRootMotionMontage, ReturnValue) == 0x000000, "Member 'Character_IsPlayingNetworkedRootMotionMontage::ReturnValue' has a wrong offset!");

// Function Engine.Character.IsPlayingRootMotion
// 0x0001 (0x0001 - 0x0000)
struct Character_IsPlayingRootMotion final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Character_IsPlayingRootMotion) == 0x000001, "Wrong alignment on Character_IsPlayingRootMotion");
static_assert(sizeof(Character_IsPlayingRootMotion) == 0x000001, "Wrong size on Character_IsPlayingRootMotion");
static_assert(offsetof(Character_IsPlayingRootMotion, ReturnValue) == 0x000000, "Member 'Character_IsPlayingRootMotion::ReturnValue' has a wrong offset!");

// Function Engine.MeshComponent.PrestreamTextures
// 0x000C (0x000C - 0x0000)
struct MeshComponent_PrestreamTextures final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrioritizeCharacterTextures;                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CinematicTextureGroups;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshComponent_PrestreamTextures) == 0x000004, "Wrong alignment on MeshComponent_PrestreamTextures");
static_assert(sizeof(MeshComponent_PrestreamTextures) == 0x00000C, "Wrong size on MeshComponent_PrestreamTextures");
static_assert(offsetof(MeshComponent_PrestreamTextures, Seconds) == 0x000000, "Member 'MeshComponent_PrestreamTextures::Seconds' has a wrong offset!");
static_assert(offsetof(MeshComponent_PrestreamTextures, bPrioritizeCharacterTextures) == 0x000004, "Member 'MeshComponent_PrestreamTextures::bPrioritizeCharacterTextures' has a wrong offset!");
static_assert(offsetof(MeshComponent_PrestreamTextures, CinematicTextureGroups) == 0x000008, "Member 'MeshComponent_PrestreamTextures::CinematicTextureGroups' has a wrong offset!");

// Function Engine.MeshComponent.SetScalarParameterValueOnMaterials
// 0x0010 (0x0010 - 0x0000)
struct MeshComponent_SetScalarParameterValueOnMaterials final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0008(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshComponent_SetScalarParameterValueOnMaterials) == 0x000004, "Wrong alignment on MeshComponent_SetScalarParameterValueOnMaterials");
static_assert(sizeof(MeshComponent_SetScalarParameterValueOnMaterials) == 0x000010, "Wrong size on MeshComponent_SetScalarParameterValueOnMaterials");
static_assert(offsetof(MeshComponent_SetScalarParameterValueOnMaterials, ParameterName) == 0x000000, "Member 'MeshComponent_SetScalarParameterValueOnMaterials::ParameterName' has a wrong offset!");
static_assert(offsetof(MeshComponent_SetScalarParameterValueOnMaterials, ParameterValue) == 0x000008, "Member 'MeshComponent_SetScalarParameterValueOnMaterials::ParameterValue' has a wrong offset!");

// Function Engine.MeshComponent.SetVectorParameterValueOnMaterials
// 0x0018 (0x0018 - 0x0000)
struct MeshComponent_SetVectorParameterValueOnMaterials final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ParameterValue;                                    // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshComponent_SetVectorParameterValueOnMaterials) == 0x000004, "Wrong alignment on MeshComponent_SetVectorParameterValueOnMaterials");
static_assert(sizeof(MeshComponent_SetVectorParameterValueOnMaterials) == 0x000018, "Wrong size on MeshComponent_SetVectorParameterValueOnMaterials");
static_assert(offsetof(MeshComponent_SetVectorParameterValueOnMaterials, ParameterName) == 0x000000, "Member 'MeshComponent_SetVectorParameterValueOnMaterials::ParameterName' has a wrong offset!");
static_assert(offsetof(MeshComponent_SetVectorParameterValueOnMaterials, ParameterValue) == 0x000008, "Member 'MeshComponent_SetVectorParameterValueOnMaterials::ParameterValue' has a wrong offset!");

// Function Engine.MeshComponent.GetMaterialIndex
// 0x0010 (0x0010 - 0x0000)
struct MeshComponent_GetMaterialIndex final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshComponent_GetMaterialIndex) == 0x000004, "Wrong alignment on MeshComponent_GetMaterialIndex");
static_assert(sizeof(MeshComponent_GetMaterialIndex) == 0x000010, "Wrong size on MeshComponent_GetMaterialIndex");
static_assert(offsetof(MeshComponent_GetMaterialIndex, MaterialSlotName) == 0x000000, "Member 'MeshComponent_GetMaterialIndex::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(MeshComponent_GetMaterialIndex, ReturnValue) == 0x000008, "Member 'MeshComponent_GetMaterialIndex::ReturnValue' has a wrong offset!");

// Function Engine.MeshComponent.GetMaterials
// 0x0010 (0x0010 - 0x0000)
struct MeshComponent_GetMaterials final
{
public:
	TArray<class UMaterialInterface*>             ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshComponent_GetMaterials) == 0x000008, "Wrong alignment on MeshComponent_GetMaterials");
static_assert(sizeof(MeshComponent_GetMaterials) == 0x000010, "Wrong size on MeshComponent_GetMaterials");
static_assert(offsetof(MeshComponent_GetMaterials, ReturnValue) == 0x000000, "Member 'MeshComponent_GetMaterials::ReturnValue' has a wrong offset!");

// Function Engine.MeshComponent.GetMaterialSlotNames
// 0x0010 (0x0010 - 0x0000)
struct MeshComponent_GetMaterialSlotNames final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshComponent_GetMaterialSlotNames) == 0x000008, "Wrong alignment on MeshComponent_GetMaterialSlotNames");
static_assert(sizeof(MeshComponent_GetMaterialSlotNames) == 0x000010, "Wrong size on MeshComponent_GetMaterialSlotNames");
static_assert(offsetof(MeshComponent_GetMaterialSlotNames, ReturnValue) == 0x000000, "Member 'MeshComponent_GetMaterialSlotNames::ReturnValue' has a wrong offset!");

// Function Engine.MeshComponent.IsMaterialSlotNameValid
// 0x0010 (0x0010 - 0x0000)
struct MeshComponent_IsMaterialSlotNameValid final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshComponent_IsMaterialSlotNameValid) == 0x000004, "Wrong alignment on MeshComponent_IsMaterialSlotNameValid");
static_assert(sizeof(MeshComponent_IsMaterialSlotNameValid) == 0x000010, "Wrong size on MeshComponent_IsMaterialSlotNameValid");
static_assert(offsetof(MeshComponent_IsMaterialSlotNameValid, MaterialSlotName) == 0x000000, "Member 'MeshComponent_IsMaterialSlotNameValid::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(MeshComponent_IsMaterialSlotNameValid, ReturnValue) == 0x000008, "Member 'MeshComponent_IsMaterialSlotNameValid::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.ClearSkinWeightOverride
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_ClearSkinWeightOverride final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_ClearSkinWeightOverride) == 0x000004, "Wrong alignment on SkinnedMeshComponent_ClearSkinWeightOverride");
static_assert(sizeof(SkinnedMeshComponent_ClearSkinWeightOverride) == 0x000004, "Wrong size on SkinnedMeshComponent_ClearSkinWeightOverride");
static_assert(offsetof(SkinnedMeshComponent_ClearSkinWeightOverride, LODIndex) == 0x000000, "Member 'SkinnedMeshComponent_ClearSkinWeightOverride::LODIndex' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.ClearVertexColorOverride
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_ClearVertexColorOverride final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_ClearVertexColorOverride) == 0x000004, "Wrong alignment on SkinnedMeshComponent_ClearVertexColorOverride");
static_assert(sizeof(SkinnedMeshComponent_ClearVertexColorOverride) == 0x000004, "Wrong size on SkinnedMeshComponent_ClearVertexColorOverride");
static_assert(offsetof(SkinnedMeshComponent_ClearVertexColorOverride, LODIndex) == 0x000000, "Member 'SkinnedMeshComponent_ClearVertexColorOverride::LODIndex' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.HideBoneByName
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_HideBoneByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPhysBodyOp                                   PhysBodyOption;                                    // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_HideBoneByName) == 0x000004, "Wrong alignment on SkinnedMeshComponent_HideBoneByName");
static_assert(sizeof(SkinnedMeshComponent_HideBoneByName) == 0x000010, "Wrong size on SkinnedMeshComponent_HideBoneByName");
static_assert(offsetof(SkinnedMeshComponent_HideBoneByName, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_HideBoneByName::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_HideBoneByName, PhysBodyOption) == 0x000008, "Member 'SkinnedMeshComponent_HideBoneByName::PhysBodyOption' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.IsBoneHiddenByName
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_IsBoneHiddenByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_IsBoneHiddenByName) == 0x000004, "Wrong alignment on SkinnedMeshComponent_IsBoneHiddenByName");
static_assert(sizeof(SkinnedMeshComponent_IsBoneHiddenByName) == 0x000010, "Wrong size on SkinnedMeshComponent_IsBoneHiddenByName");
static_assert(offsetof(SkinnedMeshComponent_IsBoneHiddenByName, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_IsBoneHiddenByName::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_IsBoneHiddenByName, ReturnValue) == 0x000008, "Member 'SkinnedMeshComponent_IsBoneHiddenByName::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetCapsuleIndirectShadowMinVisibility
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility) == 0x000004, "Wrong alignment on SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility");
static_assert(sizeof(SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility) == 0x000004, "Wrong size on SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility");
static_assert(offsetof(SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility, NewValue) == 0x000000, "Member 'SkinnedMeshComponent_SetCapsuleIndirectShadowMinVisibility::NewValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetCastCapsuleDirectShadow
// 0x0001 (0x0001 - 0x0000)
struct SkinnedMeshComponent_SetCastCapsuleDirectShadow final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetCastCapsuleDirectShadow) == 0x000001, "Wrong alignment on SkinnedMeshComponent_SetCastCapsuleDirectShadow");
static_assert(sizeof(SkinnedMeshComponent_SetCastCapsuleDirectShadow) == 0x000001, "Wrong size on SkinnedMeshComponent_SetCastCapsuleDirectShadow");
static_assert(offsetof(SkinnedMeshComponent_SetCastCapsuleDirectShadow, bNewValue) == 0x000000, "Member 'SkinnedMeshComponent_SetCastCapsuleDirectShadow::bNewValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetCastCapsuleIndirectShadow
// 0x0001 (0x0001 - 0x0000)
struct SkinnedMeshComponent_SetCastCapsuleIndirectShadow final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetCastCapsuleIndirectShadow) == 0x000001, "Wrong alignment on SkinnedMeshComponent_SetCastCapsuleIndirectShadow");
static_assert(sizeof(SkinnedMeshComponent_SetCastCapsuleIndirectShadow) == 0x000001, "Wrong size on SkinnedMeshComponent_SetCastCapsuleIndirectShadow");
static_assert(offsetof(SkinnedMeshComponent_SetCastCapsuleIndirectShadow, bNewValue) == 0x000000, "Member 'SkinnedMeshComponent_SetCastCapsuleIndirectShadow::bNewValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetForcedLOD
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_SetForcedLOD final
{
public:
	int32                                         InNewForcedLOD;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetForcedLOD) == 0x000004, "Wrong alignment on SkinnedMeshComponent_SetForcedLOD");
static_assert(sizeof(SkinnedMeshComponent_SetForcedLOD) == 0x000004, "Wrong size on SkinnedMeshComponent_SetForcedLOD");
static_assert(offsetof(SkinnedMeshComponent_SetForcedLOD, InNewForcedLOD) == 0x000000, "Member 'SkinnedMeshComponent_SetForcedLOD::InNewForcedLOD' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetMasterPoseComponent
// 0x0008 (0x0008 - 0x0000)
struct SkinnedMeshComponent_SetMasterPoseComponent final
{
public:
	class USkinnedMeshComponent*                  NewMasterBoneComponent;                            // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetMasterPoseComponent) == 0x000008, "Wrong alignment on SkinnedMeshComponent_SetMasterPoseComponent");
static_assert(sizeof(SkinnedMeshComponent_SetMasterPoseComponent) == 0x000008, "Wrong size on SkinnedMeshComponent_SetMasterPoseComponent");
static_assert(offsetof(SkinnedMeshComponent_SetMasterPoseComponent, NewMasterBoneComponent) == 0x000000, "Member 'SkinnedMeshComponent_SetMasterPoseComponent::NewMasterBoneComponent' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetMinLOD
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_SetMinLOD final
{
public:
	int32                                         InNewMinLOD;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetMinLOD) == 0x000004, "Wrong alignment on SkinnedMeshComponent_SetMinLOD");
static_assert(sizeof(SkinnedMeshComponent_SetMinLOD) == 0x000004, "Wrong size on SkinnedMeshComponent_SetMinLOD");
static_assert(offsetof(SkinnedMeshComponent_SetMinLOD, InNewMinLOD) == 0x000000, "Member 'SkinnedMeshComponent_SetMinLOD::InNewMinLOD' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetPhysicsAsset
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_SetPhysicsAsset final
{
public:
	class UPhysicsAsset*                          NewPhysicsAsset;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceReInit;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_SetPhysicsAsset) == 0x000008, "Wrong alignment on SkinnedMeshComponent_SetPhysicsAsset");
static_assert(sizeof(SkinnedMeshComponent_SetPhysicsAsset) == 0x000010, "Wrong size on SkinnedMeshComponent_SetPhysicsAsset");
static_assert(offsetof(SkinnedMeshComponent_SetPhysicsAsset, NewPhysicsAsset) == 0x000000, "Member 'SkinnedMeshComponent_SetPhysicsAsset::NewPhysicsAsset' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_SetPhysicsAsset, bForceReInit) == 0x000008, "Member 'SkinnedMeshComponent_SetPhysicsAsset::bForceReInit' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetSkeletalMesh
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_SetSkeletalMesh final
{
public:
	class USkeletalMesh*                          NewMesh;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReinitPose;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_SetSkeletalMesh) == 0x000008, "Wrong alignment on SkinnedMeshComponent_SetSkeletalMesh");
static_assert(sizeof(SkinnedMeshComponent_SetSkeletalMesh) == 0x000010, "Wrong size on SkinnedMeshComponent_SetSkeletalMesh");
static_assert(offsetof(SkinnedMeshComponent_SetSkeletalMesh, NewMesh) == 0x000000, "Member 'SkinnedMeshComponent_SetSkeletalMesh::NewMesh' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_SetSkeletalMesh, bReinitPose) == 0x000008, "Member 'SkinnedMeshComponent_SetSkeletalMesh::bReinitPose' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetSkinWeightOverride
// 0x0018 (0x0018 - 0x0000)
struct SkinnedMeshComponent_SetSkinWeightOverride final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSkelMeshSkinWeightInfo>        SkinWeights;                                       // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetSkinWeightOverride) == 0x000008, "Wrong alignment on SkinnedMeshComponent_SetSkinWeightOverride");
static_assert(sizeof(SkinnedMeshComponent_SetSkinWeightOverride) == 0x000018, "Wrong size on SkinnedMeshComponent_SetSkinWeightOverride");
static_assert(offsetof(SkinnedMeshComponent_SetSkinWeightOverride, LODIndex) == 0x000000, "Member 'SkinnedMeshComponent_SetSkinWeightOverride::LODIndex' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_SetSkinWeightOverride, SkinWeights) == 0x000008, "Member 'SkinnedMeshComponent_SetSkinWeightOverride::SkinWeights' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.SetVertexColorOverride_LinearColor
// 0x0018 (0x0018 - 0x0000)
struct SkinnedMeshComponent_SetVertexColorOverride_LinearColor final
{
public:
	int32                                         LODIndex;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FLinearColor>                   VertexColors;                                      // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_SetVertexColorOverride_LinearColor) == 0x000008, "Wrong alignment on SkinnedMeshComponent_SetVertexColorOverride_LinearColor");
static_assert(sizeof(SkinnedMeshComponent_SetVertexColorOverride_LinearColor) == 0x000018, "Wrong size on SkinnedMeshComponent_SetVertexColorOverride_LinearColor");
static_assert(offsetof(SkinnedMeshComponent_SetVertexColorOverride_LinearColor, LODIndex) == 0x000000, "Member 'SkinnedMeshComponent_SetVertexColorOverride_LinearColor::LODIndex' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_SetVertexColorOverride_LinearColor, VertexColors) == 0x000008, "Member 'SkinnedMeshComponent_SetVertexColorOverride_LinearColor::VertexColors' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.TransformFromBoneSpace
// 0x0038 (0x0038 - 0x0000)
struct SkinnedMeshComponent_TransformFromBoneSpace final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosition;                                        // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotation;                                        // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OutPosition;                                       // 0x0020(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x002C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_TransformFromBoneSpace) == 0x000004, "Wrong alignment on SkinnedMeshComponent_TransformFromBoneSpace");
static_assert(sizeof(SkinnedMeshComponent_TransformFromBoneSpace) == 0x000038, "Wrong size on SkinnedMeshComponent_TransformFromBoneSpace");
static_assert(offsetof(SkinnedMeshComponent_TransformFromBoneSpace, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_TransformFromBoneSpace::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformFromBoneSpace, InPosition) == 0x000008, "Member 'SkinnedMeshComponent_TransformFromBoneSpace::InPosition' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformFromBoneSpace, InRotation) == 0x000014, "Member 'SkinnedMeshComponent_TransformFromBoneSpace::InRotation' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformFromBoneSpace, OutPosition) == 0x000020, "Member 'SkinnedMeshComponent_TransformFromBoneSpace::OutPosition' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformFromBoneSpace, OutRotation) == 0x00002C, "Member 'SkinnedMeshComponent_TransformFromBoneSpace::OutRotation' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.UnHideBoneByName
// 0x0008 (0x0008 - 0x0000)
struct SkinnedMeshComponent_UnHideBoneByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_UnHideBoneByName) == 0x000004, "Wrong alignment on SkinnedMeshComponent_UnHideBoneByName");
static_assert(sizeof(SkinnedMeshComponent_UnHideBoneByName) == 0x000008, "Wrong size on SkinnedMeshComponent_UnHideBoneByName");
static_assert(offsetof(SkinnedMeshComponent_UnHideBoneByName, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_UnHideBoneByName::BoneName' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.BoneIsChildOf
// 0x0018 (0x0018 - 0x0000)
struct SkinnedMeshComponent_BoneIsChildOf final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParentBoneName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_BoneIsChildOf) == 0x000004, "Wrong alignment on SkinnedMeshComponent_BoneIsChildOf");
static_assert(sizeof(SkinnedMeshComponent_BoneIsChildOf) == 0x000018, "Wrong size on SkinnedMeshComponent_BoneIsChildOf");
static_assert(offsetof(SkinnedMeshComponent_BoneIsChildOf, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_BoneIsChildOf::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_BoneIsChildOf, ParentBoneName) == 0x000008, "Member 'SkinnedMeshComponent_BoneIsChildOf::ParentBoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_BoneIsChildOf, ReturnValue) == 0x000010, "Member 'SkinnedMeshComponent_BoneIsChildOf::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.FindClosestBone_K2
// 0x0028 (0x0028 - 0x0000)
struct SkinnedMeshComponent_FindClosestBone_K2 final
{
public:
	struct FVector                                TestLocation;                                      // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoneLocation;                                      // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         IgnoreScale;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRequirePhysicsAsset;                              // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_FindClosestBone_K2) == 0x000004, "Wrong alignment on SkinnedMeshComponent_FindClosestBone_K2");
static_assert(sizeof(SkinnedMeshComponent_FindClosestBone_K2) == 0x000028, "Wrong size on SkinnedMeshComponent_FindClosestBone_K2");
static_assert(offsetof(SkinnedMeshComponent_FindClosestBone_K2, TestLocation) == 0x000000, "Member 'SkinnedMeshComponent_FindClosestBone_K2::TestLocation' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_FindClosestBone_K2, BoneLocation) == 0x00000C, "Member 'SkinnedMeshComponent_FindClosestBone_K2::BoneLocation' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_FindClosestBone_K2, IgnoreScale) == 0x000018, "Member 'SkinnedMeshComponent_FindClosestBone_K2::IgnoreScale' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_FindClosestBone_K2, bRequirePhysicsAsset) == 0x00001C, "Member 'SkinnedMeshComponent_FindClosestBone_K2::bRequirePhysicsAsset' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_FindClosestBone_K2, ReturnValue) == 0x000020, "Member 'SkinnedMeshComponent_FindClosestBone_K2::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.GetBoneIndex
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_GetBoneIndex final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkinnedMeshComponent_GetBoneIndex) == 0x000004, "Wrong alignment on SkinnedMeshComponent_GetBoneIndex");
static_assert(sizeof(SkinnedMeshComponent_GetBoneIndex) == 0x000010, "Wrong size on SkinnedMeshComponent_GetBoneIndex");
static_assert(offsetof(SkinnedMeshComponent_GetBoneIndex, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_GetBoneIndex::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_GetBoneIndex, ReturnValue) == 0x000008, "Member 'SkinnedMeshComponent_GetBoneIndex::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.GetBoneName
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_GetBoneName final
{
public:
	int32                                         BoneIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_GetBoneName) == 0x000004, "Wrong alignment on SkinnedMeshComponent_GetBoneName");
static_assert(sizeof(SkinnedMeshComponent_GetBoneName) == 0x000010, "Wrong size on SkinnedMeshComponent_GetBoneName");
static_assert(offsetof(SkinnedMeshComponent_GetBoneName, BoneIndex) == 0x000000, "Member 'SkinnedMeshComponent_GetBoneName::BoneIndex' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_GetBoneName, ReturnValue) == 0x000008, "Member 'SkinnedMeshComponent_GetBoneName::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.GetNumBones
// 0x0004 (0x0004 - 0x0000)
struct SkinnedMeshComponent_GetNumBones final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_GetNumBones) == 0x000004, "Wrong alignment on SkinnedMeshComponent_GetNumBones");
static_assert(sizeof(SkinnedMeshComponent_GetNumBones) == 0x000004, "Wrong size on SkinnedMeshComponent_GetNumBones");
static_assert(offsetof(SkinnedMeshComponent_GetNumBones, ReturnValue) == 0x000000, "Member 'SkinnedMeshComponent_GetNumBones::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.GetParentBone
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_GetParentBone final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_GetParentBone) == 0x000004, "Wrong alignment on SkinnedMeshComponent_GetParentBone");
static_assert(sizeof(SkinnedMeshComponent_GetParentBone) == 0x000010, "Wrong size on SkinnedMeshComponent_GetParentBone");
static_assert(offsetof(SkinnedMeshComponent_GetParentBone, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_GetParentBone::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_GetParentBone, ReturnValue) == 0x000008, "Member 'SkinnedMeshComponent_GetParentBone::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.GetSocketBoneName
// 0x0010 (0x0010 - 0x0000)
struct SkinnedMeshComponent_GetSocketBoneName final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_GetSocketBoneName) == 0x000004, "Wrong alignment on SkinnedMeshComponent_GetSocketBoneName");
static_assert(sizeof(SkinnedMeshComponent_GetSocketBoneName) == 0x000010, "Wrong size on SkinnedMeshComponent_GetSocketBoneName");
static_assert(offsetof(SkinnedMeshComponent_GetSocketBoneName, InSocketName) == 0x000000, "Member 'SkinnedMeshComponent_GetSocketBoneName::InSocketName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_GetSocketBoneName, ReturnValue) == 0x000008, "Member 'SkinnedMeshComponent_GetSocketBoneName::ReturnValue' has a wrong offset!");

// Function Engine.SkinnedMeshComponent.TransformToBoneSpace
// 0x0038 (0x0038 - 0x0000)
struct SkinnedMeshComponent_TransformToBoneSpace final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InPosition;                                        // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotation;                                        // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                OutPosition;                                       // 0x0020(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRotation;                                       // 0x002C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkinnedMeshComponent_TransformToBoneSpace) == 0x000004, "Wrong alignment on SkinnedMeshComponent_TransformToBoneSpace");
static_assert(sizeof(SkinnedMeshComponent_TransformToBoneSpace) == 0x000038, "Wrong size on SkinnedMeshComponent_TransformToBoneSpace");
static_assert(offsetof(SkinnedMeshComponent_TransformToBoneSpace, BoneName) == 0x000000, "Member 'SkinnedMeshComponent_TransformToBoneSpace::BoneName' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformToBoneSpace, InPosition) == 0x000008, "Member 'SkinnedMeshComponent_TransformToBoneSpace::InPosition' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformToBoneSpace, InRotation) == 0x000014, "Member 'SkinnedMeshComponent_TransformToBoneSpace::InRotation' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformToBoneSpace, OutPosition) == 0x000020, "Member 'SkinnedMeshComponent_TransformToBoneSpace::OutPosition' has a wrong offset!");
static_assert(offsetof(SkinnedMeshComponent_TransformToBoneSpace, OutRotation) == 0x00002C, "Member 'SkinnedMeshComponent_TransformToBoneSpace::OutRotation' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.AccumulateAllBodiesBelowPhysicsBlendWeight
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight final
{
public:
	class FName                                   InBoneName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AddPhysicsBlendWeight;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight) == 0x000004, "Wrong alignment on SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight");
static_assert(sizeof(SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight) == 0x000010, "Wrong size on SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight");
static_assert(offsetof(SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight, InBoneName) == 0x000000, "Member 'SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight::InBoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight, AddPhysicsBlendWeight) == 0x000008, "Member 'SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight::AddPhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight, bSkipCustomPhysicsType) == 0x00000C, "Member 'SkeletalMeshComponent_AccumulateAllBodiesBelowPhysicsBlendWeight::bSkipCustomPhysicsType' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.AddForceToAllBodiesBelow
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMeshComponent_AddForceToAllBodiesBelow final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAccelChange;                                      // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_AddForceToAllBodiesBelow) == 0x000004, "Wrong alignment on SkeletalMeshComponent_AddForceToAllBodiesBelow");
static_assert(sizeof(SkeletalMeshComponent_AddForceToAllBodiesBelow) == 0x000020, "Wrong size on SkeletalMeshComponent_AddForceToAllBodiesBelow");
static_assert(offsetof(SkeletalMeshComponent_AddForceToAllBodiesBelow, Force) == 0x000000, "Member 'SkeletalMeshComponent_AddForceToAllBodiesBelow::Force' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddForceToAllBodiesBelow, BoneName) == 0x000010, "Member 'SkeletalMeshComponent_AddForceToAllBodiesBelow::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddForceToAllBodiesBelow, bAccelChange) == 0x000018, "Member 'SkeletalMeshComponent_AddForceToAllBodiesBelow::bAccelChange' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddForceToAllBodiesBelow, bIncludeSelf) == 0x000019, "Member 'SkeletalMeshComponent_AddForceToAllBodiesBelow::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.AddImpulseToAllBodiesBelow
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMeshComponent_AddImpulseToAllBodiesBelow final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelChange;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow) == 0x000004, "Wrong alignment on SkeletalMeshComponent_AddImpulseToAllBodiesBelow");
static_assert(sizeof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow) == 0x000020, "Wrong size on SkeletalMeshComponent_AddImpulseToAllBodiesBelow");
static_assert(offsetof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow, Impulse) == 0x000000, "Member 'SkeletalMeshComponent_AddImpulseToAllBodiesBelow::Impulse' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow, BoneName) == 0x000010, "Member 'SkeletalMeshComponent_AddImpulseToAllBodiesBelow::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow, bVelChange) == 0x000018, "Member 'SkeletalMeshComponent_AddImpulseToAllBodiesBelow::bVelChange' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AddImpulseToAllBodiesBelow, bIncludeSelf) == 0x000019, "Member 'SkeletalMeshComponent_AddImpulseToAllBodiesBelow::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.AllowAnimCurveEvaluation
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_AllowAnimCurveEvaluation final
{
public:
	class FName                                   NameOfCurve;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllow;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_AllowAnimCurveEvaluation) == 0x000004, "Wrong alignment on SkeletalMeshComponent_AllowAnimCurveEvaluation");
static_assert(sizeof(SkeletalMeshComponent_AllowAnimCurveEvaluation) == 0x000010, "Wrong size on SkeletalMeshComponent_AllowAnimCurveEvaluation");
static_assert(offsetof(SkeletalMeshComponent_AllowAnimCurveEvaluation, NameOfCurve) == 0x000000, "Member 'SkeletalMeshComponent_AllowAnimCurveEvaluation::NameOfCurve' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_AllowAnimCurveEvaluation, bAllow) == 0x000008, "Member 'SkeletalMeshComponent_AllowAnimCurveEvaluation::bAllow' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.BreakConstraint
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMeshComponent_BreakConstraint final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_BreakConstraint) == 0x000004, "Wrong alignment on SkeletalMeshComponent_BreakConstraint");
static_assert(sizeof(SkeletalMeshComponent_BreakConstraint) == 0x000020, "Wrong size on SkeletalMeshComponent_BreakConstraint");
static_assert(offsetof(SkeletalMeshComponent_BreakConstraint, Impulse) == 0x000000, "Member 'SkeletalMeshComponent_BreakConstraint::Impulse' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_BreakConstraint, HitLocation) == 0x00000C, "Member 'SkeletalMeshComponent_BreakConstraint::HitLocation' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_BreakConstraint, InBoneName) == 0x000018, "Member 'SkeletalMeshComponent_BreakConstraint::InBoneName' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.FindConstraintBoneName
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_FindConstraintBoneName final
{
public:
	int32                                         ConstraintIndex;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_FindConstraintBoneName) == 0x000004, "Wrong alignment on SkeletalMeshComponent_FindConstraintBoneName");
static_assert(sizeof(SkeletalMeshComponent_FindConstraintBoneName) == 0x000010, "Wrong size on SkeletalMeshComponent_FindConstraintBoneName");
static_assert(offsetof(SkeletalMeshComponent_FindConstraintBoneName, ConstraintIndex) == 0x000000, "Member 'SkeletalMeshComponent_FindConstraintBoneName::ConstraintIndex' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_FindConstraintBoneName, ReturnValue) == 0x000008, "Member 'SkeletalMeshComponent_FindConstraintBoneName::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetClothMaxDistanceScale
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetClothMaxDistanceScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetClothMaxDistanceScale) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetClothMaxDistanceScale");
static_assert(sizeof(SkeletalMeshComponent_GetClothMaxDistanceScale) == 0x000004, "Wrong size on SkeletalMeshComponent_GetClothMaxDistanceScale");
static_assert(offsetof(SkeletalMeshComponent_GetClothMaxDistanceScale, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetClothMaxDistanceScale::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetClothSimulateScale
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetClothSimulateScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetClothSimulateScale) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetClothSimulateScale");
static_assert(sizeof(SkeletalMeshComponent_GetClothSimulateScale) == 0x000004, "Wrong size on SkeletalMeshComponent_GetClothSimulateScale");
static_assert(offsetof(SkeletalMeshComponent_GetClothSimulateScale, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetClothSimulateScale::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetCurrentJointAngles
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_GetCurrentJointAngles final
{
public:
	class FName                                   InBoneName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing1Angle;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistAngle;                                        // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing2Angle;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_GetCurrentJointAngles) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetCurrentJointAngles");
static_assert(sizeof(SkeletalMeshComponent_GetCurrentJointAngles) == 0x000018, "Wrong size on SkeletalMeshComponent_GetCurrentJointAngles");
static_assert(offsetof(SkeletalMeshComponent_GetCurrentJointAngles, InBoneName) == 0x000000, "Member 'SkeletalMeshComponent_GetCurrentJointAngles::InBoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetCurrentJointAngles, Swing1Angle) == 0x000008, "Member 'SkeletalMeshComponent_GetCurrentJointAngles::Swing1Angle' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetCurrentJointAngles, TwistAngle) == 0x00000C, "Member 'SkeletalMeshComponent_GetCurrentJointAngles::TwistAngle' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetCurrentJointAngles, Swing2Angle) == 0x000010, "Member 'SkeletalMeshComponent_GetCurrentJointAngles::Swing2Angle' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.IsBodyGravityEnabled
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_IsBodyGravityEnabled final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_IsBodyGravityEnabled) == 0x000004, "Wrong alignment on SkeletalMeshComponent_IsBodyGravityEnabled");
static_assert(sizeof(SkeletalMeshComponent_IsBodyGravityEnabled) == 0x000010, "Wrong size on SkeletalMeshComponent_IsBodyGravityEnabled");
static_assert(offsetof(SkeletalMeshComponent_IsBodyGravityEnabled, BoneName) == 0x000000, "Member 'SkeletalMeshComponent_IsBodyGravityEnabled::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_IsBodyGravityEnabled, ReturnValue) == 0x000008, "Member 'SkeletalMeshComponent_IsBodyGravityEnabled::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.IsClothingSimulationSuspended
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_IsClothingSimulationSuspended final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_IsClothingSimulationSuspended) == 0x000001, "Wrong alignment on SkeletalMeshComponent_IsClothingSimulationSuspended");
static_assert(sizeof(SkeletalMeshComponent_IsClothingSimulationSuspended) == 0x000001, "Wrong size on SkeletalMeshComponent_IsClothingSimulationSuspended");
static_assert(offsetof(SkeletalMeshComponent_IsClothingSimulationSuspended, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_IsClothingSimulationSuspended::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.OverrideAnimationData
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_OverrideAnimationData final
{
public:
	class UAnimationAsset*                        InAnimToPlay;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsPlaying;                                        // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Position;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayRate;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_OverrideAnimationData) == 0x000008, "Wrong alignment on SkeletalMeshComponent_OverrideAnimationData");
static_assert(sizeof(SkeletalMeshComponent_OverrideAnimationData) == 0x000018, "Wrong size on SkeletalMeshComponent_OverrideAnimationData");
static_assert(offsetof(SkeletalMeshComponent_OverrideAnimationData, InAnimToPlay) == 0x000000, "Member 'SkeletalMeshComponent_OverrideAnimationData::InAnimToPlay' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_OverrideAnimationData, bIsLooping) == 0x000008, "Member 'SkeletalMeshComponent_OverrideAnimationData::bIsLooping' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_OverrideAnimationData, bIsPlaying) == 0x000009, "Member 'SkeletalMeshComponent_OverrideAnimationData::bIsPlaying' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_OverrideAnimationData, Position) == 0x00000C, "Member 'SkeletalMeshComponent_OverrideAnimationData::Position' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_OverrideAnimationData, PlayRate) == 0x000010, "Member 'SkeletalMeshComponent_OverrideAnimationData::PlayRate' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.Play
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_Play final
{
public:
	bool                                          bLooping;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_Play) == 0x000001, "Wrong alignment on SkeletalMeshComponent_Play");
static_assert(sizeof(SkeletalMeshComponent_Play) == 0x000001, "Wrong size on SkeletalMeshComponent_Play");
static_assert(offsetof(SkeletalMeshComponent_Play, bLooping) == 0x000000, "Member 'SkeletalMeshComponent_Play::bLooping' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.PlayAnimation
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_PlayAnimation final
{
public:
	class UAnimationAsset*                        NewAnimToPlay;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_PlayAnimation) == 0x000008, "Wrong alignment on SkeletalMeshComponent_PlayAnimation");
static_assert(sizeof(SkeletalMeshComponent_PlayAnimation) == 0x000010, "Wrong size on SkeletalMeshComponent_PlayAnimation");
static_assert(offsetof(SkeletalMeshComponent_PlayAnimation, NewAnimToPlay) == 0x000000, "Member 'SkeletalMeshComponent_PlayAnimation::NewAnimToPlay' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_PlayAnimation, bLooping) == 0x000008, "Member 'SkeletalMeshComponent_PlayAnimation::bLooping' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.RecalcSlaveComponents
// 0x0002 (0x0002 - 0x0000)
struct SkeletalMeshComponent_RecalcSlaveComponents final
{
public:
	bool                                          bAllowPhysicsAssetsMerge;                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipRefreshBoneTransforms;                        // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_RecalcSlaveComponents) == 0x000001, "Wrong alignment on SkeletalMeshComponent_RecalcSlaveComponents");
static_assert(sizeof(SkeletalMeshComponent_RecalcSlaveComponents) == 0x000002, "Wrong size on SkeletalMeshComponent_RecalcSlaveComponents");
static_assert(offsetof(SkeletalMeshComponent_RecalcSlaveComponents, bAllowPhysicsAssetsMerge) == 0x000000, "Member 'SkeletalMeshComponent_RecalcSlaveComponents::bAllowPhysicsAssetsMerge' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_RecalcSlaveComponents, bSkipRefreshBoneTransforms) == 0x000001, "Member 'SkeletalMeshComponent_RecalcSlaveComponents::bSkipRefreshBoneTransforms' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowPhysicsBlendWeight
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight final
{
public:
	class FName                                   InBoneName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PhysicsBlendWeight;                                // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight");
static_assert(sizeof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight) == 0x000010, "Wrong size on SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight, InBoneName) == 0x000000, "Member 'SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight::InBoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight, PhysicsBlendWeight) == 0x000008, "Member 'SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight::PhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight, bSkipCustomPhysicsType) == 0x00000C, "Member 'SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight::bSkipCustomPhysicsType' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight, bIncludeSelf) == 0x00000D, "Member 'SkeletalMeshComponent_SetAllBodiesBelowPhysicsBlendWeight::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllBodiesBelowSimulatePhysics
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics final
{
public:
	class FName                                   InBoneName;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNewSimulate;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0009(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics");
static_assert(sizeof(SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics) == 0x000010, "Wrong size on SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics, InBoneName) == 0x000000, "Member 'SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics::InBoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics, bNewSimulate) == 0x000008, "Member 'SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics::bNewSimulate' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics, bIncludeSelf) == 0x000009, "Member 'SkeletalMeshComponent_SetAllBodiesBelowSimulatePhysics::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllBodiesPhysicsBlendWeight
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight final
{
public:
	float                                         PhysicsBlendWeight;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight");
static_assert(sizeof(SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight) == 0x000008, "Wrong size on SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight, PhysicsBlendWeight) == 0x000000, "Member 'SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight::PhysicsBlendWeight' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight, bSkipCustomPhysicsType) == 0x000004, "Member 'SkeletalMeshComponent_SetAllBodiesPhysicsBlendWeight::bSkipCustomPhysicsType' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllBodiesSimulatePhysics
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetAllBodiesSimulatePhysics final
{
public:
	bool                                          bNewSimulate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAllBodiesSimulatePhysics) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetAllBodiesSimulatePhysics");
static_assert(sizeof(SkeletalMeshComponent_SetAllBodiesSimulatePhysics) == 0x000001, "Wrong size on SkeletalMeshComponent_SetAllBodiesSimulatePhysics");
static_assert(offsetof(SkeletalMeshComponent_SetAllBodiesSimulatePhysics, bNewSimulate) == 0x000000, "Member 'SkeletalMeshComponent_SetAllBodiesSimulatePhysics::bNewSimulate' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularDriveParams
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetAllMotorsAngularDriveParams final
{
public:
	float                                         InSpring;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDamping;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceLimit;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetAllMotorsAngularDriveParams");
static_assert(sizeof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams) == 0x000010, "Wrong size on SkeletalMeshComponent_SetAllMotorsAngularDriveParams");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams, InSpring) == 0x000000, "Member 'SkeletalMeshComponent_SetAllMotorsAngularDriveParams::InSpring' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams, InDamping) == 0x000004, "Member 'SkeletalMeshComponent_SetAllMotorsAngularDriveParams::InDamping' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams, InForceLimit) == 0x000008, "Member 'SkeletalMeshComponent_SetAllMotorsAngularDriveParams::InForceLimit' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularDriveParams, bSkipCustomPhysicsType) == 0x00000C, "Member 'SkeletalMeshComponent_SetAllMotorsAngularDriveParams::bSkipCustomPhysicsType' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularPositionDrive
// 0x0003 (0x0003 - 0x0000)
struct SkeletalMeshComponent_SetAllMotorsAngularPositionDrive final
{
public:
	bool                                          bEnableSwingDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwistDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAllMotorsAngularPositionDrive) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetAllMotorsAngularPositionDrive");
static_assert(sizeof(SkeletalMeshComponent_SetAllMotorsAngularPositionDrive) == 0x000003, "Wrong size on SkeletalMeshComponent_SetAllMotorsAngularPositionDrive");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularPositionDrive, bEnableSwingDrive) == 0x000000, "Member 'SkeletalMeshComponent_SetAllMotorsAngularPositionDrive::bEnableSwingDrive' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularPositionDrive, bEnableTwistDrive) == 0x000001, "Member 'SkeletalMeshComponent_SetAllMotorsAngularPositionDrive::bEnableTwistDrive' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularPositionDrive, bSkipCustomPhysicsType) == 0x000002, "Member 'SkeletalMeshComponent_SetAllMotorsAngularPositionDrive::bSkipCustomPhysicsType' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllMotorsAngularVelocityDrive
// 0x0003 (0x0003 - 0x0000)
struct SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive final
{
public:
	bool                                          bEnableSwingDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwistDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipCustomPhysicsType;                            // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive");
static_assert(sizeof(SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive) == 0x000003, "Wrong size on SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive, bEnableSwingDrive) == 0x000000, "Member 'SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive::bEnableSwingDrive' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive, bEnableTwistDrive) == 0x000001, "Member 'SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive::bEnableTwistDrive' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive, bSkipCustomPhysicsType) == 0x000002, "Member 'SkeletalMeshComponent_SetAllMotorsAngularVelocityDrive::bSkipCustomPhysicsType' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllowAnimCurveEvaluation
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetAllowAnimCurveEvaluation final
{
public:
	bool                                          bInAllow;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAllowAnimCurveEvaluation) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetAllowAnimCurveEvaluation");
static_assert(sizeof(SkeletalMeshComponent_SetAllowAnimCurveEvaluation) == 0x000001, "Wrong size on SkeletalMeshComponent_SetAllowAnimCurveEvaluation");
static_assert(offsetof(SkeletalMeshComponent_SetAllowAnimCurveEvaluation, bInAllow) == 0x000000, "Member 'SkeletalMeshComponent_SetAllowAnimCurveEvaluation::bInAllow' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAllowedAnimCurvesEvaluation
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation final
{
public:
	TArray<class FName>                           List;                                              // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bAllow;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation) == 0x000008, "Wrong alignment on SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation");
static_assert(sizeof(SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation) == 0x000018, "Wrong size on SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation");
static_assert(offsetof(SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation, List) == 0x000000, "Member 'SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation::List' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation, bAllow) == 0x000010, "Member 'SkeletalMeshComponent_SetAllowedAnimCurvesEvaluation::bAllow' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAngularLimits
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_SetAngularLimits final
{
public:
	class FName                                   InBoneName;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing1LimitAngle;                                  // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TwistLimitAngle;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Swing2LimitAngle;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetAngularLimits) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetAngularLimits");
static_assert(sizeof(SkeletalMeshComponent_SetAngularLimits) == 0x000018, "Wrong size on SkeletalMeshComponent_SetAngularLimits");
static_assert(offsetof(SkeletalMeshComponent_SetAngularLimits, InBoneName) == 0x000000, "Member 'SkeletalMeshComponent_SetAngularLimits::InBoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAngularLimits, Swing1LimitAngle) == 0x000008, "Member 'SkeletalMeshComponent_SetAngularLimits::Swing1LimitAngle' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAngularLimits, TwistLimitAngle) == 0x00000C, "Member 'SkeletalMeshComponent_SetAngularLimits::TwistLimitAngle' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetAngularLimits, Swing2LimitAngle) == 0x000010, "Member 'SkeletalMeshComponent_SetAngularLimits::Swing2LimitAngle' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAnimation
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_SetAnimation final
{
public:
	class UAnimationAsset*                        NewAnimToPlay;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAnimation) == 0x000008, "Wrong alignment on SkeletalMeshComponent_SetAnimation");
static_assert(sizeof(SkeletalMeshComponent_SetAnimation) == 0x000008, "Wrong size on SkeletalMeshComponent_SetAnimation");
static_assert(offsetof(SkeletalMeshComponent_SetAnimation, NewAnimToPlay) == 0x000000, "Member 'SkeletalMeshComponent_SetAnimation::NewAnimToPlay' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAnimationMode
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetAnimationMode final
{
public:
	EAnimationMode                                InAnimationMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAnimationMode) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetAnimationMode");
static_assert(sizeof(SkeletalMeshComponent_SetAnimationMode) == 0x000001, "Wrong size on SkeletalMeshComponent_SetAnimationMode");
static_assert(offsetof(SkeletalMeshComponent_SetAnimationMode, InAnimationMode) == 0x000000, "Member 'SkeletalMeshComponent_SetAnimationMode::InAnimationMode' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetAnimInstanceClass
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_SetAnimInstanceClass final
{
public:
	class UClass*                                 NewClass;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetAnimInstanceClass) == 0x000008, "Wrong alignment on SkeletalMeshComponent_SetAnimInstanceClass");
static_assert(sizeof(SkeletalMeshComponent_SetAnimInstanceClass) == 0x000008, "Wrong size on SkeletalMeshComponent_SetAnimInstanceClass");
static_assert(offsetof(SkeletalMeshComponent_SetAnimInstanceClass, NewClass) == 0x000000, "Member 'SkeletalMeshComponent_SetAnimInstanceClass::NewClass' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetBodiesBelowSimulatePhysicsByResetBoneList
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList final
{
public:
	bool                                          bNewSimulate;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList");
static_assert(sizeof(SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList) == 0x000001, "Wrong size on SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList");
static_assert(offsetof(SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList, bNewSimulate) == 0x000000, "Member 'SkeletalMeshComponent_SetBodiesBelowSimulatePhysicsByResetBoneList::bNewSimulate' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetBodyNotifyRigidBodyCollision
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision final
{
public:
	bool                                          bNewNotifyRigidBodyCollision;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision");
static_assert(sizeof(SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision) == 0x000010, "Wrong size on SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision");
static_assert(offsetof(SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision, bNewNotifyRigidBodyCollision) == 0x000000, "Member 'SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision::bNewNotifyRigidBodyCollision' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision, BoneName) == 0x000008, "Member 'SkeletalMeshComponent_SetBodyNotifyRigidBodyCollision::BoneName' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetClothMaxDistanceScale
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetClothMaxDistanceScale final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetClothMaxDistanceScale) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetClothMaxDistanceScale");
static_assert(sizeof(SkeletalMeshComponent_SetClothMaxDistanceScale) == 0x000004, "Wrong size on SkeletalMeshComponent_SetClothMaxDistanceScale");
static_assert(offsetof(SkeletalMeshComponent_SetClothMaxDistanceScale, Scale) == 0x000000, "Member 'SkeletalMeshComponent_SetClothMaxDistanceScale::Scale' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetClothSimulateScale
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetClothSimulateScale final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetClothSimulateScale) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetClothSimulateScale");
static_assert(sizeof(SkeletalMeshComponent_SetClothSimulateScale) == 0x000004, "Wrong size on SkeletalMeshComponent_SetClothSimulateScale");
static_assert(offsetof(SkeletalMeshComponent_SetClothSimulateScale, Scale) == 0x000000, "Member 'SkeletalMeshComponent_SetClothSimulateScale::Scale' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetConstraintProfile
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_SetConstraintProfile final
{
public:
	class FName                                   JointName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultIfNotFound;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetConstraintProfile) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetConstraintProfile");
static_assert(sizeof(SkeletalMeshComponent_SetConstraintProfile) == 0x000018, "Wrong size on SkeletalMeshComponent_SetConstraintProfile");
static_assert(offsetof(SkeletalMeshComponent_SetConstraintProfile, JointName) == 0x000000, "Member 'SkeletalMeshComponent_SetConstraintProfile::JointName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetConstraintProfile, ProfileName) == 0x000008, "Member 'SkeletalMeshComponent_SetConstraintProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetConstraintProfile, bDefaultIfNotFound) == 0x000010, "Member 'SkeletalMeshComponent_SetConstraintProfile::bDefaultIfNotFound' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetConstraintProfileForAll
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetConstraintProfileForAll final
{
public:
	class FName                                   ProfileName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDefaultIfNotFound;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetConstraintProfileForAll) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetConstraintProfileForAll");
static_assert(sizeof(SkeletalMeshComponent_SetConstraintProfileForAll) == 0x000010, "Wrong size on SkeletalMeshComponent_SetConstraintProfileForAll");
static_assert(offsetof(SkeletalMeshComponent_SetConstraintProfileForAll, ProfileName) == 0x000000, "Member 'SkeletalMeshComponent_SetConstraintProfileForAll::ProfileName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetConstraintProfileForAll, bDefaultIfNotFound) == 0x000008, "Member 'SkeletalMeshComponent_SetConstraintProfileForAll::bDefaultIfNotFound' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetDisableAnimCurves
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetDisableAnimCurves final
{
public:
	bool                                          bInDisableAnimCurves;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetDisableAnimCurves) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetDisableAnimCurves");
static_assert(sizeof(SkeletalMeshComponent_SetDisableAnimCurves) == 0x000001, "Wrong size on SkeletalMeshComponent_SetDisableAnimCurves");
static_assert(offsetof(SkeletalMeshComponent_SetDisableAnimCurves, bInDisableAnimCurves) == 0x000000, "Member 'SkeletalMeshComponent_SetDisableAnimCurves::bInDisableAnimCurves' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetEnableBodyGravity
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetEnableBodyGravity final
{
public:
	bool                                          bEnableGravity;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetEnableBodyGravity) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetEnableBodyGravity");
static_assert(sizeof(SkeletalMeshComponent_SetEnableBodyGravity) == 0x000010, "Wrong size on SkeletalMeshComponent_SetEnableBodyGravity");
static_assert(offsetof(SkeletalMeshComponent_SetEnableBodyGravity, bEnableGravity) == 0x000000, "Member 'SkeletalMeshComponent_SetEnableBodyGravity::bEnableGravity' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetEnableBodyGravity, BoneName) == 0x000008, "Member 'SkeletalMeshComponent_SetEnableBodyGravity::BoneName' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetEnableGravityOnAllBodiesBelow
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow final
{
public:
	bool                                          bEnableGravity;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow");
static_assert(sizeof(SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow) == 0x000018, "Wrong size on SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow");
static_assert(offsetof(SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow, bEnableGravity) == 0x000000, "Member 'SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow::bEnableGravity' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow, BoneName) == 0x000008, "Member 'SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow, bIncludeSelf) == 0x000010, "Member 'SkeletalMeshComponent_SetEnableGravityOnAllBodiesBelow::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetEnablePhysicsBlending
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetEnablePhysicsBlending final
{
public:
	bool                                          bNewBlendPhysics;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetEnablePhysicsBlending) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetEnablePhysicsBlending");
static_assert(sizeof(SkeletalMeshComponent_SetEnablePhysicsBlending) == 0x000001, "Wrong size on SkeletalMeshComponent_SetEnablePhysicsBlending");
static_assert(offsetof(SkeletalMeshComponent_SetEnablePhysicsBlending, bNewBlendPhysics) == 0x000000, "Member 'SkeletalMeshComponent_SetEnablePhysicsBlending::bNewBlendPhysics' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetMorphTarget
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_SetMorphTarget final
{
public:
	class FName                                   MorphTargetName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveZeroWeight;                                 // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetMorphTarget) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetMorphTarget");
static_assert(sizeof(SkeletalMeshComponent_SetMorphTarget) == 0x000010, "Wrong size on SkeletalMeshComponent_SetMorphTarget");
static_assert(offsetof(SkeletalMeshComponent_SetMorphTarget, MorphTargetName) == 0x000000, "Member 'SkeletalMeshComponent_SetMorphTarget::MorphTargetName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetMorphTarget, Value) == 0x000008, "Member 'SkeletalMeshComponent_SetMorphTarget::Value' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetMorphTarget, bRemoveZeroWeight) == 0x00000C, "Member 'SkeletalMeshComponent_SetMorphTarget::bRemoveZeroWeight' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetNotifyRigidBodyCollisionBelow
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow final
{
public:
	bool                                          bNewNotifyRigidBodyCollision;                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow");
static_assert(sizeof(SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow) == 0x000018, "Wrong size on SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow");
static_assert(offsetof(SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow, bNewNotifyRigidBodyCollision) == 0x000000, "Member 'SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow::bNewNotifyRigidBodyCollision' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow, BoneName) == 0x000008, "Member 'SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow, bIncludeSelf) == 0x000010, "Member 'SkeletalMeshComponent_SetNotifyRigidBodyCollisionBelow::bIncludeSelf' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetPhysicsBlendWeight
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetPhysicsBlendWeight final
{
public:
	float                                         PhysicsBlendWeight;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetPhysicsBlendWeight) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetPhysicsBlendWeight");
static_assert(sizeof(SkeletalMeshComponent_SetPhysicsBlendWeight) == 0x000004, "Wrong size on SkeletalMeshComponent_SetPhysicsBlendWeight");
static_assert(offsetof(SkeletalMeshComponent_SetPhysicsBlendWeight, PhysicsBlendWeight) == 0x000000, "Member 'SkeletalMeshComponent_SetPhysicsBlendWeight::PhysicsBlendWeight' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetPlayRate final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetPlayRate) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetPlayRate");
static_assert(sizeof(SkeletalMeshComponent_SetPlayRate) == 0x000004, "Wrong size on SkeletalMeshComponent_SetPlayRate");
static_assert(offsetof(SkeletalMeshComponent_SetPlayRate, Rate) == 0x000000, "Member 'SkeletalMeshComponent_SetPlayRate::Rate' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetPosition
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_SetPosition final
{
public:
	float                                         InPos;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireNotifies;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_SetPosition) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetPosition");
static_assert(sizeof(SkeletalMeshComponent_SetPosition) == 0x000008, "Wrong size on SkeletalMeshComponent_SetPosition");
static_assert(offsetof(SkeletalMeshComponent_SetPosition, InPos) == 0x000000, "Member 'SkeletalMeshComponent_SetPosition::InPos' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_SetPosition, bFireNotifies) == 0x000004, "Member 'SkeletalMeshComponent_SetPosition::bFireNotifies' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetTeleportDistanceThreshold
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetTeleportDistanceThreshold final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetTeleportDistanceThreshold) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetTeleportDistanceThreshold");
static_assert(sizeof(SkeletalMeshComponent_SetTeleportDistanceThreshold) == 0x000004, "Wrong size on SkeletalMeshComponent_SetTeleportDistanceThreshold");
static_assert(offsetof(SkeletalMeshComponent_SetTeleportDistanceThreshold, Threshold) == 0x000000, "Member 'SkeletalMeshComponent_SetTeleportDistanceThreshold::Threshold' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetTeleportRotationThreshold
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_SetTeleportRotationThreshold final
{
public:
	float                                         Threshold;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetTeleportRotationThreshold) == 0x000004, "Wrong alignment on SkeletalMeshComponent_SetTeleportRotationThreshold");
static_assert(sizeof(SkeletalMeshComponent_SetTeleportRotationThreshold) == 0x000004, "Wrong size on SkeletalMeshComponent_SetTeleportRotationThreshold");
static_assert(offsetof(SkeletalMeshComponent_SetTeleportRotationThreshold, Threshold) == 0x000000, "Member 'SkeletalMeshComponent_SetTeleportRotationThreshold::Threshold' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SetUpdateAnimationInEditor
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_SetUpdateAnimationInEditor final
{
public:
	bool                                          NewUpdateState;                                    // 0x0000(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SetUpdateAnimationInEditor) == 0x000001, "Wrong alignment on SkeletalMeshComponent_SetUpdateAnimationInEditor");
static_assert(sizeof(SkeletalMeshComponent_SetUpdateAnimationInEditor) == 0x000001, "Wrong size on SkeletalMeshComponent_SetUpdateAnimationInEditor");
static_assert(offsetof(SkeletalMeshComponent_SetUpdateAnimationInEditor, NewUpdateState) == 0x000000, "Member 'SkeletalMeshComponent_SetUpdateAnimationInEditor::NewUpdateState' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.SnapshotPose
// 0x0038 (0x0038 - 0x0000)
struct SkeletalMeshComponent_SnapshotPose final
{
public:
	struct FPoseSnapshot                          Snapshot;                                          // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_SnapshotPose) == 0x000008, "Wrong alignment on SkeletalMeshComponent_SnapshotPose");
static_assert(sizeof(SkeletalMeshComponent_SnapshotPose) == 0x000038, "Wrong size on SkeletalMeshComponent_SnapshotPose");
static_assert(offsetof(SkeletalMeshComponent_SnapshotPose, Snapshot) == 0x000000, "Member 'SkeletalMeshComponent_SnapshotPose::Snapshot' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.UnbindClothFromMasterPoseComponent
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_UnbindClothFromMasterPoseComponent final
{
public:
	bool                                          bRestoreSimulationSpace;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_UnbindClothFromMasterPoseComponent) == 0x000001, "Wrong alignment on SkeletalMeshComponent_UnbindClothFromMasterPoseComponent");
static_assert(sizeof(SkeletalMeshComponent_UnbindClothFromMasterPoseComponent) == 0x000001, "Wrong size on SkeletalMeshComponent_UnbindClothFromMasterPoseComponent");
static_assert(offsetof(SkeletalMeshComponent_UnbindClothFromMasterPoseComponent, bRestoreSimulationSpace) == 0x000000, "Member 'SkeletalMeshComponent_UnbindClothFromMasterPoseComponent::bRestoreSimulationSpace' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetAllowedAnimCurveEvaluate
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_GetAllowedAnimCurveEvaluate final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetAllowedAnimCurveEvaluate) == 0x000001, "Wrong alignment on SkeletalMeshComponent_GetAllowedAnimCurveEvaluate");
static_assert(sizeof(SkeletalMeshComponent_GetAllowedAnimCurveEvaluate) == 0x000001, "Wrong size on SkeletalMeshComponent_GetAllowedAnimCurveEvaluate");
static_assert(offsetof(SkeletalMeshComponent_GetAllowedAnimCurveEvaluate, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetAllowedAnimCurveEvaluate::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetAnimationMode
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_GetAnimationMode final
{
public:
	EAnimationMode                                ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetAnimationMode) == 0x000001, "Wrong alignment on SkeletalMeshComponent_GetAnimationMode");
static_assert(sizeof(SkeletalMeshComponent_GetAnimationMode) == 0x000001, "Wrong size on SkeletalMeshComponent_GetAnimationMode");
static_assert(offsetof(SkeletalMeshComponent_GetAnimationMode, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetAnimationMode::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetAnimInstance
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_GetAnimInstance final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetAnimInstance) == 0x000008, "Wrong alignment on SkeletalMeshComponent_GetAnimInstance");
static_assert(sizeof(SkeletalMeshComponent_GetAnimInstance) == 0x000008, "Wrong size on SkeletalMeshComponent_GetAnimInstance");
static_assert(offsetof(SkeletalMeshComponent_GetAnimInstance, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetAnimInstance::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetBoneMass
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_GetBoneMass final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScaleMass;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetBoneMass) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetBoneMass");
static_assert(sizeof(SkeletalMeshComponent_GetBoneMass) == 0x000010, "Wrong size on SkeletalMeshComponent_GetBoneMass");
static_assert(offsetof(SkeletalMeshComponent_GetBoneMass, BoneName) == 0x000000, "Member 'SkeletalMeshComponent_GetBoneMass::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetBoneMass, bScaleMass) == 0x000008, "Member 'SkeletalMeshComponent_GetBoneMass::bScaleMass' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetBoneMass, ReturnValue) == 0x00000C, "Member 'SkeletalMeshComponent_GetBoneMass::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetDisableAnimCurves
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_GetDisableAnimCurves final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetDisableAnimCurves) == 0x000001, "Wrong alignment on SkeletalMeshComponent_GetDisableAnimCurves");
static_assert(sizeof(SkeletalMeshComponent_GetDisableAnimCurves) == 0x000001, "Wrong size on SkeletalMeshComponent_GetDisableAnimCurves");
static_assert(offsetof(SkeletalMeshComponent_GetDisableAnimCurves, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetDisableAnimCurves::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetMorphTarget
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMeshComponent_GetMorphTarget final
{
public:
	class FName                                   MorphTargetName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_GetMorphTarget) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetMorphTarget");
static_assert(sizeof(SkeletalMeshComponent_GetMorphTarget) == 0x000010, "Wrong size on SkeletalMeshComponent_GetMorphTarget");
static_assert(offsetof(SkeletalMeshComponent_GetMorphTarget, MorphTargetName) == 0x000000, "Member 'SkeletalMeshComponent_GetMorphTarget::MorphTargetName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_GetMorphTarget, ReturnValue) == 0x000008, "Member 'SkeletalMeshComponent_GetMorphTarget::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetPlayRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetPlayRate) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetPlayRate");
static_assert(sizeof(SkeletalMeshComponent_GetPlayRate) == 0x000004, "Wrong size on SkeletalMeshComponent_GetPlayRate");
static_assert(offsetof(SkeletalMeshComponent_GetPlayRate, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetPlayRate::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetPosition
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetPosition final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetPosition) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetPosition");
static_assert(sizeof(SkeletalMeshComponent_GetPosition) == 0x000004, "Wrong size on SkeletalMeshComponent_GetPosition");
static_assert(offsetof(SkeletalMeshComponent_GetPosition, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetPosition::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetPostProcessInstance
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMeshComponent_GetPostProcessInstance final
{
public:
	class UAnimInstance*                          ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetPostProcessInstance) == 0x000008, "Wrong alignment on SkeletalMeshComponent_GetPostProcessInstance");
static_assert(sizeof(SkeletalMeshComponent_GetPostProcessInstance) == 0x000008, "Wrong size on SkeletalMeshComponent_GetPostProcessInstance");
static_assert(offsetof(SkeletalMeshComponent_GetPostProcessInstance, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetPostProcessInstance::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetSkeletalCenterOfMass
// 0x000C (0x000C - 0x0000)
struct SkeletalMeshComponent_GetSkeletalCenterOfMass final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetSkeletalCenterOfMass) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetSkeletalCenterOfMass");
static_assert(sizeof(SkeletalMeshComponent_GetSkeletalCenterOfMass) == 0x00000C, "Wrong size on SkeletalMeshComponent_GetSkeletalCenterOfMass");
static_assert(offsetof(SkeletalMeshComponent_GetSkeletalCenterOfMass, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetSkeletalCenterOfMass::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetTeleportDistanceThreshold
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetTeleportDistanceThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetTeleportDistanceThreshold) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetTeleportDistanceThreshold");
static_assert(sizeof(SkeletalMeshComponent_GetTeleportDistanceThreshold) == 0x000004, "Wrong size on SkeletalMeshComponent_GetTeleportDistanceThreshold");
static_assert(offsetof(SkeletalMeshComponent_GetTeleportDistanceThreshold, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetTeleportDistanceThreshold::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.GetTeleportRotationThreshold
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMeshComponent_GetTeleportRotationThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_GetTeleportRotationThreshold) == 0x000004, "Wrong alignment on SkeletalMeshComponent_GetTeleportRotationThreshold");
static_assert(sizeof(SkeletalMeshComponent_GetTeleportRotationThreshold) == 0x000004, "Wrong size on SkeletalMeshComponent_GetTeleportRotationThreshold");
static_assert(offsetof(SkeletalMeshComponent_GetTeleportRotationThreshold, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_GetTeleportRotationThreshold::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct SkeletalMeshComponent_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshComponent_IsPlaying) == 0x000001, "Wrong alignment on SkeletalMeshComponent_IsPlaying");
static_assert(sizeof(SkeletalMeshComponent_IsPlaying) == 0x000001, "Wrong size on SkeletalMeshComponent_IsPlaying");
static_assert(offsetof(SkeletalMeshComponent_IsPlaying, ReturnValue) == 0x000000, "Member 'SkeletalMeshComponent_IsPlaying::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshComponent.K2_GetClosestPointOnPhysicsAsset
// 0x0038 (0x0038 - 0x0000)
struct SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset final
{
public:
	struct FVector                                WorldPosition;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ClosestWorldPosition;                              // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0018(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   BoneName;                                          // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset) == 0x000004, "Wrong alignment on SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset");
static_assert(sizeof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset) == 0x000038, "Wrong size on SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, WorldPosition) == 0x000000, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::WorldPosition' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, ClosestWorldPosition) == 0x00000C, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::ClosestWorldPosition' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, Normal) == 0x000018, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::Normal' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, BoneName) == 0x000028, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::BoneName' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, Distance) == 0x000030, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::Distance' has a wrong offset!");
static_assert(offsetof(SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset, ReturnValue) == 0x000034, "Member 'SkeletalMeshComponent_K2_GetClosestPointOnPhysicsAsset::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.BlueprintUpdateAnimation
// 0x0004 (0x0004 - 0x0000)
struct AnimInstance_BlueprintUpdateAnimation final
{
public:
	float                                         DeltaTimeX;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_BlueprintUpdateAnimation) == 0x000004, "Wrong alignment on AnimInstance_BlueprintUpdateAnimation");
static_assert(sizeof(AnimInstance_BlueprintUpdateAnimation) == 0x000004, "Wrong size on AnimInstance_BlueprintUpdateAnimation");
static_assert(offsetof(AnimInstance_BlueprintUpdateAnimation, DeltaTimeX) == 0x000000, "Member 'AnimInstance_BlueprintUpdateAnimation::DeltaTimeX' has a wrong offset!");

// Function Engine.AnimInstance.CalculateDirection
// 0x001C (0x001C - 0x0000)
struct AnimInstance_CalculateDirection final
{
public:
	struct FVector                                Velocity;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               BaseRotation;                                      // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_CalculateDirection) == 0x000004, "Wrong alignment on AnimInstance_CalculateDirection");
static_assert(sizeof(AnimInstance_CalculateDirection) == 0x00001C, "Wrong size on AnimInstance_CalculateDirection");
static_assert(offsetof(AnimInstance_CalculateDirection, Velocity) == 0x000000, "Member 'AnimInstance_CalculateDirection::Velocity' has a wrong offset!");
static_assert(offsetof(AnimInstance_CalculateDirection, BaseRotation) == 0x00000C, "Member 'AnimInstance_CalculateDirection::BaseRotation' has a wrong offset!");
static_assert(offsetof(AnimInstance_CalculateDirection, ReturnValue) == 0x000018, "Member 'AnimInstance_CalculateDirection::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetCurrentStateName
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_GetCurrentStateName final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetCurrentStateName) == 0x000004, "Wrong alignment on AnimInstance_GetCurrentStateName");
static_assert(sizeof(AnimInstance_GetCurrentStateName) == 0x000010, "Wrong size on AnimInstance_GetCurrentStateName");
static_assert(offsetof(AnimInstance_GetCurrentStateName, MachineIndex) == 0x000000, "Member 'AnimInstance_GetCurrentStateName::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetCurrentStateName, ReturnValue) == 0x000008, "Member 'AnimInstance_GetCurrentStateName::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetCurveValue
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_GetCurveValue final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_GetCurveValue) == 0x000004, "Wrong alignment on AnimInstance_GetCurveValue");
static_assert(sizeof(AnimInstance_GetCurveValue) == 0x000010, "Wrong size on AnimInstance_GetCurveValue");
static_assert(offsetof(AnimInstance_GetCurveValue, CurveName) == 0x000000, "Member 'AnimInstance_GetCurveValue::CurveName' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetCurveValue, ReturnValue) == 0x000008, "Member 'AnimInstance_GetCurveValue::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceAssetPlayerLength
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceAssetPlayerLength final
{
public:
	int32                                         AssetPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceAssetPlayerLength) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceAssetPlayerLength");
static_assert(sizeof(AnimInstance_GetInstanceAssetPlayerLength) == 0x000008, "Wrong size on AnimInstance_GetInstanceAssetPlayerLength");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerLength, AssetPlayerIndex) == 0x000000, "Member 'AnimInstance_GetInstanceAssetPlayerLength::AssetPlayerIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerLength, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceAssetPlayerLength::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceAssetPlayerTime
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceAssetPlayerTime final
{
public:
	int32                                         AssetPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceAssetPlayerTime) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceAssetPlayerTime");
static_assert(sizeof(AnimInstance_GetInstanceAssetPlayerTime) == 0x000008, "Wrong size on AnimInstance_GetInstanceAssetPlayerTime");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTime, AssetPlayerIndex) == 0x000000, "Member 'AnimInstance_GetInstanceAssetPlayerTime::AssetPlayerIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTime, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceAssetPlayerTime::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFraction
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceAssetPlayerTimeFraction final
{
public:
	int32                                         AssetPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceAssetPlayerTimeFraction) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceAssetPlayerTimeFraction");
static_assert(sizeof(AnimInstance_GetInstanceAssetPlayerTimeFraction) == 0x000008, "Wrong size on AnimInstance_GetInstanceAssetPlayerTimeFraction");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFraction, AssetPlayerIndex) == 0x000000, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFraction::AssetPlayerIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFraction, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFraction::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEnd
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceAssetPlayerTimeFromEnd final
{
public:
	int32                                         AssetPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceAssetPlayerTimeFromEnd) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceAssetPlayerTimeFromEnd");
static_assert(sizeof(AnimInstance_GetInstanceAssetPlayerTimeFromEnd) == 0x000008, "Wrong size on AnimInstance_GetInstanceAssetPlayerTimeFromEnd");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFromEnd, AssetPlayerIndex) == 0x000000, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFromEnd::AssetPlayerIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFromEnd, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFromEnd::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceAssetPlayerTimeFromEndFraction
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction final
{
public:
	int32                                         AssetPlayerIndex;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction");
static_assert(sizeof(AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction) == 0x000008, "Wrong size on AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction, AssetPlayerIndex) == 0x000000, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction::AssetPlayerIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceAssetPlayerTimeFromEndFraction::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceCurrentStateElapsedTime
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceCurrentStateElapsedTime final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceCurrentStateElapsedTime) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceCurrentStateElapsedTime");
static_assert(sizeof(AnimInstance_GetInstanceCurrentStateElapsedTime) == 0x000008, "Wrong size on AnimInstance_GetInstanceCurrentStateElapsedTime");
static_assert(offsetof(AnimInstance_GetInstanceCurrentStateElapsedTime, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceCurrentStateElapsedTime::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceCurrentStateElapsedTime, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceCurrentStateElapsedTime::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceMachineWeight
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetInstanceMachineWeight final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceMachineWeight) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceMachineWeight");
static_assert(sizeof(AnimInstance_GetInstanceMachineWeight) == 0x000008, "Wrong size on AnimInstance_GetInstanceMachineWeight");
static_assert(offsetof(AnimInstance_GetInstanceMachineWeight, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceMachineWeight::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceMachineWeight, ReturnValue) == 0x000004, "Member 'AnimInstance_GetInstanceMachineWeight::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceStateWeight
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetInstanceStateWeight final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceStateWeight) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceStateWeight");
static_assert(sizeof(AnimInstance_GetInstanceStateWeight) == 0x00000C, "Wrong size on AnimInstance_GetInstanceStateWeight");
static_assert(offsetof(AnimInstance_GetInstanceStateWeight, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceStateWeight::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceStateWeight, StateIndex) == 0x000004, "Member 'AnimInstance_GetInstanceStateWeight::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceStateWeight, ReturnValue) == 0x000008, "Member 'AnimInstance_GetInstanceStateWeight::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceTransitionCrossfadeDuration
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetInstanceTransitionCrossfadeDuration final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionIndex;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceTransitionCrossfadeDuration) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceTransitionCrossfadeDuration");
static_assert(sizeof(AnimInstance_GetInstanceTransitionCrossfadeDuration) == 0x00000C, "Wrong size on AnimInstance_GetInstanceTransitionCrossfadeDuration");
static_assert(offsetof(AnimInstance_GetInstanceTransitionCrossfadeDuration, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceTransitionCrossfadeDuration::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionCrossfadeDuration, TransitionIndex) == 0x000004, "Member 'AnimInstance_GetInstanceTransitionCrossfadeDuration::TransitionIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionCrossfadeDuration, ReturnValue) == 0x000008, "Member 'AnimInstance_GetInstanceTransitionCrossfadeDuration::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsed
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetInstanceTransitionTimeElapsed final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionIndex;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceTransitionTimeElapsed) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceTransitionTimeElapsed");
static_assert(sizeof(AnimInstance_GetInstanceTransitionTimeElapsed) == 0x00000C, "Wrong size on AnimInstance_GetInstanceTransitionTimeElapsed");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsed, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceTransitionTimeElapsed::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsed, TransitionIndex) == 0x000004, "Member 'AnimInstance_GetInstanceTransitionTimeElapsed::TransitionIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsed, ReturnValue) == 0x000008, "Member 'AnimInstance_GetInstanceTransitionTimeElapsed::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetInstanceTransitionTimeElapsedFraction
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetInstanceTransitionTimeElapsedFraction final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TransitionIndex;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetInstanceTransitionTimeElapsedFraction) == 0x000004, "Wrong alignment on AnimInstance_GetInstanceTransitionTimeElapsedFraction");
static_assert(sizeof(AnimInstance_GetInstanceTransitionTimeElapsedFraction) == 0x00000C, "Wrong size on AnimInstance_GetInstanceTransitionTimeElapsedFraction");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsedFraction, MachineIndex) == 0x000000, "Member 'AnimInstance_GetInstanceTransitionTimeElapsedFraction::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsedFraction, TransitionIndex) == 0x000004, "Member 'AnimInstance_GetInstanceTransitionTimeElapsedFraction::TransitionIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetInstanceTransitionTimeElapsedFraction, ReturnValue) == 0x000008, "Member 'AnimInstance_GetInstanceTransitionTimeElapsedFraction::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetRelevantAnimLength
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetRelevantAnimLength final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetRelevantAnimLength) == 0x000004, "Wrong alignment on AnimInstance_GetRelevantAnimLength");
static_assert(sizeof(AnimInstance_GetRelevantAnimLength) == 0x00000C, "Wrong size on AnimInstance_GetRelevantAnimLength");
static_assert(offsetof(AnimInstance_GetRelevantAnimLength, MachineIndex) == 0x000000, "Member 'AnimInstance_GetRelevantAnimLength::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimLength, StateIndex) == 0x000004, "Member 'AnimInstance_GetRelevantAnimLength::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimLength, ReturnValue) == 0x000008, "Member 'AnimInstance_GetRelevantAnimLength::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetRelevantAnimTime
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetRelevantAnimTime final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetRelevantAnimTime) == 0x000004, "Wrong alignment on AnimInstance_GetRelevantAnimTime");
static_assert(sizeof(AnimInstance_GetRelevantAnimTime) == 0x00000C, "Wrong size on AnimInstance_GetRelevantAnimTime");
static_assert(offsetof(AnimInstance_GetRelevantAnimTime, MachineIndex) == 0x000000, "Member 'AnimInstance_GetRelevantAnimTime::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTime, StateIndex) == 0x000004, "Member 'AnimInstance_GetRelevantAnimTime::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTime, ReturnValue) == 0x000008, "Member 'AnimInstance_GetRelevantAnimTime::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetRelevantAnimTimeFraction
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetRelevantAnimTimeFraction final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetRelevantAnimTimeFraction) == 0x000004, "Wrong alignment on AnimInstance_GetRelevantAnimTimeFraction");
static_assert(sizeof(AnimInstance_GetRelevantAnimTimeFraction) == 0x00000C, "Wrong size on AnimInstance_GetRelevantAnimTimeFraction");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeFraction, MachineIndex) == 0x000000, "Member 'AnimInstance_GetRelevantAnimTimeFraction::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeFraction, StateIndex) == 0x000004, "Member 'AnimInstance_GetRelevantAnimTimeFraction::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeFraction, ReturnValue) == 0x000008, "Member 'AnimInstance_GetRelevantAnimTimeFraction::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetRelevantAnimTimeRemaining
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetRelevantAnimTimeRemaining final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetRelevantAnimTimeRemaining) == 0x000004, "Wrong alignment on AnimInstance_GetRelevantAnimTimeRemaining");
static_assert(sizeof(AnimInstance_GetRelevantAnimTimeRemaining) == 0x00000C, "Wrong size on AnimInstance_GetRelevantAnimTimeRemaining");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemaining, MachineIndex) == 0x000000, "Member 'AnimInstance_GetRelevantAnimTimeRemaining::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemaining, StateIndex) == 0x000004, "Member 'AnimInstance_GetRelevantAnimTimeRemaining::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemaining, ReturnValue) == 0x000008, "Member 'AnimInstance_GetRelevantAnimTimeRemaining::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetRelevantAnimTimeRemainingFraction
// 0x000C (0x000C - 0x0000)
struct AnimInstance_GetRelevantAnimTimeRemainingFraction final
{
public:
	int32                                         MachineIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StateIndex;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetRelevantAnimTimeRemainingFraction) == 0x000004, "Wrong alignment on AnimInstance_GetRelevantAnimTimeRemainingFraction");
static_assert(sizeof(AnimInstance_GetRelevantAnimTimeRemainingFraction) == 0x00000C, "Wrong size on AnimInstance_GetRelevantAnimTimeRemainingFraction");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemainingFraction, MachineIndex) == 0x000000, "Member 'AnimInstance_GetRelevantAnimTimeRemainingFraction::MachineIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemainingFraction, StateIndex) == 0x000004, "Member 'AnimInstance_GetRelevantAnimTimeRemainingFraction::StateIndex' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetRelevantAnimTimeRemainingFraction, ReturnValue) == 0x000008, "Member 'AnimInstance_GetRelevantAnimTimeRemainingFraction::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.LockAIResources
// 0x0002 (0x0002 - 0x0000)
struct AnimInstance_LockAIResources final
{
public:
	bool                                          bLockMovement;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LockAILogic;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_LockAIResources) == 0x000001, "Wrong alignment on AnimInstance_LockAIResources");
static_assert(sizeof(AnimInstance_LockAIResources) == 0x000002, "Wrong size on AnimInstance_LockAIResources");
static_assert(offsetof(AnimInstance_LockAIResources, bLockMovement) == 0x000000, "Member 'AnimInstance_LockAIResources::bLockMovement' has a wrong offset!");
static_assert(offsetof(AnimInstance_LockAIResources, LockAILogic) == 0x000001, "Member 'AnimInstance_LockAIResources::LockAILogic' has a wrong offset!");

// Function Engine.AnimInstance.Montage_JumpToSection
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_JumpToSection final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_JumpToSection) == 0x000008, "Wrong alignment on AnimInstance_Montage_JumpToSection");
static_assert(sizeof(AnimInstance_Montage_JumpToSection) == 0x000010, "Wrong size on AnimInstance_Montage_JumpToSection");
static_assert(offsetof(AnimInstance_Montage_JumpToSection, SectionName) == 0x000000, "Member 'AnimInstance_Montage_JumpToSection::SectionName' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_JumpToSection, Montage) == 0x000008, "Member 'AnimInstance_Montage_JumpToSection::Montage' has a wrong offset!");

// Function Engine.AnimInstance.Montage_JumpToSectionsEnd
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_JumpToSectionsEnd final
{
public:
	class FName                                   SectionName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_JumpToSectionsEnd) == 0x000008, "Wrong alignment on AnimInstance_Montage_JumpToSectionsEnd");
static_assert(sizeof(AnimInstance_Montage_JumpToSectionsEnd) == 0x000010, "Wrong size on AnimInstance_Montage_JumpToSectionsEnd");
static_assert(offsetof(AnimInstance_Montage_JumpToSectionsEnd, SectionName) == 0x000000, "Member 'AnimInstance_Montage_JumpToSectionsEnd::SectionName' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_JumpToSectionsEnd, Montage) == 0x000008, "Member 'AnimInstance_Montage_JumpToSectionsEnd::Montage' has a wrong offset!");

// Function Engine.AnimInstance.Montage_Pause
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_Montage_Pause final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_Pause) == 0x000008, "Wrong alignment on AnimInstance_Montage_Pause");
static_assert(sizeof(AnimInstance_Montage_Pause) == 0x000008, "Wrong size on AnimInstance_Montage_Pause");
static_assert(offsetof(AnimInstance_Montage_Pause, Montage) == 0x000000, "Member 'AnimInstance_Montage_Pause::Montage' has a wrong offset!");

// Function Engine.AnimInstance.Montage_Play
// 0x0018 (0x0018 - 0x0000)
struct AnimInstance_Montage_Play final
{
public:
	class UAnimMontage*                           MontageToPlay;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMontagePlayReturnType                        ReturnValueType;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InTimeToStartMontageAt;                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_Play) == 0x000008, "Wrong alignment on AnimInstance_Montage_Play");
static_assert(sizeof(AnimInstance_Montage_Play) == 0x000018, "Wrong size on AnimInstance_Montage_Play");
static_assert(offsetof(AnimInstance_Montage_Play, MontageToPlay) == 0x000000, "Member 'AnimInstance_Montage_Play::MontageToPlay' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_Play, InPlayRate) == 0x000008, "Member 'AnimInstance_Montage_Play::InPlayRate' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_Play, ReturnValueType) == 0x00000C, "Member 'AnimInstance_Montage_Play::ReturnValueType' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_Play, InTimeToStartMontageAt) == 0x000010, "Member 'AnimInstance_Montage_Play::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_Play, ReturnValue) == 0x000014, "Member 'AnimInstance_Montage_Play::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_Resume
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_Montage_Resume final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_Resume) == 0x000008, "Wrong alignment on AnimInstance_Montage_Resume");
static_assert(sizeof(AnimInstance_Montage_Resume) == 0x000008, "Wrong size on AnimInstance_Montage_Resume");
static_assert(offsetof(AnimInstance_Montage_Resume, Montage) == 0x000000, "Member 'AnimInstance_Montage_Resume::Montage' has a wrong offset!");

// Function Engine.AnimInstance.Montage_SetNextSection
// 0x0018 (0x0018 - 0x0000)
struct AnimInstance_Montage_SetNextSection final
{
public:
	class FName                                   SectionNameToChange;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextSection;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UAnimMontage*                     Montage;                                           // 0x0010(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_SetNextSection) == 0x000008, "Wrong alignment on AnimInstance_Montage_SetNextSection");
static_assert(sizeof(AnimInstance_Montage_SetNextSection) == 0x000018, "Wrong size on AnimInstance_Montage_SetNextSection");
static_assert(offsetof(AnimInstance_Montage_SetNextSection, SectionNameToChange) == 0x000000, "Member 'AnimInstance_Montage_SetNextSection::SectionNameToChange' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_SetNextSection, NextSection) == 0x000008, "Member 'AnimInstance_Montage_SetNextSection::NextSection' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_SetNextSection, Montage) == 0x000010, "Member 'AnimInstance_Montage_SetNextSection::Montage' has a wrong offset!");

// Function Engine.AnimInstance.Montage_SetPlayRate
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_SetPlayRate final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewPlayRate;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_SetPlayRate) == 0x000008, "Wrong alignment on AnimInstance_Montage_SetPlayRate");
static_assert(sizeof(AnimInstance_Montage_SetPlayRate) == 0x000010, "Wrong size on AnimInstance_Montage_SetPlayRate");
static_assert(offsetof(AnimInstance_Montage_SetPlayRate, Montage) == 0x000000, "Member 'AnimInstance_Montage_SetPlayRate::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_SetPlayRate, NewPlayRate) == 0x000008, "Member 'AnimInstance_Montage_SetPlayRate::NewPlayRate' has a wrong offset!");

// Function Engine.AnimInstance.Montage_SetPosition
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_SetPosition final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NewPosition;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_SetPosition) == 0x000008, "Wrong alignment on AnimInstance_Montage_SetPosition");
static_assert(sizeof(AnimInstance_Montage_SetPosition) == 0x000010, "Wrong size on AnimInstance_Montage_SetPosition");
static_assert(offsetof(AnimInstance_Montage_SetPosition, Montage) == 0x000000, "Member 'AnimInstance_Montage_SetPosition::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_SetPosition, NewPosition) == 0x000008, "Member 'AnimInstance_Montage_SetPosition::NewPosition' has a wrong offset!");

// Function Engine.AnimInstance.Montage_Stop
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_Stop final
{
public:
	float                                         InBlendOutTime;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	const class UAnimMontage*                     Montage;                                           // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_Stop) == 0x000008, "Wrong alignment on AnimInstance_Montage_Stop");
static_assert(sizeof(AnimInstance_Montage_Stop) == 0x000010, "Wrong size on AnimInstance_Montage_Stop");
static_assert(offsetof(AnimInstance_Montage_Stop, InBlendOutTime) == 0x000000, "Member 'AnimInstance_Montage_Stop::InBlendOutTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_Stop, Montage) == 0x000008, "Member 'AnimInstance_Montage_Stop::Montage' has a wrong offset!");

// Function Engine.AnimInstance.PlaySlotAnimation
// 0x0028 (0x0028 - 0x0000)
struct AnimInstance_PlaySlotAnimation final
{
public:
	class UAnimSequenceBase*                      Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_PlaySlotAnimation) == 0x000008, "Wrong alignment on AnimInstance_PlaySlotAnimation");
static_assert(sizeof(AnimInstance_PlaySlotAnimation) == 0x000028, "Wrong size on AnimInstance_PlaySlotAnimation");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, Asset) == 0x000000, "Member 'AnimInstance_PlaySlotAnimation::Asset' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, SlotNodeName) == 0x000008, "Member 'AnimInstance_PlaySlotAnimation::SlotNodeName' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, BlendInTime) == 0x000010, "Member 'AnimInstance_PlaySlotAnimation::BlendInTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, BlendOutTime) == 0x000014, "Member 'AnimInstance_PlaySlotAnimation::BlendOutTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, InPlayRate) == 0x000018, "Member 'AnimInstance_PlaySlotAnimation::InPlayRate' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, LoopCount) == 0x00001C, "Member 'AnimInstance_PlaySlotAnimation::LoopCount' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimation, ReturnValue) == 0x000020, "Member 'AnimInstance_PlaySlotAnimation::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.PlaySlotAnimationAsDynamicMontage
// 0x0030 (0x0030 - 0x0000)
struct AnimInstance_PlaySlotAnimationAsDynamicMontage final
{
public:
	class UAnimSequenceBase*                      Asset;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPlayRate;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LoopCount;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTriggerTime;                               // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InTimeToStartMontageAt;                            // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimMontage*                           ReturnValue;                                       // 0x0028(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_PlaySlotAnimationAsDynamicMontage) == 0x000008, "Wrong alignment on AnimInstance_PlaySlotAnimationAsDynamicMontage");
static_assert(sizeof(AnimInstance_PlaySlotAnimationAsDynamicMontage) == 0x000030, "Wrong size on AnimInstance_PlaySlotAnimationAsDynamicMontage");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, Asset) == 0x000000, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::Asset' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, SlotNodeName) == 0x000008, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::SlotNodeName' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, BlendInTime) == 0x000010, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::BlendInTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, BlendOutTime) == 0x000014, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::BlendOutTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, InPlayRate) == 0x000018, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::InPlayRate' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, LoopCount) == 0x00001C, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::LoopCount' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, BlendOutTriggerTime) == 0x000020, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::BlendOutTriggerTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, InTimeToStartMontageAt) == 0x000024, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::InTimeToStartMontageAt' has a wrong offset!");
static_assert(offsetof(AnimInstance_PlaySlotAnimationAsDynamicMontage, ReturnValue) == 0x000028, "Member 'AnimInstance_PlaySlotAnimationAsDynamicMontage::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.SavePoseSnapshot
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_SavePoseSnapshot final
{
public:
	class FName                                   SnapshotName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_SavePoseSnapshot) == 0x000004, "Wrong alignment on AnimInstance_SavePoseSnapshot");
static_assert(sizeof(AnimInstance_SavePoseSnapshot) == 0x000008, "Wrong size on AnimInstance_SavePoseSnapshot");
static_assert(offsetof(AnimInstance_SavePoseSnapshot, SnapshotName) == 0x000000, "Member 'AnimInstance_SavePoseSnapshot::SnapshotName' has a wrong offset!");

// Function Engine.AnimInstance.SetMorphTarget
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_SetMorphTarget final
{
public:
	class FName                                   MorphTargetName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_SetMorphTarget) == 0x000004, "Wrong alignment on AnimInstance_SetMorphTarget");
static_assert(sizeof(AnimInstance_SetMorphTarget) == 0x000010, "Wrong size on AnimInstance_SetMorphTarget");
static_assert(offsetof(AnimInstance_SetMorphTarget, MorphTargetName) == 0x000000, "Member 'AnimInstance_SetMorphTarget::MorphTargetName' has a wrong offset!");
static_assert(offsetof(AnimInstance_SetMorphTarget, Value) == 0x000008, "Member 'AnimInstance_SetMorphTarget::Value' has a wrong offset!");

// Function Engine.AnimInstance.SetRootMotionMode
// 0x0001 (0x0001 - 0x0000)
struct AnimInstance_SetRootMotionMode final
{
public:
	ERootMotionMode                               Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_SetRootMotionMode) == 0x000001, "Wrong alignment on AnimInstance_SetRootMotionMode");
static_assert(sizeof(AnimInstance_SetRootMotionMode) == 0x000001, "Wrong size on AnimInstance_SetRootMotionMode");
static_assert(offsetof(AnimInstance_SetRootMotionMode, Value) == 0x000000, "Member 'AnimInstance_SetRootMotionMode::Value' has a wrong offset!");

// Function Engine.AnimInstance.SnapshotPose
// 0x0038 (0x0038 - 0x0000)
struct AnimInstance_SnapshotPose final
{
public:
	struct FPoseSnapshot                          Snapshot;                                          // 0x0000(0x0038)(Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_SnapshotPose) == 0x000008, "Wrong alignment on AnimInstance_SnapshotPose");
static_assert(sizeof(AnimInstance_SnapshotPose) == 0x000038, "Wrong size on AnimInstance_SnapshotPose");
static_assert(offsetof(AnimInstance_SnapshotPose, Snapshot) == 0x000000, "Member 'AnimInstance_SnapshotPose::Snapshot' has a wrong offset!");

// Function Engine.AnimInstance.StopSlotAnimation
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_StopSlotAnimation final
{
public:
	float                                         InBlendOutTime;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   SlotNodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_StopSlotAnimation) == 0x000004, "Wrong alignment on AnimInstance_StopSlotAnimation");
static_assert(sizeof(AnimInstance_StopSlotAnimation) == 0x000010, "Wrong size on AnimInstance_StopSlotAnimation");
static_assert(offsetof(AnimInstance_StopSlotAnimation, InBlendOutTime) == 0x000000, "Member 'AnimInstance_StopSlotAnimation::InBlendOutTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_StopSlotAnimation, SlotNodeName) == 0x000008, "Member 'AnimInstance_StopSlotAnimation::SlotNodeName' has a wrong offset!");

// Function Engine.AnimInstance.UnlockAIResources
// 0x0002 (0x0002 - 0x0000)
struct AnimInstance_UnlockAIResources final
{
public:
	bool                                          bUnlockMovement;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          UnlockAILogic;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_UnlockAIResources) == 0x000001, "Wrong alignment on AnimInstance_UnlockAIResources");
static_assert(sizeof(AnimInstance_UnlockAIResources) == 0x000002, "Wrong size on AnimInstance_UnlockAIResources");
static_assert(offsetof(AnimInstance_UnlockAIResources, bUnlockMovement) == 0x000000, "Member 'AnimInstance_UnlockAIResources::bUnlockMovement' has a wrong offset!");
static_assert(offsetof(AnimInstance_UnlockAIResources, UnlockAILogic) == 0x000001, "Member 'AnimInstance_UnlockAIResources::UnlockAILogic' has a wrong offset!");

// Function Engine.AnimInstance.GetCurrentActiveMontage
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetCurrentActiveMontage final
{
public:
	class UAnimMontage*                           ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetCurrentActiveMontage) == 0x000008, "Wrong alignment on AnimInstance_GetCurrentActiveMontage");
static_assert(sizeof(AnimInstance_GetCurrentActiveMontage) == 0x000008, "Wrong size on AnimInstance_GetCurrentActiveMontage");
static_assert(offsetof(AnimInstance_GetCurrentActiveMontage, ReturnValue) == 0x000000, "Member 'AnimInstance_GetCurrentActiveMontage::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetOwningActor
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetOwningActor final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetOwningActor) == 0x000008, "Wrong alignment on AnimInstance_GetOwningActor");
static_assert(sizeof(AnimInstance_GetOwningActor) == 0x000008, "Wrong size on AnimInstance_GetOwningActor");
static_assert(offsetof(AnimInstance_GetOwningActor, ReturnValue) == 0x000000, "Member 'AnimInstance_GetOwningActor::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetOwningComponent
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_GetOwningComponent final
{
public:
	class USkeletalMeshComponent*                 ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetOwningComponent) == 0x000008, "Wrong alignment on AnimInstance_GetOwningComponent");
static_assert(sizeof(AnimInstance_GetOwningComponent) == 0x000008, "Wrong size on AnimInstance_GetOwningComponent");
static_assert(offsetof(AnimInstance_GetOwningComponent, ReturnValue) == 0x000000, "Member 'AnimInstance_GetOwningComponent::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetSyncGroupPosition
// 0x0020 (0x0020 - 0x0000)
struct AnimInstance_GetSyncGroupPosition final
{
public:
	class FName                                   InSyncGroupName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMarkerSyncAnimPosition                ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_GetSyncGroupPosition) == 0x000008, "Wrong alignment on AnimInstance_GetSyncGroupPosition");
static_assert(sizeof(AnimInstance_GetSyncGroupPosition) == 0x000020, "Wrong size on AnimInstance_GetSyncGroupPosition");
static_assert(offsetof(AnimInstance_GetSyncGroupPosition, InSyncGroupName) == 0x000000, "Member 'AnimInstance_GetSyncGroupPosition::InSyncGroupName' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetSyncGroupPosition, ReturnValue) == 0x000008, "Member 'AnimInstance_GetSyncGroupPosition::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.GetTimeToClosestMarker
// 0x0018 (0x0018 - 0x0000)
struct AnimInstance_GetTimeToClosestMarker final
{
public:
	class FName                                   SyncGroup;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutMarkerTime;                                     // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_GetTimeToClosestMarker) == 0x000004, "Wrong alignment on AnimInstance_GetTimeToClosestMarker");
static_assert(sizeof(AnimInstance_GetTimeToClosestMarker) == 0x000018, "Wrong size on AnimInstance_GetTimeToClosestMarker");
static_assert(offsetof(AnimInstance_GetTimeToClosestMarker, SyncGroup) == 0x000000, "Member 'AnimInstance_GetTimeToClosestMarker::SyncGroup' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetTimeToClosestMarker, MarkerName) == 0x000008, "Member 'AnimInstance_GetTimeToClosestMarker::MarkerName' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetTimeToClosestMarker, OutMarkerTime) == 0x000010, "Member 'AnimInstance_GetTimeToClosestMarker::OutMarkerTime' has a wrong offset!");
static_assert(offsetof(AnimInstance_GetTimeToClosestMarker, ReturnValue) == 0x000014, "Member 'AnimInstance_GetTimeToClosestMarker::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.HasMarkerBeenHitThisFrame
// 0x0018 (0x0018 - 0x0000)
struct AnimInstance_HasMarkerBeenHitThisFrame final
{
public:
	class FName                                   SyncGroup;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MarkerName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_HasMarkerBeenHitThisFrame) == 0x000004, "Wrong alignment on AnimInstance_HasMarkerBeenHitThisFrame");
static_assert(sizeof(AnimInstance_HasMarkerBeenHitThisFrame) == 0x000018, "Wrong size on AnimInstance_HasMarkerBeenHitThisFrame");
static_assert(offsetof(AnimInstance_HasMarkerBeenHitThisFrame, SyncGroup) == 0x000000, "Member 'AnimInstance_HasMarkerBeenHitThisFrame::SyncGroup' has a wrong offset!");
static_assert(offsetof(AnimInstance_HasMarkerBeenHitThisFrame, MarkerName) == 0x000008, "Member 'AnimInstance_HasMarkerBeenHitThisFrame::MarkerName' has a wrong offset!");
static_assert(offsetof(AnimInstance_HasMarkerBeenHitThisFrame, ReturnValue) == 0x000010, "Member 'AnimInstance_HasMarkerBeenHitThisFrame::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.IsAnyMontagePlaying
// 0x0001 (0x0001 - 0x0000)
struct AnimInstance_IsAnyMontagePlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_IsAnyMontagePlaying) == 0x000001, "Wrong alignment on AnimInstance_IsAnyMontagePlaying");
static_assert(sizeof(AnimInstance_IsAnyMontagePlaying) == 0x000001, "Wrong size on AnimInstance_IsAnyMontagePlaying");
static_assert(offsetof(AnimInstance_IsAnyMontagePlaying, ReturnValue) == 0x000000, "Member 'AnimInstance_IsAnyMontagePlaying::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.IsPlayingSlotAnimation
// 0x0018 (0x0018 - 0x0000)
struct AnimInstance_IsPlayingSlotAnimation final
{
public:
	const class UAnimSequenceBase*                Asset;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   SlotNodeName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_IsPlayingSlotAnimation) == 0x000008, "Wrong alignment on AnimInstance_IsPlayingSlotAnimation");
static_assert(sizeof(AnimInstance_IsPlayingSlotAnimation) == 0x000018, "Wrong size on AnimInstance_IsPlayingSlotAnimation");
static_assert(offsetof(AnimInstance_IsPlayingSlotAnimation, Asset) == 0x000000, "Member 'AnimInstance_IsPlayingSlotAnimation::Asset' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsPlayingSlotAnimation, SlotNodeName) == 0x000008, "Member 'AnimInstance_IsPlayingSlotAnimation::SlotNodeName' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsPlayingSlotAnimation, ReturnValue) == 0x000010, "Member 'AnimInstance_IsPlayingSlotAnimation::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.IsSyncGroupBetweenMarkers
// 0x0020 (0x0020 - 0x0000)
struct AnimInstance_IsSyncGroupBetweenMarkers final
{
public:
	class FName                                   InSyncGroupName;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PreviousMarker;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NextMarker;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRespectMarkerOrder;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_IsSyncGroupBetweenMarkers) == 0x000004, "Wrong alignment on AnimInstance_IsSyncGroupBetweenMarkers");
static_assert(sizeof(AnimInstance_IsSyncGroupBetweenMarkers) == 0x000020, "Wrong size on AnimInstance_IsSyncGroupBetweenMarkers");
static_assert(offsetof(AnimInstance_IsSyncGroupBetweenMarkers, InSyncGroupName) == 0x000000, "Member 'AnimInstance_IsSyncGroupBetweenMarkers::InSyncGroupName' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsSyncGroupBetweenMarkers, PreviousMarker) == 0x000008, "Member 'AnimInstance_IsSyncGroupBetweenMarkers::PreviousMarker' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsSyncGroupBetweenMarkers, NextMarker) == 0x000010, "Member 'AnimInstance_IsSyncGroupBetweenMarkers::NextMarker' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsSyncGroupBetweenMarkers, bRespectMarkerOrder) == 0x000018, "Member 'AnimInstance_IsSyncGroupBetweenMarkers::bRespectMarkerOrder' has a wrong offset!");
static_assert(offsetof(AnimInstance_IsSyncGroupBetweenMarkers, ReturnValue) == 0x000019, "Member 'AnimInstance_IsSyncGroupBetweenMarkers::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_GetBlendTime
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_GetBlendTime final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_GetBlendTime) == 0x000008, "Wrong alignment on AnimInstance_Montage_GetBlendTime");
static_assert(sizeof(AnimInstance_Montage_GetBlendTime) == 0x000010, "Wrong size on AnimInstance_Montage_GetBlendTime");
static_assert(offsetof(AnimInstance_Montage_GetBlendTime, Montage) == 0x000000, "Member 'AnimInstance_Montage_GetBlendTime::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_GetBlendTime, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_GetBlendTime::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_GetCurrentSection
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_GetCurrentSection final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_Montage_GetCurrentSection) == 0x000008, "Wrong alignment on AnimInstance_Montage_GetCurrentSection");
static_assert(sizeof(AnimInstance_Montage_GetCurrentSection) == 0x000010, "Wrong size on AnimInstance_Montage_GetCurrentSection");
static_assert(offsetof(AnimInstance_Montage_GetCurrentSection, Montage) == 0x000000, "Member 'AnimInstance_Montage_GetCurrentSection::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_GetCurrentSection, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_GetCurrentSection::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_GetIsStopped
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_GetIsStopped final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_GetIsStopped) == 0x000008, "Wrong alignment on AnimInstance_Montage_GetIsStopped");
static_assert(sizeof(AnimInstance_Montage_GetIsStopped) == 0x000010, "Wrong size on AnimInstance_Montage_GetIsStopped");
static_assert(offsetof(AnimInstance_Montage_GetIsStopped, Montage) == 0x000000, "Member 'AnimInstance_Montage_GetIsStopped::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_GetIsStopped, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_GetIsStopped::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_GetPlayRate
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_GetPlayRate final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_GetPlayRate) == 0x000008, "Wrong alignment on AnimInstance_Montage_GetPlayRate");
static_assert(sizeof(AnimInstance_Montage_GetPlayRate) == 0x000010, "Wrong size on AnimInstance_Montage_GetPlayRate");
static_assert(offsetof(AnimInstance_Montage_GetPlayRate, Montage) == 0x000000, "Member 'AnimInstance_Montage_GetPlayRate::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_GetPlayRate, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_GetPlayRate::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_GetPosition
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_GetPosition final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_GetPosition) == 0x000008, "Wrong alignment on AnimInstance_Montage_GetPosition");
static_assert(sizeof(AnimInstance_Montage_GetPosition) == 0x000010, "Wrong size on AnimInstance_Montage_GetPosition");
static_assert(offsetof(AnimInstance_Montage_GetPosition, Montage) == 0x000000, "Member 'AnimInstance_Montage_GetPosition::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_GetPosition, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_GetPosition::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_IsActive
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_IsActive final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_IsActive) == 0x000008, "Wrong alignment on AnimInstance_Montage_IsActive");
static_assert(sizeof(AnimInstance_Montage_IsActive) == 0x000010, "Wrong size on AnimInstance_Montage_IsActive");
static_assert(offsetof(AnimInstance_Montage_IsActive, Montage) == 0x000000, "Member 'AnimInstance_Montage_IsActive::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_IsActive, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_IsActive::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.Montage_IsPlaying
// 0x0010 (0x0010 - 0x0000)
struct AnimInstance_Montage_IsPlaying final
{
public:
	const class UAnimMontage*                     Montage;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimInstance_Montage_IsPlaying) == 0x000008, "Wrong alignment on AnimInstance_Montage_IsPlaying");
static_assert(sizeof(AnimInstance_Montage_IsPlaying) == 0x000010, "Wrong size on AnimInstance_Montage_IsPlaying");
static_assert(offsetof(AnimInstance_Montage_IsPlaying, Montage) == 0x000000, "Member 'AnimInstance_Montage_IsPlaying::Montage' has a wrong offset!");
static_assert(offsetof(AnimInstance_Montage_IsPlaying, ReturnValue) == 0x000008, "Member 'AnimInstance_Montage_IsPlaying::ReturnValue' has a wrong offset!");

// Function Engine.AnimInstance.TryGetPawnOwner
// 0x0008 (0x0008 - 0x0000)
struct AnimInstance_TryGetPawnOwner final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimInstance_TryGetPawnOwner) == 0x000008, "Wrong alignment on AnimInstance_TryGetPawnOwner");
static_assert(sizeof(AnimInstance_TryGetPawnOwner) == 0x000008, "Wrong size on AnimInstance_TryGetPawnOwner");
static_assert(offsetof(AnimInstance_TryGetPawnOwner, ReturnValue) == 0x000000, "Member 'AnimInstance_TryGetPawnOwner::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotify.GetNotifyName
// 0x0010 (0x0010 - 0x0000)
struct AnimNotify_GetNotifyName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotify_GetNotifyName) == 0x000008, "Wrong alignment on AnimNotify_GetNotifyName");
static_assert(sizeof(AnimNotify_GetNotifyName) == 0x000010, "Wrong size on AnimNotify_GetNotifyName");
static_assert(offsetof(AnimNotify_GetNotifyName, ReturnValue) == 0x000000, "Member 'AnimNotify_GetNotifyName::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotify.Received_Notify
// 0x0018 (0x0018 - 0x0000)
struct AnimNotify_Received_Notify final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotify_Received_Notify) == 0x000008, "Wrong alignment on AnimNotify_Received_Notify");
static_assert(sizeof(AnimNotify_Received_Notify) == 0x000018, "Wrong size on AnimNotify_Received_Notify");
static_assert(offsetof(AnimNotify_Received_Notify, MeshComp) == 0x000000, "Member 'AnimNotify_Received_Notify::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotify_Received_Notify, Animation) == 0x000008, "Member 'AnimNotify_Received_Notify::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotify_Received_Notify, ReturnValue) == 0x000010, "Member 'AnimNotify_Received_Notify::ReturnValue' has a wrong offset!");

// Function Engine.AnimNotify.Received_NotifyAnimationEnd
// 0x0018 (0x0018 - 0x0000)
struct AnimNotify_Received_NotifyAnimationEnd final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimNotify_Received_NotifyAnimationEnd) == 0x000008, "Wrong alignment on AnimNotify_Received_NotifyAnimationEnd");
static_assert(sizeof(AnimNotify_Received_NotifyAnimationEnd) == 0x000018, "Wrong size on AnimNotify_Received_NotifyAnimationEnd");
static_assert(offsetof(AnimNotify_Received_NotifyAnimationEnd, MeshComp) == 0x000000, "Member 'AnimNotify_Received_NotifyAnimationEnd::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotify_Received_NotifyAnimationEnd, Animation) == 0x000008, "Member 'AnimNotify_Received_NotifyAnimationEnd::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotify_Received_NotifyAnimationEnd, ReturnValue) == 0x000010, "Member 'AnimNotify_Received_NotifyAnimationEnd::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMeshSocket.InitializeSocketFromLocation
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMeshSocket_InitializeSocketFromLocation final
{
public:
	const class USkeletalMeshComponent*           SkelComp;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldNormal;                                       // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMeshSocket_InitializeSocketFromLocation) == 0x000008, "Wrong alignment on SkeletalMeshSocket_InitializeSocketFromLocation");
static_assert(sizeof(SkeletalMeshSocket_InitializeSocketFromLocation) == 0x000020, "Wrong size on SkeletalMeshSocket_InitializeSocketFromLocation");
static_assert(offsetof(SkeletalMeshSocket_InitializeSocketFromLocation, SkelComp) == 0x000000, "Member 'SkeletalMeshSocket_InitializeSocketFromLocation::SkelComp' has a wrong offset!");
static_assert(offsetof(SkeletalMeshSocket_InitializeSocketFromLocation, WorldLocation) == 0x000008, "Member 'SkeletalMeshSocket_InitializeSocketFromLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SkeletalMeshSocket_InitializeSocketFromLocation, WorldNormal) == 0x000014, "Member 'SkeletalMeshSocket_InitializeSocketFromLocation::WorldNormal' has a wrong offset!");

// Function Engine.SkeletalMeshSocket.GetSocketLocation
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMeshSocket_GetSocketLocation final
{
public:
	const class USkeletalMeshComponent*           SkelComp;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMeshSocket_GetSocketLocation) == 0x000008, "Wrong alignment on SkeletalMeshSocket_GetSocketLocation");
static_assert(sizeof(SkeletalMeshSocket_GetSocketLocation) == 0x000018, "Wrong size on SkeletalMeshSocket_GetSocketLocation");
static_assert(offsetof(SkeletalMeshSocket_GetSocketLocation, SkelComp) == 0x000000, "Member 'SkeletalMeshSocket_GetSocketLocation::SkelComp' has a wrong offset!");
static_assert(offsetof(SkeletalMeshSocket_GetSocketLocation, ReturnValue) == 0x000008, "Member 'SkeletalMeshSocket_GetSocketLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameStateBase.GetPlayerRespawnDelay
// 0x0010 (0x0010 - 0x0000)
struct GameStateBase_GetPlayerRespawnDelay final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStateBase_GetPlayerRespawnDelay) == 0x000008, "Wrong alignment on GameStateBase_GetPlayerRespawnDelay");
static_assert(sizeof(GameStateBase_GetPlayerRespawnDelay) == 0x000010, "Wrong size on GameStateBase_GetPlayerRespawnDelay");
static_assert(offsetof(GameStateBase_GetPlayerRespawnDelay, Controller) == 0x000000, "Member 'GameStateBase_GetPlayerRespawnDelay::Controller' has a wrong offset!");
static_assert(offsetof(GameStateBase_GetPlayerRespawnDelay, ReturnValue) == 0x000008, "Member 'GameStateBase_GetPlayerRespawnDelay::ReturnValue' has a wrong offset!");

// Function Engine.GameStateBase.GetPlayerStartTime
// 0x0010 (0x0010 - 0x0000)
struct GameStateBase_GetPlayerStartTime final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameStateBase_GetPlayerStartTime) == 0x000008, "Wrong alignment on GameStateBase_GetPlayerStartTime");
static_assert(sizeof(GameStateBase_GetPlayerStartTime) == 0x000010, "Wrong size on GameStateBase_GetPlayerStartTime");
static_assert(offsetof(GameStateBase_GetPlayerStartTime, Controller) == 0x000000, "Member 'GameStateBase_GetPlayerStartTime::Controller' has a wrong offset!");
static_assert(offsetof(GameStateBase_GetPlayerStartTime, ReturnValue) == 0x000008, "Member 'GameStateBase_GetPlayerStartTime::ReturnValue' has a wrong offset!");

// Function Engine.GameStateBase.GetServerWorldTimeSeconds
// 0x0004 (0x0004 - 0x0000)
struct GameStateBase_GetServerWorldTimeSeconds final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStateBase_GetServerWorldTimeSeconds) == 0x000004, "Wrong alignment on GameStateBase_GetServerWorldTimeSeconds");
static_assert(sizeof(GameStateBase_GetServerWorldTimeSeconds) == 0x000004, "Wrong size on GameStateBase_GetServerWorldTimeSeconds");
static_assert(offsetof(GameStateBase_GetServerWorldTimeSeconds, ReturnValue) == 0x000000, "Member 'GameStateBase_GetServerWorldTimeSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameStateBase.HasBegunPlay
// 0x0001 (0x0001 - 0x0000)
struct GameStateBase_HasBegunPlay final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStateBase_HasBegunPlay) == 0x000001, "Wrong alignment on GameStateBase_HasBegunPlay");
static_assert(sizeof(GameStateBase_HasBegunPlay) == 0x000001, "Wrong size on GameStateBase_HasBegunPlay");
static_assert(offsetof(GameStateBase_HasBegunPlay, ReturnValue) == 0x000000, "Member 'GameStateBase_HasBegunPlay::ReturnValue' has a wrong offset!");

// Function Engine.GameStateBase.HasMatchStarted
// 0x0001 (0x0001 - 0x0000)
struct GameStateBase_HasMatchStarted final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameStateBase_HasMatchStarted) == 0x000001, "Wrong alignment on GameStateBase_HasMatchStarted");
static_assert(sizeof(GameStateBase_HasMatchStarted) == 0x000001, "Wrong size on GameStateBase_HasMatchStarted");
static_assert(offsetof(GameStateBase_HasMatchStarted, ReturnValue) == 0x000000, "Member 'GameStateBase_HasMatchStarted::ReturnValue' has a wrong offset!");

// Function Engine.PawnNoiseEmitterComponent.MakeNoise
// 0x0018 (0x0018 - 0x0000)
struct PawnNoiseEmitterComponent_MakeNoise final
{
public:
	class AActor*                                 NoiseMaker;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Loudness;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NoiseLocation;                                     // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnNoiseEmitterComponent_MakeNoise) == 0x000008, "Wrong alignment on PawnNoiseEmitterComponent_MakeNoise");
static_assert(sizeof(PawnNoiseEmitterComponent_MakeNoise) == 0x000018, "Wrong size on PawnNoiseEmitterComponent_MakeNoise");
static_assert(offsetof(PawnNoiseEmitterComponent_MakeNoise, NoiseMaker) == 0x000000, "Member 'PawnNoiseEmitterComponent_MakeNoise::NoiseMaker' has a wrong offset!");
static_assert(offsetof(PawnNoiseEmitterComponent_MakeNoise, Loudness) == 0x000008, "Member 'PawnNoiseEmitterComponent_MakeNoise::Loudness' has a wrong offset!");
static_assert(offsetof(PawnNoiseEmitterComponent_MakeNoise, NoiseLocation) == 0x00000C, "Member 'PawnNoiseEmitterComponent_MakeNoise::NoiseLocation' has a wrong offset!");

// Function Engine.NavModifierVolume.SetAreaClass
// 0x0008 (0x0008 - 0x0000)
struct NavModifierVolume_SetAreaClass final
{
public:
	TSubclassOf<class UNavArea>                   NewAreaClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModifierVolume_SetAreaClass) == 0x000008, "Wrong alignment on NavModifierVolume_SetAreaClass");
static_assert(sizeof(NavModifierVolume_SetAreaClass) == 0x000008, "Wrong size on NavModifierVolume_SetAreaClass");
static_assert(offsetof(NavModifierVolume_SetAreaClass, NewAreaClass) == 0x000000, "Member 'NavModifierVolume_SetAreaClass::NewAreaClass' has a wrong offset!");

// Function Engine.MaterialInterface.GetBaseMaterial
// 0x0008 (0x0008 - 0x0000)
struct MaterialInterface_GetBaseMaterial final
{
public:
	class UMaterial*                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInterface_GetBaseMaterial) == 0x000008, "Wrong alignment on MaterialInterface_GetBaseMaterial");
static_assert(sizeof(MaterialInterface_GetBaseMaterial) == 0x000008, "Wrong size on MaterialInterface_GetBaseMaterial");
static_assert(offsetof(MaterialInterface_GetBaseMaterial, ReturnValue) == 0x000000, "Member 'MaterialInterface_GetBaseMaterial::ReturnValue' has a wrong offset!");

// Function Engine.MaterialInterface.SetForceMipLevelsToBeResident
// 0x000C (0x000C - 0x0000)
struct MaterialInterface_SetForceMipLevelsToBeResident final
{
public:
	bool                                          OverrideForceMiplevelsToBeResident;                // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceMiplevelsToBeResidentValue;                  // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceDuration;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CinematicTextureGroups;                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInterface_SetForceMipLevelsToBeResident) == 0x000004, "Wrong alignment on MaterialInterface_SetForceMipLevelsToBeResident");
static_assert(sizeof(MaterialInterface_SetForceMipLevelsToBeResident) == 0x00000C, "Wrong size on MaterialInterface_SetForceMipLevelsToBeResident");
static_assert(offsetof(MaterialInterface_SetForceMipLevelsToBeResident, OverrideForceMiplevelsToBeResident) == 0x000000, "Member 'MaterialInterface_SetForceMipLevelsToBeResident::OverrideForceMiplevelsToBeResident' has a wrong offset!");
static_assert(offsetof(MaterialInterface_SetForceMipLevelsToBeResident, bForceMiplevelsToBeResidentValue) == 0x000001, "Member 'MaterialInterface_SetForceMipLevelsToBeResident::bForceMiplevelsToBeResidentValue' has a wrong offset!");
static_assert(offsetof(MaterialInterface_SetForceMipLevelsToBeResident, ForceDuration) == 0x000004, "Member 'MaterialInterface_SetForceMipLevelsToBeResident::ForceDuration' has a wrong offset!");
static_assert(offsetof(MaterialInterface_SetForceMipLevelsToBeResident, CinematicTextureGroups) == 0x000008, "Member 'MaterialInterface_SetForceMipLevelsToBeResident::CinematicTextureGroups' has a wrong offset!");

// Function Engine.MaterialInterface.GetPhysicalMaterial
// 0x0008 (0x0008 - 0x0000)
struct MaterialInterface_GetPhysicalMaterial final
{
public:
	class UPhysicalMaterial*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInterface_GetPhysicalMaterial) == 0x000008, "Wrong alignment on MaterialInterface_GetPhysicalMaterial");
static_assert(sizeof(MaterialInterface_GetPhysicalMaterial) == 0x000008, "Wrong size on MaterialInterface_GetPhysicalMaterial");
static_assert(offsetof(MaterialInterface_GetPhysicalMaterial, ReturnValue) == 0x000000, "Member 'MaterialInterface_GetPhysicalMaterial::ReturnValue' has a wrong offset!");

// Function Engine.NavMovementComponent.IsCrouching
// 0x0001 (0x0001 - 0x0000)
struct NavMovementComponent_IsCrouching final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavMovementComponent_IsCrouching) == 0x000001, "Wrong alignment on NavMovementComponent_IsCrouching");
static_assert(sizeof(NavMovementComponent_IsCrouching) == 0x000001, "Wrong size on NavMovementComponent_IsCrouching");
static_assert(offsetof(NavMovementComponent_IsCrouching, ReturnValue) == 0x000000, "Member 'NavMovementComponent_IsCrouching::ReturnValue' has a wrong offset!");

// Function Engine.NavMovementComponent.IsFalling
// 0x0001 (0x0001 - 0x0000)
struct NavMovementComponent_IsFalling final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavMovementComponent_IsFalling) == 0x000001, "Wrong alignment on NavMovementComponent_IsFalling");
static_assert(sizeof(NavMovementComponent_IsFalling) == 0x000001, "Wrong size on NavMovementComponent_IsFalling");
static_assert(offsetof(NavMovementComponent_IsFalling, ReturnValue) == 0x000000, "Member 'NavMovementComponent_IsFalling::ReturnValue' has a wrong offset!");

// Function Engine.NavMovementComponent.IsFlying
// 0x0001 (0x0001 - 0x0000)
struct NavMovementComponent_IsFlying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavMovementComponent_IsFlying) == 0x000001, "Wrong alignment on NavMovementComponent_IsFlying");
static_assert(sizeof(NavMovementComponent_IsFlying) == 0x000001, "Wrong size on NavMovementComponent_IsFlying");
static_assert(offsetof(NavMovementComponent_IsFlying, ReturnValue) == 0x000000, "Member 'NavMovementComponent_IsFlying::ReturnValue' has a wrong offset!");

// Function Engine.NavMovementComponent.IsMovingOnGround
// 0x0001 (0x0001 - 0x0000)
struct NavMovementComponent_IsMovingOnGround final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavMovementComponent_IsMovingOnGround) == 0x000001, "Wrong alignment on NavMovementComponent_IsMovingOnGround");
static_assert(sizeof(NavMovementComponent_IsMovingOnGround) == 0x000001, "Wrong size on NavMovementComponent_IsMovingOnGround");
static_assert(offsetof(NavMovementComponent_IsMovingOnGround, ReturnValue) == 0x000000, "Member 'NavMovementComponent_IsMovingOnGround::ReturnValue' has a wrong offset!");

// Function Engine.NavMovementComponent.IsSwimming
// 0x0001 (0x0001 - 0x0000)
struct NavMovementComponent_IsSwimming final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavMovementComponent_IsSwimming) == 0x000001, "Wrong alignment on NavMovementComponent_IsSwimming");
static_assert(sizeof(NavMovementComponent_IsSwimming) == 0x000001, "Wrong size on NavMovementComponent_IsSwimming");
static_assert(offsetof(NavMovementComponent_IsSwimming, ReturnValue) == 0x000000, "Member 'NavMovementComponent_IsSwimming::ReturnValue' has a wrong offset!");

// Function Engine.BoxComponent.SetBoxExtent
// 0x0010 (0x0010 - 0x0000)
struct BoxComponent_SetBoxExtent final
{
public:
	struct FVector                                InBoxExtent;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlaps;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BoxComponent_SetBoxExtent) == 0x000004, "Wrong alignment on BoxComponent_SetBoxExtent");
static_assert(sizeof(BoxComponent_SetBoxExtent) == 0x000010, "Wrong size on BoxComponent_SetBoxExtent");
static_assert(offsetof(BoxComponent_SetBoxExtent, InBoxExtent) == 0x000000, "Member 'BoxComponent_SetBoxExtent::InBoxExtent' has a wrong offset!");
static_assert(offsetof(BoxComponent_SetBoxExtent, bUpdateOverlaps) == 0x00000C, "Member 'BoxComponent_SetBoxExtent::bUpdateOverlaps' has a wrong offset!");

// Function Engine.BoxComponent.GetScaledBoxExtent
// 0x000C (0x000C - 0x0000)
struct BoxComponent_GetScaledBoxExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoxComponent_GetScaledBoxExtent) == 0x000004, "Wrong alignment on BoxComponent_GetScaledBoxExtent");
static_assert(sizeof(BoxComponent_GetScaledBoxExtent) == 0x00000C, "Wrong size on BoxComponent_GetScaledBoxExtent");
static_assert(offsetof(BoxComponent_GetScaledBoxExtent, ReturnValue) == 0x000000, "Member 'BoxComponent_GetScaledBoxExtent::ReturnValue' has a wrong offset!");

// Function Engine.BoxComponent.GetUnscaledBoxExtent
// 0x000C (0x000C - 0x0000)
struct BoxComponent_GetUnscaledBoxExtent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BoxComponent_GetUnscaledBoxExtent) == 0x000004, "Wrong alignment on BoxComponent_GetUnscaledBoxExtent");
static_assert(sizeof(BoxComponent_GetUnscaledBoxExtent) == 0x00000C, "Wrong size on BoxComponent_GetUnscaledBoxExtent");
static_assert(offsetof(BoxComponent_GetUnscaledBoxExtent, ReturnValue) == 0x000000, "Member 'BoxComponent_GetUnscaledBoxExtent::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.GetConstraintForce
// 0x0018 (0x0018 - 0x0000)
struct PhysicsConstraintComponent_GetConstraintForce final
{
public:
	struct FVector                                OutLinearForce;                                    // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutAngularForce;                                   // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_GetConstraintForce) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_GetConstraintForce");
static_assert(sizeof(PhysicsConstraintComponent_GetConstraintForce) == 0x000018, "Wrong size on PhysicsConstraintComponent_GetConstraintForce");
static_assert(offsetof(PhysicsConstraintComponent_GetConstraintForce, OutLinearForce) == 0x000000, "Member 'PhysicsConstraintComponent_GetConstraintForce::OutLinearForce' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_GetConstraintForce, OutAngularForce) == 0x00000C, "Member 'PhysicsConstraintComponent_GetConstraintForce::OutAngularForce' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.IsBroken
// 0x0001 (0x0001 - 0x0000)
struct PhysicsConstraintComponent_IsBroken final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_IsBroken) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_IsBroken");
static_assert(sizeof(PhysicsConstraintComponent_IsBroken) == 0x000001, "Wrong size on PhysicsConstraintComponent_IsBroken");
static_assert(offsetof(PhysicsConstraintComponent_IsBroken, ReturnValue) == 0x000000, "Member 'PhysicsConstraintComponent_IsBroken::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularBreakable
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetAngularBreakable final
{
public:
	bool                                          bAngularBreakable;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AngularBreakThreshold;                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularBreakable) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularBreakable");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularBreakable) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetAngularBreakable");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularBreakable, bAngularBreakable) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularBreakable::bAngularBreakable' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularBreakable, AngularBreakThreshold) == 0x000004, "Member 'PhysicsConstraintComponent_SetAngularBreakable::AngularBreakThreshold' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularDriveMode
// 0x0001 (0x0001 - 0x0000)
struct PhysicsConstraintComponent_SetAngularDriveMode final
{
public:
	EAngularDriveMode                             DriveMode;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularDriveMode) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetAngularDriveMode");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularDriveMode) == 0x000001, "Wrong size on PhysicsConstraintComponent_SetAngularDriveMode");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularDriveMode, DriveMode) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularDriveMode::DriveMode' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularDriveParams
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetAngularDriveParams final
{
public:
	float                                         PositionStrength;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityStrength;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceLimit;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularDriveParams) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularDriveParams");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularDriveParams) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetAngularDriveParams");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularDriveParams, PositionStrength) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularDriveParams::PositionStrength' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularDriveParams, VelocityStrength) == 0x000004, "Member 'PhysicsConstraintComponent_SetAngularDriveParams::VelocityStrength' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularDriveParams, InForceLimit) == 0x000008, "Member 'PhysicsConstraintComponent_SetAngularDriveParams::InForceLimit' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularOrientationDrive
// 0x0002 (0x0002 - 0x0000)
struct PhysicsConstraintComponent_SetAngularOrientationDrive final
{
public:
	bool                                          bEnableSwingDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwistDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularOrientationDrive) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetAngularOrientationDrive");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularOrientationDrive) == 0x000002, "Wrong size on PhysicsConstraintComponent_SetAngularOrientationDrive");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularOrientationDrive, bEnableSwingDrive) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularOrientationDrive::bEnableSwingDrive' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularOrientationDrive, bEnableTwistDrive) == 0x000001, "Member 'PhysicsConstraintComponent_SetAngularOrientationDrive::bEnableTwistDrive' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularOrientationTarget
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetAngularOrientationTarget final
{
public:
	struct FRotator                               InPosTarget;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularOrientationTarget) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularOrientationTarget");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularOrientationTarget) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetAngularOrientationTarget");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularOrientationTarget, InPosTarget) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularOrientationTarget::InPosTarget' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularSwing1Limit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetAngularSwing1Limit final
{
public:
	EAngularConstraintMotion                      MotionType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Swing1LimitAngle;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularSwing1Limit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularSwing1Limit");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularSwing1Limit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetAngularSwing1Limit");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularSwing1Limit, MotionType) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularSwing1Limit::MotionType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularSwing1Limit, Swing1LimitAngle) == 0x000004, "Member 'PhysicsConstraintComponent_SetAngularSwing1Limit::Swing1LimitAngle' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularSwing2Limit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetAngularSwing2Limit final
{
public:
	EAngularConstraintMotion                      MotionType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Swing2LimitAngle;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularSwing2Limit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularSwing2Limit");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularSwing2Limit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetAngularSwing2Limit");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularSwing2Limit, MotionType) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularSwing2Limit::MotionType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularSwing2Limit, Swing2LimitAngle) == 0x000004, "Member 'PhysicsConstraintComponent_SetAngularSwing2Limit::Swing2LimitAngle' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularTwistLimit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetAngularTwistLimit final
{
public:
	EAngularConstraintMotion                      ConstraintType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TwistLimitAngle;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularTwistLimit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularTwistLimit");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularTwistLimit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetAngularTwistLimit");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularTwistLimit, ConstraintType) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularTwistLimit::ConstraintType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularTwistLimit, TwistLimitAngle) == 0x000004, "Member 'PhysicsConstraintComponent_SetAngularTwistLimit::TwistLimitAngle' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDrive
// 0x0002 (0x0002 - 0x0000)
struct PhysicsConstraintComponent_SetAngularVelocityDrive final
{
public:
	bool                                          bEnableSwingDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableTwistDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularVelocityDrive) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetAngularVelocityDrive");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularVelocityDrive) == 0x000002, "Wrong size on PhysicsConstraintComponent_SetAngularVelocityDrive");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityDrive, bEnableSwingDrive) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularVelocityDrive::bEnableSwingDrive' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityDrive, bEnableTwistDrive) == 0x000001, "Member 'PhysicsConstraintComponent_SetAngularVelocityDrive::bEnableTwistDrive' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveSLERP
// 0x0001 (0x0001 - 0x0000)
struct PhysicsConstraintComponent_SetAngularVelocityDriveSLERP final
{
public:
	bool                                          bEnableSLERP;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularVelocityDriveSLERP) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetAngularVelocityDriveSLERP");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularVelocityDriveSLERP) == 0x000001, "Wrong size on PhysicsConstraintComponent_SetAngularVelocityDriveSLERP");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityDriveSLERP, bEnableSLERP) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularVelocityDriveSLERP::bEnableSLERP' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularVelocityDriveTwistAndSwing
// 0x0002 (0x0002 - 0x0000)
struct PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing final
{
public:
	bool                                          bEnableTwistDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSwingDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing) == 0x000002, "Wrong size on PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing, bEnableTwistDrive) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing::bEnableTwistDrive' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing, bEnableSwingDrive) == 0x000001, "Member 'PhysicsConstraintComponent_SetAngularVelocityDriveTwistAndSwing::bEnableSwingDrive' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetAngularVelocityTarget
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetAngularVelocityTarget final
{
public:
	struct FVector                                InVelTarget;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetAngularVelocityTarget) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetAngularVelocityTarget");
static_assert(sizeof(PhysicsConstraintComponent_SetAngularVelocityTarget) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetAngularVelocityTarget");
static_assert(offsetof(PhysicsConstraintComponent_SetAngularVelocityTarget, InVelTarget) == 0x000000, "Member 'PhysicsConstraintComponent_SetAngularVelocityTarget::InVelTarget' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetConstrainedComponents
// 0x0020 (0x0020 - 0x0000)
struct PhysicsConstraintComponent_SetConstrainedComponents final
{
public:
	class UPrimitiveComponent*                    Component1;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName1;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    Component2;                                        // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   BoneName2;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetConstrainedComponents) == 0x000008, "Wrong alignment on PhysicsConstraintComponent_SetConstrainedComponents");
static_assert(sizeof(PhysicsConstraintComponent_SetConstrainedComponents) == 0x000020, "Wrong size on PhysicsConstraintComponent_SetConstrainedComponents");
static_assert(offsetof(PhysicsConstraintComponent_SetConstrainedComponents, Component1) == 0x000000, "Member 'PhysicsConstraintComponent_SetConstrainedComponents::Component1' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstrainedComponents, BoneName1) == 0x000008, "Member 'PhysicsConstraintComponent_SetConstrainedComponents::BoneName1' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstrainedComponents, Component2) == 0x000010, "Member 'PhysicsConstraintComponent_SetConstrainedComponents::Component2' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstrainedComponents, BoneName2) == 0x000018, "Member 'PhysicsConstraintComponent_SetConstrainedComponents::BoneName2' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceFrame
// 0x0040 (0x0040 - 0x0000)
struct PhysicsConstraintComponent_SetConstraintReferenceFrame final
{
public:
	EConstraintFrame                              Frame;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0xF];                                        // 0x0001(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             RefFrame;                                          // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetConstraintReferenceFrame) == 0x000010, "Wrong alignment on PhysicsConstraintComponent_SetConstraintReferenceFrame");
static_assert(sizeof(PhysicsConstraintComponent_SetConstraintReferenceFrame) == 0x000040, "Wrong size on PhysicsConstraintComponent_SetConstraintReferenceFrame");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferenceFrame, Frame) == 0x000000, "Member 'PhysicsConstraintComponent_SetConstraintReferenceFrame::Frame' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferenceFrame, RefFrame) == 0x000010, "Member 'PhysicsConstraintComponent_SetConstraintReferenceFrame::RefFrame' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetConstraintReferenceOrientation
// 0x001C (0x001C - 0x0000)
struct PhysicsConstraintComponent_SetConstraintReferenceOrientation final
{
public:
	EConstraintFrame                              Frame;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                PriAxis;                                           // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SecAxis;                                           // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetConstraintReferenceOrientation) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetConstraintReferenceOrientation");
static_assert(sizeof(PhysicsConstraintComponent_SetConstraintReferenceOrientation) == 0x00001C, "Wrong size on PhysicsConstraintComponent_SetConstraintReferenceOrientation");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferenceOrientation, Frame) == 0x000000, "Member 'PhysicsConstraintComponent_SetConstraintReferenceOrientation::Frame' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferenceOrientation, PriAxis) == 0x000004, "Member 'PhysicsConstraintComponent_SetConstraintReferenceOrientation::PriAxis' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferenceOrientation, SecAxis) == 0x000010, "Member 'PhysicsConstraintComponent_SetConstraintReferenceOrientation::SecAxis' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetConstraintReferencePosition
// 0x0010 (0x0010 - 0x0000)
struct PhysicsConstraintComponent_SetConstraintReferencePosition final
{
public:
	EConstraintFrame                              Frame;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                RefPosition;                                       // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetConstraintReferencePosition) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetConstraintReferencePosition");
static_assert(sizeof(PhysicsConstraintComponent_SetConstraintReferencePosition) == 0x000010, "Wrong size on PhysicsConstraintComponent_SetConstraintReferencePosition");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferencePosition, Frame) == 0x000000, "Member 'PhysicsConstraintComponent_SetConstraintReferencePosition::Frame' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetConstraintReferencePosition, RefPosition) == 0x000004, "Member 'PhysicsConstraintComponent_SetConstraintReferencePosition::RefPosition' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetDisableCollision
// 0x0001 (0x0001 - 0x0000)
struct PhysicsConstraintComponent_SetDisableCollision final
{
public:
	bool                                          bDisableCollision;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetDisableCollision) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetDisableCollision");
static_assert(sizeof(PhysicsConstraintComponent_SetDisableCollision) == 0x000001, "Wrong size on PhysicsConstraintComponent_SetDisableCollision");
static_assert(offsetof(PhysicsConstraintComponent_SetDisableCollision, bDisableCollision) == 0x000000, "Member 'PhysicsConstraintComponent_SetDisableCollision::bDisableCollision' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearBreakable
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetLinearBreakable final
{
public:
	bool                                          bLinearBreakable;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LinearBreakThreshold;                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearBreakable) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearBreakable");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearBreakable) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetLinearBreakable");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearBreakable, bLinearBreakable) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearBreakable::bLinearBreakable' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearBreakable, LinearBreakThreshold) == 0x000004, "Member 'PhysicsConstraintComponent_SetLinearBreakable::LinearBreakThreshold' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearDriveParams
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetLinearDriveParams final
{
public:
	float                                         PositionStrength;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VelocityStrength;                                  // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InForceLimit;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearDriveParams) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearDriveParams");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearDriveParams) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetLinearDriveParams");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearDriveParams, PositionStrength) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearDriveParams::PositionStrength' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearDriveParams, VelocityStrength) == 0x000004, "Member 'PhysicsConstraintComponent_SetLinearDriveParams::VelocityStrength' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearDriveParams, InForceLimit) == 0x000008, "Member 'PhysicsConstraintComponent_SetLinearDriveParams::InForceLimit' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearPositionDrive
// 0x0003 (0x0003 - 0x0000)
struct PhysicsConstraintComponent_SetLinearPositionDrive final
{
public:
	bool                                          bEnableDriveX;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDriveY;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDriveZ;                                     // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearPositionDrive) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetLinearPositionDrive");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearPositionDrive) == 0x000003, "Wrong size on PhysicsConstraintComponent_SetLinearPositionDrive");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearPositionDrive, bEnableDriveX) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearPositionDrive::bEnableDriveX' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearPositionDrive, bEnableDriveY) == 0x000001, "Member 'PhysicsConstraintComponent_SetLinearPositionDrive::bEnableDriveY' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearPositionDrive, bEnableDriveZ) == 0x000002, "Member 'PhysicsConstraintComponent_SetLinearPositionDrive::bEnableDriveZ' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearPositionTarget
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetLinearPositionTarget final
{
public:
	struct FVector                                InPosTarget;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearPositionTarget) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearPositionTarget");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearPositionTarget) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetLinearPositionTarget");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearPositionTarget, InPosTarget) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearPositionTarget::InPosTarget' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearVelocityDrive
// 0x0003 (0x0003 - 0x0000)
struct PhysicsConstraintComponent_SetLinearVelocityDrive final
{
public:
	bool                                          bEnableDriveX;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDriveY;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDriveZ;                                     // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearVelocityDrive) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetLinearVelocityDrive");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearVelocityDrive) == 0x000003, "Wrong size on PhysicsConstraintComponent_SetLinearVelocityDrive");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearVelocityDrive, bEnableDriveX) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearVelocityDrive::bEnableDriveX' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearVelocityDrive, bEnableDriveY) == 0x000001, "Member 'PhysicsConstraintComponent_SetLinearVelocityDrive::bEnableDriveY' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearVelocityDrive, bEnableDriveZ) == 0x000002, "Member 'PhysicsConstraintComponent_SetLinearVelocityDrive::bEnableDriveZ' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearVelocityTarget
// 0x000C (0x000C - 0x0000)
struct PhysicsConstraintComponent_SetLinearVelocityTarget final
{
public:
	struct FVector                                InVelTarget;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearVelocityTarget) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearVelocityTarget");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearVelocityTarget) == 0x00000C, "Wrong size on PhysicsConstraintComponent_SetLinearVelocityTarget");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearVelocityTarget, InVelTarget) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearVelocityTarget::InVelTarget' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearXLimit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetLinearXLimit final
{
public:
	ELinearConstraintMotion                       ConstraintType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitSize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearXLimit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearXLimit");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearXLimit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetLinearXLimit");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearXLimit, ConstraintType) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearXLimit::ConstraintType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearXLimit, LimitSize) == 0x000004, "Member 'PhysicsConstraintComponent_SetLinearXLimit::LimitSize' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearYLimit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetLinearYLimit final
{
public:
	ELinearConstraintMotion                       ConstraintType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitSize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearYLimit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearYLimit");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearYLimit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetLinearYLimit");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearYLimit, ConstraintType) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearYLimit::ConstraintType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearYLimit, LimitSize) == 0x000004, "Member 'PhysicsConstraintComponent_SetLinearYLimit::LimitSize' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetLinearZLimit
// 0x0008 (0x0008 - 0x0000)
struct PhysicsConstraintComponent_SetLinearZLimit final
{
public:
	ELinearConstraintMotion                       ConstraintType;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LimitSize;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetLinearZLimit) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_SetLinearZLimit");
static_assert(sizeof(PhysicsConstraintComponent_SetLinearZLimit) == 0x000008, "Wrong size on PhysicsConstraintComponent_SetLinearZLimit");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearZLimit, ConstraintType) == 0x000000, "Member 'PhysicsConstraintComponent_SetLinearZLimit::ConstraintType' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetLinearZLimit, LimitSize) == 0x000004, "Member 'PhysicsConstraintComponent_SetLinearZLimit::LimitSize' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetOrientationDriveSLERP
// 0x0001 (0x0001 - 0x0000)
struct PhysicsConstraintComponent_SetOrientationDriveSLERP final
{
public:
	bool                                          bEnableSLERP;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetOrientationDriveSLERP) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetOrientationDriveSLERP");
static_assert(sizeof(PhysicsConstraintComponent_SetOrientationDriveSLERP) == 0x000001, "Wrong size on PhysicsConstraintComponent_SetOrientationDriveSLERP");
static_assert(offsetof(PhysicsConstraintComponent_SetOrientationDriveSLERP, bEnableSLERP) == 0x000000, "Member 'PhysicsConstraintComponent_SetOrientationDriveSLERP::bEnableSLERP' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.SetOrientationDriveTwistAndSwing
// 0x0002 (0x0002 - 0x0000)
struct PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing final
{
public:
	bool                                          bEnableTwistDrive;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableSwingDrive;                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing) == 0x000001, "Wrong alignment on PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing");
static_assert(sizeof(PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing) == 0x000002, "Wrong size on PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing");
static_assert(offsetof(PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing, bEnableTwistDrive) == 0x000000, "Member 'PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing::bEnableTwistDrive' has a wrong offset!");
static_assert(offsetof(PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing, bEnableSwingDrive) == 0x000001, "Member 'PhysicsConstraintComponent_SetOrientationDriveTwistAndSwing::bEnableSwingDrive' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.GetCurrentSwing1
// 0x0004 (0x0004 - 0x0000)
struct PhysicsConstraintComponent_GetCurrentSwing1 final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_GetCurrentSwing1) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_GetCurrentSwing1");
static_assert(sizeof(PhysicsConstraintComponent_GetCurrentSwing1) == 0x000004, "Wrong size on PhysicsConstraintComponent_GetCurrentSwing1");
static_assert(offsetof(PhysicsConstraintComponent_GetCurrentSwing1, ReturnValue) == 0x000000, "Member 'PhysicsConstraintComponent_GetCurrentSwing1::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.GetCurrentSwing2
// 0x0004 (0x0004 - 0x0000)
struct PhysicsConstraintComponent_GetCurrentSwing2 final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_GetCurrentSwing2) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_GetCurrentSwing2");
static_assert(sizeof(PhysicsConstraintComponent_GetCurrentSwing2) == 0x000004, "Wrong size on PhysicsConstraintComponent_GetCurrentSwing2");
static_assert(offsetof(PhysicsConstraintComponent_GetCurrentSwing2, ReturnValue) == 0x000000, "Member 'PhysicsConstraintComponent_GetCurrentSwing2::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsConstraintComponent.GetCurrentTwist
// 0x0004 (0x0004 - 0x0000)
struct PhysicsConstraintComponent_GetCurrentTwist final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsConstraintComponent_GetCurrentTwist) == 0x000004, "Wrong alignment on PhysicsConstraintComponent_GetCurrentTwist");
static_assert(sizeof(PhysicsConstraintComponent_GetCurrentTwist) == 0x000004, "Wrong size on PhysicsConstraintComponent_GetCurrentTwist");
static_assert(offsetof(PhysicsConstraintComponent_GetCurrentTwist, ReturnValue) == 0x000000, "Member 'PhysicsConstraintComponent_GetCurrentTwist::ReturnValue' has a wrong offset!");

// Function Engine.HUD.AddDebugText
// 0x0050 (0x0050 - 0x0000)
struct HUD_AddDebugText final
{
public:
	class FString                                 DebugText;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 SrcActor;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Offset;                                            // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DesiredOffset;                                     // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 TextColor;                                         // 0x0034(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipOverwriteCheck;                               // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsoluteLocation;                                 // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bKeepAttachedToActor;                              // 0x003A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UFont*                                  InFont;                                            // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FontScale;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawShadow;                                       // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_AddDebugText) == 0x000008, "Wrong alignment on HUD_AddDebugText");
static_assert(sizeof(HUD_AddDebugText) == 0x000050, "Wrong size on HUD_AddDebugText");
static_assert(offsetof(HUD_AddDebugText, DebugText) == 0x000000, "Member 'HUD_AddDebugText::DebugText' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, SrcActor) == 0x000010, "Member 'HUD_AddDebugText::SrcActor' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, Duration) == 0x000018, "Member 'HUD_AddDebugText::Duration' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, Offset) == 0x00001C, "Member 'HUD_AddDebugText::Offset' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, DesiredOffset) == 0x000028, "Member 'HUD_AddDebugText::DesiredOffset' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, TextColor) == 0x000034, "Member 'HUD_AddDebugText::TextColor' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, bSkipOverwriteCheck) == 0x000038, "Member 'HUD_AddDebugText::bSkipOverwriteCheck' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, bAbsoluteLocation) == 0x000039, "Member 'HUD_AddDebugText::bAbsoluteLocation' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, bKeepAttachedToActor) == 0x00003A, "Member 'HUD_AddDebugText::bKeepAttachedToActor' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, InFont) == 0x000040, "Member 'HUD_AddDebugText::InFont' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, FontScale) == 0x000048, "Member 'HUD_AddDebugText::FontScale' has a wrong offset!");
static_assert(offsetof(HUD_AddDebugText, bDrawShadow) == 0x00004C, "Member 'HUD_AddDebugText::bDrawShadow' has a wrong offset!");

// Function Engine.HUD.AddHitBox
// 0x0020 (0x0020 - 0x0000)
struct HUD_AddHitBox final
{
public:
	struct FVector2D                              Position;                                          // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InName;                                            // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConsumesInput;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Priority;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_AddHitBox) == 0x000004, "Wrong alignment on HUD_AddHitBox");
static_assert(sizeof(HUD_AddHitBox) == 0x000020, "Wrong size on HUD_AddHitBox");
static_assert(offsetof(HUD_AddHitBox, Position) == 0x000000, "Member 'HUD_AddHitBox::Position' has a wrong offset!");
static_assert(offsetof(HUD_AddHitBox, Size) == 0x000008, "Member 'HUD_AddHitBox::Size' has a wrong offset!");
static_assert(offsetof(HUD_AddHitBox, InName) == 0x000010, "Member 'HUD_AddHitBox::InName' has a wrong offset!");
static_assert(offsetof(HUD_AddHitBox, bConsumesInput) == 0x000018, "Member 'HUD_AddHitBox::bConsumesInput' has a wrong offset!");
static_assert(offsetof(HUD_AddHitBox, Priority) == 0x00001C, "Member 'HUD_AddHitBox::Priority' has a wrong offset!");

// Function Engine.HUD.DrawLine
// 0x0024 (0x0024 - 0x0000)
struct HUD_DrawLine final
{
public:
	float                                         StartScreenX;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartScreenY;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScreenX;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EndScreenY;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineThickness;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_DrawLine) == 0x000004, "Wrong alignment on HUD_DrawLine");
static_assert(sizeof(HUD_DrawLine) == 0x000024, "Wrong size on HUD_DrawLine");
static_assert(offsetof(HUD_DrawLine, StartScreenX) == 0x000000, "Member 'HUD_DrawLine::StartScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawLine, StartScreenY) == 0x000004, "Member 'HUD_DrawLine::StartScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawLine, EndScreenX) == 0x000008, "Member 'HUD_DrawLine::EndScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawLine, EndScreenY) == 0x00000C, "Member 'HUD_DrawLine::EndScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawLine, LineColor) == 0x000010, "Member 'HUD_DrawLine::LineColor' has a wrong offset!");
static_assert(offsetof(HUD_DrawLine, LineThickness) == 0x000020, "Member 'HUD_DrawLine::LineThickness' has a wrong offset!");

// Function Engine.HUD.DrawMaterial
// 0x0040 (0x0040 - 0x0000)
struct HUD_DrawMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenW;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenH;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialU;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialV;                                         // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialUWidth;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaterialVHeight;                                   // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x002C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotPivot;                                          // 0x0034(0x0008)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_DrawMaterial) == 0x000008, "Wrong alignment on HUD_DrawMaterial");
static_assert(sizeof(HUD_DrawMaterial) == 0x000040, "Wrong size on HUD_DrawMaterial");
static_assert(offsetof(HUD_DrawMaterial, Material) == 0x000000, "Member 'HUD_DrawMaterial::Material' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, ScreenX) == 0x000008, "Member 'HUD_DrawMaterial::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, ScreenY) == 0x00000C, "Member 'HUD_DrawMaterial::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, ScreenW) == 0x000010, "Member 'HUD_DrawMaterial::ScreenW' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, ScreenH) == 0x000014, "Member 'HUD_DrawMaterial::ScreenH' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, MaterialU) == 0x000018, "Member 'HUD_DrawMaterial::MaterialU' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, MaterialV) == 0x00001C, "Member 'HUD_DrawMaterial::MaterialV' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, MaterialUWidth) == 0x000020, "Member 'HUD_DrawMaterial::MaterialUWidth' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, MaterialVHeight) == 0x000024, "Member 'HUD_DrawMaterial::MaterialVHeight' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, Scale) == 0x000028, "Member 'HUD_DrawMaterial::Scale' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, bScalePosition) == 0x00002C, "Member 'HUD_DrawMaterial::bScalePosition' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, Rotation) == 0x000030, "Member 'HUD_DrawMaterial::Rotation' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterial, RotPivot) == 0x000034, "Member 'HUD_DrawMaterial::RotPivot' has a wrong offset!");

// Function Engine.HUD.DrawMaterialSimple
// 0x0020 (0x0020 - 0x0000)
struct HUD_DrawMaterialSimple final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenW;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenH;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_DrawMaterialSimple) == 0x000008, "Wrong alignment on HUD_DrawMaterialSimple");
static_assert(sizeof(HUD_DrawMaterialSimple) == 0x000020, "Wrong size on HUD_DrawMaterialSimple");
static_assert(offsetof(HUD_DrawMaterialSimple, Material) == 0x000000, "Member 'HUD_DrawMaterialSimple::Material' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, ScreenX) == 0x000008, "Member 'HUD_DrawMaterialSimple::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, ScreenY) == 0x00000C, "Member 'HUD_DrawMaterialSimple::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, ScreenW) == 0x000010, "Member 'HUD_DrawMaterialSimple::ScreenW' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, ScreenH) == 0x000014, "Member 'HUD_DrawMaterialSimple::ScreenH' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, Scale) == 0x000018, "Member 'HUD_DrawMaterialSimple::Scale' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialSimple, bScalePosition) == 0x00001C, "Member 'HUD_DrawMaterialSimple::bScalePosition' has a wrong offset!");

// Function Engine.HUD.DrawMaterialTriangle
// 0x0068 (0x0068 - 0x0000)
struct HUD_DrawMaterialTriangle final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V0_Pos;                                            // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_Pos;                                            // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_Pos;                                            // 0x0018(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V0_UV;                                             // 0x0020(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V1_UV;                                             // 0x0028(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              V2_UV;                                             // 0x0030(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V0_Color;                                          // 0x0038(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V1_Color;                                          // 0x0048(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           V2_Color;                                          // 0x0058(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_DrawMaterialTriangle) == 0x000008, "Wrong alignment on HUD_DrawMaterialTriangle");
static_assert(sizeof(HUD_DrawMaterialTriangle) == 0x000068, "Wrong size on HUD_DrawMaterialTriangle");
static_assert(offsetof(HUD_DrawMaterialTriangle, Material) == 0x000000, "Member 'HUD_DrawMaterialTriangle::Material' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V0_Pos) == 0x000008, "Member 'HUD_DrawMaterialTriangle::V0_Pos' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V1_Pos) == 0x000010, "Member 'HUD_DrawMaterialTriangle::V1_Pos' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V2_Pos) == 0x000018, "Member 'HUD_DrawMaterialTriangle::V2_Pos' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V0_UV) == 0x000020, "Member 'HUD_DrawMaterialTriangle::V0_UV' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V1_UV) == 0x000028, "Member 'HUD_DrawMaterialTriangle::V1_UV' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V2_UV) == 0x000030, "Member 'HUD_DrawMaterialTriangle::V2_UV' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V0_Color) == 0x000038, "Member 'HUD_DrawMaterialTriangle::V0_Color' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V1_Color) == 0x000048, "Member 'HUD_DrawMaterialTriangle::V1_Color' has a wrong offset!");
static_assert(offsetof(HUD_DrawMaterialTriangle, V2_Color) == 0x000058, "Member 'HUD_DrawMaterialTriangle::V2_Color' has a wrong offset!");

// Function Engine.HUD.DrawRect
// 0x0020 (0x0020 - 0x0000)
struct HUD_DrawRect final
{
public:
	struct FLinearColor                           RectColor;                                         // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenW;                                           // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenH;                                           // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_DrawRect) == 0x000004, "Wrong alignment on HUD_DrawRect");
static_assert(sizeof(HUD_DrawRect) == 0x000020, "Wrong size on HUD_DrawRect");
static_assert(offsetof(HUD_DrawRect, RectColor) == 0x000000, "Member 'HUD_DrawRect::RectColor' has a wrong offset!");
static_assert(offsetof(HUD_DrawRect, ScreenX) == 0x000010, "Member 'HUD_DrawRect::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawRect, ScreenY) == 0x000014, "Member 'HUD_DrawRect::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawRect, ScreenW) == 0x000018, "Member 'HUD_DrawRect::ScreenW' has a wrong offset!");
static_assert(offsetof(HUD_DrawRect, ScreenH) == 0x00001C, "Member 'HUD_DrawRect::ScreenH' has a wrong offset!");

// Function Engine.HUD.DrawText
// 0x0038 (0x0038 - 0x0000)
struct HUD_DrawText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_DrawText) == 0x000008, "Wrong alignment on HUD_DrawText");
static_assert(sizeof(HUD_DrawText) == 0x000038, "Wrong size on HUD_DrawText");
static_assert(offsetof(HUD_DrawText, Text) == 0x000000, "Member 'HUD_DrawText::Text' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, TextColor) == 0x000010, "Member 'HUD_DrawText::TextColor' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, ScreenX) == 0x000020, "Member 'HUD_DrawText::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, ScreenY) == 0x000024, "Member 'HUD_DrawText::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, Font) == 0x000028, "Member 'HUD_DrawText::Font' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, Scale) == 0x000030, "Member 'HUD_DrawText::Scale' has a wrong offset!");
static_assert(offsetof(HUD_DrawText, bScalePosition) == 0x000034, "Member 'HUD_DrawText::bScalePosition' has a wrong offset!");

// Function Engine.HUD.DrawTexture
// 0x0050 (0x0050 - 0x0000)
struct HUD_DrawTexture final
{
public:
	class UTexture*                               Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenW;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenH;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureU;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureV;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureUWidth;                                     // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TextureVHeight;                                    // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TintColor;                                         // 0x0028(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Scale;                                             // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              RotPivot;                                          // 0x0048(0x0008)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_DrawTexture) == 0x000008, "Wrong alignment on HUD_DrawTexture");
static_assert(sizeof(HUD_DrawTexture) == 0x000050, "Wrong size on HUD_DrawTexture");
static_assert(offsetof(HUD_DrawTexture, Texture) == 0x000000, "Member 'HUD_DrawTexture::Texture' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, ScreenX) == 0x000008, "Member 'HUD_DrawTexture::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, ScreenY) == 0x00000C, "Member 'HUD_DrawTexture::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, ScreenW) == 0x000010, "Member 'HUD_DrawTexture::ScreenW' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, ScreenH) == 0x000014, "Member 'HUD_DrawTexture::ScreenH' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, TextureU) == 0x000018, "Member 'HUD_DrawTexture::TextureU' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, TextureV) == 0x00001C, "Member 'HUD_DrawTexture::TextureV' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, TextureUWidth) == 0x000020, "Member 'HUD_DrawTexture::TextureUWidth' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, TextureVHeight) == 0x000024, "Member 'HUD_DrawTexture::TextureVHeight' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, TintColor) == 0x000028, "Member 'HUD_DrawTexture::TintColor' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, BlendMode) == 0x000038, "Member 'HUD_DrawTexture::BlendMode' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, Scale) == 0x00003C, "Member 'HUD_DrawTexture::Scale' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, bScalePosition) == 0x000040, "Member 'HUD_DrawTexture::bScalePosition' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, Rotation) == 0x000044, "Member 'HUD_DrawTexture::Rotation' has a wrong offset!");
static_assert(offsetof(HUD_DrawTexture, RotPivot) == 0x000048, "Member 'HUD_DrawTexture::RotPivot' has a wrong offset!");

// Function Engine.HUD.DrawTextureSimple
// 0x0018 (0x0018 - 0x0000)
struct HUD_DrawTextureSimple final
{
public:
	class UTexture*                               Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenX;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bScalePosition;                                    // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_DrawTextureSimple) == 0x000008, "Wrong alignment on HUD_DrawTextureSimple");
static_assert(sizeof(HUD_DrawTextureSimple) == 0x000018, "Wrong size on HUD_DrawTextureSimple");
static_assert(offsetof(HUD_DrawTextureSimple, Texture) == 0x000000, "Member 'HUD_DrawTextureSimple::Texture' has a wrong offset!");
static_assert(offsetof(HUD_DrawTextureSimple, ScreenX) == 0x000008, "Member 'HUD_DrawTextureSimple::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_DrawTextureSimple, ScreenY) == 0x00000C, "Member 'HUD_DrawTextureSimple::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_DrawTextureSimple, Scale) == 0x000010, "Member 'HUD_DrawTextureSimple::Scale' has a wrong offset!");
static_assert(offsetof(HUD_DrawTextureSimple, bScalePosition) == 0x000014, "Member 'HUD_DrawTextureSimple::bScalePosition' has a wrong offset!");

// Function Engine.HUD.GetActorsInSelectionRectangle
// 0x0030 (0x0030 - 0x0000)
struct HUD_GetActorsInSelectionRectangle final
{
public:
	TSubclassOf<class AActor>                     ClassFilter;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              FirstPoint;                                        // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SecondPoint;                                       // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeNonCollidingComponents;                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActorMustBeFullyEnclosed;                         // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_GetActorsInSelectionRectangle) == 0x000008, "Wrong alignment on HUD_GetActorsInSelectionRectangle");
static_assert(sizeof(HUD_GetActorsInSelectionRectangle) == 0x000030, "Wrong size on HUD_GetActorsInSelectionRectangle");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, ClassFilter) == 0x000000, "Member 'HUD_GetActorsInSelectionRectangle::ClassFilter' has a wrong offset!");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, FirstPoint) == 0x000008, "Member 'HUD_GetActorsInSelectionRectangle::FirstPoint' has a wrong offset!");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, SecondPoint) == 0x000010, "Member 'HUD_GetActorsInSelectionRectangle::SecondPoint' has a wrong offset!");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, OutActors) == 0x000018, "Member 'HUD_GetActorsInSelectionRectangle::OutActors' has a wrong offset!");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, bIncludeNonCollidingComponents) == 0x000028, "Member 'HUD_GetActorsInSelectionRectangle::bIncludeNonCollidingComponents' has a wrong offset!");
static_assert(offsetof(HUD_GetActorsInSelectionRectangle, bActorMustBeFullyEnclosed) == 0x000029, "Member 'HUD_GetActorsInSelectionRectangle::bActorMustBeFullyEnclosed' has a wrong offset!");

// Function Engine.HUD.ReceiveDrawHUD
// 0x0008 (0x0008 - 0x0000)
struct HUD_ReceiveDrawHUD final
{
public:
	int32                                         SizeX;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SizeY;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ReceiveDrawHUD) == 0x000004, "Wrong alignment on HUD_ReceiveDrawHUD");
static_assert(sizeof(HUD_ReceiveDrawHUD) == 0x000008, "Wrong size on HUD_ReceiveDrawHUD");
static_assert(offsetof(HUD_ReceiveDrawHUD, SizeX) == 0x000000, "Member 'HUD_ReceiveDrawHUD::SizeX' has a wrong offset!");
static_assert(offsetof(HUD_ReceiveDrawHUD, SizeY) == 0x000004, "Member 'HUD_ReceiveDrawHUD::SizeY' has a wrong offset!");

// Function Engine.HUD.ReceiveHitBoxBeginCursorOver
// 0x0008 (0x0008 - 0x0000)
struct HUD_ReceiveHitBoxBeginCursorOver final
{
public:
	class FName                                   BoxName;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ReceiveHitBoxBeginCursorOver) == 0x000004, "Wrong alignment on HUD_ReceiveHitBoxBeginCursorOver");
static_assert(sizeof(HUD_ReceiveHitBoxBeginCursorOver) == 0x000008, "Wrong size on HUD_ReceiveHitBoxBeginCursorOver");
static_assert(offsetof(HUD_ReceiveHitBoxBeginCursorOver, BoxName) == 0x000000, "Member 'HUD_ReceiveHitBoxBeginCursorOver::BoxName' has a wrong offset!");

// Function Engine.HUD.ReceiveHitBoxClick
// 0x0008 (0x0008 - 0x0000)
struct HUD_ReceiveHitBoxClick final
{
public:
	class FName                                   BoxName;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ReceiveHitBoxClick) == 0x000004, "Wrong alignment on HUD_ReceiveHitBoxClick");
static_assert(sizeof(HUD_ReceiveHitBoxClick) == 0x000008, "Wrong size on HUD_ReceiveHitBoxClick");
static_assert(offsetof(HUD_ReceiveHitBoxClick, BoxName) == 0x000000, "Member 'HUD_ReceiveHitBoxClick::BoxName' has a wrong offset!");

// Function Engine.HUD.ReceiveHitBoxEndCursorOver
// 0x0008 (0x0008 - 0x0000)
struct HUD_ReceiveHitBoxEndCursorOver final
{
public:
	class FName                                   BoxName;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ReceiveHitBoxEndCursorOver) == 0x000004, "Wrong alignment on HUD_ReceiveHitBoxEndCursorOver");
static_assert(sizeof(HUD_ReceiveHitBoxEndCursorOver) == 0x000008, "Wrong size on HUD_ReceiveHitBoxEndCursorOver");
static_assert(offsetof(HUD_ReceiveHitBoxEndCursorOver, BoxName) == 0x000000, "Member 'HUD_ReceiveHitBoxEndCursorOver::BoxName' has a wrong offset!");

// Function Engine.HUD.ReceiveHitBoxRelease
// 0x0008 (0x0008 - 0x0000)
struct HUD_ReceiveHitBoxRelease final
{
public:
	class FName                                   BoxName;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ReceiveHitBoxRelease) == 0x000004, "Wrong alignment on HUD_ReceiveHitBoxRelease");
static_assert(sizeof(HUD_ReceiveHitBoxRelease) == 0x000008, "Wrong size on HUD_ReceiveHitBoxRelease");
static_assert(offsetof(HUD_ReceiveHitBoxRelease, BoxName) == 0x000000, "Member 'HUD_ReceiveHitBoxRelease::BoxName' has a wrong offset!");

// Function Engine.HUD.RemoveDebugText
// 0x0010 (0x0010 - 0x0000)
struct HUD_RemoveDebugText final
{
public:
	class AActor*                                 SrcActor;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLeaveDurationText;                                // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_RemoveDebugText) == 0x000008, "Wrong alignment on HUD_RemoveDebugText");
static_assert(sizeof(HUD_RemoveDebugText) == 0x000010, "Wrong size on HUD_RemoveDebugText");
static_assert(offsetof(HUD_RemoveDebugText, SrcActor) == 0x000000, "Member 'HUD_RemoveDebugText::SrcActor' has a wrong offset!");
static_assert(offsetof(HUD_RemoveDebugText, bLeaveDurationText) == 0x000008, "Member 'HUD_RemoveDebugText::bLeaveDurationText' has a wrong offset!");

// Function Engine.HUD.ShowDebug
// 0x0008 (0x0008 - 0x0000)
struct HUD_ShowDebug final
{
public:
	class FName                                   DebugType;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ShowDebug) == 0x000004, "Wrong alignment on HUD_ShowDebug");
static_assert(sizeof(HUD_ShowDebug) == 0x000008, "Wrong size on HUD_ShowDebug");
static_assert(offsetof(HUD_ShowDebug, DebugType) == 0x000000, "Member 'HUD_ShowDebug::DebugType' has a wrong offset!");

// Function Engine.HUD.ShowDebugForReticleTargetToggle
// 0x0008 (0x0008 - 0x0000)
struct HUD_ShowDebugForReticleTargetToggle final
{
public:
	TSubclassOf<class AActor>                     DesiredClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ShowDebugForReticleTargetToggle) == 0x000008, "Wrong alignment on HUD_ShowDebugForReticleTargetToggle");
static_assert(sizeof(HUD_ShowDebugForReticleTargetToggle) == 0x000008, "Wrong size on HUD_ShowDebugForReticleTargetToggle");
static_assert(offsetof(HUD_ShowDebugForReticleTargetToggle, DesiredClass) == 0x000000, "Member 'HUD_ShowDebugForReticleTargetToggle::DesiredClass' has a wrong offset!");

// Function Engine.HUD.ShowDebugToggleSubCategory
// 0x0008 (0x0008 - 0x0000)
struct HUD_ShowDebugToggleSubCategory final
{
public:
	class FName                                   Category;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_ShowDebugToggleSubCategory) == 0x000004, "Wrong alignment on HUD_ShowDebugToggleSubCategory");
static_assert(sizeof(HUD_ShowDebugToggleSubCategory) == 0x000008, "Wrong size on HUD_ShowDebugToggleSubCategory");
static_assert(offsetof(HUD_ShowDebugToggleSubCategory, Category) == 0x000000, "Member 'HUD_ShowDebugToggleSubCategory::Category' has a wrong offset!");

// Function Engine.HUD.Deproject
// 0x0020 (0x0020 - 0x0000)
struct HUD_Deproject final
{
public:
	float                                         ScreenX;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ScreenY;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_Deproject) == 0x000004, "Wrong alignment on HUD_Deproject");
static_assert(sizeof(HUD_Deproject) == 0x000020, "Wrong size on HUD_Deproject");
static_assert(offsetof(HUD_Deproject, ScreenX) == 0x000000, "Member 'HUD_Deproject::ScreenX' has a wrong offset!");
static_assert(offsetof(HUD_Deproject, ScreenY) == 0x000004, "Member 'HUD_Deproject::ScreenY' has a wrong offset!");
static_assert(offsetof(HUD_Deproject, WorldPosition) == 0x000008, "Member 'HUD_Deproject::WorldPosition' has a wrong offset!");
static_assert(offsetof(HUD_Deproject, WorldDirection) == 0x000014, "Member 'HUD_Deproject::WorldDirection' has a wrong offset!");

// Function Engine.HUD.GetOwningPawn
// 0x0008 (0x0008 - 0x0000)
struct HUD_GetOwningPawn final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_GetOwningPawn) == 0x000008, "Wrong alignment on HUD_GetOwningPawn");
static_assert(sizeof(HUD_GetOwningPawn) == 0x000008, "Wrong size on HUD_GetOwningPawn");
static_assert(offsetof(HUD_GetOwningPawn, ReturnValue) == 0x000000, "Member 'HUD_GetOwningPawn::ReturnValue' has a wrong offset!");

// Function Engine.HUD.GetOwningPlayerController
// 0x0008 (0x0008 - 0x0000)
struct HUD_GetOwningPlayerController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_GetOwningPlayerController) == 0x000008, "Wrong alignment on HUD_GetOwningPlayerController");
static_assert(sizeof(HUD_GetOwningPlayerController) == 0x000008, "Wrong size on HUD_GetOwningPlayerController");
static_assert(offsetof(HUD_GetOwningPlayerController, ReturnValue) == 0x000000, "Member 'HUD_GetOwningPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.HUD.GetTextSize
// 0x0028 (0x0028 - 0x0000)
struct HUD_GetTextSize final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutWidth;                                          // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHeight;                                         // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UFont*                                  Font;                                              // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HUD_GetTextSize) == 0x000008, "Wrong alignment on HUD_GetTextSize");
static_assert(sizeof(HUD_GetTextSize) == 0x000028, "Wrong size on HUD_GetTextSize");
static_assert(offsetof(HUD_GetTextSize, Text) == 0x000000, "Member 'HUD_GetTextSize::Text' has a wrong offset!");
static_assert(offsetof(HUD_GetTextSize, OutWidth) == 0x000010, "Member 'HUD_GetTextSize::OutWidth' has a wrong offset!");
static_assert(offsetof(HUD_GetTextSize, OutHeight) == 0x000014, "Member 'HUD_GetTextSize::OutHeight' has a wrong offset!");
static_assert(offsetof(HUD_GetTextSize, Font) == 0x000018, "Member 'HUD_GetTextSize::Font' has a wrong offset!");
static_assert(offsetof(HUD_GetTextSize, Scale) == 0x000020, "Member 'HUD_GetTextSize::Scale' has a wrong offset!");

// Function Engine.HUD.Project
// 0x0018 (0x0018 - 0x0000)
struct HUD_Project final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(HUD_Project) == 0x000004, "Wrong alignment on HUD_Project");
static_assert(sizeof(HUD_Project) == 0x000018, "Wrong size on HUD_Project");
static_assert(offsetof(HUD_Project, Location) == 0x000000, "Member 'HUD_Project::Location' has a wrong offset!");
static_assert(offsetof(HUD_Project, ReturnValue) == 0x00000C, "Member 'HUD_Project::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.SetCapsuleHalfHeight
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_SetCapsuleHalfHeight final
{
public:
	float                                         HalfHeight;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlaps;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CapsuleComponent_SetCapsuleHalfHeight) == 0x000004, "Wrong alignment on CapsuleComponent_SetCapsuleHalfHeight");
static_assert(sizeof(CapsuleComponent_SetCapsuleHalfHeight) == 0x000008, "Wrong size on CapsuleComponent_SetCapsuleHalfHeight");
static_assert(offsetof(CapsuleComponent_SetCapsuleHalfHeight, HalfHeight) == 0x000000, "Member 'CapsuleComponent_SetCapsuleHalfHeight::HalfHeight' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_SetCapsuleHalfHeight, bUpdateOverlaps) == 0x000004, "Member 'CapsuleComponent_SetCapsuleHalfHeight::bUpdateOverlaps' has a wrong offset!");

// Function Engine.CapsuleComponent.SetCapsuleRadius
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_SetCapsuleRadius final
{
public:
	float                                         Radius;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlaps;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CapsuleComponent_SetCapsuleRadius) == 0x000004, "Wrong alignment on CapsuleComponent_SetCapsuleRadius");
static_assert(sizeof(CapsuleComponent_SetCapsuleRadius) == 0x000008, "Wrong size on CapsuleComponent_SetCapsuleRadius");
static_assert(offsetof(CapsuleComponent_SetCapsuleRadius, Radius) == 0x000000, "Member 'CapsuleComponent_SetCapsuleRadius::Radius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_SetCapsuleRadius, bUpdateOverlaps) == 0x000004, "Member 'CapsuleComponent_SetCapsuleRadius::bUpdateOverlaps' has a wrong offset!");

// Function Engine.CapsuleComponent.SetCapsuleSize
// 0x000C (0x000C - 0x0000)
struct CapsuleComponent_SetCapsuleSize final
{
public:
	float                                         InRadius;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InHalfHeight;                                      // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlaps;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CapsuleComponent_SetCapsuleSize) == 0x000004, "Wrong alignment on CapsuleComponent_SetCapsuleSize");
static_assert(sizeof(CapsuleComponent_SetCapsuleSize) == 0x00000C, "Wrong size on CapsuleComponent_SetCapsuleSize");
static_assert(offsetof(CapsuleComponent_SetCapsuleSize, InRadius) == 0x000000, "Member 'CapsuleComponent_SetCapsuleSize::InRadius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_SetCapsuleSize, InHalfHeight) == 0x000004, "Member 'CapsuleComponent_SetCapsuleSize::InHalfHeight' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_SetCapsuleSize, bUpdateOverlaps) == 0x000008, "Member 'CapsuleComponent_SetCapsuleSize::bUpdateOverlaps' has a wrong offset!");

// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetScaledCapsuleHalfHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetScaledCapsuleHalfHeight) == 0x000004, "Wrong alignment on CapsuleComponent_GetScaledCapsuleHalfHeight");
static_assert(sizeof(CapsuleComponent_GetScaledCapsuleHalfHeight) == 0x000004, "Wrong size on CapsuleComponent_GetScaledCapsuleHalfHeight");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleHalfHeight, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetScaledCapsuleHalfHeight::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetScaledCapsuleHalfHeight_WithoutHemisphere
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere) == 0x000004, "Wrong alignment on CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere");
static_assert(sizeof(CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere) == 0x000004, "Wrong size on CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetScaledCapsuleHalfHeight_WithoutHemisphere::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetScaledCapsuleRadius
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetScaledCapsuleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetScaledCapsuleRadius) == 0x000004, "Wrong alignment on CapsuleComponent_GetScaledCapsuleRadius");
static_assert(sizeof(CapsuleComponent_GetScaledCapsuleRadius) == 0x000004, "Wrong size on CapsuleComponent_GetScaledCapsuleRadius");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleRadius, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetScaledCapsuleRadius::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetScaledCapsuleSize
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_GetScaledCapsuleSize final
{
public:
	float                                         OutRadius;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHalfHeight;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetScaledCapsuleSize) == 0x000004, "Wrong alignment on CapsuleComponent_GetScaledCapsuleSize");
static_assert(sizeof(CapsuleComponent_GetScaledCapsuleSize) == 0x000008, "Wrong size on CapsuleComponent_GetScaledCapsuleSize");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleSize, OutRadius) == 0x000000, "Member 'CapsuleComponent_GetScaledCapsuleSize::OutRadius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleSize, OutHalfHeight) == 0x000004, "Member 'CapsuleComponent_GetScaledCapsuleSize::OutHalfHeight' has a wrong offset!");

// Function Engine.CapsuleComponent.GetScaledCapsuleSize_WithoutHemisphere
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere final
{
public:
	float                                         OutRadius;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHalfHeightWithoutHemisphere;                    // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere) == 0x000004, "Wrong alignment on CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere");
static_assert(sizeof(CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere) == 0x000008, "Wrong size on CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere, OutRadius) == 0x000000, "Member 'CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere::OutRadius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere, OutHalfHeightWithoutHemisphere) == 0x000004, "Member 'CapsuleComponent_GetScaledCapsuleSize_WithoutHemisphere::OutHalfHeightWithoutHemisphere' has a wrong offset!");

// Function Engine.CapsuleComponent.GetShapeScale
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetShapeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetShapeScale) == 0x000004, "Wrong alignment on CapsuleComponent_GetShapeScale");
static_assert(sizeof(CapsuleComponent_GetShapeScale) == 0x000004, "Wrong size on CapsuleComponent_GetShapeScale");
static_assert(offsetof(CapsuleComponent_GetShapeScale, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetShapeScale::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetUnscaledCapsuleHalfHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetUnscaledCapsuleHalfHeight) == 0x000004, "Wrong alignment on CapsuleComponent_GetUnscaledCapsuleHalfHeight");
static_assert(sizeof(CapsuleComponent_GetUnscaledCapsuleHalfHeight) == 0x000004, "Wrong size on CapsuleComponent_GetUnscaledCapsuleHalfHeight");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleHalfHeight, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetUnscaledCapsuleHalfHeight::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetUnscaledCapsuleHalfHeight_WithoutHemisphere
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere) == 0x000004, "Wrong alignment on CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere");
static_assert(sizeof(CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere) == 0x000004, "Wrong size on CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetUnscaledCapsuleHalfHeight_WithoutHemisphere::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetUnscaledCapsuleRadius
// 0x0004 (0x0004 - 0x0000)
struct CapsuleComponent_GetUnscaledCapsuleRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetUnscaledCapsuleRadius) == 0x000004, "Wrong alignment on CapsuleComponent_GetUnscaledCapsuleRadius");
static_assert(sizeof(CapsuleComponent_GetUnscaledCapsuleRadius) == 0x000004, "Wrong size on CapsuleComponent_GetUnscaledCapsuleRadius");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleRadius, ReturnValue) == 0x000000, "Member 'CapsuleComponent_GetUnscaledCapsuleRadius::ReturnValue' has a wrong offset!");

// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_GetUnscaledCapsuleSize final
{
public:
	float                                         OutRadius;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHalfHeight;                                     // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetUnscaledCapsuleSize) == 0x000004, "Wrong alignment on CapsuleComponent_GetUnscaledCapsuleSize");
static_assert(sizeof(CapsuleComponent_GetUnscaledCapsuleSize) == 0x000008, "Wrong size on CapsuleComponent_GetUnscaledCapsuleSize");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleSize, OutRadius) == 0x000000, "Member 'CapsuleComponent_GetUnscaledCapsuleSize::OutRadius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleSize, OutHalfHeight) == 0x000004, "Member 'CapsuleComponent_GetUnscaledCapsuleSize::OutHalfHeight' has a wrong offset!");

// Function Engine.CapsuleComponent.GetUnscaledCapsuleSize_WithoutHemisphere
// 0x0008 (0x0008 - 0x0000)
struct CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere final
{
public:
	float                                         OutRadius;                                         // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutHalfHeightWithoutHemisphere;                    // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere) == 0x000004, "Wrong alignment on CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere");
static_assert(sizeof(CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere) == 0x000008, "Wrong size on CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere, OutRadius) == 0x000000, "Member 'CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere::OutRadius' has a wrong offset!");
static_assert(offsetof(CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere, OutHalfHeightWithoutHemisphere) == 0x000004, "Member 'CapsuleComponent_GetUnscaledCapsuleSize_WithoutHemisphere::OutHalfHeightWithoutHemisphere' has a wrong offset!");

// Function Engine.KismetMathLibrary.Abs
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Abs final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Abs) == 0x000004, "Wrong alignment on KismetMathLibrary_Abs");
static_assert(sizeof(KismetMathLibrary_Abs) == 0x000008, "Wrong size on KismetMathLibrary_Abs");
static_assert(offsetof(KismetMathLibrary_Abs, A) == 0x000000, "Member 'KismetMathLibrary_Abs::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Abs, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Abs::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Abs_Int
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Abs_Int final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Abs_Int) == 0x000004, "Wrong alignment on KismetMathLibrary_Abs_Int");
static_assert(sizeof(KismetMathLibrary_Abs_Int) == 0x000008, "Wrong size on KismetMathLibrary_Abs_Int");
static_assert(offsetof(KismetMathLibrary_Abs_Int, A) == 0x000000, "Member 'KismetMathLibrary_Abs_Int::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Abs_Int, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Abs_Int::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Acos
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Acos final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Acos) == 0x000004, "Wrong alignment on KismetMathLibrary_Acos");
static_assert(sizeof(KismetMathLibrary_Acos) == 0x000008, "Wrong size on KismetMathLibrary_Acos");
static_assert(offsetof(KismetMathLibrary_Acos, A) == 0x000000, "Member 'KismetMathLibrary_Acos::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Acos, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Acos::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Add_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Add_ByteByte");
static_assert(sizeof(KismetMathLibrary_Add_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Add_ByteByte");
static_assert(offsetof(KismetMathLibrary_Add_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Add_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Add_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Add_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_DateTimeTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Add_DateTimeTimespan final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_DateTimeTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Add_DateTimeTimespan");
static_assert(sizeof(KismetMathLibrary_Add_DateTimeTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Add_DateTimeTimespan");
static_assert(offsetof(KismetMathLibrary_Add_DateTimeTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Add_DateTimeTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_DateTimeTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Add_DateTimeTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_DateTimeTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Add_DateTimeTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Add_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Add_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Add_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Add_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Add_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Add_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Add_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Add_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_IntInt");
static_assert(sizeof(KismetMathLibrary_Add_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Add_IntInt");
static_assert(offsetof(KismetMathLibrary_Add_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Add_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Add_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Add_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Add_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Add_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_Add_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Add_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_Add_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Add_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Add_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Add_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_Vector2DFloat
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Add_Vector2DFloat final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_Vector2DFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_Vector2DFloat");
static_assert(sizeof(KismetMathLibrary_Add_Vector2DFloat) == 0x000014, "Wrong size on KismetMathLibrary_Add_Vector2DFloat");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DFloat, A) == 0x000000, "Member 'KismetMathLibrary_Add_Vector2DFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DFloat, B) == 0x000008, "Member 'KismetMathLibrary_Add_Vector2DFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Add_Vector2DFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Add_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_Add_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_Add_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_Add_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_Add_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_Vector2DVector2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Add_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_VectorFloat
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Add_VectorFloat final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_VectorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_VectorFloat");
static_assert(sizeof(KismetMathLibrary_Add_VectorFloat) == 0x00001C, "Wrong size on KismetMathLibrary_Add_VectorFloat");
static_assert(offsetof(KismetMathLibrary_Add_VectorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Add_VectorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorFloat, B) == 0x00000C, "Member 'KismetMathLibrary_Add_VectorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Add_VectorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_VectorInt
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Add_VectorInt final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_VectorInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_VectorInt");
static_assert(sizeof(KismetMathLibrary_Add_VectorInt) == 0x00001C, "Wrong size on KismetMathLibrary_Add_VectorInt");
static_assert(offsetof(KismetMathLibrary_Add_VectorInt, A) == 0x000000, "Member 'KismetMathLibrary_Add_VectorInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorInt, B) == 0x00000C, "Member 'KismetMathLibrary_Add_VectorInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorInt, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Add_VectorInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Add_VectorVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Add_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Add_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Add_VectorVector");
static_assert(sizeof(KismetMathLibrary_Add_VectorVector) == 0x000024, "Wrong size on KismetMathLibrary_Add_VectorVector");
static_assert(offsetof(KismetMathLibrary_Add_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Add_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Add_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Add_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Add_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.And_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_And_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_And_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_And_IntInt");
static_assert(sizeof(KismetMathLibrary_And_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_And_IntInt");
static_assert(offsetof(KismetMathLibrary_And_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_And_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_And_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_And_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_And_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_And_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Asin
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Asin final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Asin) == 0x000004, "Wrong alignment on KismetMathLibrary_Asin");
static_assert(sizeof(KismetMathLibrary_Asin) == 0x000008, "Wrong size on KismetMathLibrary_Asin");
static_assert(offsetof(KismetMathLibrary_Asin, A) == 0x000000, "Member 'KismetMathLibrary_Asin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Asin, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Asin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Atan
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Atan final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Atan) == 0x000004, "Wrong alignment on KismetMathLibrary_Atan");
static_assert(sizeof(KismetMathLibrary_Atan) == 0x000008, "Wrong size on KismetMathLibrary_Atan");
static_assert(offsetof(KismetMathLibrary_Atan, A) == 0x000000, "Member 'KismetMathLibrary_Atan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Atan, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Atan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Atan2
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Atan2 final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Atan2) == 0x000004, "Wrong alignment on KismetMathLibrary_Atan2");
static_assert(sizeof(KismetMathLibrary_Atan2) == 0x00000C, "Wrong size on KismetMathLibrary_Atan2");
static_assert(offsetof(KismetMathLibrary_Atan2, A) == 0x000000, "Member 'KismetMathLibrary_Atan2::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Atan2, B) == 0x000004, "Member 'KismetMathLibrary_Atan2::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Atan2, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Atan2::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BMax
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BMax final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BMax) == 0x000001, "Wrong alignment on KismetMathLibrary_BMax");
static_assert(sizeof(KismetMathLibrary_BMax) == 0x000003, "Wrong size on KismetMathLibrary_BMax");
static_assert(offsetof(KismetMathLibrary_BMax, A) == 0x000000, "Member 'KismetMathLibrary_BMax::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BMax, B) == 0x000001, "Member 'KismetMathLibrary_BMax::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BMax, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BMax::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BMin
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BMin final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BMin) == 0x000001, "Wrong alignment on KismetMathLibrary_BMin");
static_assert(sizeof(KismetMathLibrary_BMin) == 0x000003, "Wrong size on KismetMathLibrary_BMin");
static_assert(offsetof(KismetMathLibrary_BMin, A) == 0x000000, "Member 'KismetMathLibrary_BMin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BMin, B) == 0x000001, "Member 'KismetMathLibrary_BMin::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BMin, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BMin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BooleanAND
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BooleanAND final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BooleanAND) == 0x000001, "Wrong alignment on KismetMathLibrary_BooleanAND");
static_assert(sizeof(KismetMathLibrary_BooleanAND) == 0x000003, "Wrong size on KismetMathLibrary_BooleanAND");
static_assert(offsetof(KismetMathLibrary_BooleanAND, A) == 0x000000, "Member 'KismetMathLibrary_BooleanAND::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanAND, B) == 0x000001, "Member 'KismetMathLibrary_BooleanAND::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanAND, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BooleanAND::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BooleanNAND
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BooleanNAND final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BooleanNAND) == 0x000001, "Wrong alignment on KismetMathLibrary_BooleanNAND");
static_assert(sizeof(KismetMathLibrary_BooleanNAND) == 0x000003, "Wrong size on KismetMathLibrary_BooleanNAND");
static_assert(offsetof(KismetMathLibrary_BooleanNAND, A) == 0x000000, "Member 'KismetMathLibrary_BooleanNAND::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanNAND, B) == 0x000001, "Member 'KismetMathLibrary_BooleanNAND::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanNAND, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BooleanNAND::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BooleanNOR
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BooleanNOR final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BooleanNOR) == 0x000001, "Wrong alignment on KismetMathLibrary_BooleanNOR");
static_assert(sizeof(KismetMathLibrary_BooleanNOR) == 0x000003, "Wrong size on KismetMathLibrary_BooleanNOR");
static_assert(offsetof(KismetMathLibrary_BooleanNOR, A) == 0x000000, "Member 'KismetMathLibrary_BooleanNOR::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanNOR, B) == 0x000001, "Member 'KismetMathLibrary_BooleanNOR::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanNOR, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BooleanNOR::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BooleanOR
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BooleanOR final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BooleanOR) == 0x000001, "Wrong alignment on KismetMathLibrary_BooleanOR");
static_assert(sizeof(KismetMathLibrary_BooleanOR) == 0x000003, "Wrong size on KismetMathLibrary_BooleanOR");
static_assert(offsetof(KismetMathLibrary_BooleanOR, A) == 0x000000, "Member 'KismetMathLibrary_BooleanOR::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanOR, B) == 0x000001, "Member 'KismetMathLibrary_BooleanOR::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanOR, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BooleanOR::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BooleanXOR
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_BooleanXOR final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BooleanXOR) == 0x000001, "Wrong alignment on KismetMathLibrary_BooleanXOR");
static_assert(sizeof(KismetMathLibrary_BooleanXOR) == 0x000003, "Wrong size on KismetMathLibrary_BooleanXOR");
static_assert(offsetof(KismetMathLibrary_BooleanXOR, A) == 0x000000, "Member 'KismetMathLibrary_BooleanXOR::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanXOR, B) == 0x000001, "Member 'KismetMathLibrary_BooleanXOR::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BooleanXOR, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_BooleanXOR::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakColor
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_BreakColor final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         R;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakColor) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakColor");
static_assert(sizeof(KismetMathLibrary_BreakColor) == 0x000020, "Wrong size on KismetMathLibrary_BreakColor");
static_assert(offsetof(KismetMathLibrary_BreakColor, InColor) == 0x000000, "Member 'KismetMathLibrary_BreakColor::InColor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakColor, R) == 0x000010, "Member 'KismetMathLibrary_BreakColor::R' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakColor, G) == 0x000014, "Member 'KismetMathLibrary_BreakColor::G' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakColor, B) == 0x000018, "Member 'KismetMathLibrary_BreakColor::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakColor, A) == 0x00001C, "Member 'KismetMathLibrary_BreakColor::A' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakDateTime
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_BreakDateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Year;                                              // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Month;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Day;                                               // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hour;                                              // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minute;                                            // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Second;                                            // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Millisecond;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_BreakDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_BreakDateTime");
static_assert(sizeof(KismetMathLibrary_BreakDateTime) == 0x000028, "Wrong size on KismetMathLibrary_BreakDateTime");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, InDateTime) == 0x000000, "Member 'KismetMathLibrary_BreakDateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Year) == 0x000008, "Member 'KismetMathLibrary_BreakDateTime::Year' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Month) == 0x00000C, "Member 'KismetMathLibrary_BreakDateTime::Month' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Day) == 0x000010, "Member 'KismetMathLibrary_BreakDateTime::Day' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Hour) == 0x000014, "Member 'KismetMathLibrary_BreakDateTime::Hour' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Minute) == 0x000018, "Member 'KismetMathLibrary_BreakDateTime::Minute' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Second) == 0x00001C, "Member 'KismetMathLibrary_BreakDateTime::Second' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakDateTime, Millisecond) == 0x000020, "Member 'KismetMathLibrary_BreakDateTime::Millisecond' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakRandomStream
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_BreakRandomStream final
{
public:
	struct FRandomStream                          InRandomStream;                                    // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         InitialSeed;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakRandomStream) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakRandomStream");
static_assert(sizeof(KismetMathLibrary_BreakRandomStream) == 0x00000C, "Wrong size on KismetMathLibrary_BreakRandomStream");
static_assert(offsetof(KismetMathLibrary_BreakRandomStream, InRandomStream) == 0x000000, "Member 'KismetMathLibrary_BreakRandomStream::InRandomStream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRandomStream, InitialSeed) == 0x000008, "Member 'KismetMathLibrary_BreakRandomStream::InitialSeed' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakRotator
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_BreakRotator final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakRotator");
static_assert(sizeof(KismetMathLibrary_BreakRotator) == 0x000018, "Wrong size on KismetMathLibrary_BreakRotator");
static_assert(offsetof(KismetMathLibrary_BreakRotator, InRot) == 0x000000, "Member 'KismetMathLibrary_BreakRotator::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotator, Roll) == 0x00000C, "Member 'KismetMathLibrary_BreakRotator::Roll' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotator, Pitch) == 0x000010, "Member 'KismetMathLibrary_BreakRotator::Pitch' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotator, Yaw) == 0x000014, "Member 'KismetMathLibrary_BreakRotator::Yaw' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakRotIntoAxes
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_BreakRotIntoAxes final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0018(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakRotIntoAxes) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakRotIntoAxes");
static_assert(sizeof(KismetMathLibrary_BreakRotIntoAxes) == 0x000030, "Wrong size on KismetMathLibrary_BreakRotIntoAxes");
static_assert(offsetof(KismetMathLibrary_BreakRotIntoAxes, InRot) == 0x000000, "Member 'KismetMathLibrary_BreakRotIntoAxes::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotIntoAxes, X) == 0x00000C, "Member 'KismetMathLibrary_BreakRotIntoAxes::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotIntoAxes, Y) == 0x000018, "Member 'KismetMathLibrary_BreakRotIntoAxes::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakRotIntoAxes, Z) == 0x000024, "Member 'KismetMathLibrary_BreakRotIntoAxes::Z' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakTimespan
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_BreakTimespan final
{
public:
	struct FTimespan                              InTimespan;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Days;                                              // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hours;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Milliseconds;                                      // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_BreakTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_BreakTimespan");
static_assert(sizeof(KismetMathLibrary_BreakTimespan) == 0x000020, "Wrong size on KismetMathLibrary_BreakTimespan");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, InTimespan) == 0x000000, "Member 'KismetMathLibrary_BreakTimespan::InTimespan' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, Days) == 0x000008, "Member 'KismetMathLibrary_BreakTimespan::Days' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, Hours) == 0x00000C, "Member 'KismetMathLibrary_BreakTimespan::Hours' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, Minutes) == 0x000010, "Member 'KismetMathLibrary_BreakTimespan::Minutes' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, Seconds) == 0x000014, "Member 'KismetMathLibrary_BreakTimespan::Seconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan, Milliseconds) == 0x000018, "Member 'KismetMathLibrary_BreakTimespan::Milliseconds' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakTimespan2
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_BreakTimespan2 final
{
public:
	struct FTimespan                              InTimespan;                                        // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Days;                                              // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hours;                                             // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FractionNano;                                      // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_BreakTimespan2) == 0x000008, "Wrong alignment on KismetMathLibrary_BreakTimespan2");
static_assert(sizeof(KismetMathLibrary_BreakTimespan2) == 0x000020, "Wrong size on KismetMathLibrary_BreakTimespan2");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, InTimespan) == 0x000000, "Member 'KismetMathLibrary_BreakTimespan2::InTimespan' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, Days) == 0x000008, "Member 'KismetMathLibrary_BreakTimespan2::Days' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, Hours) == 0x00000C, "Member 'KismetMathLibrary_BreakTimespan2::Hours' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, Minutes) == 0x000010, "Member 'KismetMathLibrary_BreakTimespan2::Minutes' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, Seconds) == 0x000014, "Member 'KismetMathLibrary_BreakTimespan2::Seconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTimespan2, FractionNano) == 0x000018, "Member 'KismetMathLibrary_BreakTimespan2::FractionNano' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakTransform
// 0x0060 (0x0060 - 0x0000)
struct KismetMathLibrary_BreakTransform final
{
public:
	struct FTransform                             InTransform;                                       // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x003C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0048(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0xC];                                       // 0x0054(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_BreakTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_BreakTransform");
static_assert(sizeof(KismetMathLibrary_BreakTransform) == 0x000060, "Wrong size on KismetMathLibrary_BreakTransform");
static_assert(offsetof(KismetMathLibrary_BreakTransform, InTransform) == 0x000000, "Member 'KismetMathLibrary_BreakTransform::InTransform' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTransform, Location) == 0x000030, "Member 'KismetMathLibrary_BreakTransform::Location' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTransform, Rotation) == 0x00003C, "Member 'KismetMathLibrary_BreakTransform::Rotation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakTransform, Scale) == 0x000048, "Member 'KismetMathLibrary_BreakTransform::Scale' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_BreakVector final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakVector) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakVector");
static_assert(sizeof(KismetMathLibrary_BreakVector) == 0x000018, "Wrong size on KismetMathLibrary_BreakVector");
static_assert(offsetof(KismetMathLibrary_BreakVector, InVec) == 0x000000, "Member 'KismetMathLibrary_BreakVector::InVec' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakVector, X) == 0x00000C, "Member 'KismetMathLibrary_BreakVector::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakVector, Y) == 0x000010, "Member 'KismetMathLibrary_BreakVector::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakVector, Z) == 0x000014, "Member 'KismetMathLibrary_BreakVector::Z' has a wrong offset!");

// Function Engine.KismetMathLibrary.BreakVector2D
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_BreakVector2D final
{
public:
	struct FVector2D                              InVec;                                             // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         X;                                                 // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_BreakVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_BreakVector2D");
static_assert(sizeof(KismetMathLibrary_BreakVector2D) == 0x000010, "Wrong size on KismetMathLibrary_BreakVector2D");
static_assert(offsetof(KismetMathLibrary_BreakVector2D, InVec) == 0x000000, "Member 'KismetMathLibrary_BreakVector2D::InVec' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakVector2D, X) == 0x000008, "Member 'KismetMathLibrary_BreakVector2D::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_BreakVector2D, Y) == 0x00000C, "Member 'KismetMathLibrary_BreakVector2D::Y' has a wrong offset!");

// Function Engine.KismetMathLibrary.CInterpTo
// 0x0038 (0x0038 - 0x0000)
struct KismetMathLibrary_CInterpTo final
{
public:
	struct FLinearColor                           Current;                                           // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Target;                                            // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_CInterpTo) == 0x000004, "Wrong alignment on KismetMathLibrary_CInterpTo");
static_assert(sizeof(KismetMathLibrary_CInterpTo) == 0x000038, "Wrong size on KismetMathLibrary_CInterpTo");
static_assert(offsetof(KismetMathLibrary_CInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_CInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CInterpTo, Target) == 0x000010, "Member 'KismetMathLibrary_CInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CInterpTo, DeltaTime) == 0x000020, "Member 'KismetMathLibrary_CInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CInterpTo, InterpSpeed) == 0x000024, "Member 'KismetMathLibrary_CInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CInterpTo, ReturnValue) == 0x000028, "Member 'KismetMathLibrary_CInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Clamp
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_Clamp final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_0;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_0;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Clamp) == 0x000004, "Wrong alignment on KismetMathLibrary_Clamp");
static_assert(sizeof(KismetMathLibrary_Clamp) == 0x000010, "Wrong size on KismetMathLibrary_Clamp");
static_assert(offsetof(KismetMathLibrary_Clamp, Value) == 0x000000, "Member 'KismetMathLibrary_Clamp::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Clamp, Min_0) == 0x000004, "Member 'KismetMathLibrary_Clamp::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Clamp, Max_0) == 0x000008, "Member 'KismetMathLibrary_Clamp::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Clamp, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Clamp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ClampAngle
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_ClampAngle final
{
public:
	float                                         AngleDegrees;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinAngleDegrees;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAngleDegrees;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ClampAngle) == 0x000004, "Wrong alignment on KismetMathLibrary_ClampAngle");
static_assert(sizeof(KismetMathLibrary_ClampAngle) == 0x000010, "Wrong size on KismetMathLibrary_ClampAngle");
static_assert(offsetof(KismetMathLibrary_ClampAngle, AngleDegrees) == 0x000000, "Member 'KismetMathLibrary_ClampAngle::AngleDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampAngle, MinAngleDegrees) == 0x000004, "Member 'KismetMathLibrary_ClampAngle::MinAngleDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampAngle, MaxAngleDegrees) == 0x000008, "Member 'KismetMathLibrary_ClampAngle::MaxAngleDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampAngle, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_ClampAngle::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ClampAxis
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_ClampAxis final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ClampAxis) == 0x000004, "Wrong alignment on KismetMathLibrary_ClampAxis");
static_assert(sizeof(KismetMathLibrary_ClampAxis) == 0x000008, "Wrong size on KismetMathLibrary_ClampAxis");
static_assert(offsetof(KismetMathLibrary_ClampAxis, Angle) == 0x000000, "Member 'KismetMathLibrary_ClampAxis::Angle' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampAxis, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_ClampAxis::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ClampVectorSize
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_ClampVectorSize final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_0;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_0;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ClampVectorSize) == 0x000004, "Wrong alignment on KismetMathLibrary_ClampVectorSize");
static_assert(sizeof(KismetMathLibrary_ClampVectorSize) == 0x000020, "Wrong size on KismetMathLibrary_ClampVectorSize");
static_assert(offsetof(KismetMathLibrary_ClampVectorSize, A) == 0x000000, "Member 'KismetMathLibrary_ClampVectorSize::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampVectorSize, Min_0) == 0x00000C, "Member 'KismetMathLibrary_ClampVectorSize::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampVectorSize, Max_0) == 0x000010, "Member 'KismetMathLibrary_ClampVectorSize::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClampVectorSize, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_ClampVectorSize::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ClassIsChildOf
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_ClassIsChildOf final
{
public:
	TSubclassOf<class UObject>                    TestClass;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    ParentClass;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_ClassIsChildOf) == 0x000008, "Wrong alignment on KismetMathLibrary_ClassIsChildOf");
static_assert(sizeof(KismetMathLibrary_ClassIsChildOf) == 0x000018, "Wrong size on KismetMathLibrary_ClassIsChildOf");
static_assert(offsetof(KismetMathLibrary_ClassIsChildOf, TestClass) == 0x000000, "Member 'KismetMathLibrary_ClassIsChildOf::TestClass' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClassIsChildOf, ParentClass) == 0x000008, "Member 'KismetMathLibrary_ClassIsChildOf::ParentClass' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ClassIsChildOf, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_ClassIsChildOf::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ComposeRotators
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_ComposeRotators final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ComposeRotators) == 0x000004, "Wrong alignment on KismetMathLibrary_ComposeRotators");
static_assert(sizeof(KismetMathLibrary_ComposeRotators) == 0x000024, "Wrong size on KismetMathLibrary_ComposeRotators");
static_assert(offsetof(KismetMathLibrary_ComposeRotators, A) == 0x000000, "Member 'KismetMathLibrary_ComposeRotators::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ComposeRotators, B) == 0x00000C, "Member 'KismetMathLibrary_ComposeRotators::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ComposeRotators, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_ComposeRotators::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ComposeTransforms
// 0x0090 (0x0090 - 0x0000)
struct KismetMathLibrary_ComposeTransforms final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0060(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ComposeTransforms) == 0x000010, "Wrong alignment on KismetMathLibrary_ComposeTransforms");
static_assert(sizeof(KismetMathLibrary_ComposeTransforms) == 0x000090, "Wrong size on KismetMathLibrary_ComposeTransforms");
static_assert(offsetof(KismetMathLibrary_ComposeTransforms, A) == 0x000000, "Member 'KismetMathLibrary_ComposeTransforms::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ComposeTransforms, B) == 0x000030, "Member 'KismetMathLibrary_ComposeTransforms::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ComposeTransforms, ReturnValue) == 0x000060, "Member 'KismetMathLibrary_ComposeTransforms::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_BoolToByte
// 0x0002 (0x0002 - 0x0000)
struct KismetMathLibrary_Conv_BoolToByte final
{
public:
	bool                                          InBool;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_BoolToByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Conv_BoolToByte");
static_assert(sizeof(KismetMathLibrary_Conv_BoolToByte) == 0x000002, "Wrong size on KismetMathLibrary_Conv_BoolToByte");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToByte, InBool) == 0x000000, "Member 'KismetMathLibrary_Conv_BoolToByte::InBool' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToByte, ReturnValue) == 0x000001, "Member 'KismetMathLibrary_Conv_BoolToByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_BoolToFloat
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_BoolToFloat final
{
public:
	bool                                          InBool;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_BoolToFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_BoolToFloat");
static_assert(sizeof(KismetMathLibrary_Conv_BoolToFloat) == 0x000008, "Wrong size on KismetMathLibrary_Conv_BoolToFloat");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToFloat, InBool) == 0x000000, "Member 'KismetMathLibrary_Conv_BoolToFloat::InBool' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToFloat, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_BoolToFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_BoolToInt
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_BoolToInt final
{
public:
	bool                                          InBool;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_BoolToInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_BoolToInt");
static_assert(sizeof(KismetMathLibrary_Conv_BoolToInt) == 0x000008, "Wrong size on KismetMathLibrary_Conv_BoolToInt");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToInt, InBool) == 0x000000, "Member 'KismetMathLibrary_Conv_BoolToInt::InBool' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_BoolToInt, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_BoolToInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_ByteToFloat
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_ByteToFloat final
{
public:
	uint8                                         InByte;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_ByteToFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_ByteToFloat");
static_assert(sizeof(KismetMathLibrary_Conv_ByteToFloat) == 0x000008, "Wrong size on KismetMathLibrary_Conv_ByteToFloat");
static_assert(offsetof(KismetMathLibrary_Conv_ByteToFloat, InByte) == 0x000000, "Member 'KismetMathLibrary_Conv_ByteToFloat::InByte' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_ByteToFloat, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_ByteToFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_ByteToInt
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_ByteToInt final
{
public:
	uint8                                         InByte;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_ByteToInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_ByteToInt");
static_assert(sizeof(KismetMathLibrary_Conv_ByteToInt) == 0x000008, "Wrong size on KismetMathLibrary_Conv_ByteToInt");
static_assert(offsetof(KismetMathLibrary_Conv_ByteToInt, InByte) == 0x000000, "Member 'KismetMathLibrary_Conv_ByteToInt::InByte' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_ByteToInt, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_ByteToInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_ColorToLinearColor
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Conv_ColorToLinearColor final
{
public:
	struct FColor                                 InColor;                                           // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_ColorToLinearColor) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_ColorToLinearColor");
static_assert(sizeof(KismetMathLibrary_Conv_ColorToLinearColor) == 0x000014, "Wrong size on KismetMathLibrary_Conv_ColorToLinearColor");
static_assert(offsetof(KismetMathLibrary_Conv_ColorToLinearColor, InColor) == 0x000000, "Member 'KismetMathLibrary_Conv_ColorToLinearColor::InColor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_ColorToLinearColor, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_ColorToLinearColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_FloatToLinearColor
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Conv_FloatToLinearColor final
{
public:
	float                                         InFloat;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0004(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_FloatToLinearColor) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_FloatToLinearColor");
static_assert(sizeof(KismetMathLibrary_Conv_FloatToLinearColor) == 0x000014, "Wrong size on KismetMathLibrary_Conv_FloatToLinearColor");
static_assert(offsetof(KismetMathLibrary_Conv_FloatToLinearColor, InFloat) == 0x000000, "Member 'KismetMathLibrary_Conv_FloatToLinearColor::InFloat' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_FloatToLinearColor, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_FloatToLinearColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_FloatToVector
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_Conv_FloatToVector final
{
public:
	float                                         InFloat;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_FloatToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_FloatToVector");
static_assert(sizeof(KismetMathLibrary_Conv_FloatToVector) == 0x000010, "Wrong size on KismetMathLibrary_Conv_FloatToVector");
static_assert(offsetof(KismetMathLibrary_Conv_FloatToVector, InFloat) == 0x000000, "Member 'KismetMathLibrary_Conv_FloatToVector::InFloat' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_FloatToVector, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_FloatToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_IntToBool
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_IntToBool final
{
public:
	int32                                         InInt;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Conv_IntToBool) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_IntToBool");
static_assert(sizeof(KismetMathLibrary_Conv_IntToBool) == 0x000008, "Wrong size on KismetMathLibrary_Conv_IntToBool");
static_assert(offsetof(KismetMathLibrary_Conv_IntToBool, InInt) == 0x000000, "Member 'KismetMathLibrary_Conv_IntToBool::InInt' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_IntToBool, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_IntToBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_IntToByte
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_IntToByte final
{
public:
	int32                                         InInt;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Conv_IntToByte) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_IntToByte");
static_assert(sizeof(KismetMathLibrary_Conv_IntToByte) == 0x000008, "Wrong size on KismetMathLibrary_Conv_IntToByte");
static_assert(offsetof(KismetMathLibrary_Conv_IntToByte, InInt) == 0x000000, "Member 'KismetMathLibrary_Conv_IntToByte::InInt' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_IntToByte, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_IntToByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_IntToFloat
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Conv_IntToFloat final
{
public:
	int32                                         InInt;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_IntToFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_IntToFloat");
static_assert(sizeof(KismetMathLibrary_Conv_IntToFloat) == 0x000008, "Wrong size on KismetMathLibrary_Conv_IntToFloat");
static_assert(offsetof(KismetMathLibrary_Conv_IntToFloat, InInt) == 0x000000, "Member 'KismetMathLibrary_Conv_IntToFloat::InInt' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_IntToFloat, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_IntToFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_IntToIntVector
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_Conv_IntToIntVector final
{
public:
	int32                                         InInt;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_IntToIntVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_IntToIntVector");
static_assert(sizeof(KismetMathLibrary_Conv_IntToIntVector) == 0x000010, "Wrong size on KismetMathLibrary_Conv_IntToIntVector");
static_assert(offsetof(KismetMathLibrary_Conv_IntToIntVector, InInt) == 0x000000, "Member 'KismetMathLibrary_Conv_IntToIntVector::InInt' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_IntToIntVector, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Conv_IntToIntVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_IntVectorToVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Conv_IntVectorToVector final
{
public:
	struct FIntVector                             InIntVector;                                       // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_IntVectorToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_IntVectorToVector");
static_assert(sizeof(KismetMathLibrary_Conv_IntVectorToVector) == 0x000018, "Wrong size on KismetMathLibrary_Conv_IntVectorToVector");
static_assert(offsetof(KismetMathLibrary_Conv_IntVectorToVector, InIntVector) == 0x000000, "Member 'KismetMathLibrary_Conv_IntVectorToVector::InIntVector' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_IntVectorToVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_IntVectorToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_LinearColorToColor
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Conv_LinearColorToColor final
{
public:
	struct FLinearColor                           InLinearColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_LinearColorToColor) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_LinearColorToColor");
static_assert(sizeof(KismetMathLibrary_Conv_LinearColorToColor) == 0x000014, "Wrong size on KismetMathLibrary_Conv_LinearColorToColor");
static_assert(offsetof(KismetMathLibrary_Conv_LinearColorToColor, InLinearColor) == 0x000000, "Member 'KismetMathLibrary_Conv_LinearColorToColor::InLinearColor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_LinearColorToColor, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Conv_LinearColorToColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_LinearColorToVector
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Conv_LinearColorToVector final
{
public:
	struct FLinearColor                           InLinearColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_LinearColorToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_LinearColorToVector");
static_assert(sizeof(KismetMathLibrary_Conv_LinearColorToVector) == 0x00001C, "Wrong size on KismetMathLibrary_Conv_LinearColorToVector");
static_assert(offsetof(KismetMathLibrary_Conv_LinearColorToVector, InLinearColor) == 0x000000, "Member 'KismetMathLibrary_Conv_LinearColorToVector::InLinearColor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_LinearColorToVector, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Conv_LinearColorToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_RotatorToVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Conv_RotatorToVector final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_RotatorToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_RotatorToVector");
static_assert(sizeof(KismetMathLibrary_Conv_RotatorToVector) == 0x000018, "Wrong size on KismetMathLibrary_Conv_RotatorToVector");
static_assert(offsetof(KismetMathLibrary_Conv_RotatorToVector, InRot) == 0x000000, "Member 'KismetMathLibrary_Conv_RotatorToVector::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_RotatorToVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_RotatorToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_Vector2DToVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Conv_Vector2DToVector final
{
public:
	struct FVector2D                              InVector2D;                                        // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_Vector2DToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_Vector2DToVector");
static_assert(sizeof(KismetMathLibrary_Conv_Vector2DToVector) == 0x000018, "Wrong size on KismetMathLibrary_Conv_Vector2DToVector");
static_assert(offsetof(KismetMathLibrary_Conv_Vector2DToVector, InVector2D) == 0x000000, "Member 'KismetMathLibrary_Conv_Vector2DToVector::InVector2D' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_Vector2DToVector, Z) == 0x000008, "Member 'KismetMathLibrary_Conv_Vector2DToVector::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_Vector2DToVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_Vector2DToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_VectorToLinearColor
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Conv_VectorToLinearColor final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x000C(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_VectorToLinearColor) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_VectorToLinearColor");
static_assert(sizeof(KismetMathLibrary_Conv_VectorToLinearColor) == 0x00001C, "Wrong size on KismetMathLibrary_Conv_VectorToLinearColor");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToLinearColor, InVec) == 0x000000, "Member 'KismetMathLibrary_Conv_VectorToLinearColor::InVec' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToLinearColor, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_VectorToLinearColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_VectorToRotator
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Conv_VectorToRotator final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_VectorToRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_VectorToRotator");
static_assert(sizeof(KismetMathLibrary_Conv_VectorToRotator) == 0x000018, "Wrong size on KismetMathLibrary_Conv_VectorToRotator");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToRotator, InVec) == 0x000000, "Member 'KismetMathLibrary_Conv_VectorToRotator::InVec' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToRotator, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_VectorToRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_VectorToTransform
// 0x0040 (0x0040 - 0x0000)
struct KismetMathLibrary_Conv_VectorToTransform final
{
public:
	struct FVector                                InLocation;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_VectorToTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_Conv_VectorToTransform");
static_assert(sizeof(KismetMathLibrary_Conv_VectorToTransform) == 0x000040, "Wrong size on KismetMathLibrary_Conv_VectorToTransform");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToTransform, InLocation) == 0x000000, "Member 'KismetMathLibrary_Conv_VectorToTransform::InLocation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToTransform, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Conv_VectorToTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Conv_VectorToVector2D
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Conv_VectorToVector2D final
{
public:
	struct FVector                                InVector;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Conv_VectorToVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Conv_VectorToVector2D");
static_assert(sizeof(KismetMathLibrary_Conv_VectorToVector2D) == 0x000014, "Wrong size on KismetMathLibrary_Conv_VectorToVector2D");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToVector2D, InVector) == 0x000000, "Member 'KismetMathLibrary_Conv_VectorToVector2D::InVector' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Conv_VectorToVector2D, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Conv_VectorToVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ConvertTransformToRelative
// 0x0090 (0x0090 - 0x0000)
struct KismetMathLibrary_ConvertTransformToRelative final
{
public:
	struct FTransform                             Transform;                                         // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ParentTransform;                                   // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0060(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ConvertTransformToRelative) == 0x000010, "Wrong alignment on KismetMathLibrary_ConvertTransformToRelative");
static_assert(sizeof(KismetMathLibrary_ConvertTransformToRelative) == 0x000090, "Wrong size on KismetMathLibrary_ConvertTransformToRelative");
static_assert(offsetof(KismetMathLibrary_ConvertTransformToRelative, Transform) == 0x000000, "Member 'KismetMathLibrary_ConvertTransformToRelative::Transform' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ConvertTransformToRelative, ParentTransform) == 0x000030, "Member 'KismetMathLibrary_ConvertTransformToRelative::ParentTransform' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ConvertTransformToRelative, ReturnValue) == 0x000060, "Member 'KismetMathLibrary_ConvertTransformToRelative::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Cos
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Cos final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Cos) == 0x000004, "Wrong alignment on KismetMathLibrary_Cos");
static_assert(sizeof(KismetMathLibrary_Cos) == 0x000008, "Wrong size on KismetMathLibrary_Cos");
static_assert(offsetof(KismetMathLibrary_Cos, A) == 0x000000, "Member 'KismetMathLibrary_Cos::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Cos, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Cos::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.CreateVectorFromYawPitch
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_CreateVectorFromYawPitch final
{
public:
	float                                         Yaw;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_CreateVectorFromYawPitch) == 0x000004, "Wrong alignment on KismetMathLibrary_CreateVectorFromYawPitch");
static_assert(sizeof(KismetMathLibrary_CreateVectorFromYawPitch) == 0x000018, "Wrong size on KismetMathLibrary_CreateVectorFromYawPitch");
static_assert(offsetof(KismetMathLibrary_CreateVectorFromYawPitch, Yaw) == 0x000000, "Member 'KismetMathLibrary_CreateVectorFromYawPitch::Yaw' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CreateVectorFromYawPitch, Pitch) == 0x000004, "Member 'KismetMathLibrary_CreateVectorFromYawPitch::Pitch' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CreateVectorFromYawPitch, Length) == 0x000008, "Member 'KismetMathLibrary_CreateVectorFromYawPitch::Length' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CreateVectorFromYawPitch, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_CreateVectorFromYawPitch::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Cross_VectorVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Cross_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Cross_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Cross_VectorVector");
static_assert(sizeof(KismetMathLibrary_Cross_VectorVector) == 0x000024, "Wrong size on KismetMathLibrary_Cross_VectorVector");
static_assert(offsetof(KismetMathLibrary_Cross_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Cross_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Cross_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Cross_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Cross_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Cross_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.CrossProduct2D
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_CrossProduct2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_CrossProduct2D) == 0x000004, "Wrong alignment on KismetMathLibrary_CrossProduct2D");
static_assert(sizeof(KismetMathLibrary_CrossProduct2D) == 0x000014, "Wrong size on KismetMathLibrary_CrossProduct2D");
static_assert(offsetof(KismetMathLibrary_CrossProduct2D, A) == 0x000000, "Member 'KismetMathLibrary_CrossProduct2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CrossProduct2D, B) == 0x000008, "Member 'KismetMathLibrary_CrossProduct2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_CrossProduct2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_CrossProduct2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DateTimeFromIsoString
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_DateTimeFromIsoString final
{
public:
	class FString                                 IsoString;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Result;                                            // 0x0010(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_DateTimeFromIsoString) == 0x000008, "Wrong alignment on KismetMathLibrary_DateTimeFromIsoString");
static_assert(sizeof(KismetMathLibrary_DateTimeFromIsoString) == 0x000020, "Wrong size on KismetMathLibrary_DateTimeFromIsoString");
static_assert(offsetof(KismetMathLibrary_DateTimeFromIsoString, IsoString) == 0x000000, "Member 'KismetMathLibrary_DateTimeFromIsoString::IsoString' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DateTimeFromIsoString, Result) == 0x000010, "Member 'KismetMathLibrary_DateTimeFromIsoString::Result' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DateTimeFromIsoString, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_DateTimeFromIsoString::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DateTimeFromString
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_DateTimeFromString final
{
public:
	class FString                                 DateTimeString;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              Result;                                            // 0x0010(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_DateTimeFromString) == 0x000008, "Wrong alignment on KismetMathLibrary_DateTimeFromString");
static_assert(sizeof(KismetMathLibrary_DateTimeFromString) == 0x000020, "Wrong size on KismetMathLibrary_DateTimeFromString");
static_assert(offsetof(KismetMathLibrary_DateTimeFromString, DateTimeString) == 0x000000, "Member 'KismetMathLibrary_DateTimeFromString::DateTimeString' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DateTimeFromString, Result) == 0x000010, "Member 'KismetMathLibrary_DateTimeFromString::Result' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DateTimeFromString, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_DateTimeFromString::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DateTimeMaxValue
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DateTimeMaxValue final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DateTimeMaxValue) == 0x000008, "Wrong alignment on KismetMathLibrary_DateTimeMaxValue");
static_assert(sizeof(KismetMathLibrary_DateTimeMaxValue) == 0x000008, "Wrong size on KismetMathLibrary_DateTimeMaxValue");
static_assert(offsetof(KismetMathLibrary_DateTimeMaxValue, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_DateTimeMaxValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DateTimeMinValue
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DateTimeMinValue final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DateTimeMinValue) == 0x000008, "Wrong alignment on KismetMathLibrary_DateTimeMinValue");
static_assert(sizeof(KismetMathLibrary_DateTimeMinValue) == 0x000008, "Wrong size on KismetMathLibrary_DateTimeMinValue");
static_assert(offsetof(KismetMathLibrary_DateTimeMinValue, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_DateTimeMinValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DaysInMonth
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_DaysInMonth final
{
public:
	int32                                         Year;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Month;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DaysInMonth) == 0x000004, "Wrong alignment on KismetMathLibrary_DaysInMonth");
static_assert(sizeof(KismetMathLibrary_DaysInMonth) == 0x00000C, "Wrong size on KismetMathLibrary_DaysInMonth");
static_assert(offsetof(KismetMathLibrary_DaysInMonth, Year) == 0x000000, "Member 'KismetMathLibrary_DaysInMonth::Year' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DaysInMonth, Month) == 0x000004, "Member 'KismetMathLibrary_DaysInMonth::Month' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DaysInMonth, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_DaysInMonth::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DaysInYear
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DaysInYear final
{
public:
	int32                                         Year;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DaysInYear) == 0x000004, "Wrong alignment on KismetMathLibrary_DaysInYear");
static_assert(sizeof(KismetMathLibrary_DaysInYear) == 0x000008, "Wrong size on KismetMathLibrary_DaysInYear");
static_assert(offsetof(KismetMathLibrary_DaysInYear, Year) == 0x000000, "Member 'KismetMathLibrary_DaysInYear::Year' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DaysInYear, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DaysInYear::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegAcos
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegAcos final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegAcos) == 0x000004, "Wrong alignment on KismetMathLibrary_DegAcos");
static_assert(sizeof(KismetMathLibrary_DegAcos) == 0x000008, "Wrong size on KismetMathLibrary_DegAcos");
static_assert(offsetof(KismetMathLibrary_DegAcos, A) == 0x000000, "Member 'KismetMathLibrary_DegAcos::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegAcos, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegAcos::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegAsin
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegAsin final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegAsin) == 0x000004, "Wrong alignment on KismetMathLibrary_DegAsin");
static_assert(sizeof(KismetMathLibrary_DegAsin) == 0x000008, "Wrong size on KismetMathLibrary_DegAsin");
static_assert(offsetof(KismetMathLibrary_DegAsin, A) == 0x000000, "Member 'KismetMathLibrary_DegAsin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegAsin, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegAsin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegAtan
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegAtan final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegAtan) == 0x000004, "Wrong alignment on KismetMathLibrary_DegAtan");
static_assert(sizeof(KismetMathLibrary_DegAtan) == 0x000008, "Wrong size on KismetMathLibrary_DegAtan");
static_assert(offsetof(KismetMathLibrary_DegAtan, A) == 0x000000, "Member 'KismetMathLibrary_DegAtan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegAtan, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegAtan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegAtan2
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_DegAtan2 final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegAtan2) == 0x000004, "Wrong alignment on KismetMathLibrary_DegAtan2");
static_assert(sizeof(KismetMathLibrary_DegAtan2) == 0x00000C, "Wrong size on KismetMathLibrary_DegAtan2");
static_assert(offsetof(KismetMathLibrary_DegAtan2, A) == 0x000000, "Member 'KismetMathLibrary_DegAtan2::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegAtan2, B) == 0x000004, "Member 'KismetMathLibrary_DegAtan2::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegAtan2, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_DegAtan2::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegCos
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegCos final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegCos) == 0x000004, "Wrong alignment on KismetMathLibrary_DegCos");
static_assert(sizeof(KismetMathLibrary_DegCos) == 0x000008, "Wrong size on KismetMathLibrary_DegCos");
static_assert(offsetof(KismetMathLibrary_DegCos, A) == 0x000000, "Member 'KismetMathLibrary_DegCos::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegCos, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegCos::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegreesToRadians
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegreesToRadians final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegreesToRadians) == 0x000004, "Wrong alignment on KismetMathLibrary_DegreesToRadians");
static_assert(sizeof(KismetMathLibrary_DegreesToRadians) == 0x000008, "Wrong size on KismetMathLibrary_DegreesToRadians");
static_assert(offsetof(KismetMathLibrary_DegreesToRadians, A) == 0x000000, "Member 'KismetMathLibrary_DegreesToRadians::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegreesToRadians, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegreesToRadians::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegSin
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegSin final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegSin) == 0x000004, "Wrong alignment on KismetMathLibrary_DegSin");
static_assert(sizeof(KismetMathLibrary_DegSin) == 0x000008, "Wrong size on KismetMathLibrary_DegSin");
static_assert(offsetof(KismetMathLibrary_DegSin, A) == 0x000000, "Member 'KismetMathLibrary_DegSin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegSin, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegSin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DegTan
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_DegTan final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DegTan) == 0x000004, "Wrong alignment on KismetMathLibrary_DegTan");
static_assert(sizeof(KismetMathLibrary_DegTan) == 0x000008, "Wrong size on KismetMathLibrary_DegTan");
static_assert(offsetof(KismetMathLibrary_DegTan, A) == 0x000000, "Member 'KismetMathLibrary_DegTan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DegTan, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_DegTan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Divide_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Divide_ByteByte");
static_assert(sizeof(KismetMathLibrary_Divide_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Divide_ByteByte");
static_assert(offsetof(KismetMathLibrary_Divide_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Divide_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Divide_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Divide_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Divide_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Divide_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Divide_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Divide_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Divide_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Divide_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Divide_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Divide_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_IntInt");
static_assert(sizeof(KismetMathLibrary_Divide_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Divide_IntInt");
static_assert(offsetof(KismetMathLibrary_Divide_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Divide_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Divide_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Divide_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_TimespanFloat
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Divide_TimespanFloat final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scalar;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_TimespanFloat) == 0x000008, "Wrong alignment on KismetMathLibrary_Divide_TimespanFloat");
static_assert(sizeof(KismetMathLibrary_Divide_TimespanFloat) == 0x000018, "Wrong size on KismetMathLibrary_Divide_TimespanFloat");
static_assert(offsetof(KismetMathLibrary_Divide_TimespanFloat, A) == 0x000000, "Member 'KismetMathLibrary_Divide_TimespanFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_TimespanFloat, Scalar) == 0x000008, "Member 'KismetMathLibrary_Divide_TimespanFloat::Scalar' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_TimespanFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Divide_TimespanFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_Vector2DFloat
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Divide_Vector2DFloat final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_Vector2DFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_Vector2DFloat");
static_assert(sizeof(KismetMathLibrary_Divide_Vector2DFloat) == 0x000014, "Wrong size on KismetMathLibrary_Divide_Vector2DFloat");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DFloat, A) == 0x000000, "Member 'KismetMathLibrary_Divide_Vector2DFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DFloat, B) == 0x000008, "Member 'KismetMathLibrary_Divide_Vector2DFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Divide_Vector2DFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Divide_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_Divide_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_Divide_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_Divide_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_Divide_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_Vector2DVector2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Divide_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_VectorFloat
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Divide_VectorFloat final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_VectorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_VectorFloat");
static_assert(sizeof(KismetMathLibrary_Divide_VectorFloat) == 0x00001C, "Wrong size on KismetMathLibrary_Divide_VectorFloat");
static_assert(offsetof(KismetMathLibrary_Divide_VectorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Divide_VectorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorFloat, B) == 0x00000C, "Member 'KismetMathLibrary_Divide_VectorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Divide_VectorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_VectorInt
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Divide_VectorInt final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_VectorInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_VectorInt");
static_assert(sizeof(KismetMathLibrary_Divide_VectorInt) == 0x00001C, "Wrong size on KismetMathLibrary_Divide_VectorInt");
static_assert(offsetof(KismetMathLibrary_Divide_VectorInt, A) == 0x000000, "Member 'KismetMathLibrary_Divide_VectorInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorInt, B) == 0x00000C, "Member 'KismetMathLibrary_Divide_VectorInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorInt, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Divide_VectorInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Divide_VectorVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Divide_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Divide_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Divide_VectorVector");
static_assert(sizeof(KismetMathLibrary_Divide_VectorVector) == 0x000024, "Wrong size on KismetMathLibrary_Divide_VectorVector");
static_assert(offsetof(KismetMathLibrary_Divide_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Divide_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Divide_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Divide_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Divide_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Dot_VectorVector
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Dot_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Dot_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Dot_VectorVector");
static_assert(sizeof(KismetMathLibrary_Dot_VectorVector) == 0x00001C, "Wrong size on KismetMathLibrary_Dot_VectorVector");
static_assert(offsetof(KismetMathLibrary_Dot_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Dot_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Dot_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Dot_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Dot_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Dot_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.DotProduct2D
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_DotProduct2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_DotProduct2D) == 0x000004, "Wrong alignment on KismetMathLibrary_DotProduct2D");
static_assert(sizeof(KismetMathLibrary_DotProduct2D) == 0x000014, "Wrong size on KismetMathLibrary_DotProduct2D");
static_assert(offsetof(KismetMathLibrary_DotProduct2D, A) == 0x000000, "Member 'KismetMathLibrary_DotProduct2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DotProduct2D, B) == 0x000008, "Member 'KismetMathLibrary_DotProduct2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_DotProduct2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_DotProduct2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Ease
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Ease final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Ease) == 0x000004, "Wrong alignment on KismetMathLibrary_Ease");
static_assert(sizeof(KismetMathLibrary_Ease) == 0x00001C, "Wrong size on KismetMathLibrary_Ease");
static_assert(offsetof(KismetMathLibrary_Ease, A) == 0x000000, "Member 'KismetMathLibrary_Ease::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, B) == 0x000004, "Member 'KismetMathLibrary_Ease::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, Alpha) == 0x000008, "Member 'KismetMathLibrary_Ease::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, EasingFunc) == 0x00000C, "Member 'KismetMathLibrary_Ease::EasingFunc' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, BlendExp) == 0x000010, "Member 'KismetMathLibrary_Ease::BlendExp' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, Steps) == 0x000014, "Member 'KismetMathLibrary_Ease::Steps' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Ease, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Ease::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_BoolBool
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_EqualEqual_BoolBool final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_EqualEqual_BoolBool) == 0x000001, "Wrong alignment on KismetMathLibrary_EqualEqual_BoolBool");
static_assert(sizeof(KismetMathLibrary_EqualEqual_BoolBool) == 0x000003, "Wrong size on KismetMathLibrary_EqualEqual_BoolBool");
static_assert(offsetof(KismetMathLibrary_EqualEqual_BoolBool, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_BoolBool::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_BoolBool, B) == 0x000001, "Member 'KismetMathLibrary_EqualEqual_BoolBool::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_BoolBool, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_EqualEqual_BoolBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_EqualEqual_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_EqualEqual_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_EqualEqual_ByteByte");
static_assert(sizeof(KismetMathLibrary_EqualEqual_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_EqualEqual_ByteByte");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_EqualEqual_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_EqualEqual_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_ClassClass
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_ClassClass final
{
public:
	class UClass*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_ClassClass) == 0x000008, "Wrong alignment on KismetMathLibrary_EqualEqual_ClassClass");
static_assert(sizeof(KismetMathLibrary_EqualEqual_ClassClass) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_ClassClass");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ClassClass, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_ClassClass::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ClassClass, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_ClassClass::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ClassClass, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_ClassClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_EqualEqual_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_EqualEqual_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_EqualEqual_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_EqualEqual_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_FloatFloat");
static_assert(sizeof(KismetMathLibrary_EqualEqual_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_EqualEqual_FloatFloat");
static_assert(offsetof(KismetMathLibrary_EqualEqual_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_EqualEqual_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_EqualEqual_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_IntInt");
static_assert(sizeof(KismetMathLibrary_EqualEqual_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_EqualEqual_IntInt");
static_assert(offsetof(KismetMathLibrary_EqualEqual_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_EqualEqual_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_NameName
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_NameName final
{
public:
	class FName                                   A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_NameName) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_NameName");
static_assert(sizeof(KismetMathLibrary_EqualEqual_NameName) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_NameName");
static_assert(offsetof(KismetMathLibrary_EqualEqual_NameName, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_NameName::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_NameName, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_NameName::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_NameName, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_NameName::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_ObjectObject
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_ObjectObject final
{
public:
	class UObject*                                A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_ObjectObject) == 0x000008, "Wrong alignment on KismetMathLibrary_EqualEqual_ObjectObject");
static_assert(sizeof(KismetMathLibrary_EqualEqual_ObjectObject) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_ObjectObject");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ObjectObject, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_ObjectObject::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ObjectObject, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_ObjectObject::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_ObjectObject, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_ObjectObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_RotatorRotator
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_EqualEqual_RotatorRotator final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_RotatorRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_RotatorRotator");
static_assert(sizeof(KismetMathLibrary_EqualEqual_RotatorRotator) == 0x000020, "Wrong size on KismetMathLibrary_EqualEqual_RotatorRotator");
static_assert(offsetof(KismetMathLibrary_EqualEqual_RotatorRotator, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_RotatorRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_RotatorRotator, B) == 0x00000C, "Member 'KismetMathLibrary_EqualEqual_RotatorRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_RotatorRotator, ErrorTolerance) == 0x000018, "Member 'KismetMathLibrary_EqualEqual_RotatorRotator::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_RotatorRotator, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_EqualEqual_RotatorRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_EqualEqual_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_EqualEqual_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_TransformTransform
// 0x0070 (0x0070 - 0x0000)
struct KismetMathLibrary_EqualEqual_TransformTransform final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0060(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_TransformTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_EqualEqual_TransformTransform");
static_assert(sizeof(KismetMathLibrary_EqualEqual_TransformTransform) == 0x000070, "Wrong size on KismetMathLibrary_EqualEqual_TransformTransform");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TransformTransform, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_TransformTransform::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TransformTransform, B) == 0x000030, "Member 'KismetMathLibrary_EqualEqual_TransformTransform::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_TransformTransform, ReturnValue) == 0x000060, "Member 'KismetMathLibrary_EqualEqual_TransformTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_EqualEqual_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_EqualEqual_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_EqualEqual_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_EqualEqual_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_EqualEqual_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_Vector2DVector2D, ErrorTolerance) == 0x000010, "Member 'KismetMathLibrary_EqualEqual_Vector2DVector2D::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_Vector2DVector2D, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_EqualEqual_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.EqualEqual_VectorVector
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_EqualEqual_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_EqualEqual_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_EqualEqual_VectorVector");
static_assert(sizeof(KismetMathLibrary_EqualEqual_VectorVector) == 0x000020, "Wrong size on KismetMathLibrary_EqualEqual_VectorVector");
static_assert(offsetof(KismetMathLibrary_EqualEqual_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_EqualEqual_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_EqualEqual_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_VectorVector, ErrorTolerance) == 0x000018, "Member 'KismetMathLibrary_EqualEqual_VectorVector::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_EqualEqual_VectorVector, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_EqualEqual_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Exp
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Exp final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Exp) == 0x000004, "Wrong alignment on KismetMathLibrary_Exp");
static_assert(sizeof(KismetMathLibrary_Exp) == 0x000008, "Wrong size on KismetMathLibrary_Exp");
static_assert(offsetof(KismetMathLibrary_Exp, A) == 0x000000, "Member 'KismetMathLibrary_Exp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Exp, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Exp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FCeil
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_FCeil final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FCeil) == 0x000004, "Wrong alignment on KismetMathLibrary_FCeil");
static_assert(sizeof(KismetMathLibrary_FCeil) == 0x000008, "Wrong size on KismetMathLibrary_FCeil");
static_assert(offsetof(KismetMathLibrary_FCeil, A) == 0x000000, "Member 'KismetMathLibrary_FCeil::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FCeil, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_FCeil::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FClamp
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FClamp final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_0;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_0;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FClamp) == 0x000004, "Wrong alignment on KismetMathLibrary_FClamp");
static_assert(sizeof(KismetMathLibrary_FClamp) == 0x000010, "Wrong size on KismetMathLibrary_FClamp");
static_assert(offsetof(KismetMathLibrary_FClamp, Value) == 0x000000, "Member 'KismetMathLibrary_FClamp::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FClamp, Min_0) == 0x000004, "Member 'KismetMathLibrary_FClamp::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FClamp, Max_0) == 0x000008, "Member 'KismetMathLibrary_FClamp::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FClamp, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_FClamp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FFloor
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_FFloor final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FFloor) == 0x000004, "Wrong alignment on KismetMathLibrary_FFloor");
static_assert(sizeof(KismetMathLibrary_FFloor) == 0x000008, "Wrong size on KismetMathLibrary_FFloor");
static_assert(offsetof(KismetMathLibrary_FFloor, A) == 0x000000, "Member 'KismetMathLibrary_FFloor::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FFloor, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_FFloor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FindClosestPointOnLine
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_FindClosestPointOnLine final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineOrigin;                                        // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineDirection;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FindClosestPointOnLine) == 0x000004, "Wrong alignment on KismetMathLibrary_FindClosestPointOnLine");
static_assert(sizeof(KismetMathLibrary_FindClosestPointOnLine) == 0x000030, "Wrong size on KismetMathLibrary_FindClosestPointOnLine");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnLine, Point) == 0x000000, "Member 'KismetMathLibrary_FindClosestPointOnLine::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnLine, LineOrigin) == 0x00000C, "Member 'KismetMathLibrary_FindClosestPointOnLine::LineOrigin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnLine, LineDirection) == 0x000018, "Member 'KismetMathLibrary_FindClosestPointOnLine::LineDirection' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnLine, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_FindClosestPointOnLine::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FindClosestPointOnSegment
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_FindClosestPointOnSegment final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentStart;                                      // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentEnd;                                        // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FindClosestPointOnSegment) == 0x000004, "Wrong alignment on KismetMathLibrary_FindClosestPointOnSegment");
static_assert(sizeof(KismetMathLibrary_FindClosestPointOnSegment) == 0x000030, "Wrong size on KismetMathLibrary_FindClosestPointOnSegment");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnSegment, Point) == 0x000000, "Member 'KismetMathLibrary_FindClosestPointOnSegment::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnSegment, SegmentStart) == 0x00000C, "Member 'KismetMathLibrary_FindClosestPointOnSegment::SegmentStart' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnSegment, SegmentEnd) == 0x000018, "Member 'KismetMathLibrary_FindClosestPointOnSegment::SegmentEnd' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindClosestPointOnSegment, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_FindClosestPointOnSegment::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FindLookAtRotation
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_FindLookAtRotation final
{
public:
	struct FVector                                Start;                                             // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FindLookAtRotation) == 0x000004, "Wrong alignment on KismetMathLibrary_FindLookAtRotation");
static_assert(sizeof(KismetMathLibrary_FindLookAtRotation) == 0x000024, "Wrong size on KismetMathLibrary_FindLookAtRotation");
static_assert(offsetof(KismetMathLibrary_FindLookAtRotation, Start) == 0x000000, "Member 'KismetMathLibrary_FindLookAtRotation::Start' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindLookAtRotation, Target) == 0x00000C, "Member 'KismetMathLibrary_FindLookAtRotation::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindLookAtRotation, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_FindLookAtRotation::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FindNearestPointsOnLineSegments
// 0x0048 (0x0048 - 0x0000)
struct KismetMathLibrary_FindNearestPointsOnLineSegments final
{
public:
	struct FVector                                Segment1Start;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Segment1End;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Segment2Start;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Segment2End;                                       // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Segment1Point;                                     // 0x0030(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Segment2Point;                                     // 0x003C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FindNearestPointsOnLineSegments) == 0x000004, "Wrong alignment on KismetMathLibrary_FindNearestPointsOnLineSegments");
static_assert(sizeof(KismetMathLibrary_FindNearestPointsOnLineSegments) == 0x000048, "Wrong size on KismetMathLibrary_FindNearestPointsOnLineSegments");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment1Start) == 0x000000, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment1Start' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment1End) == 0x00000C, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment1End' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment2Start) == 0x000018, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment2Start' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment2End) == 0x000024, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment2End' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment1Point) == 0x000030, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment1Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FindNearestPointsOnLineSegments, Segment2Point) == 0x00003C, "Member 'KismetMathLibrary_FindNearestPointsOnLineSegments::Segment2Point' has a wrong offset!");

// Function Engine.KismetMathLibrary.FInterpEaseInOut
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_FInterpEaseInOut final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exponent;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FInterpEaseInOut) == 0x000004, "Wrong alignment on KismetMathLibrary_FInterpEaseInOut");
static_assert(sizeof(KismetMathLibrary_FInterpEaseInOut) == 0x000014, "Wrong size on KismetMathLibrary_FInterpEaseInOut");
static_assert(offsetof(KismetMathLibrary_FInterpEaseInOut, A) == 0x000000, "Member 'KismetMathLibrary_FInterpEaseInOut::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpEaseInOut, B) == 0x000004, "Member 'KismetMathLibrary_FInterpEaseInOut::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpEaseInOut, Alpha) == 0x000008, "Member 'KismetMathLibrary_FInterpEaseInOut::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpEaseInOut, Exponent) == 0x00000C, "Member 'KismetMathLibrary_FInterpEaseInOut::Exponent' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpEaseInOut, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_FInterpEaseInOut::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FInterpTo
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_FInterpTo final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FInterpTo) == 0x000004, "Wrong alignment on KismetMathLibrary_FInterpTo");
static_assert(sizeof(KismetMathLibrary_FInterpTo) == 0x000014, "Wrong size on KismetMathLibrary_FInterpTo");
static_assert(offsetof(KismetMathLibrary_FInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_FInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo, Target) == 0x000004, "Member 'KismetMathLibrary_FInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo, DeltaTime) == 0x000008, "Member 'KismetMathLibrary_FInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo, InterpSpeed) == 0x00000C, "Member 'KismetMathLibrary_FInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_FInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FInterpTo_Constant
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_FInterpTo_Constant final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FInterpTo_Constant) == 0x000004, "Wrong alignment on KismetMathLibrary_FInterpTo_Constant");
static_assert(sizeof(KismetMathLibrary_FInterpTo_Constant) == 0x000014, "Wrong size on KismetMathLibrary_FInterpTo_Constant");
static_assert(offsetof(KismetMathLibrary_FInterpTo_Constant, Current) == 0x000000, "Member 'KismetMathLibrary_FInterpTo_Constant::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo_Constant, Target) == 0x000004, "Member 'KismetMathLibrary_FInterpTo_Constant::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo_Constant, DeltaTime) == 0x000008, "Member 'KismetMathLibrary_FInterpTo_Constant::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo_Constant, InterpSpeed) == 0x00000C, "Member 'KismetMathLibrary_FInterpTo_Constant::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FInterpTo_Constant, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_FInterpTo_Constant::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FixedTurn
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FixedTurn final
{
public:
	float                                         InCurrent;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDesired;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InDeltaRate;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FixedTurn) == 0x000004, "Wrong alignment on KismetMathLibrary_FixedTurn");
static_assert(sizeof(KismetMathLibrary_FixedTurn) == 0x000010, "Wrong size on KismetMathLibrary_FixedTurn");
static_assert(offsetof(KismetMathLibrary_FixedTurn, InCurrent) == 0x000000, "Member 'KismetMathLibrary_FixedTurn::InCurrent' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FixedTurn, InDesired) == 0x000004, "Member 'KismetMathLibrary_FixedTurn::InDesired' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FixedTurn, InDeltaRate) == 0x000008, "Member 'KismetMathLibrary_FixedTurn::InDeltaRate' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FixedTurn, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_FixedTurn::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FloatSpringInterp
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_FloatSpringInterp final
{
public:
	float                                         Current;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Target;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFloatSpringState                      SpringState;                                       // 0x0008(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDampingFactor;                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FloatSpringInterp) == 0x000004, "Wrong alignment on KismetMathLibrary_FloatSpringInterp");
static_assert(sizeof(KismetMathLibrary_FloatSpringInterp) == 0x000024, "Wrong size on KismetMathLibrary_FloatSpringInterp");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, Current) == 0x000000, "Member 'KismetMathLibrary_FloatSpringInterp::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, Target) == 0x000004, "Member 'KismetMathLibrary_FloatSpringInterp::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, SpringState) == 0x000008, "Member 'KismetMathLibrary_FloatSpringInterp::SpringState' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, Stiffness) == 0x000010, "Member 'KismetMathLibrary_FloatSpringInterp::Stiffness' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, CriticalDampingFactor) == 0x000014, "Member 'KismetMathLibrary_FloatSpringInterp::CriticalDampingFactor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, DeltaTime) == 0x000018, "Member 'KismetMathLibrary_FloatSpringInterp::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, Mass) == 0x00001C, "Member 'KismetMathLibrary_FloatSpringInterp::Mass' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FloatSpringInterp, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_FloatSpringInterp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FMax
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_FMax final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FMax) == 0x000004, "Wrong alignment on KismetMathLibrary_FMax");
static_assert(sizeof(KismetMathLibrary_FMax) == 0x00000C, "Wrong size on KismetMathLibrary_FMax");
static_assert(offsetof(KismetMathLibrary_FMax, A) == 0x000000, "Member 'KismetMathLibrary_FMax::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMax, B) == 0x000004, "Member 'KismetMathLibrary_FMax::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMax, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FMax::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FMin
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_FMin final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FMin) == 0x000004, "Wrong alignment on KismetMathLibrary_FMin");
static_assert(sizeof(KismetMathLibrary_FMin) == 0x00000C, "Wrong size on KismetMathLibrary_FMin");
static_assert(offsetof(KismetMathLibrary_FMin, A) == 0x000000, "Member 'KismetMathLibrary_FMin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMin, B) == 0x000004, "Member 'KismetMathLibrary_FMin::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMin, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FMin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FMod
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FMod final
{
public:
	float                                         Dividend;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Divisor;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Remainder;                                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FMod) == 0x000004, "Wrong alignment on KismetMathLibrary_FMod");
static_assert(sizeof(KismetMathLibrary_FMod) == 0x000010, "Wrong size on KismetMathLibrary_FMod");
static_assert(offsetof(KismetMathLibrary_FMod, Dividend) == 0x000000, "Member 'KismetMathLibrary_FMod::Dividend' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMod, Divisor) == 0x000004, "Member 'KismetMathLibrary_FMod::Divisor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMod, Remainder) == 0x000008, "Member 'KismetMathLibrary_FMod::Remainder' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FMod, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_FMod::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Fraction
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Fraction final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Fraction) == 0x000004, "Wrong alignment on KismetMathLibrary_Fraction");
static_assert(sizeof(KismetMathLibrary_Fraction) == 0x000008, "Wrong size on KismetMathLibrary_Fraction");
static_assert(offsetof(KismetMathLibrary_Fraction, A) == 0x000000, "Member 'KismetMathLibrary_Fraction::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Fraction, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Fraction::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FromDays
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FromDays final
{
public:
	float                                         Days;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FromDays) == 0x000008, "Wrong alignment on KismetMathLibrary_FromDays");
static_assert(sizeof(KismetMathLibrary_FromDays) == 0x000010, "Wrong size on KismetMathLibrary_FromDays");
static_assert(offsetof(KismetMathLibrary_FromDays, Days) == 0x000000, "Member 'KismetMathLibrary_FromDays::Days' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FromDays, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FromDays::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FromHours
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FromHours final
{
public:
	float                                         Hours;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FromHours) == 0x000008, "Wrong alignment on KismetMathLibrary_FromHours");
static_assert(sizeof(KismetMathLibrary_FromHours) == 0x000010, "Wrong size on KismetMathLibrary_FromHours");
static_assert(offsetof(KismetMathLibrary_FromHours, Hours) == 0x000000, "Member 'KismetMathLibrary_FromHours::Hours' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FromHours, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FromHours::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FromMilliseconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FromMilliseconds final
{
public:
	float                                         Milliseconds;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FromMilliseconds) == 0x000008, "Wrong alignment on KismetMathLibrary_FromMilliseconds");
static_assert(sizeof(KismetMathLibrary_FromMilliseconds) == 0x000010, "Wrong size on KismetMathLibrary_FromMilliseconds");
static_assert(offsetof(KismetMathLibrary_FromMilliseconds, Milliseconds) == 0x000000, "Member 'KismetMathLibrary_FromMilliseconds::Milliseconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FromMilliseconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FromMilliseconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FromMinutes
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FromMinutes final
{
public:
	float                                         Minutes;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FromMinutes) == 0x000008, "Wrong alignment on KismetMathLibrary_FromMinutes");
static_assert(sizeof(KismetMathLibrary_FromMinutes) == 0x000010, "Wrong size on KismetMathLibrary_FromMinutes");
static_assert(offsetof(KismetMathLibrary_FromMinutes, Minutes) == 0x000000, "Member 'KismetMathLibrary_FromMinutes::Minutes' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FromMinutes, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FromMinutes::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FromSeconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_FromSeconds final
{
public:
	float                                         Seconds;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FromSeconds) == 0x000008, "Wrong alignment on KismetMathLibrary_FromSeconds");
static_assert(sizeof(KismetMathLibrary_FromSeconds) == 0x000010, "Wrong size on KismetMathLibrary_FromSeconds");
static_assert(offsetof(KismetMathLibrary_FromSeconds, Seconds) == 0x000000, "Member 'KismetMathLibrary_FromSeconds::Seconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FromSeconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_FromSeconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FTrunc
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_FTrunc final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FTrunc) == 0x000004, "Wrong alignment on KismetMathLibrary_FTrunc");
static_assert(sizeof(KismetMathLibrary_FTrunc) == 0x000008, "Wrong size on KismetMathLibrary_FTrunc");
static_assert(offsetof(KismetMathLibrary_FTrunc, A) == 0x000000, "Member 'KismetMathLibrary_FTrunc::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FTrunc, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_FTrunc::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.FTruncVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_FTruncVector final
{
public:
	struct FVector                                InVector;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_FTruncVector) == 0x000004, "Wrong alignment on KismetMathLibrary_FTruncVector");
static_assert(sizeof(KismetMathLibrary_FTruncVector) == 0x000018, "Wrong size on KismetMathLibrary_FTruncVector");
static_assert(offsetof(KismetMathLibrary_FTruncVector, InVector) == 0x000000, "Member 'KismetMathLibrary_FTruncVector::InVector' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_FTruncVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_FTruncVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetAxes
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_GetAxes final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x0018(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetAxes) == 0x000004, "Wrong alignment on KismetMathLibrary_GetAxes");
static_assert(sizeof(KismetMathLibrary_GetAxes) == 0x000030, "Wrong size on KismetMathLibrary_GetAxes");
static_assert(offsetof(KismetMathLibrary_GetAxes, A) == 0x000000, "Member 'KismetMathLibrary_GetAxes::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAxes, X) == 0x00000C, "Member 'KismetMathLibrary_GetAxes::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAxes, Y) == 0x000018, "Member 'KismetMathLibrary_GetAxes::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAxes, Z) == 0x000024, "Member 'KismetMathLibrary_GetAxes::Z' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetAzimuthAndElevation
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_GetAzimuthAndElevation final
{
public:
	struct FVector                                InDirection;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReferenceFrame;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Azimuth;                                           // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Elevation;                                         // 0x0044(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetAzimuthAndElevation) == 0x000010, "Wrong alignment on KismetMathLibrary_GetAzimuthAndElevation");
static_assert(sizeof(KismetMathLibrary_GetAzimuthAndElevation) == 0x000050, "Wrong size on KismetMathLibrary_GetAzimuthAndElevation");
static_assert(offsetof(KismetMathLibrary_GetAzimuthAndElevation, InDirection) == 0x000000, "Member 'KismetMathLibrary_GetAzimuthAndElevation::InDirection' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAzimuthAndElevation, ReferenceFrame) == 0x000010, "Member 'KismetMathLibrary_GetAzimuthAndElevation::ReferenceFrame' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAzimuthAndElevation, Azimuth) == 0x000040, "Member 'KismetMathLibrary_GetAzimuthAndElevation::Azimuth' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetAzimuthAndElevation, Elevation) == 0x000044, "Member 'KismetMathLibrary_GetAzimuthAndElevation::Elevation' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDate
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetDate final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetDate) == 0x000008, "Wrong alignment on KismetMathLibrary_GetDate");
static_assert(sizeof(KismetMathLibrary_GetDate) == 0x000010, "Wrong size on KismetMathLibrary_GetDate");
static_assert(offsetof(KismetMathLibrary_GetDate, A) == 0x000000, "Member 'KismetMathLibrary_GetDate::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDate, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetDate::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDay
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetDay final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetDay) == 0x000008, "Wrong alignment on KismetMathLibrary_GetDay");
static_assert(sizeof(KismetMathLibrary_GetDay) == 0x000010, "Wrong size on KismetMathLibrary_GetDay");
static_assert(offsetof(KismetMathLibrary_GetDay, A) == 0x000000, "Member 'KismetMathLibrary_GetDay::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDay, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetDay::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDayOfYear
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetDayOfYear final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetDayOfYear) == 0x000008, "Wrong alignment on KismetMathLibrary_GetDayOfYear");
static_assert(sizeof(KismetMathLibrary_GetDayOfYear) == 0x000010, "Wrong size on KismetMathLibrary_GetDayOfYear");
static_assert(offsetof(KismetMathLibrary_GetDayOfYear, A) == 0x000000, "Member 'KismetMathLibrary_GetDayOfYear::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDayOfYear, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetDayOfYear::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDays
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetDays final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetDays) == 0x000008, "Wrong alignment on KismetMathLibrary_GetDays");
static_assert(sizeof(KismetMathLibrary_GetDays) == 0x000010, "Wrong size on KismetMathLibrary_GetDays");
static_assert(offsetof(KismetMathLibrary_GetDays, A) == 0x000000, "Member 'KismetMathLibrary_GetDays::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDays, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetDays::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDirectionUnitVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_GetDirectionUnitVector final
{
public:
	struct FVector                                From;                                              // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                To;                                                // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetDirectionUnitVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetDirectionUnitVector");
static_assert(sizeof(KismetMathLibrary_GetDirectionUnitVector) == 0x000024, "Wrong size on KismetMathLibrary_GetDirectionUnitVector");
static_assert(offsetof(KismetMathLibrary_GetDirectionUnitVector, From) == 0x000000, "Member 'KismetMathLibrary_GetDirectionUnitVector::From' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDirectionUnitVector, To) == 0x00000C, "Member 'KismetMathLibrary_GetDirectionUnitVector::To' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDirectionUnitVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_GetDirectionUnitVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetDuration
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetDuration final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetDuration) == 0x000008, "Wrong alignment on KismetMathLibrary_GetDuration");
static_assert(sizeof(KismetMathLibrary_GetDuration) == 0x000010, "Wrong size on KismetMathLibrary_GetDuration");
static_assert(offsetof(KismetMathLibrary_GetDuration, A) == 0x000000, "Member 'KismetMathLibrary_GetDuration::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetDuration, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetDuration::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetForwardVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_GetForwardVector final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetForwardVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetForwardVector");
static_assert(sizeof(KismetMathLibrary_GetForwardVector) == 0x000018, "Wrong size on KismetMathLibrary_GetForwardVector");
static_assert(offsetof(KismetMathLibrary_GetForwardVector, InRot) == 0x000000, "Member 'KismetMathLibrary_GetForwardVector::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetForwardVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_GetForwardVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetHour
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetHour final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetHour) == 0x000008, "Wrong alignment on KismetMathLibrary_GetHour");
static_assert(sizeof(KismetMathLibrary_GetHour) == 0x000010, "Wrong size on KismetMathLibrary_GetHour");
static_assert(offsetof(KismetMathLibrary_GetHour, A) == 0x000000, "Member 'KismetMathLibrary_GetHour::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetHour, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetHour::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetHour12
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetHour12 final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetHour12) == 0x000008, "Wrong alignment on KismetMathLibrary_GetHour12");
static_assert(sizeof(KismetMathLibrary_GetHour12) == 0x000010, "Wrong size on KismetMathLibrary_GetHour12");
static_assert(offsetof(KismetMathLibrary_GetHour12, A) == 0x000000, "Member 'KismetMathLibrary_GetHour12::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetHour12, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetHour12::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetHours
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetHours final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetHours) == 0x000008, "Wrong alignment on KismetMathLibrary_GetHours");
static_assert(sizeof(KismetMathLibrary_GetHours) == 0x000010, "Wrong size on KismetMathLibrary_GetHours");
static_assert(offsetof(KismetMathLibrary_GetHours, A) == 0x000000, "Member 'KismetMathLibrary_GetHours::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetHours, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetHours::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMaxElement
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMaxElement final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetMaxElement) == 0x000004, "Wrong alignment on KismetMathLibrary_GetMaxElement");
static_assert(sizeof(KismetMathLibrary_GetMaxElement) == 0x000010, "Wrong size on KismetMathLibrary_GetMaxElement");
static_assert(offsetof(KismetMathLibrary_GetMaxElement, A) == 0x000000, "Member 'KismetMathLibrary_GetMaxElement::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMaxElement, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_GetMaxElement::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMillisecond
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMillisecond final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetMillisecond) == 0x000008, "Wrong alignment on KismetMathLibrary_GetMillisecond");
static_assert(sizeof(KismetMathLibrary_GetMillisecond) == 0x000010, "Wrong size on KismetMathLibrary_GetMillisecond");
static_assert(offsetof(KismetMathLibrary_GetMillisecond, A) == 0x000000, "Member 'KismetMathLibrary_GetMillisecond::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMillisecond, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetMillisecond::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMilliseconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMilliseconds final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetMilliseconds) == 0x000008, "Wrong alignment on KismetMathLibrary_GetMilliseconds");
static_assert(sizeof(KismetMathLibrary_GetMilliseconds) == 0x000010, "Wrong size on KismetMathLibrary_GetMilliseconds");
static_assert(offsetof(KismetMathLibrary_GetMilliseconds, A) == 0x000000, "Member 'KismetMathLibrary_GetMilliseconds::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMilliseconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetMilliseconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMinElement
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMinElement final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetMinElement) == 0x000004, "Wrong alignment on KismetMathLibrary_GetMinElement");
static_assert(sizeof(KismetMathLibrary_GetMinElement) == 0x000010, "Wrong size on KismetMathLibrary_GetMinElement");
static_assert(offsetof(KismetMathLibrary_GetMinElement, A) == 0x000000, "Member 'KismetMathLibrary_GetMinElement::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMinElement, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_GetMinElement::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMinute
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMinute final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetMinute) == 0x000008, "Wrong alignment on KismetMathLibrary_GetMinute");
static_assert(sizeof(KismetMathLibrary_GetMinute) == 0x000010, "Wrong size on KismetMathLibrary_GetMinute");
static_assert(offsetof(KismetMathLibrary_GetMinute, A) == 0x000000, "Member 'KismetMathLibrary_GetMinute::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMinute, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetMinute::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMinutes
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMinutes final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetMinutes) == 0x000008, "Wrong alignment on KismetMathLibrary_GetMinutes");
static_assert(sizeof(KismetMathLibrary_GetMinutes) == 0x000010, "Wrong size on KismetMathLibrary_GetMinutes");
static_assert(offsetof(KismetMathLibrary_GetMinutes, A) == 0x000000, "Member 'KismetMathLibrary_GetMinutes::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMinutes, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetMinutes::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetMonth
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetMonth final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetMonth) == 0x000008, "Wrong alignment on KismetMathLibrary_GetMonth");
static_assert(sizeof(KismetMathLibrary_GetMonth) == 0x000010, "Wrong size on KismetMathLibrary_GetMonth");
static_assert(offsetof(KismetMathLibrary_GetMonth, A) == 0x000000, "Member 'KismetMathLibrary_GetMonth::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetMonth, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetMonth::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetPI
// 0x0004 (0x0004 - 0x0000)
struct KismetMathLibrary_GetPI final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetPI) == 0x000004, "Wrong alignment on KismetMathLibrary_GetPI");
static_assert(sizeof(KismetMathLibrary_GetPI) == 0x000004, "Wrong size on KismetMathLibrary_GetPI");
static_assert(offsetof(KismetMathLibrary_GetPI, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_GetPI::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetPointDistanceToLine
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_GetPointDistanceToLine final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineOrigin;                                        // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineDirection;                                     // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetPointDistanceToLine) == 0x000004, "Wrong alignment on KismetMathLibrary_GetPointDistanceToLine");
static_assert(sizeof(KismetMathLibrary_GetPointDistanceToLine) == 0x000028, "Wrong size on KismetMathLibrary_GetPointDistanceToLine");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToLine, Point) == 0x000000, "Member 'KismetMathLibrary_GetPointDistanceToLine::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToLine, LineOrigin) == 0x00000C, "Member 'KismetMathLibrary_GetPointDistanceToLine::LineOrigin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToLine, LineDirection) == 0x000018, "Member 'KismetMathLibrary_GetPointDistanceToLine::LineDirection' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToLine, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_GetPointDistanceToLine::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetPointDistanceToSegment
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_GetPointDistanceToSegment final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentStart;                                      // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SegmentEnd;                                        // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetPointDistanceToSegment) == 0x000004, "Wrong alignment on KismetMathLibrary_GetPointDistanceToSegment");
static_assert(sizeof(KismetMathLibrary_GetPointDistanceToSegment) == 0x000028, "Wrong size on KismetMathLibrary_GetPointDistanceToSegment");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToSegment, Point) == 0x000000, "Member 'KismetMathLibrary_GetPointDistanceToSegment::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToSegment, SegmentStart) == 0x00000C, "Member 'KismetMathLibrary_GetPointDistanceToSegment::SegmentStart' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToSegment, SegmentEnd) == 0x000018, "Member 'KismetMathLibrary_GetPointDistanceToSegment::SegmentEnd' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetPointDistanceToSegment, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_GetPointDistanceToSegment::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetReflectionVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_GetReflectionVector final
{
public:
	struct FVector                                Direction;                                         // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SurfaceNormal;                                     // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetReflectionVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetReflectionVector");
static_assert(sizeof(KismetMathLibrary_GetReflectionVector) == 0x000024, "Wrong size on KismetMathLibrary_GetReflectionVector");
static_assert(offsetof(KismetMathLibrary_GetReflectionVector, Direction) == 0x000000, "Member 'KismetMathLibrary_GetReflectionVector::Direction' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetReflectionVector, SurfaceNormal) == 0x00000C, "Member 'KismetMathLibrary_GetReflectionVector::SurfaceNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetReflectionVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_GetReflectionVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetRightVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_GetRightVector final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetRightVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetRightVector");
static_assert(sizeof(KismetMathLibrary_GetRightVector) == 0x000018, "Wrong size on KismetMathLibrary_GetRightVector");
static_assert(offsetof(KismetMathLibrary_GetRightVector, InRot) == 0x000000, "Member 'KismetMathLibrary_GetRightVector::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetRightVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_GetRightVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetSecond
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetSecond final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetSecond) == 0x000008, "Wrong alignment on KismetMathLibrary_GetSecond");
static_assert(sizeof(KismetMathLibrary_GetSecond) == 0x000010, "Wrong size on KismetMathLibrary_GetSecond");
static_assert(offsetof(KismetMathLibrary_GetSecond, A) == 0x000000, "Member 'KismetMathLibrary_GetSecond::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetSecond, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetSecond::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetSeconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetSeconds final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetSeconds) == 0x000008, "Wrong alignment on KismetMathLibrary_GetSeconds");
static_assert(sizeof(KismetMathLibrary_GetSeconds) == 0x000010, "Wrong size on KismetMathLibrary_GetSeconds");
static_assert(offsetof(KismetMathLibrary_GetSeconds, A) == 0x000000, "Member 'KismetMathLibrary_GetSeconds::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetSeconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetSeconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTAU
// 0x0004 (0x0004 - 0x0000)
struct KismetMathLibrary_GetTAU final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetTAU) == 0x000004, "Wrong alignment on KismetMathLibrary_GetTAU");
static_assert(sizeof(KismetMathLibrary_GetTAU) == 0x000004, "Wrong size on KismetMathLibrary_GetTAU");
static_assert(offsetof(KismetMathLibrary_GetTAU, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_GetTAU::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTimeOfDay
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTimeOfDay final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetTimeOfDay) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTimeOfDay");
static_assert(sizeof(KismetMathLibrary_GetTimeOfDay) == 0x000010, "Wrong size on KismetMathLibrary_GetTimeOfDay");
static_assert(offsetof(KismetMathLibrary_GetTimeOfDay, A) == 0x000000, "Member 'KismetMathLibrary_GetTimeOfDay::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTimeOfDay, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTimeOfDay::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTotalDays
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTotalDays final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetTotalDays) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTotalDays");
static_assert(sizeof(KismetMathLibrary_GetTotalDays) == 0x000010, "Wrong size on KismetMathLibrary_GetTotalDays");
static_assert(offsetof(KismetMathLibrary_GetTotalDays, A) == 0x000000, "Member 'KismetMathLibrary_GetTotalDays::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTotalDays, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTotalDays::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTotalHours
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTotalHours final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetTotalHours) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTotalHours");
static_assert(sizeof(KismetMathLibrary_GetTotalHours) == 0x000010, "Wrong size on KismetMathLibrary_GetTotalHours");
static_assert(offsetof(KismetMathLibrary_GetTotalHours, A) == 0x000000, "Member 'KismetMathLibrary_GetTotalHours::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTotalHours, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTotalHours::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTotalMilliseconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTotalMilliseconds final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetTotalMilliseconds) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTotalMilliseconds");
static_assert(sizeof(KismetMathLibrary_GetTotalMilliseconds) == 0x000010, "Wrong size on KismetMathLibrary_GetTotalMilliseconds");
static_assert(offsetof(KismetMathLibrary_GetTotalMilliseconds, A) == 0x000000, "Member 'KismetMathLibrary_GetTotalMilliseconds::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTotalMilliseconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTotalMilliseconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTotalMinutes
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTotalMinutes final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetTotalMinutes) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTotalMinutes");
static_assert(sizeof(KismetMathLibrary_GetTotalMinutes) == 0x000010, "Wrong size on KismetMathLibrary_GetTotalMinutes");
static_assert(offsetof(KismetMathLibrary_GetTotalMinutes, A) == 0x000000, "Member 'KismetMathLibrary_GetTotalMinutes::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTotalMinutes, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTotalMinutes::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetTotalSeconds
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetTotalSeconds final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetTotalSeconds) == 0x000008, "Wrong alignment on KismetMathLibrary_GetTotalSeconds");
static_assert(sizeof(KismetMathLibrary_GetTotalSeconds) == 0x000010, "Wrong size on KismetMathLibrary_GetTotalSeconds");
static_assert(offsetof(KismetMathLibrary_GetTotalSeconds, A) == 0x000000, "Member 'KismetMathLibrary_GetTotalSeconds::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetTotalSeconds, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetTotalSeconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetUpVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_GetUpVector final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetUpVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetUpVector");
static_assert(sizeof(KismetMathLibrary_GetUpVector) == 0x000018, "Wrong size on KismetMathLibrary_GetUpVector");
static_assert(offsetof(KismetMathLibrary_GetUpVector, InRot) == 0x000000, "Member 'KismetMathLibrary_GetUpVector::InRot' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetUpVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_GetUpVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetVectorArrayAverage
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_GetVectorArrayAverage final
{
public:
	TArray<struct FVector>                        Vectors;                                           // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetVectorArrayAverage) == 0x000008, "Wrong alignment on KismetMathLibrary_GetVectorArrayAverage");
static_assert(sizeof(KismetMathLibrary_GetVectorArrayAverage) == 0x000020, "Wrong size on KismetMathLibrary_GetVectorArrayAverage");
static_assert(offsetof(KismetMathLibrary_GetVectorArrayAverage, Vectors) == 0x000000, "Member 'KismetMathLibrary_GetVectorArrayAverage::Vectors' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetVectorArrayAverage, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_GetVectorArrayAverage::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetYawPitchFromVector
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_GetYawPitchFromVector final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GetYawPitchFromVector) == 0x000004, "Wrong alignment on KismetMathLibrary_GetYawPitchFromVector");
static_assert(sizeof(KismetMathLibrary_GetYawPitchFromVector) == 0x000014, "Wrong size on KismetMathLibrary_GetYawPitchFromVector");
static_assert(offsetof(KismetMathLibrary_GetYawPitchFromVector, InVec) == 0x000000, "Member 'KismetMathLibrary_GetYawPitchFromVector::InVec' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetYawPitchFromVector, Yaw) == 0x00000C, "Member 'KismetMathLibrary_GetYawPitchFromVector::Yaw' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetYawPitchFromVector, Pitch) == 0x000010, "Member 'KismetMathLibrary_GetYawPitchFromVector::Pitch' has a wrong offset!");

// Function Engine.KismetMathLibrary.GetYear
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_GetYear final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GetYear) == 0x000008, "Wrong alignment on KismetMathLibrary_GetYear");
static_assert(sizeof(KismetMathLibrary_GetYear) == 0x000010, "Wrong size on KismetMathLibrary_GetYear");
static_assert(offsetof(KismetMathLibrary_GetYear, A) == 0x000000, "Member 'KismetMathLibrary_GetYear::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GetYear, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GetYear::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Greater_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Greater_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Greater_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Greater_ByteByte");
static_assert(sizeof(KismetMathLibrary_Greater_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Greater_ByteByte");
static_assert(offsetof(KismetMathLibrary_Greater_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Greater_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Greater_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Greater_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Greater_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Greater_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Greater_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_Greater_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_Greater_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_Greater_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_Greater_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_Greater_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_Greater_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Greater_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Greater_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Greater_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Greater_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Greater_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Greater_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Greater_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Greater_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Greater_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Greater_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Greater_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Greater_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Greater_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Greater_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Greater_IntInt");
static_assert(sizeof(KismetMathLibrary_Greater_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Greater_IntInt");
static_assert(offsetof(KismetMathLibrary_Greater_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Greater_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Greater_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Greater_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Greater_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Greater_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Greater_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Greater_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_Greater_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Greater_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_Greater_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Greater_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Greater_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Greater_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Greater_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterEqual_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_GreaterEqual_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GreaterEqual_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_GreaterEqual_ByteByte");
static_assert(sizeof(KismetMathLibrary_GreaterEqual_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_GreaterEqual_ByteByte");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_GreaterEqual_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_GreaterEqual_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_GreaterEqual_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterEqual_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_GreaterEqual_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GreaterEqual_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_GreaterEqual_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_GreaterEqual_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_GreaterEqual_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_GreaterEqual_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_GreaterEqual_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_GreaterEqual_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterEqual_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_GreaterEqual_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GreaterEqual_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_GreaterEqual_FloatFloat");
static_assert(sizeof(KismetMathLibrary_GreaterEqual_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_GreaterEqual_FloatFloat");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_GreaterEqual_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_GreaterEqual_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GreaterEqual_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterEqual_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_GreaterEqual_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GreaterEqual_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_GreaterEqual_IntInt");
static_assert(sizeof(KismetMathLibrary_GreaterEqual_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_GreaterEqual_IntInt");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_GreaterEqual_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_GreaterEqual_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GreaterEqual_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterEqual_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_GreaterEqual_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_GreaterEqual_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_GreaterEqual_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_GreaterEqual_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_GreaterEqual_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_GreaterEqual_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_GreaterEqual_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterEqual_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_GreaterEqual_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GreaterGreater_VectorRotator
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_GreaterGreater_VectorRotator final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GreaterGreater_VectorRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_GreaterGreater_VectorRotator");
static_assert(sizeof(KismetMathLibrary_GreaterGreater_VectorRotator) == 0x000024, "Wrong size on KismetMathLibrary_GreaterGreater_VectorRotator");
static_assert(offsetof(KismetMathLibrary_GreaterGreater_VectorRotator, A) == 0x000000, "Member 'KismetMathLibrary_GreaterGreater_VectorRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterGreater_VectorRotator, B) == 0x00000C, "Member 'KismetMathLibrary_GreaterGreater_VectorRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GreaterGreater_VectorRotator, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_GreaterGreater_VectorRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.GridSnap_Float
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_GridSnap_Float final
{
public:
	float                                         Location;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_GridSnap_Float) == 0x000004, "Wrong alignment on KismetMathLibrary_GridSnap_Float");
static_assert(sizeof(KismetMathLibrary_GridSnap_Float) == 0x00000C, "Wrong size on KismetMathLibrary_GridSnap_Float");
static_assert(offsetof(KismetMathLibrary_GridSnap_Float, Location) == 0x000000, "Member 'KismetMathLibrary_GridSnap_Float::Location' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GridSnap_Float, GridSize) == 0x000004, "Member 'KismetMathLibrary_GridSnap_Float::GridSize' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_GridSnap_Float, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_GridSnap_Float::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.HSVToRGB
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_HSVToRGB final
{
public:
	float                                         H;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         S;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_HSVToRGB) == 0x000004, "Wrong alignment on KismetMathLibrary_HSVToRGB");
static_assert(sizeof(KismetMathLibrary_HSVToRGB) == 0x000020, "Wrong size on KismetMathLibrary_HSVToRGB");
static_assert(offsetof(KismetMathLibrary_HSVToRGB, H) == 0x000000, "Member 'KismetMathLibrary_HSVToRGB::H' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_HSVToRGB, S) == 0x000004, "Member 'KismetMathLibrary_HSVToRGB::S' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_HSVToRGB, V) == 0x000008, "Member 'KismetMathLibrary_HSVToRGB::V' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_HSVToRGB, A) == 0x00000C, "Member 'KismetMathLibrary_HSVToRGB::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_HSVToRGB, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_HSVToRGB::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.HSVToRGB_Vector
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_HSVToRGB_Vector final
{
public:
	struct FLinearColor                           HSV;                                               // 0x0000(0x0010)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RGB;                                               // 0x0010(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_HSVToRGB_Vector) == 0x000004, "Wrong alignment on KismetMathLibrary_HSVToRGB_Vector");
static_assert(sizeof(KismetMathLibrary_HSVToRGB_Vector) == 0x000020, "Wrong size on KismetMathLibrary_HSVToRGB_Vector");
static_assert(offsetof(KismetMathLibrary_HSVToRGB_Vector, HSV) == 0x000000, "Member 'KismetMathLibrary_HSVToRGB_Vector::HSV' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_HSVToRGB_Vector, RGB) == 0x000010, "Member 'KismetMathLibrary_HSVToRGB_Vector::RGB' has a wrong offset!");

// Function Engine.KismetMathLibrary.Hypotenuse
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Hypotenuse final
{
public:
	float                                         Width;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Height;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Hypotenuse) == 0x000004, "Wrong alignment on KismetMathLibrary_Hypotenuse");
static_assert(sizeof(KismetMathLibrary_Hypotenuse) == 0x00000C, "Wrong size on KismetMathLibrary_Hypotenuse");
static_assert(offsetof(KismetMathLibrary_Hypotenuse, Width) == 0x000000, "Member 'KismetMathLibrary_Hypotenuse::Width' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Hypotenuse, Height) == 0x000004, "Member 'KismetMathLibrary_Hypotenuse::Height' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Hypotenuse, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Hypotenuse::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InRange_FloatFloat
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_InRange_FloatFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Min_0;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max_0;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InclusiveMin;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InclusiveMax;                                      // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_InRange_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_InRange_FloatFloat");
static_assert(sizeof(KismetMathLibrary_InRange_FloatFloat) == 0x000010, "Wrong size on KismetMathLibrary_InRange_FloatFloat");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, Value) == 0x000000, "Member 'KismetMathLibrary_InRange_FloatFloat::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, Min_0) == 0x000004, "Member 'KismetMathLibrary_InRange_FloatFloat::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, Max_0) == 0x000008, "Member 'KismetMathLibrary_InRange_FloatFloat::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, InclusiveMin) == 0x00000C, "Member 'KismetMathLibrary_InRange_FloatFloat::InclusiveMin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, InclusiveMax) == 0x00000D, "Member 'KismetMathLibrary_InRange_FloatFloat::InclusiveMax' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_FloatFloat, ReturnValue) == 0x00000E, "Member 'KismetMathLibrary_InRange_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InRange_IntInt
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_InRange_IntInt final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Min_0;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max_0;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InclusiveMin;                                      // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InclusiveMax;                                      // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F[0x1];                                        // 0x000F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_InRange_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_InRange_IntInt");
static_assert(sizeof(KismetMathLibrary_InRange_IntInt) == 0x000010, "Wrong size on KismetMathLibrary_InRange_IntInt");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, Value) == 0x000000, "Member 'KismetMathLibrary_InRange_IntInt::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, Min_0) == 0x000004, "Member 'KismetMathLibrary_InRange_IntInt::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, Max_0) == 0x000008, "Member 'KismetMathLibrary_InRange_IntInt::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, InclusiveMin) == 0x00000C, "Member 'KismetMathLibrary_InRange_IntInt::InclusiveMin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, InclusiveMax) == 0x00000D, "Member 'KismetMathLibrary_InRange_IntInt::InclusiveMax' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InRange_IntInt, ReturnValue) == 0x00000E, "Member 'KismetMathLibrary_InRange_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InverseLerp
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_InverseLerp final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_InverseLerp) == 0x000004, "Wrong alignment on KismetMathLibrary_InverseLerp");
static_assert(sizeof(KismetMathLibrary_InverseLerp) == 0x000010, "Wrong size on KismetMathLibrary_InverseLerp");
static_assert(offsetof(KismetMathLibrary_InverseLerp, A) == 0x000000, "Member 'KismetMathLibrary_InverseLerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseLerp, B) == 0x000004, "Member 'KismetMathLibrary_InverseLerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseLerp, Value) == 0x000008, "Member 'KismetMathLibrary_InverseLerp::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseLerp, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_InverseLerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InverseTransformDirection
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_InverseTransformDirection final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_InverseTransformDirection) == 0x000010, "Wrong alignment on KismetMathLibrary_InverseTransformDirection");
static_assert(sizeof(KismetMathLibrary_InverseTransformDirection) == 0x000050, "Wrong size on KismetMathLibrary_InverseTransformDirection");
static_assert(offsetof(KismetMathLibrary_InverseTransformDirection, T) == 0x000000, "Member 'KismetMathLibrary_InverseTransformDirection::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformDirection, Direction) == 0x000030, "Member 'KismetMathLibrary_InverseTransformDirection::Direction' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformDirection, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_InverseTransformDirection::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InverseTransformLocation
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_InverseTransformLocation final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_InverseTransformLocation) == 0x000010, "Wrong alignment on KismetMathLibrary_InverseTransformLocation");
static_assert(sizeof(KismetMathLibrary_InverseTransformLocation) == 0x000050, "Wrong size on KismetMathLibrary_InverseTransformLocation");
static_assert(offsetof(KismetMathLibrary_InverseTransformLocation, T) == 0x000000, "Member 'KismetMathLibrary_InverseTransformLocation::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformLocation, Location) == 0x000030, "Member 'KismetMathLibrary_InverseTransformLocation::Location' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformLocation, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_InverseTransformLocation::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InverseTransformRotation
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_InverseTransformRotation final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_InverseTransformRotation) == 0x000010, "Wrong alignment on KismetMathLibrary_InverseTransformRotation");
static_assert(sizeof(KismetMathLibrary_InverseTransformRotation) == 0x000050, "Wrong size on KismetMathLibrary_InverseTransformRotation");
static_assert(offsetof(KismetMathLibrary_InverseTransformRotation, T) == 0x000000, "Member 'KismetMathLibrary_InverseTransformRotation::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformRotation, Rotation) == 0x000030, "Member 'KismetMathLibrary_InverseTransformRotation::Rotation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InverseTransformRotation, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_InverseTransformRotation::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.InvertTransform
// 0x0060 (0x0060 - 0x0000)
struct KismetMathLibrary_InvertTransform final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0030(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_InvertTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_InvertTransform");
static_assert(sizeof(KismetMathLibrary_InvertTransform) == 0x000060, "Wrong size on KismetMathLibrary_InvertTransform");
static_assert(offsetof(KismetMathLibrary_InvertTransform, T) == 0x000000, "Member 'KismetMathLibrary_InvertTransform::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_InvertTransform, ReturnValue) == 0x000030, "Member 'KismetMathLibrary_InvertTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.IsAfternoon
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_IsAfternoon final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_IsAfternoon) == 0x000008, "Wrong alignment on KismetMathLibrary_IsAfternoon");
static_assert(sizeof(KismetMathLibrary_IsAfternoon) == 0x000010, "Wrong size on KismetMathLibrary_IsAfternoon");
static_assert(offsetof(KismetMathLibrary_IsAfternoon, A) == 0x000000, "Member 'KismetMathLibrary_IsAfternoon::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsAfternoon, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_IsAfternoon::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.IsLeapYear
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_IsLeapYear final
{
public:
	int32                                         Year;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_IsLeapYear) == 0x000004, "Wrong alignment on KismetMathLibrary_IsLeapYear");
static_assert(sizeof(KismetMathLibrary_IsLeapYear) == 0x000008, "Wrong size on KismetMathLibrary_IsLeapYear");
static_assert(offsetof(KismetMathLibrary_IsLeapYear, Year) == 0x000000, "Member 'KismetMathLibrary_IsLeapYear::Year' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsLeapYear, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_IsLeapYear::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.IsMorning
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_IsMorning final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_IsMorning) == 0x000008, "Wrong alignment on KismetMathLibrary_IsMorning");
static_assert(sizeof(KismetMathLibrary_IsMorning) == 0x000010, "Wrong size on KismetMathLibrary_IsMorning");
static_assert(offsetof(KismetMathLibrary_IsMorning, A) == 0x000000, "Member 'KismetMathLibrary_IsMorning::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsMorning, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_IsMorning::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.IsPointInBox
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_IsPointInBox final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxOrigin;                                         // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_IsPointInBox) == 0x000004, "Wrong alignment on KismetMathLibrary_IsPointInBox");
static_assert(sizeof(KismetMathLibrary_IsPointInBox) == 0x000028, "Wrong size on KismetMathLibrary_IsPointInBox");
static_assert(offsetof(KismetMathLibrary_IsPointInBox, Point) == 0x000000, "Member 'KismetMathLibrary_IsPointInBox::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBox, BoxOrigin) == 0x00000C, "Member 'KismetMathLibrary_IsPointInBox::BoxOrigin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBox, BoxExtent) == 0x000018, "Member 'KismetMathLibrary_IsPointInBox::BoxExtent' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBox, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_IsPointInBox::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.IsPointInBoxWithTransform
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_IsPointInBoxWithTransform final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             BoxWorldTransform;                                 // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0040(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_IsPointInBoxWithTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_IsPointInBoxWithTransform");
static_assert(sizeof(KismetMathLibrary_IsPointInBoxWithTransform) == 0x000050, "Wrong size on KismetMathLibrary_IsPointInBoxWithTransform");
static_assert(offsetof(KismetMathLibrary_IsPointInBoxWithTransform, Point) == 0x000000, "Member 'KismetMathLibrary_IsPointInBoxWithTransform::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBoxWithTransform, BoxWorldTransform) == 0x000010, "Member 'KismetMathLibrary_IsPointInBoxWithTransform::BoxWorldTransform' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBoxWithTransform, BoxExtent) == 0x000040, "Member 'KismetMathLibrary_IsPointInBoxWithTransform::BoxExtent' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_IsPointInBoxWithTransform, ReturnValue) == 0x00004C, "Member 'KismetMathLibrary_IsPointInBoxWithTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Lerp
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_Lerp final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Lerp) == 0x000004, "Wrong alignment on KismetMathLibrary_Lerp");
static_assert(sizeof(KismetMathLibrary_Lerp) == 0x000010, "Wrong size on KismetMathLibrary_Lerp");
static_assert(offsetof(KismetMathLibrary_Lerp, A) == 0x000000, "Member 'KismetMathLibrary_Lerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Lerp, B) == 0x000004, "Member 'KismetMathLibrary_Lerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Lerp, Alpha) == 0x000008, "Member 'KismetMathLibrary_Lerp::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Lerp, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Lerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Less_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Less_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Less_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Less_ByteByte");
static_assert(sizeof(KismetMathLibrary_Less_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Less_ByteByte");
static_assert(offsetof(KismetMathLibrary_Less_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Less_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Less_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Less_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Less_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Less_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Less_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_Less_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_Less_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_Less_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_Less_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_Less_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_Less_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Less_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Less_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Less_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Less_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Less_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Less_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Less_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Less_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Less_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Less_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Less_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Less_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Less_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Less_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Less_IntInt");
static_assert(sizeof(KismetMathLibrary_Less_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Less_IntInt");
static_assert(offsetof(KismetMathLibrary_Less_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Less_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Less_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Less_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Less_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Less_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_Less_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Less_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_Less_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Less_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_Less_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Less_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Less_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Less_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Less_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessEqual_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_LessEqual_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_LessEqual_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_LessEqual_ByteByte");
static_assert(sizeof(KismetMathLibrary_LessEqual_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_LessEqual_ByteByte");
static_assert(offsetof(KismetMathLibrary_LessEqual_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_LessEqual_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_LessEqual_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_LessEqual_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessEqual_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_LessEqual_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LessEqual_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_LessEqual_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_LessEqual_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_LessEqual_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_LessEqual_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_LessEqual_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_LessEqual_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_LessEqual_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessEqual_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_LessEqual_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LessEqual_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_LessEqual_FloatFloat");
static_assert(sizeof(KismetMathLibrary_LessEqual_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_LessEqual_FloatFloat");
static_assert(offsetof(KismetMathLibrary_LessEqual_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_LessEqual_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_LessEqual_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_LessEqual_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessEqual_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_LessEqual_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LessEqual_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_LessEqual_IntInt");
static_assert(sizeof(KismetMathLibrary_LessEqual_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_LessEqual_IntInt");
static_assert(offsetof(KismetMathLibrary_LessEqual_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_LessEqual_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_LessEqual_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_LessEqual_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessEqual_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_LessEqual_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LessEqual_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_LessEqual_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_LessEqual_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_LessEqual_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_LessEqual_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_LessEqual_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_LessEqual_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessEqual_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_LessEqual_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LessLess_VectorRotator
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_LessLess_VectorRotator final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_LessLess_VectorRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_LessLess_VectorRotator");
static_assert(sizeof(KismetMathLibrary_LessLess_VectorRotator) == 0x000024, "Wrong size on KismetMathLibrary_LessLess_VectorRotator");
static_assert(offsetof(KismetMathLibrary_LessLess_VectorRotator, A) == 0x000000, "Member 'KismetMathLibrary_LessLess_VectorRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessLess_VectorRotator, B) == 0x00000C, "Member 'KismetMathLibrary_LessLess_VectorRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LessLess_VectorRotator, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_LessLess_VectorRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LinearColorLerp
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_LinearColorLerp final
{
public:
	struct FLinearColor                           A;                                                 // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0024(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_LinearColorLerp) == 0x000004, "Wrong alignment on KismetMathLibrary_LinearColorLerp");
static_assert(sizeof(KismetMathLibrary_LinearColorLerp) == 0x000034, "Wrong size on KismetMathLibrary_LinearColorLerp");
static_assert(offsetof(KismetMathLibrary_LinearColorLerp, A) == 0x000000, "Member 'KismetMathLibrary_LinearColorLerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerp, B) == 0x000010, "Member 'KismetMathLibrary_LinearColorLerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerp, Alpha) == 0x000020, "Member 'KismetMathLibrary_LinearColorLerp::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerp, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_LinearColorLerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LinearColorLerpUsingHSV
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_LinearColorLerpUsingHSV final
{
public:
	struct FLinearColor                           A;                                                 // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0024(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_LinearColorLerpUsingHSV) == 0x000004, "Wrong alignment on KismetMathLibrary_LinearColorLerpUsingHSV");
static_assert(sizeof(KismetMathLibrary_LinearColorLerpUsingHSV) == 0x000034, "Wrong size on KismetMathLibrary_LinearColorLerpUsingHSV");
static_assert(offsetof(KismetMathLibrary_LinearColorLerpUsingHSV, A) == 0x000000, "Member 'KismetMathLibrary_LinearColorLerpUsingHSV::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerpUsingHSV, B) == 0x000010, "Member 'KismetMathLibrary_LinearColorLerpUsingHSV::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerpUsingHSV, Alpha) == 0x000020, "Member 'KismetMathLibrary_LinearColorLerpUsingHSV::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinearColorLerpUsingHSV, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_LinearColorLerpUsingHSV::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LinePlaneIntersection
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_LinePlaneIntersection final
{
public:
	struct FVector                                LineStart;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 APlane;                                            // 0x0020(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Intersection;                                      // 0x0034(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LinePlaneIntersection) == 0x000010, "Wrong alignment on KismetMathLibrary_LinePlaneIntersection");
static_assert(sizeof(KismetMathLibrary_LinePlaneIntersection) == 0x000050, "Wrong size on KismetMathLibrary_LinePlaneIntersection");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, LineStart) == 0x000000, "Member 'KismetMathLibrary_LinePlaneIntersection::LineStart' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, LineEnd) == 0x00000C, "Member 'KismetMathLibrary_LinePlaneIntersection::LineEnd' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, APlane) == 0x000020, "Member 'KismetMathLibrary_LinePlaneIntersection::APlane' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, T) == 0x000030, "Member 'KismetMathLibrary_LinePlaneIntersection::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, Intersection) == 0x000034, "Member 'KismetMathLibrary_LinePlaneIntersection::Intersection' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection, ReturnValue) == 0x000040, "Member 'KismetMathLibrary_LinePlaneIntersection::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.LinePlaneIntersection_OriginNormal
// 0x0044 (0x0044 - 0x0000)
struct KismetMathLibrary_LinePlaneIntersection_OriginNormal final
{
public:
	struct FVector                                LineStart;                                         // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneOrigin;                                       // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         T;                                                 // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Intersection;                                      // 0x0034(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_LinePlaneIntersection_OriginNormal) == 0x000004, "Wrong alignment on KismetMathLibrary_LinePlaneIntersection_OriginNormal");
static_assert(sizeof(KismetMathLibrary_LinePlaneIntersection_OriginNormal) == 0x000044, "Wrong size on KismetMathLibrary_LinePlaneIntersection_OriginNormal");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, LineStart) == 0x000000, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::LineStart' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, LineEnd) == 0x00000C, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::LineEnd' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, PlaneOrigin) == 0x000018, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::PlaneOrigin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, PlaneNormal) == 0x000024, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::PlaneNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, T) == 0x000030, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, Intersection) == 0x000034, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::Intersection' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_LinePlaneIntersection_OriginNormal, ReturnValue) == 0x000040, "Member 'KismetMathLibrary_LinePlaneIntersection_OriginNormal::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Log
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Log final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Base;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Log) == 0x000004, "Wrong alignment on KismetMathLibrary_Log");
static_assert(sizeof(KismetMathLibrary_Log) == 0x00000C, "Wrong size on KismetMathLibrary_Log");
static_assert(offsetof(KismetMathLibrary_Log, A) == 0x000000, "Member 'KismetMathLibrary_Log::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Log, Base) == 0x000004, "Member 'KismetMathLibrary_Log::Base' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Log, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Log::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Loge
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Loge final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Loge) == 0x000004, "Wrong alignment on KismetMathLibrary_Loge");
static_assert(sizeof(KismetMathLibrary_Loge) == 0x000008, "Wrong size on KismetMathLibrary_Loge");
static_assert(offsetof(KismetMathLibrary_Loge, A) == 0x000000, "Member 'KismetMathLibrary_Loge::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Loge, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Loge::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeBox
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_MakeBox final
{
public:
	struct FVector                                Min_0;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max_0;                                             // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   ReturnValue;                                       // 0x0018(0x001C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeBox) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeBox");
static_assert(sizeof(KismetMathLibrary_MakeBox) == 0x000034, "Wrong size on KismetMathLibrary_MakeBox");
static_assert(offsetof(KismetMathLibrary_MakeBox, Min_0) == 0x000000, "Member 'KismetMathLibrary_MakeBox::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeBox, Max_0) == 0x00000C, "Member 'KismetMathLibrary_MakeBox::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeBox, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeBox::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeBox2D
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeBox2D final
{
public:
	struct FVector2D                              Min_0;                                             // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Max_0;                                             // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox2D                                 ReturnValue;                                       // 0x0010(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeBox2D) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeBox2D");
static_assert(sizeof(KismetMathLibrary_MakeBox2D) == 0x000024, "Wrong size on KismetMathLibrary_MakeBox2D");
static_assert(offsetof(KismetMathLibrary_MakeBox2D, Min_0) == 0x000000, "Member 'KismetMathLibrary_MakeBox2D::Min_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeBox2D, Max_0) == 0x000008, "Member 'KismetMathLibrary_MakeBox2D::Max_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeBox2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_MakeBox2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeColor
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_MakeColor final
{
public:
	float                                         R;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         G;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeColor) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeColor");
static_assert(sizeof(KismetMathLibrary_MakeColor) == 0x000020, "Wrong size on KismetMathLibrary_MakeColor");
static_assert(offsetof(KismetMathLibrary_MakeColor, R) == 0x000000, "Member 'KismetMathLibrary_MakeColor::R' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeColor, G) == 0x000004, "Member 'KismetMathLibrary_MakeColor::G' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeColor, B) == 0x000008, "Member 'KismetMathLibrary_MakeColor::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeColor, A) == 0x00000C, "Member 'KismetMathLibrary_MakeColor::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeColor, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_MakeColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeDateTime
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_MakeDateTime final
{
public:
	int32                                         Year;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Month;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Day;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hour;                                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minute;                                            // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Second;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Millisecond;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_MakeDateTime");
static_assert(sizeof(KismetMathLibrary_MakeDateTime) == 0x000028, "Wrong size on KismetMathLibrary_MakeDateTime");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Year) == 0x000000, "Member 'KismetMathLibrary_MakeDateTime::Year' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Month) == 0x000004, "Member 'KismetMathLibrary_MakeDateTime::Month' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Day) == 0x000008, "Member 'KismetMathLibrary_MakeDateTime::Day' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Hour) == 0x00000C, "Member 'KismetMathLibrary_MakeDateTime::Hour' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Minute) == 0x000010, "Member 'KismetMathLibrary_MakeDateTime::Minute' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Second) == 0x000014, "Member 'KismetMathLibrary_MakeDateTime::Second' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, Millisecond) == 0x000018, "Member 'KismetMathLibrary_MakeDateTime::Millisecond' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeDateTime, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_MakeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakePlaneFromPointAndNormal
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_MakePlaneFromPointAndNormal final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal_0;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_18[0x8];                                       // 0x0018(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakePlaneFromPointAndNormal) == 0x000010, "Wrong alignment on KismetMathLibrary_MakePlaneFromPointAndNormal");
static_assert(sizeof(KismetMathLibrary_MakePlaneFromPointAndNormal) == 0x000030, "Wrong size on KismetMathLibrary_MakePlaneFromPointAndNormal");
static_assert(offsetof(KismetMathLibrary_MakePlaneFromPointAndNormal, Point) == 0x000000, "Member 'KismetMathLibrary_MakePlaneFromPointAndNormal::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakePlaneFromPointAndNormal, Normal_0) == 0x00000C, "Member 'KismetMathLibrary_MakePlaneFromPointAndNormal::Normal_0' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakePlaneFromPointAndNormal, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_MakePlaneFromPointAndNormal::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakePulsatingValue
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_MakePulsatingValue final
{
public:
	float                                         InCurrentTime;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPulsesPerSecond;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPhase;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakePulsatingValue) == 0x000004, "Wrong alignment on KismetMathLibrary_MakePulsatingValue");
static_assert(sizeof(KismetMathLibrary_MakePulsatingValue) == 0x000010, "Wrong size on KismetMathLibrary_MakePulsatingValue");
static_assert(offsetof(KismetMathLibrary_MakePulsatingValue, InCurrentTime) == 0x000000, "Member 'KismetMathLibrary_MakePulsatingValue::InCurrentTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakePulsatingValue, InPulsesPerSecond) == 0x000004, "Member 'KismetMathLibrary_MakePulsatingValue::InPulsesPerSecond' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakePulsatingValue, InPhase) == 0x000008, "Member 'KismetMathLibrary_MakePulsatingValue::InPhase' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakePulsatingValue, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakePulsatingValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRandomStream
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_MakeRandomStream final
{
public:
	int32                                         InitialSeed;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          ReturnValue;                                       // 0x0004(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRandomStream) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRandomStream");
static_assert(sizeof(KismetMathLibrary_MakeRandomStream) == 0x00000C, "Wrong size on KismetMathLibrary_MakeRandomStream");
static_assert(offsetof(KismetMathLibrary_MakeRandomStream, InitialSeed) == 0x000000, "Member 'KismetMathLibrary_MakeRandomStream::InitialSeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRandomStream, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_MakeRandomStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotationFromAxes
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_MakeRotationFromAxes final
{
public:
	struct FVector                                Forward;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Right;                                             // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Up;                                                // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotationFromAxes) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotationFromAxes");
static_assert(sizeof(KismetMathLibrary_MakeRotationFromAxes) == 0x000030, "Wrong size on KismetMathLibrary_MakeRotationFromAxes");
static_assert(offsetof(KismetMathLibrary_MakeRotationFromAxes, Forward) == 0x000000, "Member 'KismetMathLibrary_MakeRotationFromAxes::Forward' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotationFromAxes, Right) == 0x00000C, "Member 'KismetMathLibrary_MakeRotationFromAxes::Right' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotationFromAxes, Up) == 0x000018, "Member 'KismetMathLibrary_MakeRotationFromAxes::Up' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotationFromAxes, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_MakeRotationFromAxes::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotator
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MakeRotator final
{
public:
	float                                         Roll;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotator");
static_assert(sizeof(KismetMathLibrary_MakeRotator) == 0x000018, "Wrong size on KismetMathLibrary_MakeRotator");
static_assert(offsetof(KismetMathLibrary_MakeRotator, Roll) == 0x000000, "Member 'KismetMathLibrary_MakeRotator::Roll' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotator, Pitch) == 0x000004, "Member 'KismetMathLibrary_MakeRotator::Pitch' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotator, Yaw) == 0x000008, "Member 'KismetMathLibrary_MakeRotator::Yaw' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotator, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakeRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromX
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MakeRotFromX final
{
public:
	struct FVector                                X;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromX) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromX");
static_assert(sizeof(KismetMathLibrary_MakeRotFromX) == 0x000018, "Wrong size on KismetMathLibrary_MakeRotFromX");
static_assert(offsetof(KismetMathLibrary_MakeRotFromX, X) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromX::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromX, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromX::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromXY
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromXY final
{
public:
	struct FVector                                X;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromXY) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromXY");
static_assert(sizeof(KismetMathLibrary_MakeRotFromXY) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromXY");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXY, X) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromXY::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXY, Y) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromXY::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXY, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromXY::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromXZ
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromXZ final
{
public:
	struct FVector                                X;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromXZ) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromXZ");
static_assert(sizeof(KismetMathLibrary_MakeRotFromXZ) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromXZ");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXZ, X) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromXZ::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXZ, Z) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromXZ::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromXZ, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromXZ::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromY
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MakeRotFromY final
{
public:
	struct FVector                                Y;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromY) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromY");
static_assert(sizeof(KismetMathLibrary_MakeRotFromY) == 0x000018, "Wrong size on KismetMathLibrary_MakeRotFromY");
static_assert(offsetof(KismetMathLibrary_MakeRotFromY, Y) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromY::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromY, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromY::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromYX
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromYX final
{
public:
	struct FVector                                Y;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromYX) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromYX");
static_assert(sizeof(KismetMathLibrary_MakeRotFromYX) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromYX");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYX, Y) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromYX::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYX, X) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromYX::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYX, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromYX::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromYZ
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromYZ final
{
public:
	struct FVector                                Y;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Z;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromYZ) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromYZ");
static_assert(sizeof(KismetMathLibrary_MakeRotFromYZ) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromYZ");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYZ, Y) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromYZ::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYZ, Z) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromYZ::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromYZ, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromYZ::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromZ
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MakeRotFromZ final
{
public:
	struct FVector                                Z;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromZ) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromZ");
static_assert(sizeof(KismetMathLibrary_MakeRotFromZ) == 0x000018, "Wrong size on KismetMathLibrary_MakeRotFromZ");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZ, Z) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromZ::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZ, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromZ::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromZX
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromZX final
{
public:
	struct FVector                                Z;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                X;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromZX) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromZX");
static_assert(sizeof(KismetMathLibrary_MakeRotFromZX) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromZX");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZX, Z) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromZX::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZX, X) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromZX::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZX, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromZX::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeRotFromZY
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MakeRotFromZY final
{
public:
	struct FVector                                Z;                                                 // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Y;                                                 // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeRotFromZY) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeRotFromZY");
static_assert(sizeof(KismetMathLibrary_MakeRotFromZY) == 0x000024, "Wrong size on KismetMathLibrary_MakeRotFromZY");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZY, Z) == 0x000000, "Member 'KismetMathLibrary_MakeRotFromZY::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZY, Y) == 0x00000C, "Member 'KismetMathLibrary_MakeRotFromZY::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeRotFromZY, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeRotFromZY::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeTimespan
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_MakeTimespan final
{
public:
	int32                                         Days;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hours;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Milliseconds;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_MakeTimespan");
static_assert(sizeof(KismetMathLibrary_MakeTimespan) == 0x000020, "Wrong size on KismetMathLibrary_MakeTimespan");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, Days) == 0x000000, "Member 'KismetMathLibrary_MakeTimespan::Days' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, Hours) == 0x000004, "Member 'KismetMathLibrary_MakeTimespan::Hours' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, Minutes) == 0x000008, "Member 'KismetMathLibrary_MakeTimespan::Minutes' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, Seconds) == 0x00000C, "Member 'KismetMathLibrary_MakeTimespan::Seconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, Milliseconds) == 0x000010, "Member 'KismetMathLibrary_MakeTimespan::Milliseconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeTimespan2
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_MakeTimespan2 final
{
public:
	int32                                         Days;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Hours;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minutes;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FractionNano;                                      // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeTimespan2) == 0x000008, "Wrong alignment on KismetMathLibrary_MakeTimespan2");
static_assert(sizeof(KismetMathLibrary_MakeTimespan2) == 0x000020, "Wrong size on KismetMathLibrary_MakeTimespan2");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, Days) == 0x000000, "Member 'KismetMathLibrary_MakeTimespan2::Days' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, Hours) == 0x000004, "Member 'KismetMathLibrary_MakeTimespan2::Hours' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, Minutes) == 0x000008, "Member 'KismetMathLibrary_MakeTimespan2::Minutes' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, Seconds) == 0x00000C, "Member 'KismetMathLibrary_MakeTimespan2::Seconds' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, FractionNano) == 0x000010, "Member 'KismetMathLibrary_MakeTimespan2::FractionNano' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTimespan2, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MakeTimespan2::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeTransform
// 0x0060 (0x0060 - 0x0000)
struct KismetMathLibrary_MakeTransform final
{
public:
	struct FVector                                Location;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0xC];                                       // 0x0024(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0030(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_MakeTransform");
static_assert(sizeof(KismetMathLibrary_MakeTransform) == 0x000060, "Wrong size on KismetMathLibrary_MakeTransform");
static_assert(offsetof(KismetMathLibrary_MakeTransform, Location) == 0x000000, "Member 'KismetMathLibrary_MakeTransform::Location' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTransform, Rotation) == 0x00000C, "Member 'KismetMathLibrary_MakeTransform::Rotation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTransform, Scale) == 0x000018, "Member 'KismetMathLibrary_MakeTransform::Scale' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeTransform, ReturnValue) == 0x000030, "Member 'KismetMathLibrary_MakeTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MakeVector final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeVector) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeVector");
static_assert(sizeof(KismetMathLibrary_MakeVector) == 0x000018, "Wrong size on KismetMathLibrary_MakeVector");
static_assert(offsetof(KismetMathLibrary_MakeVector, X) == 0x000000, "Member 'KismetMathLibrary_MakeVector::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeVector, Y) == 0x000004, "Member 'KismetMathLibrary_MakeVector::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeVector, Z) == 0x000008, "Member 'KismetMathLibrary_MakeVector::Z' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_MakeVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MakeVector2D
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_MakeVector2D final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MakeVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_MakeVector2D");
static_assert(sizeof(KismetMathLibrary_MakeVector2D) == 0x000010, "Wrong size on KismetMathLibrary_MakeVector2D");
static_assert(offsetof(KismetMathLibrary_MakeVector2D, X) == 0x000000, "Member 'KismetMathLibrary_MakeVector2D::X' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeVector2D, Y) == 0x000004, "Member 'KismetMathLibrary_MakeVector2D::Y' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MakeVector2D, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_MakeVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MapRangeClamped
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MapRangeClamped final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRangeA;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRangeB;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRangeA;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRangeB;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MapRangeClamped) == 0x000004, "Wrong alignment on KismetMathLibrary_MapRangeClamped");
static_assert(sizeof(KismetMathLibrary_MapRangeClamped) == 0x000018, "Wrong size on KismetMathLibrary_MapRangeClamped");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, Value) == 0x000000, "Member 'KismetMathLibrary_MapRangeClamped::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, InRangeA) == 0x000004, "Member 'KismetMathLibrary_MapRangeClamped::InRangeA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, InRangeB) == 0x000008, "Member 'KismetMathLibrary_MapRangeClamped::InRangeB' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, OutRangeA) == 0x00000C, "Member 'KismetMathLibrary_MapRangeClamped::OutRangeA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, OutRangeB) == 0x000010, "Member 'KismetMathLibrary_MapRangeClamped::OutRangeB' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeClamped, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_MapRangeClamped::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MapRangeUnclamped
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MapRangeUnclamped final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRangeA;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InRangeB;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRangeA;                                         // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutRangeB;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MapRangeUnclamped) == 0x000004, "Wrong alignment on KismetMathLibrary_MapRangeUnclamped");
static_assert(sizeof(KismetMathLibrary_MapRangeUnclamped) == 0x000018, "Wrong size on KismetMathLibrary_MapRangeUnclamped");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, Value) == 0x000000, "Member 'KismetMathLibrary_MapRangeUnclamped::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, InRangeA) == 0x000004, "Member 'KismetMathLibrary_MapRangeUnclamped::InRangeA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, InRangeB) == 0x000008, "Member 'KismetMathLibrary_MapRangeUnclamped::InRangeB' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, OutRangeA) == 0x00000C, "Member 'KismetMathLibrary_MapRangeUnclamped::OutRangeA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, OutRangeB) == 0x000010, "Member 'KismetMathLibrary_MapRangeUnclamped::OutRangeB' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MapRangeUnclamped, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_MapRangeUnclamped::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Max
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Max final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Max) == 0x000004, "Wrong alignment on KismetMathLibrary_Max");
static_assert(sizeof(KismetMathLibrary_Max) == 0x00000C, "Wrong size on KismetMathLibrary_Max");
static_assert(offsetof(KismetMathLibrary_Max, A) == 0x000000, "Member 'KismetMathLibrary_Max::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Max, B) == 0x000004, "Member 'KismetMathLibrary_Max::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Max, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Max::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MaxOfByteArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MaxOfByteArray final
{
public:
	TArray<uint8>                                 ByteArray;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMaxValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MaxValue;                                          // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_MaxOfByteArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MaxOfByteArray");
static_assert(sizeof(KismetMathLibrary_MaxOfByteArray) == 0x000018, "Wrong size on KismetMathLibrary_MaxOfByteArray");
static_assert(offsetof(KismetMathLibrary_MaxOfByteArray, ByteArray) == 0x000000, "Member 'KismetMathLibrary_MaxOfByteArray::ByteArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfByteArray, IndexOfMaxValue) == 0x000010, "Member 'KismetMathLibrary_MaxOfByteArray::IndexOfMaxValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfByteArray, MaxValue) == 0x000014, "Member 'KismetMathLibrary_MaxOfByteArray::MaxValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MaxOfFloatArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MaxOfFloatArray final
{
public:
	TArray<float>                                 FloatArray;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMaxValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxValue;                                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MaxOfFloatArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MaxOfFloatArray");
static_assert(sizeof(KismetMathLibrary_MaxOfFloatArray) == 0x000018, "Wrong size on KismetMathLibrary_MaxOfFloatArray");
static_assert(offsetof(KismetMathLibrary_MaxOfFloatArray, FloatArray) == 0x000000, "Member 'KismetMathLibrary_MaxOfFloatArray::FloatArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfFloatArray, IndexOfMaxValue) == 0x000010, "Member 'KismetMathLibrary_MaxOfFloatArray::IndexOfMaxValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfFloatArray, MaxValue) == 0x000014, "Member 'KismetMathLibrary_MaxOfFloatArray::MaxValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MaxOfIntArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MaxOfIntArray final
{
public:
	TArray<int32>                                 IntArray;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMaxValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxValue;                                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MaxOfIntArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MaxOfIntArray");
static_assert(sizeof(KismetMathLibrary_MaxOfIntArray) == 0x000018, "Wrong size on KismetMathLibrary_MaxOfIntArray");
static_assert(offsetof(KismetMathLibrary_MaxOfIntArray, IntArray) == 0x000000, "Member 'KismetMathLibrary_MaxOfIntArray::IntArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfIntArray, IndexOfMaxValue) == 0x000010, "Member 'KismetMathLibrary_MaxOfIntArray::IndexOfMaxValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MaxOfIntArray, MaxValue) == 0x000014, "Member 'KismetMathLibrary_MaxOfIntArray::MaxValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Min
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Min final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Min) == 0x000004, "Wrong alignment on KismetMathLibrary_Min");
static_assert(sizeof(KismetMathLibrary_Min) == 0x00000C, "Wrong size on KismetMathLibrary_Min");
static_assert(offsetof(KismetMathLibrary_Min, A) == 0x000000, "Member 'KismetMathLibrary_Min::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Min, B) == 0x000004, "Member 'KismetMathLibrary_Min::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Min, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Min::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MinimumAreaRectangle
// 0x0048 (0x0048 - 0x0000)
struct KismetMathLibrary_MinimumAreaRectangle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        InVerts;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                SampleSurfaceNormal;                               // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutRectCenter;                                     // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutRectRotation;                                   // 0x0030(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         OutSideLengthX;                                    // 0x003C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutSideLengthY;                                    // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugDraw;                                        // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_MinimumAreaRectangle) == 0x000008, "Wrong alignment on KismetMathLibrary_MinimumAreaRectangle");
static_assert(sizeof(KismetMathLibrary_MinimumAreaRectangle) == 0x000048, "Wrong size on KismetMathLibrary_MinimumAreaRectangle");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, WorldContextObject) == 0x000000, "Member 'KismetMathLibrary_MinimumAreaRectangle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, InVerts) == 0x000008, "Member 'KismetMathLibrary_MinimumAreaRectangle::InVerts' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, SampleSurfaceNormal) == 0x000018, "Member 'KismetMathLibrary_MinimumAreaRectangle::SampleSurfaceNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, OutRectCenter) == 0x000024, "Member 'KismetMathLibrary_MinimumAreaRectangle::OutRectCenter' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, OutRectRotation) == 0x000030, "Member 'KismetMathLibrary_MinimumAreaRectangle::OutRectRotation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, OutSideLengthX) == 0x00003C, "Member 'KismetMathLibrary_MinimumAreaRectangle::OutSideLengthX' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, OutSideLengthY) == 0x000040, "Member 'KismetMathLibrary_MinimumAreaRectangle::OutSideLengthY' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinimumAreaRectangle, bDebugDraw) == 0x000044, "Member 'KismetMathLibrary_MinimumAreaRectangle::bDebugDraw' has a wrong offset!");

// Function Engine.KismetMathLibrary.MinOfByteArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MinOfByteArray final
{
public:
	TArray<uint8>                                 ByteArray;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMinValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         MinValue;                                          // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_MinOfByteArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MinOfByteArray");
static_assert(sizeof(KismetMathLibrary_MinOfByteArray) == 0x000018, "Wrong size on KismetMathLibrary_MinOfByteArray");
static_assert(offsetof(KismetMathLibrary_MinOfByteArray, ByteArray) == 0x000000, "Member 'KismetMathLibrary_MinOfByteArray::ByteArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfByteArray, IndexOfMinValue) == 0x000010, "Member 'KismetMathLibrary_MinOfByteArray::IndexOfMinValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfByteArray, MinValue) == 0x000014, "Member 'KismetMathLibrary_MinOfByteArray::MinValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MinOfFloatArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MinOfFloatArray final
{
public:
	TArray<float>                                 FloatArray;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMinValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinValue;                                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MinOfFloatArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MinOfFloatArray");
static_assert(sizeof(KismetMathLibrary_MinOfFloatArray) == 0x000018, "Wrong size on KismetMathLibrary_MinOfFloatArray");
static_assert(offsetof(KismetMathLibrary_MinOfFloatArray, FloatArray) == 0x000000, "Member 'KismetMathLibrary_MinOfFloatArray::FloatArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfFloatArray, IndexOfMinValue) == 0x000010, "Member 'KismetMathLibrary_MinOfFloatArray::IndexOfMinValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfFloatArray, MinValue) == 0x000014, "Member 'KismetMathLibrary_MinOfFloatArray::MinValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MinOfIntArray
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_MinOfIntArray final
{
public:
	TArray<int32>                                 IntArray;                                          // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexOfMinValue;                                   // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinValue;                                          // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MinOfIntArray) == 0x000008, "Wrong alignment on KismetMathLibrary_MinOfIntArray");
static_assert(sizeof(KismetMathLibrary_MinOfIntArray) == 0x000018, "Wrong size on KismetMathLibrary_MinOfIntArray");
static_assert(offsetof(KismetMathLibrary_MinOfIntArray, IntArray) == 0x000000, "Member 'KismetMathLibrary_MinOfIntArray::IntArray' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfIntArray, IndexOfMinValue) == 0x000010, "Member 'KismetMathLibrary_MinOfIntArray::IndexOfMinValue' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MinOfIntArray, MinValue) == 0x000014, "Member 'KismetMathLibrary_MinOfIntArray::MinValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MirrorVectorByNormal
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_MirrorVectorByNormal final
{
public:
	struct FVector                                InVect;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InNormal;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MirrorVectorByNormal) == 0x000004, "Wrong alignment on KismetMathLibrary_MirrorVectorByNormal");
static_assert(sizeof(KismetMathLibrary_MirrorVectorByNormal) == 0x000024, "Wrong size on KismetMathLibrary_MirrorVectorByNormal");
static_assert(offsetof(KismetMathLibrary_MirrorVectorByNormal, InVect) == 0x000000, "Member 'KismetMathLibrary_MirrorVectorByNormal::InVect' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MirrorVectorByNormal, InNormal) == 0x00000C, "Member 'KismetMathLibrary_MirrorVectorByNormal::InNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MirrorVectorByNormal, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_MirrorVectorByNormal::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Multiply_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Multiply_ByteByte");
static_assert(sizeof(KismetMathLibrary_Multiply_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Multiply_ByteByte");
static_assert(offsetof(KismetMathLibrary_Multiply_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Multiply_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Multiply_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Multiply_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Multiply_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Multiply_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Multiply_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_IntFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Multiply_IntFloat final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_IntFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_IntFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_IntFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Multiply_IntFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_IntFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_IntFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_IntFloat, B) == 0x000004, "Member 'KismetMathLibrary_Multiply_IntFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_IntFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Multiply_IntFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Multiply_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_IntInt");
static_assert(sizeof(KismetMathLibrary_Multiply_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Multiply_IntInt");
static_assert(offsetof(KismetMathLibrary_Multiply_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Multiply_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Multiply_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_LinearColorFloat
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Multiply_LinearColorFloat final
{
public:
	struct FLinearColor                           A;                                                 // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0014(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_LinearColorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_LinearColorFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_LinearColorFloat) == 0x000024, "Wrong size on KismetMathLibrary_Multiply_LinearColorFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_LinearColorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorFloat, B) == 0x000010, "Member 'KismetMathLibrary_Multiply_LinearColorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorFloat, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_Multiply_LinearColorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_LinearColorLinearColor
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_Multiply_LinearColorLinearColor final
{
public:
	struct FLinearColor                           A;                                                 // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_LinearColorLinearColor) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_LinearColorLinearColor");
static_assert(sizeof(KismetMathLibrary_Multiply_LinearColorLinearColor) == 0x000030, "Wrong size on KismetMathLibrary_Multiply_LinearColorLinearColor");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorLinearColor, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_LinearColorLinearColor::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorLinearColor, B) == 0x000010, "Member 'KismetMathLibrary_Multiply_LinearColorLinearColor::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_LinearColorLinearColor, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_Multiply_LinearColorLinearColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_RotatorFloat
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Multiply_RotatorFloat final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_RotatorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_RotatorFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_RotatorFloat) == 0x00001C, "Wrong size on KismetMathLibrary_Multiply_RotatorFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_RotatorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorFloat, B) == 0x00000C, "Member 'KismetMathLibrary_Multiply_RotatorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_RotatorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_RotatorInt
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Multiply_RotatorInt final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_RotatorInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_RotatorInt");
static_assert(sizeof(KismetMathLibrary_Multiply_RotatorInt) == 0x00001C, "Wrong size on KismetMathLibrary_Multiply_RotatorInt");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorInt, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_RotatorInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorInt, B) == 0x00000C, "Member 'KismetMathLibrary_Multiply_RotatorInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_RotatorInt, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_RotatorInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_TimespanFloat
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Multiply_TimespanFloat final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scalar;                                            // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_TimespanFloat) == 0x000008, "Wrong alignment on KismetMathLibrary_Multiply_TimespanFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_TimespanFloat) == 0x000018, "Wrong size on KismetMathLibrary_Multiply_TimespanFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_TimespanFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_TimespanFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_TimespanFloat, Scalar) == 0x000008, "Member 'KismetMathLibrary_Multiply_TimespanFloat::Scalar' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_TimespanFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_TimespanFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_Vector2DFloat
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Multiply_Vector2DFloat final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_Vector2DFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_Vector2DFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_Vector2DFloat) == 0x000014, "Wrong size on KismetMathLibrary_Multiply_Vector2DFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_Vector2DFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DFloat, B) == 0x000008, "Member 'KismetMathLibrary_Multiply_Vector2DFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Multiply_Vector2DFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Multiply_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_Multiply_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_Multiply_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_Multiply_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_Vector2DVector2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_VectorFloat
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Multiply_VectorFloat final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_VectorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_VectorFloat");
static_assert(sizeof(KismetMathLibrary_Multiply_VectorFloat) == 0x00001C, "Wrong size on KismetMathLibrary_Multiply_VectorFloat");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_VectorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorFloat, B) == 0x00000C, "Member 'KismetMathLibrary_Multiply_VectorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_VectorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_VectorInt
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Multiply_VectorInt final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_VectorInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_VectorInt");
static_assert(sizeof(KismetMathLibrary_Multiply_VectorInt) == 0x00001C, "Wrong size on KismetMathLibrary_Multiply_VectorInt");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorInt, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_VectorInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorInt, B) == 0x00000C, "Member 'KismetMathLibrary_Multiply_VectorInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorInt, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Multiply_VectorInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Multiply_VectorVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Multiply_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Multiply_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Multiply_VectorVector");
static_assert(sizeof(KismetMathLibrary_Multiply_VectorVector) == 0x000024, "Wrong size on KismetMathLibrary_Multiply_VectorVector");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Multiply_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Multiply_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Multiply_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Multiply_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MultiplyByPi
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_MultiplyByPi final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MultiplyByPi) == 0x000004, "Wrong alignment on KismetMathLibrary_MultiplyByPi");
static_assert(sizeof(KismetMathLibrary_MultiplyByPi) == 0x000008, "Wrong size on KismetMathLibrary_MultiplyByPi");
static_assert(offsetof(KismetMathLibrary_MultiplyByPi, Value) == 0x000000, "Member 'KismetMathLibrary_MultiplyByPi::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MultiplyByPi, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_MultiplyByPi::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.MultiplyMultiply_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_MultiplyMultiply_FloatFloat final
{
public:
	float                                         Base;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Exp;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_MultiplyMultiply_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_MultiplyMultiply_FloatFloat");
static_assert(sizeof(KismetMathLibrary_MultiplyMultiply_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_MultiplyMultiply_FloatFloat");
static_assert(offsetof(KismetMathLibrary_MultiplyMultiply_FloatFloat, Base) == 0x000000, "Member 'KismetMathLibrary_MultiplyMultiply_FloatFloat::Base' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MultiplyMultiply_FloatFloat, Exp) == 0x000004, "Member 'KismetMathLibrary_MultiplyMultiply_FloatFloat::Exp' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_MultiplyMultiply_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_MultiplyMultiply_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NearlyEqual_FloatFloat
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_NearlyEqual_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NearlyEqual_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_NearlyEqual_FloatFloat");
static_assert(sizeof(KismetMathLibrary_NearlyEqual_FloatFloat) == 0x000010, "Wrong size on KismetMathLibrary_NearlyEqual_FloatFloat");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_NearlyEqual_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_NearlyEqual_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_FloatFloat, ErrorTolerance) == 0x000008, "Member 'KismetMathLibrary_NearlyEqual_FloatFloat::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_FloatFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_NearlyEqual_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NearlyEqual_TransformTransform
// 0x0070 (0x0070 - 0x0000)
struct KismetMathLibrary_NearlyEqual_TransformTransform final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LocationTolerance;                                 // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RotationTolerance;                                 // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale3DTolerance;                                  // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x006C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6D[0x3];                                       // 0x006D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NearlyEqual_TransformTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_NearlyEqual_TransformTransform");
static_assert(sizeof(KismetMathLibrary_NearlyEqual_TransformTransform) == 0x000070, "Wrong size on KismetMathLibrary_NearlyEqual_TransformTransform");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, A) == 0x000000, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, B) == 0x000030, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, LocationTolerance) == 0x000060, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::LocationTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, RotationTolerance) == 0x000064, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::RotationTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, Scale3DTolerance) == 0x000068, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::Scale3DTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NearlyEqual_TransformTransform, ReturnValue) == 0x00006C, "Member 'KismetMathLibrary_NearlyEqual_TransformTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NegateRotator
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NegateRotator final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NegateRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_NegateRotator");
static_assert(sizeof(KismetMathLibrary_NegateRotator) == 0x000018, "Wrong size on KismetMathLibrary_NegateRotator");
static_assert(offsetof(KismetMathLibrary_NegateRotator, A) == 0x000000, "Member 'KismetMathLibrary_NegateRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NegateRotator, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_NegateRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NegateVector
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NegateVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NegateVector) == 0x000004, "Wrong alignment on KismetMathLibrary_NegateVector");
static_assert(sizeof(KismetMathLibrary_NegateVector) == 0x000018, "Wrong size on KismetMathLibrary_NegateVector");
static_assert(offsetof(KismetMathLibrary_NegateVector, A) == 0x000000, "Member 'KismetMathLibrary_NegateVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NegateVector, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_NegateVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Normal
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Normal final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Normal) == 0x000004, "Wrong alignment on KismetMathLibrary_Normal");
static_assert(sizeof(KismetMathLibrary_Normal) == 0x000018, "Wrong size on KismetMathLibrary_Normal");
static_assert(offsetof(KismetMathLibrary_Normal, A) == 0x000000, "Member 'KismetMathLibrary_Normal::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Normal, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Normal::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Normal2D
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_Normal2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Normal2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Normal2D");
static_assert(sizeof(KismetMathLibrary_Normal2D) == 0x000010, "Wrong size on KismetMathLibrary_Normal2D");
static_assert(offsetof(KismetMathLibrary_Normal2D, A) == 0x000000, "Member 'KismetMathLibrary_Normal2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Normal2D, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Normal2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NormalizeAxis
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_NormalizeAxis final
{
public:
	float                                         Angle;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NormalizeAxis) == 0x000004, "Wrong alignment on KismetMathLibrary_NormalizeAxis");
static_assert(sizeof(KismetMathLibrary_NormalizeAxis) == 0x000008, "Wrong size on KismetMathLibrary_NormalizeAxis");
static_assert(offsetof(KismetMathLibrary_NormalizeAxis, Angle) == 0x000000, "Member 'KismetMathLibrary_NormalizeAxis::Angle' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizeAxis, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_NormalizeAxis::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NormalizedDeltaRotator
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_NormalizedDeltaRotator final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NormalizedDeltaRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_NormalizedDeltaRotator");
static_assert(sizeof(KismetMathLibrary_NormalizedDeltaRotator) == 0x000024, "Wrong size on KismetMathLibrary_NormalizedDeltaRotator");
static_assert(offsetof(KismetMathLibrary_NormalizedDeltaRotator, A) == 0x000000, "Member 'KismetMathLibrary_NormalizedDeltaRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizedDeltaRotator, B) == 0x00000C, "Member 'KismetMathLibrary_NormalizedDeltaRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizedDeltaRotator, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_NormalizedDeltaRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NormalizeToRange
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_NormalizeToRange final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMin;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RangeMax;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NormalizeToRange) == 0x000004, "Wrong alignment on KismetMathLibrary_NormalizeToRange");
static_assert(sizeof(KismetMathLibrary_NormalizeToRange) == 0x000010, "Wrong size on KismetMathLibrary_NormalizeToRange");
static_assert(offsetof(KismetMathLibrary_NormalizeToRange, Value) == 0x000000, "Member 'KismetMathLibrary_NormalizeToRange::Value' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizeToRange, RangeMin) == 0x000004, "Member 'KismetMathLibrary_NormalizeToRange::RangeMin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizeToRange, RangeMax) == 0x000008, "Member 'KismetMathLibrary_NormalizeToRange::RangeMax' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NormalizeToRange, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_NormalizeToRange::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Not_Int
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Not_Int final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Not_Int) == 0x000004, "Wrong alignment on KismetMathLibrary_Not_Int");
static_assert(sizeof(KismetMathLibrary_Not_Int) == 0x000008, "Wrong size on KismetMathLibrary_Not_Int");
static_assert(offsetof(KismetMathLibrary_Not_Int, A) == 0x000000, "Member 'KismetMathLibrary_Not_Int::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Not_Int, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Not_Int::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Not_PreBool
// 0x0002 (0x0002 - 0x0000)
struct KismetMathLibrary_Not_PreBool final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Not_PreBool) == 0x000001, "Wrong alignment on KismetMathLibrary_Not_PreBool");
static_assert(sizeof(KismetMathLibrary_Not_PreBool) == 0x000002, "Wrong size on KismetMathLibrary_Not_PreBool");
static_assert(offsetof(KismetMathLibrary_Not_PreBool, A) == 0x000000, "Member 'KismetMathLibrary_Not_PreBool::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Not_PreBool, ReturnValue) == 0x000001, "Member 'KismetMathLibrary_Not_PreBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_BoolBool
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_NotEqual_BoolBool final
{
public:
	bool                                          A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NotEqual_BoolBool) == 0x000001, "Wrong alignment on KismetMathLibrary_NotEqual_BoolBool");
static_assert(sizeof(KismetMathLibrary_NotEqual_BoolBool) == 0x000003, "Wrong size on KismetMathLibrary_NotEqual_BoolBool");
static_assert(offsetof(KismetMathLibrary_NotEqual_BoolBool, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_BoolBool::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_BoolBool, B) == 0x000001, "Member 'KismetMathLibrary_NotEqual_BoolBool::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_BoolBool, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_NotEqual_BoolBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_NotEqual_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_NotEqual_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_NotEqual_ByteByte");
static_assert(sizeof(KismetMathLibrary_NotEqual_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_NotEqual_ByteByte");
static_assert(offsetof(KismetMathLibrary_NotEqual_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_NotEqual_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_NotEqual_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_ClassClass
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_ClassClass final
{
public:
	class UClass*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_ClassClass) == 0x000008, "Wrong alignment on KismetMathLibrary_NotEqual_ClassClass");
static_assert(sizeof(KismetMathLibrary_NotEqual_ClassClass) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_ClassClass");
static_assert(offsetof(KismetMathLibrary_NotEqual_ClassClass, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_ClassClass::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ClassClass, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_ClassClass::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ClassClass, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_NotEqual_ClassClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_NotEqual_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_NotEqual_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_NotEqual_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_NotEqual_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_NotEqual_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_FloatFloat");
static_assert(sizeof(KismetMathLibrary_NotEqual_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_NotEqual_FloatFloat");
static_assert(offsetof(KismetMathLibrary_NotEqual_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_NotEqual_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_NotEqual_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_NotEqual_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_IntInt");
static_assert(sizeof(KismetMathLibrary_NotEqual_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_NotEqual_IntInt");
static_assert(offsetof(KismetMathLibrary_NotEqual_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_NotEqual_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_NotEqual_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_NameName
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_NameName final
{
public:
	class FName                                   A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_NameName) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_NameName");
static_assert(sizeof(KismetMathLibrary_NotEqual_NameName) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_NameName");
static_assert(offsetof(KismetMathLibrary_NotEqual_NameName, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_NameName::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_NameName, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_NameName::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_NameName, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_NotEqual_NameName::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_ObjectObject
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_ObjectObject final
{
public:
	class UObject*                                A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_ObjectObject) == 0x000008, "Wrong alignment on KismetMathLibrary_NotEqual_ObjectObject");
static_assert(sizeof(KismetMathLibrary_NotEqual_ObjectObject) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_ObjectObject");
static_assert(offsetof(KismetMathLibrary_NotEqual_ObjectObject, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_ObjectObject::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ObjectObject, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_ObjectObject::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_ObjectObject, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_NotEqual_ObjectObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_RotatorRotator
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_NotEqual_RotatorRotator final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_RotatorRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_RotatorRotator");
static_assert(sizeof(KismetMathLibrary_NotEqual_RotatorRotator) == 0x000020, "Wrong size on KismetMathLibrary_NotEqual_RotatorRotator");
static_assert(offsetof(KismetMathLibrary_NotEqual_RotatorRotator, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_RotatorRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_RotatorRotator, B) == 0x00000C, "Member 'KismetMathLibrary_NotEqual_RotatorRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_RotatorRotator, ErrorTolerance) == 0x000018, "Member 'KismetMathLibrary_NotEqual_RotatorRotator::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_RotatorRotator, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_NotEqual_RotatorRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_NotEqual_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_NotEqual_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_NotEqual_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_NotEqual_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_NotEqual_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_NotEqual_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_NotEqual_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_NotEqual_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_NotEqual_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_Vector2DVector2D, ErrorTolerance) == 0x000010, "Member 'KismetMathLibrary_NotEqual_Vector2DVector2D::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_Vector2DVector2D, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_NotEqual_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.NotEqual_VectorVector
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_NotEqual_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ErrorTolerance;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_NotEqual_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_NotEqual_VectorVector");
static_assert(sizeof(KismetMathLibrary_NotEqual_VectorVector) == 0x000020, "Wrong size on KismetMathLibrary_NotEqual_VectorVector");
static_assert(offsetof(KismetMathLibrary_NotEqual_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_NotEqual_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_NotEqual_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_VectorVector, ErrorTolerance) == 0x000018, "Member 'KismetMathLibrary_NotEqual_VectorVector::ErrorTolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_NotEqual_VectorVector, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_NotEqual_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Now
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Now final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Now) == 0x000008, "Wrong alignment on KismetMathLibrary_Now");
static_assert(sizeof(KismetMathLibrary_Now) == 0x000008, "Wrong size on KismetMathLibrary_Now");
static_assert(offsetof(KismetMathLibrary_Now, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_Now::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Or_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Or_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Or_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Or_IntInt");
static_assert(sizeof(KismetMathLibrary_Or_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Or_IntInt");
static_assert(offsetof(KismetMathLibrary_Or_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Or_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Or_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Or_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Or_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Or_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Percent_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Percent_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Percent_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Percent_ByteByte");
static_assert(sizeof(KismetMathLibrary_Percent_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Percent_ByteByte");
static_assert(offsetof(KismetMathLibrary_Percent_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Percent_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Percent_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Percent_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Percent_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Percent_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Percent_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Percent_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Percent_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Percent_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Percent_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Percent_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Percent_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Percent_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Percent_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Percent_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Percent_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Percent_IntInt");
static_assert(sizeof(KismetMathLibrary_Percent_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Percent_IntInt");
static_assert(offsetof(KismetMathLibrary_Percent_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Percent_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Percent_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Percent_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Percent_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.PointsAreCoplanar
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_PointsAreCoplanar final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         Tolerance;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_PointsAreCoplanar) == 0x000008, "Wrong alignment on KismetMathLibrary_PointsAreCoplanar");
static_assert(sizeof(KismetMathLibrary_PointsAreCoplanar) == 0x000018, "Wrong size on KismetMathLibrary_PointsAreCoplanar");
static_assert(offsetof(KismetMathLibrary_PointsAreCoplanar, Points) == 0x000000, "Member 'KismetMathLibrary_PointsAreCoplanar::Points' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_PointsAreCoplanar, Tolerance) == 0x000010, "Member 'KismetMathLibrary_PointsAreCoplanar::Tolerance' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_PointsAreCoplanar, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_PointsAreCoplanar::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ProjectPointOnToPlane
// 0x0030 (0x0030 - 0x0000)
struct KismetMathLibrary_ProjectPointOnToPlane final
{
public:
	struct FVector                                Point;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneBase;                                         // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0024(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ProjectPointOnToPlane) == 0x000004, "Wrong alignment on KismetMathLibrary_ProjectPointOnToPlane");
static_assert(sizeof(KismetMathLibrary_ProjectPointOnToPlane) == 0x000030, "Wrong size on KismetMathLibrary_ProjectPointOnToPlane");
static_assert(offsetof(KismetMathLibrary_ProjectPointOnToPlane, Point) == 0x000000, "Member 'KismetMathLibrary_ProjectPointOnToPlane::Point' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectPointOnToPlane, PlaneBase) == 0x00000C, "Member 'KismetMathLibrary_ProjectPointOnToPlane::PlaneBase' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectPointOnToPlane, PlaneNormal) == 0x000018, "Member 'KismetMathLibrary_ProjectPointOnToPlane::PlaneNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectPointOnToPlane, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_ProjectPointOnToPlane::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ProjectVectorOnToPlane
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_ProjectVectorOnToPlane final
{
public:
	struct FVector                                V;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PlaneNormal;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ProjectVectorOnToPlane) == 0x000004, "Wrong alignment on KismetMathLibrary_ProjectVectorOnToPlane");
static_assert(sizeof(KismetMathLibrary_ProjectVectorOnToPlane) == 0x000024, "Wrong size on KismetMathLibrary_ProjectVectorOnToPlane");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToPlane, V) == 0x000000, "Member 'KismetMathLibrary_ProjectVectorOnToPlane::V' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToPlane, PlaneNormal) == 0x00000C, "Member 'KismetMathLibrary_ProjectVectorOnToPlane::PlaneNormal' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToPlane, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_ProjectVectorOnToPlane::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ProjectVectorOnToVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_ProjectVectorOnToVector final
{
public:
	struct FVector                                V;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ProjectVectorOnToVector) == 0x000004, "Wrong alignment on KismetMathLibrary_ProjectVectorOnToVector");
static_assert(sizeof(KismetMathLibrary_ProjectVectorOnToVector) == 0x000024, "Wrong size on KismetMathLibrary_ProjectVectorOnToVector");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToVector, V) == 0x000000, "Member 'KismetMathLibrary_ProjectVectorOnToVector::V' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToVector, Target) == 0x00000C, "Member 'KismetMathLibrary_ProjectVectorOnToVector::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_ProjectVectorOnToVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_ProjectVectorOnToVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RadiansToDegrees
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_RadiansToDegrees final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RadiansToDegrees) == 0x000004, "Wrong alignment on KismetMathLibrary_RadiansToDegrees");
static_assert(sizeof(KismetMathLibrary_RadiansToDegrees) == 0x000008, "Wrong size on KismetMathLibrary_RadiansToDegrees");
static_assert(offsetof(KismetMathLibrary_RadiansToDegrees, A) == 0x000000, "Member 'KismetMathLibrary_RadiansToDegrees::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RadiansToDegrees, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_RadiansToDegrees::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomBool
// 0x0001 (0x0001 - 0x0000)
struct KismetMathLibrary_RandomBool final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomBool) == 0x000001, "Wrong alignment on KismetMathLibrary_RandomBool");
static_assert(sizeof(KismetMathLibrary_RandomBool) == 0x000001, "Wrong size on KismetMathLibrary_RandomBool");
static_assert(offsetof(KismetMathLibrary_RandomBool, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_RandomBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomBoolFromStream
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_RandomBoolFromStream final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_RandomBoolFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomBoolFromStream");
static_assert(sizeof(KismetMathLibrary_RandomBoolFromStream) == 0x00000C, "Wrong size on KismetMathLibrary_RandomBoolFromStream");
static_assert(offsetof(KismetMathLibrary_RandomBoolFromStream, Stream) == 0x000000, "Member 'KismetMathLibrary_RandomBoolFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomBoolFromStream, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_RandomBoolFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomBoolWithWeight
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_RandomBoolWithWeight final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_RandomBoolWithWeight) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomBoolWithWeight");
static_assert(sizeof(KismetMathLibrary_RandomBoolWithWeight) == 0x000008, "Wrong size on KismetMathLibrary_RandomBoolWithWeight");
static_assert(offsetof(KismetMathLibrary_RandomBoolWithWeight, Weight) == 0x000000, "Member 'KismetMathLibrary_RandomBoolWithWeight::Weight' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomBoolWithWeight, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_RandomBoolWithWeight::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomBoolWithWeightFromStream
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_RandomBoolWithWeightFromStream final
{
public:
	float                                         Weight;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          RandomStream;                                      // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_RandomBoolWithWeightFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomBoolWithWeightFromStream");
static_assert(sizeof(KismetMathLibrary_RandomBoolWithWeightFromStream) == 0x000010, "Wrong size on KismetMathLibrary_RandomBoolWithWeightFromStream");
static_assert(offsetof(KismetMathLibrary_RandomBoolWithWeightFromStream, Weight) == 0x000000, "Member 'KismetMathLibrary_RandomBoolWithWeightFromStream::Weight' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomBoolWithWeightFromStream, RandomStream) == 0x000004, "Member 'KismetMathLibrary_RandomBoolWithWeightFromStream::RandomStream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomBoolWithWeightFromStream, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_RandomBoolWithWeightFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomFloat
// 0x0004 (0x0004 - 0x0000)
struct KismetMathLibrary_RandomFloat final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomFloat");
static_assert(sizeof(KismetMathLibrary_RandomFloat) == 0x000004, "Wrong size on KismetMathLibrary_RandomFloat");
static_assert(offsetof(KismetMathLibrary_RandomFloat, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_RandomFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomFloatFromStream
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_RandomFloatFromStream final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomFloatFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomFloatFromStream");
static_assert(sizeof(KismetMathLibrary_RandomFloatFromStream) == 0x00000C, "Wrong size on KismetMathLibrary_RandomFloatFromStream");
static_assert(offsetof(KismetMathLibrary_RandomFloatFromStream, Stream) == 0x000000, "Member 'KismetMathLibrary_RandomFloatFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatFromStream, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_RandomFloatFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomFloatInRange
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_RandomFloatInRange final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomFloatInRange) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomFloatInRange");
static_assert(sizeof(KismetMathLibrary_RandomFloatInRange) == 0x00000C, "Wrong size on KismetMathLibrary_RandomFloatInRange");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRange, Min) == 0x000000, "Member 'KismetMathLibrary_RandomFloatInRange::Min' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRange, Max) == 0x000004, "Member 'KismetMathLibrary_RandomFloatInRange::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRange, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_RandomFloatInRange::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomFloatInRangeFromStream
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_RandomFloatInRangeFromStream final
{
public:
	float                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomFloatInRangeFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomFloatInRangeFromStream");
static_assert(sizeof(KismetMathLibrary_RandomFloatInRangeFromStream) == 0x000014, "Wrong size on KismetMathLibrary_RandomFloatInRangeFromStream");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRangeFromStream, Min) == 0x000000, "Member 'KismetMathLibrary_RandomFloatInRangeFromStream::Min' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRangeFromStream, Max) == 0x000004, "Member 'KismetMathLibrary_RandomFloatInRangeFromStream::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRangeFromStream, Stream) == 0x000008, "Member 'KismetMathLibrary_RandomFloatInRangeFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomFloatInRangeFromStream, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_RandomFloatInRangeFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomInteger
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_RandomInteger final
{
public:
	int32                                         Max;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomInteger) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomInteger");
static_assert(sizeof(KismetMathLibrary_RandomInteger) == 0x000008, "Wrong size on KismetMathLibrary_RandomInteger");
static_assert(offsetof(KismetMathLibrary_RandomInteger, Max) == 0x000000, "Member 'KismetMathLibrary_RandomInteger::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomInteger, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_RandomInteger::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomIntegerFromStream
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_RandomIntegerFromStream final
{
public:
	int32                                         Max;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomIntegerFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomIntegerFromStream");
static_assert(sizeof(KismetMathLibrary_RandomIntegerFromStream) == 0x000010, "Wrong size on KismetMathLibrary_RandomIntegerFromStream");
static_assert(offsetof(KismetMathLibrary_RandomIntegerFromStream, Max) == 0x000000, "Member 'KismetMathLibrary_RandomIntegerFromStream::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerFromStream, Stream) == 0x000004, "Member 'KismetMathLibrary_RandomIntegerFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerFromStream, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_RandomIntegerFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomIntegerInRange
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_RandomIntegerInRange final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomIntegerInRange) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomIntegerInRange");
static_assert(sizeof(KismetMathLibrary_RandomIntegerInRange) == 0x00000C, "Wrong size on KismetMathLibrary_RandomIntegerInRange");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRange, Min) == 0x000000, "Member 'KismetMathLibrary_RandomIntegerInRange::Min' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRange, Max) == 0x000004, "Member 'KismetMathLibrary_RandomIntegerInRange::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRange, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_RandomIntegerInRange::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomIntegerInRangeFromStream
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_RandomIntegerInRangeFromStream final
{
public:
	int32                                         Min;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Max;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomIntegerInRangeFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomIntegerInRangeFromStream");
static_assert(sizeof(KismetMathLibrary_RandomIntegerInRangeFromStream) == 0x000014, "Wrong size on KismetMathLibrary_RandomIntegerInRangeFromStream");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRangeFromStream, Min) == 0x000000, "Member 'KismetMathLibrary_RandomIntegerInRangeFromStream::Min' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRangeFromStream, Max) == 0x000004, "Member 'KismetMathLibrary_RandomIntegerInRangeFromStream::Max' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRangeFromStream, Stream) == 0x000008, "Member 'KismetMathLibrary_RandomIntegerInRangeFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomIntegerInRangeFromStream, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_RandomIntegerInRangeFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomPointInBoundingBox
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_RandomPointInBoundingBox final
{
public:
	struct FVector                                Origin;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomPointInBoundingBox) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomPointInBoundingBox");
static_assert(sizeof(KismetMathLibrary_RandomPointInBoundingBox) == 0x000024, "Wrong size on KismetMathLibrary_RandomPointInBoundingBox");
static_assert(offsetof(KismetMathLibrary_RandomPointInBoundingBox, Origin) == 0x000000, "Member 'KismetMathLibrary_RandomPointInBoundingBox::Origin' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomPointInBoundingBox, BoxExtent) == 0x00000C, "Member 'KismetMathLibrary_RandomPointInBoundingBox::BoxExtent' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomPointInBoundingBox, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_RandomPointInBoundingBox::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomRotator
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_RandomRotator final
{
public:
	bool                                          bRoll;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomRotator");
static_assert(sizeof(KismetMathLibrary_RandomRotator) == 0x000010, "Wrong size on KismetMathLibrary_RandomRotator");
static_assert(offsetof(KismetMathLibrary_RandomRotator, bRoll) == 0x000000, "Member 'KismetMathLibrary_RandomRotator::bRoll' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomRotator, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_RandomRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomRotatorFromStream
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_RandomRotatorFromStream final
{
public:
	bool                                          bRoll;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRandomStream                          Stream;                                            // 0x0004(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomRotatorFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomRotatorFromStream");
static_assert(sizeof(KismetMathLibrary_RandomRotatorFromStream) == 0x000018, "Wrong size on KismetMathLibrary_RandomRotatorFromStream");
static_assert(offsetof(KismetMathLibrary_RandomRotatorFromStream, bRoll) == 0x000000, "Member 'KismetMathLibrary_RandomRotatorFromStream::bRoll' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomRotatorFromStream, Stream) == 0x000004, "Member 'KismetMathLibrary_RandomRotatorFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomRotatorFromStream, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_RandomRotatorFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVector
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_RandomUnitVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVector) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVector");
static_assert(sizeof(KismetMathLibrary_RandomUnitVector) == 0x00000C, "Wrong size on KismetMathLibrary_RandomUnitVector");
static_assert(offsetof(KismetMathLibrary_RandomUnitVector, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorFromStream
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorFromStream final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorFromStream");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorFromStream) == 0x000014, "Wrong size on KismetMathLibrary_RandomUnitVectorFromStream");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorFromStream, Stream) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorFromStream, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_RandomUnitVectorFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegrees
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInConeInDegrees final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngleInDegrees;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInConeInDegrees) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInConeInDegrees");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInConeInDegrees) == 0x00001C, "Wrong size on KismetMathLibrary_RandomUnitVectorInConeInDegrees");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegrees, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegrees::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegrees, ConeHalfAngleInDegrees) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegrees::ConeHalfAngleInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegrees, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegrees::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInDegreesFromStream
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngleInDegrees;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream) == 0x000024, "Wrong size on KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream, ConeHalfAngleInDegrees) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream::ConeHalfAngleInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream, Stream) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_RandomUnitVectorInConeInDegreesFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadians
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInConeInRadians final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngleInRadians;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInConeInRadians) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInConeInRadians");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInConeInRadians) == 0x00001C, "Wrong size on KismetMathLibrary_RandomUnitVectorInConeInRadians");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadians, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadians::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadians, ConeHalfAngleInRadians) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadians::ConeHalfAngleInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadians, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadians::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInConeInRadiansFromStream
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ConeHalfAngleInRadians;                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream) == 0x000024, "Wrong size on KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream, ConeHalfAngleInRadians) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream::ConeHalfAngleInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream, Stream) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_RandomUnitVectorInConeInRadiansFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegrees
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawInDegrees;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchInDegrees;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees) == 0x000020, "Wrong size on KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees, MaxYawInDegrees) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees::MaxYawInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees, MaxPitchInDegrees) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees::MaxPitchInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegrees::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInDegreesFromStream
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawInDegrees;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchInDegrees;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0014(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream) == 0x000028, "Wrong size on KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream, MaxYawInDegrees) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream::MaxYawInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream, MaxPitchInDegrees) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream::MaxPitchInDegrees' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream, Stream) == 0x000014, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInDegreesFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadians
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawInRadians;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchInRadians;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians) == 0x000020, "Wrong size on KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians, MaxYawInRadians) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians::MaxYawInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians, MaxPitchInRadians) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians::MaxPitchInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians, ReturnValue) == 0x000014, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadians::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RandomUnitVectorInEllipticalConeInRadiansFromStream
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream final
{
public:
	struct FVector                                ConeDir;                                           // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxYawInRadians;                                   // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxPitchInRadians;                                 // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRandomStream                          Stream;                                            // 0x0014(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream) == 0x000004, "Wrong alignment on KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream");
static_assert(sizeof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream) == 0x000028, "Wrong size on KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream, ConeDir) == 0x000000, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream::ConeDir' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream, MaxYawInRadians) == 0x00000C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream::MaxYawInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream, MaxPitchInRadians) == 0x000010, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream::MaxPitchInRadians' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream, Stream) == 0x000014, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_RandomUnitVectorInEllipticalConeInRadiansFromStream::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.REase
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_REase final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShortestPath;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_REase) == 0x000004, "Wrong alignment on KismetMathLibrary_REase");
static_assert(sizeof(KismetMathLibrary_REase) == 0x000034, "Wrong size on KismetMathLibrary_REase");
static_assert(offsetof(KismetMathLibrary_REase, A) == 0x000000, "Member 'KismetMathLibrary_REase::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, B) == 0x00000C, "Member 'KismetMathLibrary_REase::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, Alpha) == 0x000018, "Member 'KismetMathLibrary_REase::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, bShortestPath) == 0x00001C, "Member 'KismetMathLibrary_REase::bShortestPath' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, EasingFunc) == 0x00001D, "Member 'KismetMathLibrary_REase::EasingFunc' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, BlendExp) == 0x000020, "Member 'KismetMathLibrary_REase::BlendExp' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, Steps) == 0x000024, "Member 'KismetMathLibrary_REase::Steps' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_REase, ReturnValue) == 0x000028, "Member 'KismetMathLibrary_REase::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.ResetFloatSpringState
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_ResetFloatSpringState final
{
public:
	struct FFloatSpringState                      SpringState;                                       // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ResetFloatSpringState) == 0x000004, "Wrong alignment on KismetMathLibrary_ResetFloatSpringState");
static_assert(sizeof(KismetMathLibrary_ResetFloatSpringState) == 0x000008, "Wrong size on KismetMathLibrary_ResetFloatSpringState");
static_assert(offsetof(KismetMathLibrary_ResetFloatSpringState, SpringState) == 0x000000, "Member 'KismetMathLibrary_ResetFloatSpringState::SpringState' has a wrong offset!");

// Function Engine.KismetMathLibrary.ResetRandomStream
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_ResetRandomStream final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ResetRandomStream) == 0x000004, "Wrong alignment on KismetMathLibrary_ResetRandomStream");
static_assert(sizeof(KismetMathLibrary_ResetRandomStream) == 0x000008, "Wrong size on KismetMathLibrary_ResetRandomStream");
static_assert(offsetof(KismetMathLibrary_ResetRandomStream, Stream) == 0x000000, "Member 'KismetMathLibrary_ResetRandomStream::Stream' has a wrong offset!");

// Function Engine.KismetMathLibrary.ResetVectorSpringState
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_ResetVectorSpringState final
{
public:
	struct FVectorSpringState                     SpringState;                                       // 0x0000(0x0018)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_ResetVectorSpringState) == 0x000004, "Wrong alignment on KismetMathLibrary_ResetVectorSpringState");
static_assert(sizeof(KismetMathLibrary_ResetVectorSpringState) == 0x000018, "Wrong size on KismetMathLibrary_ResetVectorSpringState");
static_assert(offsetof(KismetMathLibrary_ResetVectorSpringState, SpringState) == 0x000000, "Member 'KismetMathLibrary_ResetVectorSpringState::SpringState' has a wrong offset!");

// Function Engine.KismetMathLibrary.RGBToHSV
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_RGBToHSV final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         H;                                                 // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         S;                                                 // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         V;                                                 // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         A;                                                 // 0x001C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RGBToHSV) == 0x000004, "Wrong alignment on KismetMathLibrary_RGBToHSV");
static_assert(sizeof(KismetMathLibrary_RGBToHSV) == 0x000020, "Wrong size on KismetMathLibrary_RGBToHSV");
static_assert(offsetof(KismetMathLibrary_RGBToHSV, InColor) == 0x000000, "Member 'KismetMathLibrary_RGBToHSV::InColor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RGBToHSV, H) == 0x000010, "Member 'KismetMathLibrary_RGBToHSV::H' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RGBToHSV, S) == 0x000014, "Member 'KismetMathLibrary_RGBToHSV::S' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RGBToHSV, V) == 0x000018, "Member 'KismetMathLibrary_RGBToHSV::V' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RGBToHSV, A) == 0x00001C, "Member 'KismetMathLibrary_RGBToHSV::A' has a wrong offset!");

// Function Engine.KismetMathLibrary.RGBToHSV_Vector
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_RGBToHSV_Vector final
{
public:
	struct FLinearColor                           RGB;                                               // 0x0000(0x0010)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           HSV;                                               // 0x0010(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RGBToHSV_Vector) == 0x000004, "Wrong alignment on KismetMathLibrary_RGBToHSV_Vector");
static_assert(sizeof(KismetMathLibrary_RGBToHSV_Vector) == 0x000020, "Wrong size on KismetMathLibrary_RGBToHSV_Vector");
static_assert(offsetof(KismetMathLibrary_RGBToHSV_Vector, RGB) == 0x000000, "Member 'KismetMathLibrary_RGBToHSV_Vector::RGB' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RGBToHSV_Vector, HSV) == 0x000010, "Member 'KismetMathLibrary_RGBToHSV_Vector::HSV' has a wrong offset!");

// Function Engine.KismetMathLibrary.RInterpTo
// 0x002C (0x002C - 0x0000)
struct KismetMathLibrary_RInterpTo final
{
public:
	struct FRotator                               Current;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RInterpTo) == 0x000004, "Wrong alignment on KismetMathLibrary_RInterpTo");
static_assert(sizeof(KismetMathLibrary_RInterpTo) == 0x00002C, "Wrong size on KismetMathLibrary_RInterpTo");
static_assert(offsetof(KismetMathLibrary_RInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_RInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo, Target) == 0x00000C, "Member 'KismetMathLibrary_RInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo, DeltaTime) == 0x000018, "Member 'KismetMathLibrary_RInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo, InterpSpeed) == 0x00001C, "Member 'KismetMathLibrary_RInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_RInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RInterpTo_Constant
// 0x002C (0x002C - 0x0000)
struct KismetMathLibrary_RInterpTo_Constant final
{
public:
	struct FRotator                               Current;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RInterpTo_Constant) == 0x000004, "Wrong alignment on KismetMathLibrary_RInterpTo_Constant");
static_assert(sizeof(KismetMathLibrary_RInterpTo_Constant) == 0x00002C, "Wrong size on KismetMathLibrary_RInterpTo_Constant");
static_assert(offsetof(KismetMathLibrary_RInterpTo_Constant, Current) == 0x000000, "Member 'KismetMathLibrary_RInterpTo_Constant::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo_Constant, Target) == 0x00000C, "Member 'KismetMathLibrary_RInterpTo_Constant::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo_Constant, DeltaTime) == 0x000018, "Member 'KismetMathLibrary_RInterpTo_Constant::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo_Constant, InterpSpeed) == 0x00001C, "Member 'KismetMathLibrary_RInterpTo_Constant::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RInterpTo_Constant, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_RInterpTo_Constant::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RLerp
// 0x002C (0x002C - 0x0000)
struct KismetMathLibrary_RLerp final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShortestPath;                                     // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RLerp) == 0x000004, "Wrong alignment on KismetMathLibrary_RLerp");
static_assert(sizeof(KismetMathLibrary_RLerp) == 0x00002C, "Wrong size on KismetMathLibrary_RLerp");
static_assert(offsetof(KismetMathLibrary_RLerp, A) == 0x000000, "Member 'KismetMathLibrary_RLerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RLerp, B) == 0x00000C, "Member 'KismetMathLibrary_RLerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RLerp, Alpha) == 0x000018, "Member 'KismetMathLibrary_RLerp::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RLerp, bShortestPath) == 0x00001C, "Member 'KismetMathLibrary_RLerp::bShortestPath' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RLerp, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_RLerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RotateAngleAxis
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_RotateAngleAxis final
{
public:
	struct FVector                                InVect;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleDeg;                                          // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Axis;                                              // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RotateAngleAxis) == 0x000004, "Wrong alignment on KismetMathLibrary_RotateAngleAxis");
static_assert(sizeof(KismetMathLibrary_RotateAngleAxis) == 0x000028, "Wrong size on KismetMathLibrary_RotateAngleAxis");
static_assert(offsetof(KismetMathLibrary_RotateAngleAxis, InVect) == 0x000000, "Member 'KismetMathLibrary_RotateAngleAxis::InVect' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RotateAngleAxis, AngleDeg) == 0x00000C, "Member 'KismetMathLibrary_RotateAngleAxis::AngleDeg' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RotateAngleAxis, Axis) == 0x000010, "Member 'KismetMathLibrary_RotateAngleAxis::Axis' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RotateAngleAxis, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_RotateAngleAxis::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.RotatorFromAxisAndAngle
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_RotatorFromAxisAndAngle final
{
public:
	struct FVector                                Axis;                                              // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Angle;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_RotatorFromAxisAndAngle) == 0x000004, "Wrong alignment on KismetMathLibrary_RotatorFromAxisAndAngle");
static_assert(sizeof(KismetMathLibrary_RotatorFromAxisAndAngle) == 0x00001C, "Wrong size on KismetMathLibrary_RotatorFromAxisAndAngle");
static_assert(offsetof(KismetMathLibrary_RotatorFromAxisAndAngle, Axis) == 0x000000, "Member 'KismetMathLibrary_RotatorFromAxisAndAngle::Axis' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RotatorFromAxisAndAngle, Angle) == 0x00000C, "Member 'KismetMathLibrary_RotatorFromAxisAndAngle::Angle' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_RotatorFromAxisAndAngle, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_RotatorFromAxisAndAngle::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Round
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Round final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Round) == 0x000004, "Wrong alignment on KismetMathLibrary_Round");
static_assert(sizeof(KismetMathLibrary_Round) == 0x000008, "Wrong size on KismetMathLibrary_Round");
static_assert(offsetof(KismetMathLibrary_Round, A) == 0x000000, "Member 'KismetMathLibrary_Round::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Round, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Round::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SeedRandomStream
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_SeedRandomStream final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SeedRandomStream) == 0x000004, "Wrong alignment on KismetMathLibrary_SeedRandomStream");
static_assert(sizeof(KismetMathLibrary_SeedRandomStream) == 0x000008, "Wrong size on KismetMathLibrary_SeedRandomStream");
static_assert(offsetof(KismetMathLibrary_SeedRandomStream, Stream) == 0x000000, "Member 'KismetMathLibrary_SeedRandomStream::Stream' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectClass
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_SelectClass final
{
public:
	class UClass*                                 A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectA;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectClass) == 0x000008, "Wrong alignment on KismetMathLibrary_SelectClass");
static_assert(sizeof(KismetMathLibrary_SelectClass) == 0x000020, "Wrong size on KismetMathLibrary_SelectClass");
static_assert(offsetof(KismetMathLibrary_SelectClass, A) == 0x000000, "Member 'KismetMathLibrary_SelectClass::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectClass, B) == 0x000008, "Member 'KismetMathLibrary_SelectClass::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectClass, bSelectA) == 0x000010, "Member 'KismetMathLibrary_SelectClass::bSelectA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectClass, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_SelectClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectColor
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_SelectColor final
{
public:
	struct FLinearColor                           A;                                                 // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           B;                                                 // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           ReturnValue;                                       // 0x0024(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectColor) == 0x000004, "Wrong alignment on KismetMathLibrary_SelectColor");
static_assert(sizeof(KismetMathLibrary_SelectColor) == 0x000034, "Wrong size on KismetMathLibrary_SelectColor");
static_assert(offsetof(KismetMathLibrary_SelectColor, A) == 0x000000, "Member 'KismetMathLibrary_SelectColor::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectColor, B) == 0x000010, "Member 'KismetMathLibrary_SelectColor::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectColor, bPickA) == 0x000020, "Member 'KismetMathLibrary_SelectColor::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectColor, ReturnValue) == 0x000024, "Member 'KismetMathLibrary_SelectColor::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectFloat
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_SelectFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_SelectFloat");
static_assert(sizeof(KismetMathLibrary_SelectFloat) == 0x000010, "Wrong size on KismetMathLibrary_SelectFloat");
static_assert(offsetof(KismetMathLibrary_SelectFloat, A) == 0x000000, "Member 'KismetMathLibrary_SelectFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectFloat, B) == 0x000004, "Member 'KismetMathLibrary_SelectFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectFloat, bPickA) == 0x000008, "Member 'KismetMathLibrary_SelectFloat::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_SelectFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectInt
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_SelectInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectInt) == 0x000004, "Wrong alignment on KismetMathLibrary_SelectInt");
static_assert(sizeof(KismetMathLibrary_SelectInt) == 0x000010, "Wrong size on KismetMathLibrary_SelectInt");
static_assert(offsetof(KismetMathLibrary_SelectInt, A) == 0x000000, "Member 'KismetMathLibrary_SelectInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectInt, B) == 0x000004, "Member 'KismetMathLibrary_SelectInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectInt, bPickA) == 0x000008, "Member 'KismetMathLibrary_SelectInt::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectInt, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_SelectInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectObject
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_SelectObject final
{
public:
	class UObject*                                A;                                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                B;                                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectA;                                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectObject) == 0x000008, "Wrong alignment on KismetMathLibrary_SelectObject");
static_assert(sizeof(KismetMathLibrary_SelectObject) == 0x000020, "Wrong size on KismetMathLibrary_SelectObject");
static_assert(offsetof(KismetMathLibrary_SelectObject, A) == 0x000000, "Member 'KismetMathLibrary_SelectObject::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectObject, B) == 0x000008, "Member 'KismetMathLibrary_SelectObject::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectObject, bSelectA) == 0x000010, "Member 'KismetMathLibrary_SelectObject::bSelectA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectObject, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_SelectObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectRotator
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_SelectRotator final
{
public:
	struct FRotator                               A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectRotator) == 0x000004, "Wrong alignment on KismetMathLibrary_SelectRotator");
static_assert(sizeof(KismetMathLibrary_SelectRotator) == 0x000028, "Wrong size on KismetMathLibrary_SelectRotator");
static_assert(offsetof(KismetMathLibrary_SelectRotator, A) == 0x000000, "Member 'KismetMathLibrary_SelectRotator::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectRotator, B) == 0x00000C, "Member 'KismetMathLibrary_SelectRotator::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectRotator, bPickA) == 0x000018, "Member 'KismetMathLibrary_SelectRotator::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectRotator, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_SelectRotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectString
// 0x0038 (0x0038 - 0x0000)
struct KismetMathLibrary_SelectString final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectString) == 0x000008, "Wrong alignment on KismetMathLibrary_SelectString");
static_assert(sizeof(KismetMathLibrary_SelectString) == 0x000038, "Wrong size on KismetMathLibrary_SelectString");
static_assert(offsetof(KismetMathLibrary_SelectString, A) == 0x000000, "Member 'KismetMathLibrary_SelectString::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectString, B) == 0x000010, "Member 'KismetMathLibrary_SelectString::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectString, bPickA) == 0x000020, "Member 'KismetMathLibrary_SelectString::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectString, ReturnValue) == 0x000028, "Member 'KismetMathLibrary_SelectString::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectTransform
// 0x00A0 (0x00A0 - 0x0000)
struct KismetMathLibrary_SelectTransform final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0xF];                                       // 0x0061(0x000F)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0070(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectTransform) == 0x000010, "Wrong alignment on KismetMathLibrary_SelectTransform");
static_assert(sizeof(KismetMathLibrary_SelectTransform) == 0x0000A0, "Wrong size on KismetMathLibrary_SelectTransform");
static_assert(offsetof(KismetMathLibrary_SelectTransform, A) == 0x000000, "Member 'KismetMathLibrary_SelectTransform::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectTransform, B) == 0x000030, "Member 'KismetMathLibrary_SelectTransform::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectTransform, bPickA) == 0x000060, "Member 'KismetMathLibrary_SelectTransform::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectTransform, ReturnValue) == 0x000070, "Member 'KismetMathLibrary_SelectTransform::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SelectVector
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_SelectVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPickA;                                            // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x3];                                       // 0x0019(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SelectVector) == 0x000004, "Wrong alignment on KismetMathLibrary_SelectVector");
static_assert(sizeof(KismetMathLibrary_SelectVector) == 0x000028, "Wrong size on KismetMathLibrary_SelectVector");
static_assert(offsetof(KismetMathLibrary_SelectVector, A) == 0x000000, "Member 'KismetMathLibrary_SelectVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectVector, B) == 0x00000C, "Member 'KismetMathLibrary_SelectVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectVector, bPickA) == 0x000018, "Member 'KismetMathLibrary_SelectVector::bPickA' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SelectVector, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_SelectVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SetRandomStreamSeed
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_SetRandomStreamSeed final
{
public:
	struct FRandomStream                          Stream;                                            // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         NewSeed;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SetRandomStreamSeed) == 0x000004, "Wrong alignment on KismetMathLibrary_SetRandomStreamSeed");
static_assert(sizeof(KismetMathLibrary_SetRandomStreamSeed) == 0x00000C, "Wrong size on KismetMathLibrary_SetRandomStreamSeed");
static_assert(offsetof(KismetMathLibrary_SetRandomStreamSeed, Stream) == 0x000000, "Member 'KismetMathLibrary_SetRandomStreamSeed::Stream' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SetRandomStreamSeed, NewSeed) == 0x000008, "Member 'KismetMathLibrary_SetRandomStreamSeed::NewSeed' has a wrong offset!");

// Function Engine.KismetMathLibrary.SignOfFloat
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_SignOfFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SignOfFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_SignOfFloat");
static_assert(sizeof(KismetMathLibrary_SignOfFloat) == 0x000008, "Wrong size on KismetMathLibrary_SignOfFloat");
static_assert(offsetof(KismetMathLibrary_SignOfFloat, A) == 0x000000, "Member 'KismetMathLibrary_SignOfFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SignOfFloat, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_SignOfFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.SignOfInteger
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_SignOfInteger final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_SignOfInteger) == 0x000004, "Wrong alignment on KismetMathLibrary_SignOfInteger");
static_assert(sizeof(KismetMathLibrary_SignOfInteger) == 0x000008, "Wrong size on KismetMathLibrary_SignOfInteger");
static_assert(offsetof(KismetMathLibrary_SignOfInteger, A) == 0x000000, "Member 'KismetMathLibrary_SignOfInteger::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_SignOfInteger, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_SignOfInteger::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Sin
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Sin final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Sin) == 0x000004, "Wrong alignment on KismetMathLibrary_Sin");
static_assert(sizeof(KismetMathLibrary_Sin) == 0x000008, "Wrong size on KismetMathLibrary_Sin");
static_assert(offsetof(KismetMathLibrary_Sin, A) == 0x000000, "Member 'KismetMathLibrary_Sin::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Sin, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Sin::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Sqrt
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Sqrt final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Sqrt) == 0x000004, "Wrong alignment on KismetMathLibrary_Sqrt");
static_assert(sizeof(KismetMathLibrary_Sqrt) == 0x000008, "Wrong size on KismetMathLibrary_Sqrt");
static_assert(offsetof(KismetMathLibrary_Sqrt, A) == 0x000000, "Member 'KismetMathLibrary_Sqrt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Sqrt, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Sqrt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Square
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Square final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Square) == 0x000004, "Wrong alignment on KismetMathLibrary_Square");
static_assert(sizeof(KismetMathLibrary_Square) == 0x000008, "Wrong size on KismetMathLibrary_Square");
static_assert(offsetof(KismetMathLibrary_Square, A) == 0x000000, "Member 'KismetMathLibrary_Square::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Square, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Square::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_ByteByte
// 0x0003 (0x0003 - 0x0000)
struct KismetMathLibrary_Subtract_ByteByte final
{
public:
	uint8                                         A;                                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         B;                                                 // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0002(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_ByteByte) == 0x000001, "Wrong alignment on KismetMathLibrary_Subtract_ByteByte");
static_assert(sizeof(KismetMathLibrary_Subtract_ByteByte) == 0x000003, "Wrong size on KismetMathLibrary_Subtract_ByteByte");
static_assert(offsetof(KismetMathLibrary_Subtract_ByteByte, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_ByteByte::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_ByteByte, B) == 0x000001, "Member 'KismetMathLibrary_Subtract_ByteByte::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_ByteByte, ReturnValue) == 0x000002, "Member 'KismetMathLibrary_Subtract_ByteByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_DateTimeDateTime
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Subtract_DateTimeDateTime final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_DateTimeDateTime) == 0x000008, "Wrong alignment on KismetMathLibrary_Subtract_DateTimeDateTime");
static_assert(sizeof(KismetMathLibrary_Subtract_DateTimeDateTime) == 0x000018, "Wrong size on KismetMathLibrary_Subtract_DateTimeDateTime");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeDateTime, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_DateTimeDateTime::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeDateTime, B) == 0x000008, "Member 'KismetMathLibrary_Subtract_DateTimeDateTime::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeDateTime, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_DateTimeDateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_DateTimeTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Subtract_DateTimeTimespan final
{
public:
	struct FDateTime                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_DateTimeTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Subtract_DateTimeTimespan");
static_assert(sizeof(KismetMathLibrary_Subtract_DateTimeTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Subtract_DateTimeTimespan");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_DateTimeTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Subtract_DateTimeTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_DateTimeTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_DateTimeTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_FloatFloat
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Subtract_FloatFloat final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_FloatFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_FloatFloat");
static_assert(sizeof(KismetMathLibrary_Subtract_FloatFloat) == 0x00000C, "Wrong size on KismetMathLibrary_Subtract_FloatFloat");
static_assert(offsetof(KismetMathLibrary_Subtract_FloatFloat, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_FloatFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_FloatFloat, B) == 0x000004, "Member 'KismetMathLibrary_Subtract_FloatFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_FloatFloat, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Subtract_FloatFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Subtract_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_IntInt");
static_assert(sizeof(KismetMathLibrary_Subtract_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Subtract_IntInt");
static_assert(offsetof(KismetMathLibrary_Subtract_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Subtract_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Subtract_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_TimespanTimespan
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Subtract_TimespanTimespan final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_TimespanTimespan) == 0x000008, "Wrong alignment on KismetMathLibrary_Subtract_TimespanTimespan");
static_assert(sizeof(KismetMathLibrary_Subtract_TimespanTimespan) == 0x000018, "Wrong size on KismetMathLibrary_Subtract_TimespanTimespan");
static_assert(offsetof(KismetMathLibrary_Subtract_TimespanTimespan, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_TimespanTimespan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_TimespanTimespan, B) == 0x000008, "Member 'KismetMathLibrary_Subtract_TimespanTimespan::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_TimespanTimespan, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_TimespanTimespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_Vector2DFloat
// 0x0014 (0x0014 - 0x0000)
struct KismetMathLibrary_Subtract_Vector2DFloat final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x000C(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_Vector2DFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_Vector2DFloat");
static_assert(sizeof(KismetMathLibrary_Subtract_Vector2DFloat) == 0x000014, "Wrong size on KismetMathLibrary_Subtract_Vector2DFloat");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DFloat, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_Vector2DFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DFloat, B) == 0x000008, "Member 'KismetMathLibrary_Subtract_Vector2DFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DFloat, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_Subtract_Vector2DFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_Vector2DVector2D
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_Subtract_Vector2DVector2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              B;                                                 // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_Vector2DVector2D) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_Vector2DVector2D");
static_assert(sizeof(KismetMathLibrary_Subtract_Vector2DVector2D) == 0x000018, "Wrong size on KismetMathLibrary_Subtract_Vector2DVector2D");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DVector2D, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_Vector2DVector2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DVector2D, B) == 0x000008, "Member 'KismetMathLibrary_Subtract_Vector2DVector2D::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_Vector2DVector2D, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_Vector2DVector2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_VectorFloat
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Subtract_VectorFloat final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_VectorFloat) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_VectorFloat");
static_assert(sizeof(KismetMathLibrary_Subtract_VectorFloat) == 0x00001C, "Wrong size on KismetMathLibrary_Subtract_VectorFloat");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorFloat, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_VectorFloat::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorFloat, B) == 0x00000C, "Member 'KismetMathLibrary_Subtract_VectorFloat::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorFloat, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_VectorFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_VectorInt
// 0x001C (0x001C - 0x0000)
struct KismetMathLibrary_Subtract_VectorInt final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_VectorInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_VectorInt");
static_assert(sizeof(KismetMathLibrary_Subtract_VectorInt) == 0x00001C, "Wrong size on KismetMathLibrary_Subtract_VectorInt");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorInt, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_VectorInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorInt, B) == 0x00000C, "Member 'KismetMathLibrary_Subtract_VectorInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorInt, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_Subtract_VectorInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Subtract_VectorVector
// 0x0024 (0x0024 - 0x0000)
struct KismetMathLibrary_Subtract_VectorVector final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Subtract_VectorVector) == 0x000004, "Wrong alignment on KismetMathLibrary_Subtract_VectorVector");
static_assert(sizeof(KismetMathLibrary_Subtract_VectorVector) == 0x000024, "Wrong size on KismetMathLibrary_Subtract_VectorVector");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorVector, A) == 0x000000, "Member 'KismetMathLibrary_Subtract_VectorVector::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorVector, B) == 0x00000C, "Member 'KismetMathLibrary_Subtract_VectorVector::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Subtract_VectorVector, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Subtract_VectorVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Tan
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Tan final
{
public:
	float                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Tan) == 0x000004, "Wrong alignment on KismetMathLibrary_Tan");
static_assert(sizeof(KismetMathLibrary_Tan) == 0x000008, "Wrong size on KismetMathLibrary_Tan");
static_assert(offsetof(KismetMathLibrary_Tan, A) == 0x000000, "Member 'KismetMathLibrary_Tan::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Tan, ReturnValue) == 0x000004, "Member 'KismetMathLibrary_Tan::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TEase
// 0x00A0 (0x00A0 - 0x0000)
struct KismetMathLibrary_TEase final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0x3];                                       // 0x0065(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0068(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x006C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             ReturnValue;                                       // 0x0070(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TEase) == 0x000010, "Wrong alignment on KismetMathLibrary_TEase");
static_assert(sizeof(KismetMathLibrary_TEase) == 0x0000A0, "Wrong size on KismetMathLibrary_TEase");
static_assert(offsetof(KismetMathLibrary_TEase, A) == 0x000000, "Member 'KismetMathLibrary_TEase::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, B) == 0x000030, "Member 'KismetMathLibrary_TEase::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, Alpha) == 0x000060, "Member 'KismetMathLibrary_TEase::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, EasingFunc) == 0x000064, "Member 'KismetMathLibrary_TEase::EasingFunc' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, BlendExp) == 0x000068, "Member 'KismetMathLibrary_TEase::BlendExp' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, Steps) == 0x00006C, "Member 'KismetMathLibrary_TEase::Steps' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TEase, ReturnValue) == 0x000070, "Member 'KismetMathLibrary_TEase::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TimespanFromString
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_TimespanFromString final
{
public:
	class FString                                 TimespanString;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              Result;                                            // 0x0010(0x0008)(Parm, OutParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_TimespanFromString) == 0x000008, "Wrong alignment on KismetMathLibrary_TimespanFromString");
static_assert(sizeof(KismetMathLibrary_TimespanFromString) == 0x000020, "Wrong size on KismetMathLibrary_TimespanFromString");
static_assert(offsetof(KismetMathLibrary_TimespanFromString, TimespanString) == 0x000000, "Member 'KismetMathLibrary_TimespanFromString::TimespanString' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TimespanFromString, Result) == 0x000010, "Member 'KismetMathLibrary_TimespanFromString::Result' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TimespanFromString, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_TimespanFromString::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TimespanMaxValue
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_TimespanMaxValue final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TimespanMaxValue) == 0x000008, "Wrong alignment on KismetMathLibrary_TimespanMaxValue");
static_assert(sizeof(KismetMathLibrary_TimespanMaxValue) == 0x000008, "Wrong size on KismetMathLibrary_TimespanMaxValue");
static_assert(offsetof(KismetMathLibrary_TimespanMaxValue, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_TimespanMaxValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TimespanMinValue
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_TimespanMinValue final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TimespanMinValue) == 0x000008, "Wrong alignment on KismetMathLibrary_TimespanMinValue");
static_assert(sizeof(KismetMathLibrary_TimespanMinValue) == 0x000008, "Wrong size on KismetMathLibrary_TimespanMinValue");
static_assert(offsetof(KismetMathLibrary_TimespanMinValue, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_TimespanMinValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TimespanRatio
// 0x0018 (0x0018 - 0x0000)
struct KismetMathLibrary_TimespanRatio final
{
public:
	struct FTimespan                              A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_TimespanRatio) == 0x000008, "Wrong alignment on KismetMathLibrary_TimespanRatio");
static_assert(sizeof(KismetMathLibrary_TimespanRatio) == 0x000018, "Wrong size on KismetMathLibrary_TimespanRatio");
static_assert(offsetof(KismetMathLibrary_TimespanRatio, A) == 0x000000, "Member 'KismetMathLibrary_TimespanRatio::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TimespanRatio, B) == 0x000008, "Member 'KismetMathLibrary_TimespanRatio::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TimespanRatio, ReturnValue) == 0x000010, "Member 'KismetMathLibrary_TimespanRatio::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TimespanZeroValue
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_TimespanZeroValue final
{
public:
	struct FTimespan                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TimespanZeroValue) == 0x000008, "Wrong alignment on KismetMathLibrary_TimespanZeroValue");
static_assert(sizeof(KismetMathLibrary_TimespanZeroValue) == 0x000008, "Wrong size on KismetMathLibrary_TimespanZeroValue");
static_assert(offsetof(KismetMathLibrary_TimespanZeroValue, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_TimespanZeroValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TInterpTo
// 0x00A0 (0x00A0 - 0x0000)
struct KismetMathLibrary_TInterpTo final
{
public:
	struct FTransform                             Current;                                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             Target;                                            // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_68[0x8];                                       // 0x0068(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0070(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TInterpTo) == 0x000010, "Wrong alignment on KismetMathLibrary_TInterpTo");
static_assert(sizeof(KismetMathLibrary_TInterpTo) == 0x0000A0, "Wrong size on KismetMathLibrary_TInterpTo");
static_assert(offsetof(KismetMathLibrary_TInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_TInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TInterpTo, Target) == 0x000030, "Member 'KismetMathLibrary_TInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TInterpTo, DeltaTime) == 0x000060, "Member 'KismetMathLibrary_TInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TInterpTo, InterpSpeed) == 0x000064, "Member 'KismetMathLibrary_TInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TInterpTo, ReturnValue) == 0x000070, "Member 'KismetMathLibrary_TInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TLerp
// 0x00A0 (0x00A0 - 0x0000)
struct KismetMathLibrary_TLerp final
{
public:
	struct FTransform                             A;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FTransform                             B;                                                 // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ELerpInterpolationMode                        InterpMode;                                        // 0x0064(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_65[0xB];                                       // 0x0065(0x000B)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0070(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_TLerp) == 0x000010, "Wrong alignment on KismetMathLibrary_TLerp");
static_assert(sizeof(KismetMathLibrary_TLerp) == 0x0000A0, "Wrong size on KismetMathLibrary_TLerp");
static_assert(offsetof(KismetMathLibrary_TLerp, A) == 0x000000, "Member 'KismetMathLibrary_TLerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TLerp, B) == 0x000030, "Member 'KismetMathLibrary_TLerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TLerp, Alpha) == 0x000060, "Member 'KismetMathLibrary_TLerp::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TLerp, InterpMode) == 0x000064, "Member 'KismetMathLibrary_TLerp::InterpMode' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TLerp, ReturnValue) == 0x000070, "Member 'KismetMathLibrary_TLerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Today
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_Today final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Today) == 0x000008, "Wrong alignment on KismetMathLibrary_Today");
static_assert(sizeof(KismetMathLibrary_Today) == 0x000008, "Wrong size on KismetMathLibrary_Today");
static_assert(offsetof(KismetMathLibrary_Today, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_Today::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TransformDirection
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_TransformDirection final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_TransformDirection) == 0x000010, "Wrong alignment on KismetMathLibrary_TransformDirection");
static_assert(sizeof(KismetMathLibrary_TransformDirection) == 0x000050, "Wrong size on KismetMathLibrary_TransformDirection");
static_assert(offsetof(KismetMathLibrary_TransformDirection, T) == 0x000000, "Member 'KismetMathLibrary_TransformDirection::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformDirection, Direction) == 0x000030, "Member 'KismetMathLibrary_TransformDirection::Direction' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformDirection, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_TransformDirection::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TransformLocation
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_TransformLocation final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_TransformLocation) == 0x000010, "Wrong alignment on KismetMathLibrary_TransformLocation");
static_assert(sizeof(KismetMathLibrary_TransformLocation) == 0x000050, "Wrong size on KismetMathLibrary_TransformLocation");
static_assert(offsetof(KismetMathLibrary_TransformLocation, T) == 0x000000, "Member 'KismetMathLibrary_TransformLocation::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformLocation, Location) == 0x000030, "Member 'KismetMathLibrary_TransformLocation::Location' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformLocation, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_TransformLocation::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.TransformRotation
// 0x0050 (0x0050 - 0x0000)
struct KismetMathLibrary_TransformRotation final
{
public:
	struct FTransform                             T;                                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x003C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMathLibrary_TransformRotation) == 0x000010, "Wrong alignment on KismetMathLibrary_TransformRotation");
static_assert(sizeof(KismetMathLibrary_TransformRotation) == 0x000050, "Wrong size on KismetMathLibrary_TransformRotation");
static_assert(offsetof(KismetMathLibrary_TransformRotation, T) == 0x000000, "Member 'KismetMathLibrary_TransformRotation::T' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformRotation, Rotation) == 0x000030, "Member 'KismetMathLibrary_TransformRotation::Rotation' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_TransformRotation, ReturnValue) == 0x00003C, "Member 'KismetMathLibrary_TransformRotation::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.UtcNow
// 0x0008 (0x0008 - 0x0000)
struct KismetMathLibrary_UtcNow final
{
public:
	struct FDateTime                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_UtcNow) == 0x000008, "Wrong alignment on KismetMathLibrary_UtcNow");
static_assert(sizeof(KismetMathLibrary_UtcNow) == 0x000008, "Wrong size on KismetMathLibrary_UtcNow");
static_assert(offsetof(KismetMathLibrary_UtcNow, ReturnValue) == 0x000000, "Member 'KismetMathLibrary_UtcNow::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VEase
// 0x0034 (0x0034 - 0x0000)
struct KismetMathLibrary_VEase final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEasingFunc                                   EasingFunc;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BlendExp;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Steps;                                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VEase) == 0x000004, "Wrong alignment on KismetMathLibrary_VEase");
static_assert(sizeof(KismetMathLibrary_VEase) == 0x000034, "Wrong size on KismetMathLibrary_VEase");
static_assert(offsetof(KismetMathLibrary_VEase, A) == 0x000000, "Member 'KismetMathLibrary_VEase::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, B) == 0x00000C, "Member 'KismetMathLibrary_VEase::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, Alpha) == 0x000018, "Member 'KismetMathLibrary_VEase::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, EasingFunc) == 0x00001C, "Member 'KismetMathLibrary_VEase::EasingFunc' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, BlendExp) == 0x000020, "Member 'KismetMathLibrary_VEase::BlendExp' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, Steps) == 0x000024, "Member 'KismetMathLibrary_VEase::Steps' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VEase, ReturnValue) == 0x000028, "Member 'KismetMathLibrary_VEase::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Vector2DInterpTo
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_Vector2DInterpTo final
{
public:
	struct FVector2D                              Current;                                           // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Target;                                            // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Vector2DInterpTo) == 0x000004, "Wrong alignment on KismetMathLibrary_Vector2DInterpTo");
static_assert(sizeof(KismetMathLibrary_Vector2DInterpTo) == 0x000020, "Wrong size on KismetMathLibrary_Vector2DInterpTo");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_Vector2DInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo, Target) == 0x000008, "Member 'KismetMathLibrary_Vector2DInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo, DeltaTime) == 0x000010, "Member 'KismetMathLibrary_Vector2DInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo, InterpSpeed) == 0x000014, "Member 'KismetMathLibrary_Vector2DInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Vector2DInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Vector2DInterpTo_Constant
// 0x0020 (0x0020 - 0x0000)
struct KismetMathLibrary_Vector2DInterpTo_Constant final
{
public:
	struct FVector2D                              Current;                                           // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Target;                                            // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Vector2DInterpTo_Constant) == 0x000004, "Wrong alignment on KismetMathLibrary_Vector2DInterpTo_Constant");
static_assert(sizeof(KismetMathLibrary_Vector2DInterpTo_Constant) == 0x000020, "Wrong size on KismetMathLibrary_Vector2DInterpTo_Constant");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo_Constant, Current) == 0x000000, "Member 'KismetMathLibrary_Vector2DInterpTo_Constant::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo_Constant, Target) == 0x000008, "Member 'KismetMathLibrary_Vector2DInterpTo_Constant::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo_Constant, DeltaTime) == 0x000010, "Member 'KismetMathLibrary_Vector2DInterpTo_Constant::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo_Constant, InterpSpeed) == 0x000014, "Member 'KismetMathLibrary_Vector2DInterpTo_Constant::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Vector2DInterpTo_Constant, ReturnValue) == 0x000018, "Member 'KismetMathLibrary_Vector2DInterpTo_Constant::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VectorSpringInterp
// 0x004C (0x004C - 0x0000)
struct KismetMathLibrary_VectorSpringInterp final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVectorSpringState                     SpringState;                                       // 0x0018(0x0018)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Stiffness;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CriticalDampingFactor;                             // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Mass;                                              // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0040(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VectorSpringInterp) == 0x000004, "Wrong alignment on KismetMathLibrary_VectorSpringInterp");
static_assert(sizeof(KismetMathLibrary_VectorSpringInterp) == 0x00004C, "Wrong size on KismetMathLibrary_VectorSpringInterp");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, Current) == 0x000000, "Member 'KismetMathLibrary_VectorSpringInterp::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, Target) == 0x00000C, "Member 'KismetMathLibrary_VectorSpringInterp::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, SpringState) == 0x000018, "Member 'KismetMathLibrary_VectorSpringInterp::SpringState' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, Stiffness) == 0x000030, "Member 'KismetMathLibrary_VectorSpringInterp::Stiffness' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, CriticalDampingFactor) == 0x000034, "Member 'KismetMathLibrary_VectorSpringInterp::CriticalDampingFactor' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, DeltaTime) == 0x000038, "Member 'KismetMathLibrary_VectorSpringInterp::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, Mass) == 0x00003C, "Member 'KismetMathLibrary_VectorSpringInterp::Mass' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VectorSpringInterp, ReturnValue) == 0x000040, "Member 'KismetMathLibrary_VectorSpringInterp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VInterpTo
// 0x002C (0x002C - 0x0000)
struct KismetMathLibrary_VInterpTo final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VInterpTo) == 0x000004, "Wrong alignment on KismetMathLibrary_VInterpTo");
static_assert(sizeof(KismetMathLibrary_VInterpTo) == 0x00002C, "Wrong size on KismetMathLibrary_VInterpTo");
static_assert(offsetof(KismetMathLibrary_VInterpTo, Current) == 0x000000, "Member 'KismetMathLibrary_VInterpTo::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo, Target) == 0x00000C, "Member 'KismetMathLibrary_VInterpTo::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo, DeltaTime) == 0x000018, "Member 'KismetMathLibrary_VInterpTo::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo, InterpSpeed) == 0x00001C, "Member 'KismetMathLibrary_VInterpTo::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_VInterpTo::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VInterpTo_Constant
// 0x002C (0x002C - 0x0000)
struct KismetMathLibrary_VInterpTo_Constant final
{
public:
	struct FVector                                Current;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Target;                                            // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VInterpTo_Constant) == 0x000004, "Wrong alignment on KismetMathLibrary_VInterpTo_Constant");
static_assert(sizeof(KismetMathLibrary_VInterpTo_Constant) == 0x00002C, "Wrong size on KismetMathLibrary_VInterpTo_Constant");
static_assert(offsetof(KismetMathLibrary_VInterpTo_Constant, Current) == 0x000000, "Member 'KismetMathLibrary_VInterpTo_Constant::Current' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo_Constant, Target) == 0x00000C, "Member 'KismetMathLibrary_VInterpTo_Constant::Target' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo_Constant, DeltaTime) == 0x000018, "Member 'KismetMathLibrary_VInterpTo_Constant::DeltaTime' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo_Constant, InterpSpeed) == 0x00001C, "Member 'KismetMathLibrary_VInterpTo_Constant::InterpSpeed' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VInterpTo_Constant, ReturnValue) == 0x000020, "Member 'KismetMathLibrary_VInterpTo_Constant::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VLerp
// 0x0028 (0x0028 - 0x0000)
struct KismetMathLibrary_VLerp final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                B;                                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x001C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VLerp) == 0x000004, "Wrong alignment on KismetMathLibrary_VLerp");
static_assert(sizeof(KismetMathLibrary_VLerp) == 0x000028, "Wrong size on KismetMathLibrary_VLerp");
static_assert(offsetof(KismetMathLibrary_VLerp, A) == 0x000000, "Member 'KismetMathLibrary_VLerp::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VLerp, B) == 0x00000C, "Member 'KismetMathLibrary_VLerp::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VLerp, Alpha) == 0x000018, "Member 'KismetMathLibrary_VLerp::Alpha' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VLerp, ReturnValue) == 0x00001C, "Member 'KismetMathLibrary_VLerp::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VSize
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_VSize final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VSize) == 0x000004, "Wrong alignment on KismetMathLibrary_VSize");
static_assert(sizeof(KismetMathLibrary_VSize) == 0x000010, "Wrong size on KismetMathLibrary_VSize");
static_assert(offsetof(KismetMathLibrary_VSize, A) == 0x000000, "Member 'KismetMathLibrary_VSize::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VSize, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_VSize::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VSize2D
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_VSize2D final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VSize2D) == 0x000004, "Wrong alignment on KismetMathLibrary_VSize2D");
static_assert(sizeof(KismetMathLibrary_VSize2D) == 0x00000C, "Wrong size on KismetMathLibrary_VSize2D");
static_assert(offsetof(KismetMathLibrary_VSize2D, A) == 0x000000, "Member 'KismetMathLibrary_VSize2D::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VSize2D, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_VSize2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VSize2DSquared
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_VSize2DSquared final
{
public:
	struct FVector2D                              A;                                                 // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VSize2DSquared) == 0x000004, "Wrong alignment on KismetMathLibrary_VSize2DSquared");
static_assert(sizeof(KismetMathLibrary_VSize2DSquared) == 0x00000C, "Wrong size on KismetMathLibrary_VSize2DSquared");
static_assert(offsetof(KismetMathLibrary_VSize2DSquared, A) == 0x000000, "Member 'KismetMathLibrary_VSize2DSquared::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VSize2DSquared, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_VSize2DSquared::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.VSizeSquared
// 0x0010 (0x0010 - 0x0000)
struct KismetMathLibrary_VSizeSquared final
{
public:
	struct FVector                                A;                                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_VSizeSquared) == 0x000004, "Wrong alignment on KismetMathLibrary_VSizeSquared");
static_assert(sizeof(KismetMathLibrary_VSizeSquared) == 0x000010, "Wrong size on KismetMathLibrary_VSizeSquared");
static_assert(offsetof(KismetMathLibrary_VSizeSquared, A) == 0x000000, "Member 'KismetMathLibrary_VSizeSquared::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_VSizeSquared, ReturnValue) == 0x00000C, "Member 'KismetMathLibrary_VSizeSquared::ReturnValue' has a wrong offset!");

// Function Engine.KismetMathLibrary.Xor_IntInt
// 0x000C (0x000C - 0x0000)
struct KismetMathLibrary_Xor_IntInt final
{
public:
	int32                                         A;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         B;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMathLibrary_Xor_IntInt) == 0x000004, "Wrong alignment on KismetMathLibrary_Xor_IntInt");
static_assert(sizeof(KismetMathLibrary_Xor_IntInt) == 0x00000C, "Wrong size on KismetMathLibrary_Xor_IntInt");
static_assert(offsetof(KismetMathLibrary_Xor_IntInt, A) == 0x000000, "Member 'KismetMathLibrary_Xor_IntInt::A' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Xor_IntInt, B) == 0x000004, "Member 'KismetMathLibrary_Xor_IntInt::B' has a wrong offset!");
static_assert(offsetof(KismetMathLibrary_Xor_IntInt, ReturnValue) == 0x000008, "Member 'KismetMathLibrary_Xor_IntInt::ReturnValue' has a wrong offset!");

// Function Engine.LightComponentBase.SetCastShadows
// 0x0001 (0x0001 - 0x0000)
struct LightComponentBase_SetCastShadows final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponentBase_SetCastShadows) == 0x000001, "Wrong alignment on LightComponentBase_SetCastShadows");
static_assert(sizeof(LightComponentBase_SetCastShadows) == 0x000001, "Wrong size on LightComponentBase_SetCastShadows");
static_assert(offsetof(LightComponentBase_SetCastShadows, bNewValue) == 0x000000, "Member 'LightComponentBase_SetCastShadows::bNewValue' has a wrong offset!");

// Function Engine.LightComponentBase.SetCastVolumetricShadow
// 0x0001 (0x0001 - 0x0000)
struct LightComponentBase_SetCastVolumetricShadow final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponentBase_SetCastVolumetricShadow) == 0x000001, "Wrong alignment on LightComponentBase_SetCastVolumetricShadow");
static_assert(sizeof(LightComponentBase_SetCastVolumetricShadow) == 0x000001, "Wrong size on LightComponentBase_SetCastVolumetricShadow");
static_assert(offsetof(LightComponentBase_SetCastVolumetricShadow, bNewValue) == 0x000000, "Member 'LightComponentBase_SetCastVolumetricShadow::bNewValue' has a wrong offset!");

// Function Engine.LightComponentBase.GetLightColor
// 0x0010 (0x0010 - 0x0000)
struct LightComponentBase_GetLightColor final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponentBase_GetLightColor) == 0x000004, "Wrong alignment on LightComponentBase_GetLightColor");
static_assert(sizeof(LightComponentBase_GetLightColor) == 0x000010, "Wrong size on LightComponentBase_GetLightColor");
static_assert(offsetof(LightComponentBase_GetLightColor, ReturnValue) == 0x000000, "Member 'LightComponentBase_GetLightColor::ReturnValue' has a wrong offset!");

// Function Engine.LightComponent.SetAffectDynamicIndirectLighting
// 0x0001 (0x0001 - 0x0000)
struct LightComponent_SetAffectDynamicIndirectLighting final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetAffectDynamicIndirectLighting) == 0x000001, "Wrong alignment on LightComponent_SetAffectDynamicIndirectLighting");
static_assert(sizeof(LightComponent_SetAffectDynamicIndirectLighting) == 0x000001, "Wrong size on LightComponent_SetAffectDynamicIndirectLighting");
static_assert(offsetof(LightComponent_SetAffectDynamicIndirectLighting, bNewValue) == 0x000000, "Member 'LightComponent_SetAffectDynamicIndirectLighting::bNewValue' has a wrong offset!");

// Function Engine.LightComponent.SetAffectTranslucentLighting
// 0x0001 (0x0001 - 0x0000)
struct LightComponent_SetAffectTranslucentLighting final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetAffectTranslucentLighting) == 0x000001, "Wrong alignment on LightComponent_SetAffectTranslucentLighting");
static_assert(sizeof(LightComponent_SetAffectTranslucentLighting) == 0x000001, "Wrong size on LightComponent_SetAffectTranslucentLighting");
static_assert(offsetof(LightComponent_SetAffectTranslucentLighting, bNewValue) == 0x000000, "Member 'LightComponent_SetAffectTranslucentLighting::bNewValue' has a wrong offset!");

// Function Engine.LightComponent.SetBloomScale
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetBloomScale final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetBloomScale) == 0x000004, "Wrong alignment on LightComponent_SetBloomScale");
static_assert(sizeof(LightComponent_SetBloomScale) == 0x000004, "Wrong size on LightComponent_SetBloomScale");
static_assert(offsetof(LightComponent_SetBloomScale, NewValue) == 0x000000, "Member 'LightComponent_SetBloomScale::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetBloomThreshold
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetBloomThreshold final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetBloomThreshold) == 0x000004, "Wrong alignment on LightComponent_SetBloomThreshold");
static_assert(sizeof(LightComponent_SetBloomThreshold) == 0x000004, "Wrong size on LightComponent_SetBloomThreshold");
static_assert(offsetof(LightComponent_SetBloomThreshold, NewValue) == 0x000000, "Member 'LightComponent_SetBloomThreshold::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetBloomTint
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetBloomTint final
{
public:
	struct FColor                                 NewValue;                                          // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetBloomTint) == 0x000004, "Wrong alignment on LightComponent_SetBloomTint");
static_assert(sizeof(LightComponent_SetBloomTint) == 0x000004, "Wrong size on LightComponent_SetBloomTint");
static_assert(offsetof(LightComponent_SetBloomTint, NewValue) == 0x000000, "Member 'LightComponent_SetBloomTint::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetCellShading
// 0x0001 (0x0001 - 0x0000)
struct LightComponent_SetCellShading final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetCellShading) == 0x000001, "Wrong alignment on LightComponent_SetCellShading");
static_assert(sizeof(LightComponent_SetCellShading) == 0x000001, "Wrong size on LightComponent_SetCellShading");
static_assert(offsetof(LightComponent_SetCellShading, bNewValue) == 0x000000, "Member 'LightComponent_SetCellShading::bNewValue' has a wrong offset!");

// Function Engine.LightComponent.SetEnableLightShaftBloom
// 0x0001 (0x0001 - 0x0000)
struct LightComponent_SetEnableLightShaftBloom final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetEnableLightShaftBloom) == 0x000001, "Wrong alignment on LightComponent_SetEnableLightShaftBloom");
static_assert(sizeof(LightComponent_SetEnableLightShaftBloom) == 0x000001, "Wrong size on LightComponent_SetEnableLightShaftBloom");
static_assert(offsetof(LightComponent_SetEnableLightShaftBloom, bNewValue) == 0x000000, "Member 'LightComponent_SetEnableLightShaftBloom::bNewValue' has a wrong offset!");

// Function Engine.LightComponent.SetIESTexture
// 0x0008 (0x0008 - 0x0000)
struct LightComponent_SetIESTexture final
{
public:
	class UTextureLightProfile*                   NewValue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetIESTexture) == 0x000008, "Wrong alignment on LightComponent_SetIESTexture");
static_assert(sizeof(LightComponent_SetIESTexture) == 0x000008, "Wrong size on LightComponent_SetIESTexture");
static_assert(offsetof(LightComponent_SetIESTexture, NewValue) == 0x000000, "Member 'LightComponent_SetIESTexture::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetIndirectLightingIntensity
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetIndirectLightingIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetIndirectLightingIntensity) == 0x000004, "Wrong alignment on LightComponent_SetIndirectLightingIntensity");
static_assert(sizeof(LightComponent_SetIndirectLightingIntensity) == 0x000004, "Wrong size on LightComponent_SetIndirectLightingIntensity");
static_assert(offsetof(LightComponent_SetIndirectLightingIntensity, NewIntensity) == 0x000000, "Member 'LightComponent_SetIndirectLightingIntensity::NewIntensity' has a wrong offset!");

// Function Engine.LightComponent.SetIntensity
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetIntensity) == 0x000004, "Wrong alignment on LightComponent_SetIntensity");
static_assert(sizeof(LightComponent_SetIntensity) == 0x000004, "Wrong size on LightComponent_SetIntensity");
static_assert(offsetof(LightComponent_SetIntensity, NewIntensity) == 0x000000, "Member 'LightComponent_SetIntensity::NewIntensity' has a wrong offset!");

// Function Engine.LightComponent.SetLightColor
// 0x0014 (0x0014 - 0x0000)
struct LightComponent_SetLightColor final
{
public:
	struct FLinearColor                           NewLightColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSRGB;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LightComponent_SetLightColor) == 0x000004, "Wrong alignment on LightComponent_SetLightColor");
static_assert(sizeof(LightComponent_SetLightColor) == 0x000014, "Wrong size on LightComponent_SetLightColor");
static_assert(offsetof(LightComponent_SetLightColor, NewLightColor) == 0x000000, "Member 'LightComponent_SetLightColor::NewLightColor' has a wrong offset!");
static_assert(offsetof(LightComponent_SetLightColor, bSRGB) == 0x000010, "Member 'LightComponent_SetLightColor::bSRGB' has a wrong offset!");

// Function Engine.LightComponent.SetLightFunctionDisabledBrightness
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetLightFunctionDisabledBrightness final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetLightFunctionDisabledBrightness) == 0x000004, "Wrong alignment on LightComponent_SetLightFunctionDisabledBrightness");
static_assert(sizeof(LightComponent_SetLightFunctionDisabledBrightness) == 0x000004, "Wrong size on LightComponent_SetLightFunctionDisabledBrightness");
static_assert(offsetof(LightComponent_SetLightFunctionDisabledBrightness, NewValue) == 0x000000, "Member 'LightComponent_SetLightFunctionDisabledBrightness::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetLightFunctionFadeDistance
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetLightFunctionFadeDistance final
{
public:
	float                                         NewLightFunctionFadeDistance;                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetLightFunctionFadeDistance) == 0x000004, "Wrong alignment on LightComponent_SetLightFunctionFadeDistance");
static_assert(sizeof(LightComponent_SetLightFunctionFadeDistance) == 0x000004, "Wrong size on LightComponent_SetLightFunctionFadeDistance");
static_assert(offsetof(LightComponent_SetLightFunctionFadeDistance, NewLightFunctionFadeDistance) == 0x000000, "Member 'LightComponent_SetLightFunctionFadeDistance::NewLightFunctionFadeDistance' has a wrong offset!");

// Function Engine.LightComponent.SetLightFunctionMaterial
// 0x0008 (0x0008 - 0x0000)
struct LightComponent_SetLightFunctionMaterial final
{
public:
	class UMaterialInterface*                     NewLightFunctionMaterial;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetLightFunctionMaterial) == 0x000008, "Wrong alignment on LightComponent_SetLightFunctionMaterial");
static_assert(sizeof(LightComponent_SetLightFunctionMaterial) == 0x000008, "Wrong size on LightComponent_SetLightFunctionMaterial");
static_assert(offsetof(LightComponent_SetLightFunctionMaterial, NewLightFunctionMaterial) == 0x000000, "Member 'LightComponent_SetLightFunctionMaterial::NewLightFunctionMaterial' has a wrong offset!");

// Function Engine.LightComponent.SetLightFunctionScale
// 0x000C (0x000C - 0x0000)
struct LightComponent_SetLightFunctionScale final
{
public:
	struct FVector                                NewLightFunctionScale;                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetLightFunctionScale) == 0x000004, "Wrong alignment on LightComponent_SetLightFunctionScale");
static_assert(sizeof(LightComponent_SetLightFunctionScale) == 0x00000C, "Wrong size on LightComponent_SetLightFunctionScale");
static_assert(offsetof(LightComponent_SetLightFunctionScale, NewLightFunctionScale) == 0x000000, "Member 'LightComponent_SetLightFunctionScale::NewLightFunctionScale' has a wrong offset!");

// Function Engine.LightComponent.SetShadowBias
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetShadowBias final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetShadowBias) == 0x000004, "Wrong alignment on LightComponent_SetShadowBias");
static_assert(sizeof(LightComponent_SetShadowBias) == 0x000004, "Wrong size on LightComponent_SetShadowBias");
static_assert(offsetof(LightComponent_SetShadowBias, NewValue) == 0x000000, "Member 'LightComponent_SetShadowBias::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetShadowCancelRate
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetShadowCancelRate final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetShadowCancelRate) == 0x000004, "Wrong alignment on LightComponent_SetShadowCancelRate");
static_assert(sizeof(LightComponent_SetShadowCancelRate) == 0x000004, "Wrong size on LightComponent_SetShadowCancelRate");
static_assert(offsetof(LightComponent_SetShadowCancelRate, NewValue) == 0x000000, "Member 'LightComponent_SetShadowCancelRate::NewValue' has a wrong offset!");

// Function Engine.LightComponent.SetTemperature
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetTemperature final
{
public:
	float                                         NewTemperature;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetTemperature) == 0x000004, "Wrong alignment on LightComponent_SetTemperature");
static_assert(sizeof(LightComponent_SetTemperature) == 0x000004, "Wrong size on LightComponent_SetTemperature");
static_assert(offsetof(LightComponent_SetTemperature, NewTemperature) == 0x000000, "Member 'LightComponent_SetTemperature::NewTemperature' has a wrong offset!");

// Function Engine.LightComponent.SetVolumetricScatteringIntensity
// 0x0004 (0x0004 - 0x0000)
struct LightComponent_SetVolumetricScatteringIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LightComponent_SetVolumetricScatteringIntensity) == 0x000004, "Wrong alignment on LightComponent_SetVolumetricScatteringIntensity");
static_assert(sizeof(LightComponent_SetVolumetricScatteringIntensity) == 0x000004, "Wrong size on LightComponent_SetVolumetricScatteringIntensity");
static_assert(offsetof(LightComponent_SetVolumetricScatteringIntensity, NewIntensity) == 0x000000, "Member 'LightComponent_SetVolumetricScatteringIntensity::NewIntensity' has a wrong offset!");

// Function Engine.PointLightComponent.SetAttenuationRadius
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetAttenuationRadius final
{
public:
	float                                         NewRadius;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetAttenuationRadius) == 0x000004, "Wrong alignment on PointLightComponent_SetAttenuationRadius");
static_assert(sizeof(PointLightComponent_SetAttenuationRadius) == 0x000004, "Wrong size on PointLightComponent_SetAttenuationRadius");
static_assert(offsetof(PointLightComponent_SetAttenuationRadius, NewRadius) == 0x000000, "Member 'PointLightComponent_SetAttenuationRadius::NewRadius' has a wrong offset!");

// Function Engine.PointLightComponent.SetCullDistance
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetCullDistance final
{
public:
	float                                         bNewValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetCullDistance) == 0x000004, "Wrong alignment on PointLightComponent_SetCullDistance");
static_assert(sizeof(PointLightComponent_SetCullDistance) == 0x000004, "Wrong size on PointLightComponent_SetCullDistance");
static_assert(offsetof(PointLightComponent_SetCullDistance, bNewValue) == 0x000000, "Member 'PointLightComponent_SetCullDistance::bNewValue' has a wrong offset!");

// Function Engine.PointLightComponent.SetLightFalloffExponent
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetLightFalloffExponent final
{
public:
	float                                         NewLightFalloffExponent;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetLightFalloffExponent) == 0x000004, "Wrong alignment on PointLightComponent_SetLightFalloffExponent");
static_assert(sizeof(PointLightComponent_SetLightFalloffExponent) == 0x000004, "Wrong size on PointLightComponent_SetLightFalloffExponent");
static_assert(offsetof(PointLightComponent_SetLightFalloffExponent, NewLightFalloffExponent) == 0x000000, "Member 'PointLightComponent_SetLightFalloffExponent::NewLightFalloffExponent' has a wrong offset!");

// Function Engine.PointLightComponent.SetShadowCullDistance
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetShadowCullDistance final
{
public:
	float                                         bNewValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetShadowCullDistance) == 0x000004, "Wrong alignment on PointLightComponent_SetShadowCullDistance");
static_assert(sizeof(PointLightComponent_SetShadowCullDistance) == 0x000004, "Wrong size on PointLightComponent_SetShadowCullDistance");
static_assert(offsetof(PointLightComponent_SetShadowCullDistance, bNewValue) == 0x000000, "Member 'PointLightComponent_SetShadowCullDistance::bNewValue' has a wrong offset!");

// Function Engine.PointLightComponent.SetSoftSourceRadius
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetSoftSourceRadius final
{
public:
	float                                         bNewValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetSoftSourceRadius) == 0x000004, "Wrong alignment on PointLightComponent_SetSoftSourceRadius");
static_assert(sizeof(PointLightComponent_SetSoftSourceRadius) == 0x000004, "Wrong size on PointLightComponent_SetSoftSourceRadius");
static_assert(offsetof(PointLightComponent_SetSoftSourceRadius, bNewValue) == 0x000000, "Member 'PointLightComponent_SetSoftSourceRadius::bNewValue' has a wrong offset!");

// Function Engine.PointLightComponent.SetSourceLength
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetSourceLength final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetSourceLength) == 0x000004, "Wrong alignment on PointLightComponent_SetSourceLength");
static_assert(sizeof(PointLightComponent_SetSourceLength) == 0x000004, "Wrong size on PointLightComponent_SetSourceLength");
static_assert(offsetof(PointLightComponent_SetSourceLength, NewValue) == 0x000000, "Member 'PointLightComponent_SetSourceLength::NewValue' has a wrong offset!");

// Function Engine.PointLightComponent.SetSourceRadius
// 0x0004 (0x0004 - 0x0000)
struct PointLightComponent_SetSourceRadius final
{
public:
	float                                         bNewValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLightComponent_SetSourceRadius) == 0x000004, "Wrong alignment on PointLightComponent_SetSourceRadius");
static_assert(sizeof(PointLightComponent_SetSourceRadius) == 0x000004, "Wrong size on PointLightComponent_SetSourceRadius");
static_assert(offsetof(PointLightComponent_SetSourceRadius, bNewValue) == 0x000000, "Member 'PointLightComponent_SetSourceRadius::bNewValue' has a wrong offset!");

// Function Engine.SceneCapture2D.OnInterpToggle
// 0x0001 (0x0001 - 0x0000)
struct SceneCapture2D_OnInterpToggle final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCapture2D_OnInterpToggle) == 0x000001, "Wrong alignment on SceneCapture2D_OnInterpToggle");
static_assert(sizeof(SceneCapture2D_OnInterpToggle) == 0x000001, "Wrong size on SceneCapture2D_OnInterpToggle");
static_assert(offsetof(SceneCapture2D_OnInterpToggle, bEnable) == 0x000000, "Member 'SceneCapture2D_OnInterpToggle::bEnable' has a wrong offset!");

// Function Engine.PawnMovementComponent.AddInputVector
// 0x0010 (0x0010 - 0x0000)
struct PawnMovementComponent_AddInputVector final
{
public:
	struct FVector                                WorldVector;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForce;                                            // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PawnMovementComponent_AddInputVector) == 0x000004, "Wrong alignment on PawnMovementComponent_AddInputVector");
static_assert(sizeof(PawnMovementComponent_AddInputVector) == 0x000010, "Wrong size on PawnMovementComponent_AddInputVector");
static_assert(offsetof(PawnMovementComponent_AddInputVector, WorldVector) == 0x000000, "Member 'PawnMovementComponent_AddInputVector::WorldVector' has a wrong offset!");
static_assert(offsetof(PawnMovementComponent_AddInputVector, bForce) == 0x00000C, "Member 'PawnMovementComponent_AddInputVector::bForce' has a wrong offset!");

// Function Engine.PawnMovementComponent.ConsumeInputVector
// 0x000C (0x000C - 0x0000)
struct PawnMovementComponent_ConsumeInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_ConsumeInputVector) == 0x000004, "Wrong alignment on PawnMovementComponent_ConsumeInputVector");
static_assert(sizeof(PawnMovementComponent_ConsumeInputVector) == 0x00000C, "Wrong size on PawnMovementComponent_ConsumeInputVector");
static_assert(offsetof(PawnMovementComponent_ConsumeInputVector, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_ConsumeInputVector::ReturnValue' has a wrong offset!");

// Function Engine.PawnMovementComponent.GetLastInputVector
// 0x000C (0x000C - 0x0000)
struct PawnMovementComponent_GetLastInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_GetLastInputVector) == 0x000004, "Wrong alignment on PawnMovementComponent_GetLastInputVector");
static_assert(sizeof(PawnMovementComponent_GetLastInputVector) == 0x00000C, "Wrong size on PawnMovementComponent_GetLastInputVector");
static_assert(offsetof(PawnMovementComponent_GetLastInputVector, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_GetLastInputVector::ReturnValue' has a wrong offset!");

// Function Engine.PawnMovementComponent.GetPawnOwner
// 0x0008 (0x0008 - 0x0000)
struct PawnMovementComponent_GetPawnOwner final
{
public:
	class APawn*                                  ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_GetPawnOwner) == 0x000008, "Wrong alignment on PawnMovementComponent_GetPawnOwner");
static_assert(sizeof(PawnMovementComponent_GetPawnOwner) == 0x000008, "Wrong size on PawnMovementComponent_GetPawnOwner");
static_assert(offsetof(PawnMovementComponent_GetPawnOwner, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_GetPawnOwner::ReturnValue' has a wrong offset!");

// Function Engine.PawnMovementComponent.GetPendingInputVector
// 0x000C (0x000C - 0x0000)
struct PawnMovementComponent_GetPendingInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_GetPendingInputVector) == 0x000004, "Wrong alignment on PawnMovementComponent_GetPendingInputVector");
static_assert(sizeof(PawnMovementComponent_GetPendingInputVector) == 0x00000C, "Wrong size on PawnMovementComponent_GetPendingInputVector");
static_assert(offsetof(PawnMovementComponent_GetPendingInputVector, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_GetPendingInputVector::ReturnValue' has a wrong offset!");

// Function Engine.PawnMovementComponent.IsMoveInputIgnored
// 0x0001 (0x0001 - 0x0000)
struct PawnMovementComponent_IsMoveInputIgnored final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_IsMoveInputIgnored) == 0x000001, "Wrong alignment on PawnMovementComponent_IsMoveInputIgnored");
static_assert(sizeof(PawnMovementComponent_IsMoveInputIgnored) == 0x000001, "Wrong size on PawnMovementComponent_IsMoveInputIgnored");
static_assert(offsetof(PawnMovementComponent_IsMoveInputIgnored, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_IsMoveInputIgnored::ReturnValue' has a wrong offset!");

// Function Engine.PawnMovementComponent.K2_GetInputVector
// 0x000C (0x000C - 0x0000)
struct PawnMovementComponent_K2_GetInputVector final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PawnMovementComponent_K2_GetInputVector) == 0x000004, "Wrong alignment on PawnMovementComponent_K2_GetInputVector");
static_assert(sizeof(PawnMovementComponent_K2_GetInputVector) == 0x00000C, "Wrong size on PawnMovementComponent_K2_GetInputVector");
static_assert(offsetof(PawnMovementComponent_K2_GetInputVector, ReturnValue) == 0x000000, "Member 'PawnMovementComponent_K2_GetInputVector::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.AddForce
// 0x000C (0x000C - 0x0000)
struct CharacterMovementComponent_AddForce final
{
public:
	struct FVector                                Force;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_AddForce) == 0x000004, "Wrong alignment on CharacterMovementComponent_AddForce");
static_assert(sizeof(CharacterMovementComponent_AddForce) == 0x00000C, "Wrong size on CharacterMovementComponent_AddForce");
static_assert(offsetof(CharacterMovementComponent_AddForce, Force) == 0x000000, "Member 'CharacterMovementComponent_AddForce::Force' has a wrong offset!");

// Function Engine.CharacterMovementComponent.AddImpulse
// 0x0010 (0x0010 - 0x0000)
struct CharacterMovementComponent_AddImpulse final
{
public:
	struct FVector                                Impulse;                                           // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bVelocityChange;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_AddImpulse) == 0x000004, "Wrong alignment on CharacterMovementComponent_AddImpulse");
static_assert(sizeof(CharacterMovementComponent_AddImpulse) == 0x000010, "Wrong size on CharacterMovementComponent_AddImpulse");
static_assert(offsetof(CharacterMovementComponent_AddImpulse, Impulse) == 0x000000, "Member 'CharacterMovementComponent_AddImpulse::Impulse' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_AddImpulse, bVelocityChange) == 0x00000C, "Member 'CharacterMovementComponent_AddImpulse::bVelocityChange' has a wrong offset!");

// Function Engine.CharacterMovementComponent.CalcVelocity
// 0x0010 (0x0010 - 0x0000)
struct CharacterMovementComponent_CalcVelocity final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Friction;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFluid;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BrakingDeceleration;                               // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_CalcVelocity) == 0x000004, "Wrong alignment on CharacterMovementComponent_CalcVelocity");
static_assert(sizeof(CharacterMovementComponent_CalcVelocity) == 0x000010, "Wrong size on CharacterMovementComponent_CalcVelocity");
static_assert(offsetof(CharacterMovementComponent_CalcVelocity, DeltaTime) == 0x000000, "Member 'CharacterMovementComponent_CalcVelocity::DeltaTime' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CalcVelocity, Friction) == 0x000004, "Member 'CharacterMovementComponent_CalcVelocity::Friction' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CalcVelocity, bFluid) == 0x000008, "Member 'CharacterMovementComponent_CalcVelocity::bFluid' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CalcVelocity, BrakingDeceleration) == 0x00000C, "Member 'CharacterMovementComponent_CalcVelocity::BrakingDeceleration' has a wrong offset!");

// Function Engine.CharacterMovementComponent.CapsuleTouched
// 0x00A8 (0x00A8 - 0x0000)
struct CharacterMovementComponent_CapsuleTouched final
{
public:
	class UPrimitiveComponent*                    OverlappedComp;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Other;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    OtherComp;                                         // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OtherBodyIndex;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFromSweep;                                        // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             SweepResult;                                       // 0x0020(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_CapsuleTouched) == 0x000008, "Wrong alignment on CharacterMovementComponent_CapsuleTouched");
static_assert(sizeof(CharacterMovementComponent_CapsuleTouched) == 0x0000A8, "Wrong size on CharacterMovementComponent_CapsuleTouched");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, OverlappedComp) == 0x000000, "Member 'CharacterMovementComponent_CapsuleTouched::OverlappedComp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, Other) == 0x000008, "Member 'CharacterMovementComponent_CapsuleTouched::Other' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, OtherComp) == 0x000010, "Member 'CharacterMovementComponent_CapsuleTouched::OtherComp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, OtherBodyIndex) == 0x000018, "Member 'CharacterMovementComponent_CapsuleTouched::OtherBodyIndex' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, bFromSweep) == 0x00001C, "Member 'CharacterMovementComponent_CapsuleTouched::bFromSweep' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_CapsuleTouched, SweepResult) == 0x000020, "Member 'CharacterMovementComponent_CapsuleTouched::SweepResult' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ClientAckGoodMove
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_ClientAckGoodMove final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_ClientAckGoodMove) == 0x000004, "Wrong alignment on CharacterMovementComponent_ClientAckGoodMove");
static_assert(sizeof(CharacterMovementComponent_ClientAckGoodMove) == 0x000004, "Wrong size on CharacterMovementComponent_ClientAckGoodMove");
static_assert(offsetof(CharacterMovementComponent_ClientAckGoodMove, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ClientAckGoodMove::Timestamp' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ClientAdjustPosition
// 0x0038 (0x0038 - 0x0000)
struct CharacterMovementComponent_ClientAdjustPosition final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLoc;                                            // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewVel;                                            // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    NewBase;                                           // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBaseBoneName;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBase;                                          // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseRelativePosition;                             // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ServerMovementMode;                                // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x5];                                       // 0x0033(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ClientAdjustPosition) == 0x000008, "Wrong alignment on CharacterMovementComponent_ClientAdjustPosition");
static_assert(sizeof(CharacterMovementComponent_ClientAdjustPosition) == 0x000038, "Wrong size on CharacterMovementComponent_ClientAdjustPosition");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ClientAdjustPosition::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, NewLoc) == 0x000004, "Member 'CharacterMovementComponent_ClientAdjustPosition::NewLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, NewVel) == 0x000010, "Member 'CharacterMovementComponent_ClientAdjustPosition::NewVel' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, NewBase) == 0x000020, "Member 'CharacterMovementComponent_ClientAdjustPosition::NewBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, NewBaseBoneName) == 0x000028, "Member 'CharacterMovementComponent_ClientAdjustPosition::NewBaseBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, bHasBase) == 0x000030, "Member 'CharacterMovementComponent_ClientAdjustPosition::bHasBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, bBaseRelativePosition) == 0x000031, "Member 'CharacterMovementComponent_ClientAdjustPosition::bBaseRelativePosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustPosition, ServerMovementMode) == 0x000032, "Member 'CharacterMovementComponent_ClientAdjustPosition::ServerMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ClientAdjustRootMotionPosition
// 0x0040 (0x0040 - 0x0000)
struct CharacterMovementComponent_ClientAdjustRootMotionPosition final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ServerMontageTrackPosition;                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerLoc;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ServerRotation;                                    // 0x0014(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerVelZ;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ServerBase;                                        // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ServerBoneName;                                    // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBase;                                          // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseRelativePosition;                             // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ServerMovementMode;                                // 0x003A(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3B[0x5];                                       // 0x003B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ClientAdjustRootMotionPosition) == 0x000008, "Wrong alignment on CharacterMovementComponent_ClientAdjustRootMotionPosition");
static_assert(sizeof(CharacterMovementComponent_ClientAdjustRootMotionPosition) == 0x000040, "Wrong size on CharacterMovementComponent_ClientAdjustRootMotionPosition");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerMontageTrackPosition) == 0x000004, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerMontageTrackPosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerLoc) == 0x000008, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerRotation) == 0x000014, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerRotation' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerVelZ) == 0x000020, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerVelZ' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerBase) == 0x000028, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerBoneName) == 0x000030, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, bHasBase) == 0x000038, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::bHasBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, bBaseRelativePosition) == 0x000039, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::bBaseRelativePosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionPosition, ServerMovementMode) == 0x00003A, "Member 'CharacterMovementComponent_ClientAdjustRootMotionPosition::ServerMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ClientAdjustRootMotionSourcePosition
// 0x0148 (0x0148 - 0x0000)
struct CharacterMovementComponent_ClientAdjustRootMotionSourcePosition final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRootMotionSourceGroup                 ServerRootMotion;                                  // 0x0008(0x0100)(Parm, NativeAccessSpecifierPublic)
	bool                                          bHasAnimRootMotion;                                // 0x0108(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x3];                                      // 0x0109(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ServerMontageTrackPosition;                        // 0x010C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ServerLoc;                                         // 0x0110(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantizeNormal              ServerRotation;                                    // 0x011C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ServerVelZ;                                        // 0x0128(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ServerBase;                                        // 0x0130(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ServerBoneName;                                    // 0x0138(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBase;                                          // 0x0140(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseRelativePosition;                             // 0x0141(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ServerMovementMode;                                // 0x0142(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_143[0x5];                                      // 0x0143(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition) == 0x000008, "Wrong alignment on CharacterMovementComponent_ClientAdjustRootMotionSourcePosition");
static_assert(sizeof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition) == 0x000148, "Wrong size on CharacterMovementComponent_ClientAdjustRootMotionSourcePosition");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerRootMotion) == 0x000008, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerRootMotion' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, bHasAnimRootMotion) == 0x000108, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::bHasAnimRootMotion' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerMontageTrackPosition) == 0x00010C, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerMontageTrackPosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerLoc) == 0x000110, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerRotation) == 0x00011C, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerRotation' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerVelZ) == 0x000128, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerVelZ' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerBase) == 0x000130, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerBoneName) == 0x000138, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, bHasBase) == 0x000140, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::bHasBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, bBaseRelativePosition) == 0x000141, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::bBaseRelativePosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientAdjustRootMotionSourcePosition, ServerMovementMode) == 0x000142, "Member 'CharacterMovementComponent_ClientAdjustRootMotionSourcePosition::ServerMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ClientVeryShortAdjustPosition
// 0x0028 (0x0028 - 0x0000)
struct CharacterMovementComponent_ClientVeryShortAdjustPosition final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewLoc;                                            // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    NewBase;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   NewBaseBoneName;                                   // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasBase;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBaseRelativePosition;                             // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ServerMovementMode;                                // 0x0022(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ClientVeryShortAdjustPosition) == 0x000008, "Wrong alignment on CharacterMovementComponent_ClientVeryShortAdjustPosition");
static_assert(sizeof(CharacterMovementComponent_ClientVeryShortAdjustPosition) == 0x000028, "Wrong size on CharacterMovementComponent_ClientVeryShortAdjustPosition");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, NewLoc) == 0x000004, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::NewLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, NewBase) == 0x000010, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::NewBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, NewBaseBoneName) == 0x000018, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::NewBaseBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, bHasBase) == 0x000020, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::bHasBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, bBaseRelativePosition) == 0x000021, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::bBaseRelativePosition' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ClientVeryShortAdjustPosition, ServerMovementMode) == 0x000022, "Member 'CharacterMovementComponent_ClientVeryShortAdjustPosition::ServerMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ServerMove
// 0x0040 (0x0040 - 0x0000)
struct CharacterMovementComponent_ServerMove final
{
public:
	float                                         Timestamp;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0010(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         CompressedMoveFlags;                               // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0028(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ServerMove) == 0x000008, "Wrong alignment on CharacterMovementComponent_ServerMove");
static_assert(sizeof(CharacterMovementComponent_ServerMove) == 0x000040, "Wrong size on CharacterMovementComponent_ServerMove");
static_assert(offsetof(CharacterMovementComponent_ServerMove, Timestamp) == 0x000000, "Member 'CharacterMovementComponent_ServerMove::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, InAccel) == 0x000004, "Member 'CharacterMovementComponent_ServerMove::InAccel' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, ClientLoc) == 0x000010, "Member 'CharacterMovementComponent_ServerMove::ClientLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, CompressedMoveFlags) == 0x00001C, "Member 'CharacterMovementComponent_ServerMove::CompressedMoveFlags' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, ClientRoll) == 0x00001D, "Member 'CharacterMovementComponent_ServerMove::ClientRoll' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, View) == 0x000020, "Member 'CharacterMovementComponent_ServerMove::View' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, ClientMovementBase) == 0x000028, "Member 'CharacterMovementComponent_ServerMove::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, ClientBaseBoneName) == 0x000030, "Member 'CharacterMovementComponent_ServerMove::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMove, ClientMovementMode) == 0x000038, "Member 'CharacterMovementComponent_ServerMove::ClientMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ServerMoveDual
// 0x0058 (0x0058 - 0x0000)
struct CharacterMovementComponent_ServerMoveDual final
{
public:
	float                                         TimeStamp0;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel0;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         PendingFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View0;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x001C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NewFlags;                                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ServerMoveDual) == 0x000008, "Wrong alignment on CharacterMovementComponent_ServerMoveDual");
static_assert(sizeof(CharacterMovementComponent_ServerMoveDual) == 0x000058, "Wrong size on CharacterMovementComponent_ServerMoveDual");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, TimeStamp0) == 0x000000, "Member 'CharacterMovementComponent_ServerMoveDual::TimeStamp0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, InAccel0) == 0x000004, "Member 'CharacterMovementComponent_ServerMoveDual::InAccel0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, PendingFlags) == 0x000010, "Member 'CharacterMovementComponent_ServerMoveDual::PendingFlags' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, View0) == 0x000014, "Member 'CharacterMovementComponent_ServerMoveDual::View0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, Timestamp) == 0x000018, "Member 'CharacterMovementComponent_ServerMoveDual::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, InAccel) == 0x00001C, "Member 'CharacterMovementComponent_ServerMoveDual::InAccel' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, ClientLoc) == 0x000028, "Member 'CharacterMovementComponent_ServerMoveDual::ClientLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, NewFlags) == 0x000034, "Member 'CharacterMovementComponent_ServerMoveDual::NewFlags' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, ClientRoll) == 0x000035, "Member 'CharacterMovementComponent_ServerMoveDual::ClientRoll' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, View) == 0x000038, "Member 'CharacterMovementComponent_ServerMoveDual::View' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, ClientMovementBase) == 0x000040, "Member 'CharacterMovementComponent_ServerMoveDual::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, ClientBaseBoneName) == 0x000048, "Member 'CharacterMovementComponent_ServerMoveDual::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDual, ClientMovementMode) == 0x000050, "Member 'CharacterMovementComponent_ServerMoveDual::ClientMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ServerMoveDualHybridRootMotion
// 0x0058 (0x0058 - 0x0000)
struct CharacterMovementComponent_ServerMoveDualHybridRootMotion final
{
public:
	float                                         TimeStamp0;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel0;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         PendingFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View0;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Timestamp;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  InAccel;                                           // 0x001C(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize100                 ClientLoc;                                         // 0x0028(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         NewFlags;                                          // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientRoll;                                        // 0x0035(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36[0x2];                                       // 0x0036(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	uint32                                        View;                                              // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPrimitiveComponent*                    ClientMovementBase;                                // 0x0040(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ClientBaseBoneName;                                // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ClientMovementMode;                                // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ServerMoveDualHybridRootMotion) == 0x000008, "Wrong alignment on CharacterMovementComponent_ServerMoveDualHybridRootMotion");
static_assert(sizeof(CharacterMovementComponent_ServerMoveDualHybridRootMotion) == 0x000058, "Wrong size on CharacterMovementComponent_ServerMoveDualHybridRootMotion");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, TimeStamp0) == 0x000000, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::TimeStamp0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, InAccel0) == 0x000004, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::InAccel0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, PendingFlags) == 0x000010, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::PendingFlags' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, View0) == 0x000014, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::View0' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, Timestamp) == 0x000018, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::Timestamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, InAccel) == 0x00001C, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::InAccel' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, ClientLoc) == 0x000028, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::ClientLoc' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, NewFlags) == 0x000034, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::NewFlags' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, ClientRoll) == 0x000035, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::ClientRoll' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, View) == 0x000038, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::View' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, ClientMovementBase) == 0x000040, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::ClientMovementBase' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, ClientBaseBoneName) == 0x000048, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::ClientBaseBoneName' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveDualHybridRootMotion, ClientMovementMode) == 0x000050, "Member 'CharacterMovementComponent_ServerMoveDualHybridRootMotion::ClientMovementMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.ServerMoveOld
// 0x0014 (0x0014 - 0x0000)
struct CharacterMovementComponent_ServerMoveOld final
{
public:
	float                                         OldTimeStamp;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector_NetQuantize10                  OldAccel;                                          // 0x0004(0x000C)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         OldMoveFlags;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_ServerMoveOld) == 0x000004, "Wrong alignment on CharacterMovementComponent_ServerMoveOld");
static_assert(sizeof(CharacterMovementComponent_ServerMoveOld) == 0x000014, "Wrong size on CharacterMovementComponent_ServerMoveOld");
static_assert(offsetof(CharacterMovementComponent_ServerMoveOld, OldTimeStamp) == 0x000000, "Member 'CharacterMovementComponent_ServerMoveOld::OldTimeStamp' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveOld, OldAccel) == 0x000004, "Member 'CharacterMovementComponent_ServerMoveOld::OldAccel' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_ServerMoveOld, OldMoveFlags) == 0x000010, "Member 'CharacterMovementComponent_ServerMoveOld::OldMoveFlags' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetAvoidanceEnabled
// 0x0001 (0x0001 - 0x0000)
struct CharacterMovementComponent_SetAvoidanceEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetAvoidanceEnabled) == 0x000001, "Wrong alignment on CharacterMovementComponent_SetAvoidanceEnabled");
static_assert(sizeof(CharacterMovementComponent_SetAvoidanceEnabled) == 0x000001, "Wrong size on CharacterMovementComponent_SetAvoidanceEnabled");
static_assert(offsetof(CharacterMovementComponent_SetAvoidanceEnabled, bEnable) == 0x000000, "Member 'CharacterMovementComponent_SetAvoidanceEnabled::bEnable' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetAvoidanceGroup
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetAvoidanceGroup final
{
public:
	int32                                         GroupFlags;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetAvoidanceGroup) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetAvoidanceGroup");
static_assert(sizeof(CharacterMovementComponent_SetAvoidanceGroup) == 0x000004, "Wrong size on CharacterMovementComponent_SetAvoidanceGroup");
static_assert(offsetof(CharacterMovementComponent_SetAvoidanceGroup, GroupFlags) == 0x000000, "Member 'CharacterMovementComponent_SetAvoidanceGroup::GroupFlags' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetAvoidanceGroupMask
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetAvoidanceGroupMask final
{
public:
	struct FNavAvoidanceMask                      GroupMask;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetAvoidanceGroupMask) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetAvoidanceGroupMask");
static_assert(sizeof(CharacterMovementComponent_SetAvoidanceGroupMask) == 0x000004, "Wrong size on CharacterMovementComponent_SetAvoidanceGroupMask");
static_assert(offsetof(CharacterMovementComponent_SetAvoidanceGroupMask, GroupMask) == 0x000000, "Member 'CharacterMovementComponent_SetAvoidanceGroupMask::GroupMask' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetGroupsToAvoid
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetGroupsToAvoid final
{
public:
	int32                                         GroupFlags;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetGroupsToAvoid) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetGroupsToAvoid");
static_assert(sizeof(CharacterMovementComponent_SetGroupsToAvoid) == 0x000004, "Wrong size on CharacterMovementComponent_SetGroupsToAvoid");
static_assert(offsetof(CharacterMovementComponent_SetGroupsToAvoid, GroupFlags) == 0x000000, "Member 'CharacterMovementComponent_SetGroupsToAvoid::GroupFlags' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetGroupsToAvoidMask
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetGroupsToAvoidMask final
{
public:
	struct FNavAvoidanceMask                      GroupMask;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetGroupsToAvoidMask) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetGroupsToAvoidMask");
static_assert(sizeof(CharacterMovementComponent_SetGroupsToAvoidMask) == 0x000004, "Wrong size on CharacterMovementComponent_SetGroupsToAvoidMask");
static_assert(offsetof(CharacterMovementComponent_SetGroupsToAvoidMask, GroupMask) == 0x000000, "Member 'CharacterMovementComponent_SetGroupsToAvoidMask::GroupMask' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetGroupsToIgnore
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetGroupsToIgnore final
{
public:
	int32                                         GroupFlags;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetGroupsToIgnore) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetGroupsToIgnore");
static_assert(sizeof(CharacterMovementComponent_SetGroupsToIgnore) == 0x000004, "Wrong size on CharacterMovementComponent_SetGroupsToIgnore");
static_assert(offsetof(CharacterMovementComponent_SetGroupsToIgnore, GroupFlags) == 0x000000, "Member 'CharacterMovementComponent_SetGroupsToIgnore::GroupFlags' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetGroupsToIgnoreMask
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetGroupsToIgnoreMask final
{
public:
	struct FNavAvoidanceMask                      GroupMask;                                         // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetGroupsToIgnoreMask) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetGroupsToIgnoreMask");
static_assert(sizeof(CharacterMovementComponent_SetGroupsToIgnoreMask) == 0x000004, "Wrong size on CharacterMovementComponent_SetGroupsToIgnoreMask");
static_assert(offsetof(CharacterMovementComponent_SetGroupsToIgnoreMask, GroupMask) == 0x000000, "Member 'CharacterMovementComponent_SetGroupsToIgnoreMask::GroupMask' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetMovementMode
// 0x0002 (0x0002 - 0x0000)
struct CharacterMovementComponent_SetMovementMode final
{
public:
	EMovementMode                                 NewMovementMode;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         NewCustomMode;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetMovementMode) == 0x000001, "Wrong alignment on CharacterMovementComponent_SetMovementMode");
static_assert(sizeof(CharacterMovementComponent_SetMovementMode) == 0x000002, "Wrong size on CharacterMovementComponent_SetMovementMode");
static_assert(offsetof(CharacterMovementComponent_SetMovementMode, NewMovementMode) == 0x000000, "Member 'CharacterMovementComponent_SetMovementMode::NewMovementMode' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_SetMovementMode, NewCustomMode) == 0x000001, "Member 'CharacterMovementComponent_SetMovementMode::NewCustomMode' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetWalkableFloorAngle
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetWalkableFloorAngle final
{
public:
	float                                         InWalkableFloorAngle;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetWalkableFloorAngle");
static_assert(sizeof(CharacterMovementComponent_SetWalkableFloorAngle) == 0x000004, "Wrong size on CharacterMovementComponent_SetWalkableFloorAngle");
static_assert(offsetof(CharacterMovementComponent_SetWalkableFloorAngle, InWalkableFloorAngle) == 0x000000, "Member 'CharacterMovementComponent_SetWalkableFloorAngle::InWalkableFloorAngle' has a wrong offset!");

// Function Engine.CharacterMovementComponent.SetWalkableFloorZ
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_SetWalkableFloorZ final
{
public:
	float                                         InWalkableFloorZ;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong alignment on CharacterMovementComponent_SetWalkableFloorZ");
static_assert(sizeof(CharacterMovementComponent_SetWalkableFloorZ) == 0x000004, "Wrong size on CharacterMovementComponent_SetWalkableFloorZ");
static_assert(offsetof(CharacterMovementComponent_SetWalkableFloorZ, InWalkableFloorZ) == 0x000000, "Member 'CharacterMovementComponent_SetWalkableFloorZ::InWalkableFloorZ' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetAnalogInputModifier
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetAnalogInputModifier final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetAnalogInputModifier) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetAnalogInputModifier");
static_assert(sizeof(CharacterMovementComponent_GetAnalogInputModifier) == 0x000004, "Wrong size on CharacterMovementComponent_GetAnalogInputModifier");
static_assert(offsetof(CharacterMovementComponent_GetAnalogInputModifier, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetAnalogInputModifier::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetCharacterOwner
// 0x0008 (0x0008 - 0x0000)
struct CharacterMovementComponent_GetCharacterOwner final
{
public:
	class ACharacter*                             ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetCharacterOwner) == 0x000008, "Wrong alignment on CharacterMovementComponent_GetCharacterOwner");
static_assert(sizeof(CharacterMovementComponent_GetCharacterOwner) == 0x000008, "Wrong size on CharacterMovementComponent_GetCharacterOwner");
static_assert(offsetof(CharacterMovementComponent_GetCharacterOwner, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetCharacterOwner::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetCurrentAcceleration
// 0x000C (0x000C - 0x0000)
struct CharacterMovementComponent_GetCurrentAcceleration final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetCurrentAcceleration) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetCurrentAcceleration");
static_assert(sizeof(CharacterMovementComponent_GetCurrentAcceleration) == 0x00000C, "Wrong size on CharacterMovementComponent_GetCurrentAcceleration");
static_assert(offsetof(CharacterMovementComponent_GetCurrentAcceleration, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetCurrentAcceleration::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetImpartedMovementBaseVelocity
// 0x000C (0x000C - 0x0000)
struct CharacterMovementComponent_GetImpartedMovementBaseVelocity final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetImpartedMovementBaseVelocity) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetImpartedMovementBaseVelocity");
static_assert(sizeof(CharacterMovementComponent_GetImpartedMovementBaseVelocity) == 0x00000C, "Wrong size on CharacterMovementComponent_GetImpartedMovementBaseVelocity");
static_assert(offsetof(CharacterMovementComponent_GetImpartedMovementBaseVelocity, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetImpartedMovementBaseVelocity::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMaxAcceleration
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetMaxAcceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMaxAcceleration) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetMaxAcceleration");
static_assert(sizeof(CharacterMovementComponent_GetMaxAcceleration) == 0x000004, "Wrong size on CharacterMovementComponent_GetMaxAcceleration");
static_assert(offsetof(CharacterMovementComponent_GetMaxAcceleration, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMaxAcceleration::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMaxBrakingDeceleration
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetMaxBrakingDeceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMaxBrakingDeceleration) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetMaxBrakingDeceleration");
static_assert(sizeof(CharacterMovementComponent_GetMaxBrakingDeceleration) == 0x000004, "Wrong size on CharacterMovementComponent_GetMaxBrakingDeceleration");
static_assert(offsetof(CharacterMovementComponent_GetMaxBrakingDeceleration, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMaxBrakingDeceleration::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMaxJumpHeight
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetMaxJumpHeight final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMaxJumpHeight) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetMaxJumpHeight");
static_assert(sizeof(CharacterMovementComponent_GetMaxJumpHeight) == 0x000004, "Wrong size on CharacterMovementComponent_GetMaxJumpHeight");
static_assert(offsetof(CharacterMovementComponent_GetMaxJumpHeight, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMaxJumpHeight::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMaxJumpHeightWithJumpTime
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetMaxJumpHeightWithJumpTime final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMaxJumpHeightWithJumpTime) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetMaxJumpHeightWithJumpTime");
static_assert(sizeof(CharacterMovementComponent_GetMaxJumpHeightWithJumpTime) == 0x000004, "Wrong size on CharacterMovementComponent_GetMaxJumpHeightWithJumpTime");
static_assert(offsetof(CharacterMovementComponent_GetMaxJumpHeightWithJumpTime, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMaxJumpHeightWithJumpTime::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMinAnalogSpeed
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetMinAnalogSpeed final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMinAnalogSpeed) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetMinAnalogSpeed");
static_assert(sizeof(CharacterMovementComponent_GetMinAnalogSpeed) == 0x000004, "Wrong size on CharacterMovementComponent_GetMinAnalogSpeed");
static_assert(offsetof(CharacterMovementComponent_GetMinAnalogSpeed, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMinAnalogSpeed::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetMovementBase
// 0x0008 (0x0008 - 0x0000)
struct CharacterMovementComponent_GetMovementBase final
{
public:
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetMovementBase) == 0x000008, "Wrong alignment on CharacterMovementComponent_GetMovementBase");
static_assert(sizeof(CharacterMovementComponent_GetMovementBase) == 0x000008, "Wrong size on CharacterMovementComponent_GetMovementBase");
static_assert(offsetof(CharacterMovementComponent_GetMovementBase, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetMovementBase::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetPerchRadiusThreshold
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetPerchRadiusThreshold final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetPerchRadiusThreshold");
static_assert(sizeof(CharacterMovementComponent_GetPerchRadiusThreshold) == 0x000004, "Wrong size on CharacterMovementComponent_GetPerchRadiusThreshold");
static_assert(offsetof(CharacterMovementComponent_GetPerchRadiusThreshold, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetPerchRadiusThreshold::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.GetValidPerchRadius
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_GetValidPerchRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong alignment on CharacterMovementComponent_GetValidPerchRadius");
static_assert(sizeof(CharacterMovementComponent_GetValidPerchRadius) == 0x000004, "Wrong size on CharacterMovementComponent_GetValidPerchRadius");
static_assert(offsetof(CharacterMovementComponent_GetValidPerchRadius, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_GetValidPerchRadius::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.IsWalkable
// 0x0090 (0x0090 - 0x0000)
struct CharacterMovementComponent_IsWalkable final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CharacterMovementComponent_IsWalkable) == 0x000008, "Wrong alignment on CharacterMovementComponent_IsWalkable");
static_assert(sizeof(CharacterMovementComponent_IsWalkable) == 0x000090, "Wrong size on CharacterMovementComponent_IsWalkable");
static_assert(offsetof(CharacterMovementComponent_IsWalkable, Hit) == 0x000000, "Member 'CharacterMovementComponent_IsWalkable::Hit' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_IsWalkable, ReturnValue) == 0x000088, "Member 'CharacterMovementComponent_IsWalkable::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.IsWalking
// 0x0001 (0x0001 - 0x0000)
struct CharacterMovementComponent_IsWalking final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_IsWalking) == 0x000001, "Wrong alignment on CharacterMovementComponent_IsWalking");
static_assert(sizeof(CharacterMovementComponent_IsWalking) == 0x000001, "Wrong size on CharacterMovementComponent_IsWalking");
static_assert(offsetof(CharacterMovementComponent_IsWalking, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_IsWalking::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.K2_ComputeFloorDist
// 0x00B0 (0x00B0 - 0x0000)
struct CharacterMovementComponent_K2_ComputeFloorDist final
{
public:
	struct FVector                                CapsuleLocation;                                   // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LineDistance;                                      // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepDistance;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SweepRadius;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FFindFloorResult                       FloorResult;                                       // 0x0018(0x0098)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_K2_ComputeFloorDist) == 0x000008, "Wrong alignment on CharacterMovementComponent_K2_ComputeFloorDist");
static_assert(sizeof(CharacterMovementComponent_K2_ComputeFloorDist) == 0x0000B0, "Wrong size on CharacterMovementComponent_K2_ComputeFloorDist");
static_assert(offsetof(CharacterMovementComponent_K2_ComputeFloorDist, CapsuleLocation) == 0x000000, "Member 'CharacterMovementComponent_K2_ComputeFloorDist::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_K2_ComputeFloorDist, LineDistance) == 0x00000C, "Member 'CharacterMovementComponent_K2_ComputeFloorDist::LineDistance' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_K2_ComputeFloorDist, SweepDistance) == 0x000010, "Member 'CharacterMovementComponent_K2_ComputeFloorDist::SweepDistance' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_K2_ComputeFloorDist, SweepRadius) == 0x000014, "Member 'CharacterMovementComponent_K2_ComputeFloorDist::SweepRadius' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_K2_ComputeFloorDist, FloorResult) == 0x000018, "Member 'CharacterMovementComponent_K2_ComputeFloorDist::FloorResult' has a wrong offset!");

// Function Engine.CharacterMovementComponent.K2_FindFloor
// 0x00A8 (0x00A8 - 0x0000)
struct CharacterMovementComponent_K2_FindFloor final
{
public:
	struct FVector                                CapsuleLocation;                                   // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFindFloorResult                       FloorResult;                                       // 0x0010(0x0098)(Parm, OutParm, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_K2_FindFloor) == 0x000008, "Wrong alignment on CharacterMovementComponent_K2_FindFloor");
static_assert(sizeof(CharacterMovementComponent_K2_FindFloor) == 0x0000A8, "Wrong size on CharacterMovementComponent_K2_FindFloor");
static_assert(offsetof(CharacterMovementComponent_K2_FindFloor, CapsuleLocation) == 0x000000, "Member 'CharacterMovementComponent_K2_FindFloor::CapsuleLocation' has a wrong offset!");
static_assert(offsetof(CharacterMovementComponent_K2_FindFloor, FloorResult) == 0x000010, "Member 'CharacterMovementComponent_K2_FindFloor::FloorResult' has a wrong offset!");

// Function Engine.CharacterMovementComponent.K2_GetModifiedMaxAcceleration
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_K2_GetModifiedMaxAcceleration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_K2_GetModifiedMaxAcceleration) == 0x000004, "Wrong alignment on CharacterMovementComponent_K2_GetModifiedMaxAcceleration");
static_assert(sizeof(CharacterMovementComponent_K2_GetModifiedMaxAcceleration) == 0x000004, "Wrong size on CharacterMovementComponent_K2_GetModifiedMaxAcceleration");
static_assert(offsetof(CharacterMovementComponent_K2_GetModifiedMaxAcceleration, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_K2_GetModifiedMaxAcceleration::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorAngle
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_K2_GetWalkableFloorAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_K2_GetWalkableFloorAngle) == 0x000004, "Wrong alignment on CharacterMovementComponent_K2_GetWalkableFloorAngle");
static_assert(sizeof(CharacterMovementComponent_K2_GetWalkableFloorAngle) == 0x000004, "Wrong size on CharacterMovementComponent_K2_GetWalkableFloorAngle");
static_assert(offsetof(CharacterMovementComponent_K2_GetWalkableFloorAngle, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_K2_GetWalkableFloorAngle::ReturnValue' has a wrong offset!");

// Function Engine.CharacterMovementComponent.K2_GetWalkableFloorZ
// 0x0004 (0x0004 - 0x0000)
struct CharacterMovementComponent_K2_GetWalkableFloorZ final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CharacterMovementComponent_K2_GetWalkableFloorZ) == 0x000004, "Wrong alignment on CharacterMovementComponent_K2_GetWalkableFloorZ");
static_assert(sizeof(CharacterMovementComponent_K2_GetWalkableFloorZ) == 0x000004, "Wrong size on CharacterMovementComponent_K2_GetWalkableFloorZ");
static_assert(offsetof(CharacterMovementComponent_K2_GetWalkableFloorZ, ReturnValue) == 0x000000, "Member 'CharacterMovementComponent_K2_GetWalkableFloorZ::ReturnValue' has a wrong offset!");

// Function Engine.CheatManager.BugIt
// 0x0010 (0x0010 - 0x0000)
struct CheatManager_BugIt final
{
public:
	class FString                                 ScreenShotDescription;                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_BugIt) == 0x000008, "Wrong alignment on CheatManager_BugIt");
static_assert(sizeof(CheatManager_BugIt) == 0x000010, "Wrong size on CheatManager_BugIt");
static_assert(offsetof(CheatManager_BugIt, ScreenShotDescription) == 0x000000, "Member 'CheatManager_BugIt::ScreenShotDescription' has a wrong offset!");

// Function Engine.CheatManager.BugItGo
// 0x0018 (0x0018 - 0x0000)
struct CheatManager_BugItGo final
{
public:
	float                                         X;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Y;                                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Z;                                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Yaw;                                               // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Roll;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_BugItGo) == 0x000004, "Wrong alignment on CheatManager_BugItGo");
static_assert(sizeof(CheatManager_BugItGo) == 0x000018, "Wrong size on CheatManager_BugItGo");
static_assert(offsetof(CheatManager_BugItGo, X) == 0x000000, "Member 'CheatManager_BugItGo::X' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItGo, Y) == 0x000004, "Member 'CheatManager_BugItGo::Y' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItGo, Z) == 0x000008, "Member 'CheatManager_BugItGo::Z' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItGo, Pitch) == 0x00000C, "Member 'CheatManager_BugItGo::Pitch' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItGo, Yaw) == 0x000010, "Member 'CheatManager_BugItGo::Yaw' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItGo, Roll) == 0x000014, "Member 'CheatManager_BugItGo::Roll' has a wrong offset!");

// Function Engine.CheatManager.BugItStringCreator
// 0x0038 (0x0038 - 0x0000)
struct CheatManager_BugItStringCreator final
{
public:
	struct FVector                                ViewLocation;                                      // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 GoString;                                          // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LocString;                                         // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_BugItStringCreator) == 0x000008, "Wrong alignment on CheatManager_BugItStringCreator");
static_assert(sizeof(CheatManager_BugItStringCreator) == 0x000038, "Wrong size on CheatManager_BugItStringCreator");
static_assert(offsetof(CheatManager_BugItStringCreator, ViewLocation) == 0x000000, "Member 'CheatManager_BugItStringCreator::ViewLocation' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItStringCreator, ViewRotation) == 0x00000C, "Member 'CheatManager_BugItStringCreator::ViewRotation' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItStringCreator, GoString) == 0x000018, "Member 'CheatManager_BugItStringCreator::GoString' has a wrong offset!");
static_assert(offsetof(CheatManager_BugItStringCreator, LocString) == 0x000028, "Member 'CheatManager_BugItStringCreator::LocString' has a wrong offset!");

// Function Engine.CheatManager.ChangeSize
// 0x0004 (0x0004 - 0x0000)
struct CheatManager_ChangeSize final
{
public:
	float                                         F;                                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_ChangeSize) == 0x000004, "Wrong alignment on CheatManager_ChangeSize");
static_assert(sizeof(CheatManager_ChangeSize) == 0x000004, "Wrong size on CheatManager_ChangeSize");
static_assert(offsetof(CheatManager_ChangeSize, F) == 0x000000, "Member 'CheatManager_ChangeSize::F' has a wrong offset!");

// Function Engine.CheatManager.CheatScript
// 0x0010 (0x0010 - 0x0000)
struct CheatManager_CheatScript final
{
public:
	class FString                                 ScriptName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_CheatScript) == 0x000008, "Wrong alignment on CheatManager_CheatScript");
static_assert(sizeof(CheatManager_CheatScript) == 0x000010, "Wrong size on CheatManager_CheatScript");
static_assert(offsetof(CheatManager_CheatScript, ScriptName) == 0x000000, "Member 'CheatManager_CheatScript::ScriptName' has a wrong offset!");

// Function Engine.CheatManager.DamageTarget
// 0x0004 (0x0004 - 0x0000)
struct CheatManager_DamageTarget final
{
public:
	float                                         DamageAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DamageTarget) == 0x000004, "Wrong alignment on CheatManager_DamageTarget");
static_assert(sizeof(CheatManager_DamageTarget) == 0x000004, "Wrong size on CheatManager_DamageTarget");
static_assert(offsetof(CheatManager_DamageTarget, DamageAmount) == 0x000000, "Member 'CheatManager_DamageTarget::DamageAmount' has a wrong offset!");

// Function Engine.CheatManager.DebugCapsuleSweepChannel
// 0x0001 (0x0001 - 0x0000)
struct CheatManager_DebugCapsuleSweepChannel final
{
public:
	ECollisionChannel                             Channel;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DebugCapsuleSweepChannel) == 0x000001, "Wrong alignment on CheatManager_DebugCapsuleSweepChannel");
static_assert(sizeof(CheatManager_DebugCapsuleSweepChannel) == 0x000001, "Wrong size on CheatManager_DebugCapsuleSweepChannel");
static_assert(offsetof(CheatManager_DebugCapsuleSweepChannel, Channel) == 0x000000, "Member 'CheatManager_DebugCapsuleSweepChannel::Channel' has a wrong offset!");

// Function Engine.CheatManager.DebugCapsuleSweepComplex
// 0x0001 (0x0001 - 0x0000)
struct CheatManager_DebugCapsuleSweepComplex final
{
public:
	bool                                          bTraceComplex;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DebugCapsuleSweepComplex) == 0x000001, "Wrong alignment on CheatManager_DebugCapsuleSweepComplex");
static_assert(sizeof(CheatManager_DebugCapsuleSweepComplex) == 0x000001, "Wrong size on CheatManager_DebugCapsuleSweepComplex");
static_assert(offsetof(CheatManager_DebugCapsuleSweepComplex, bTraceComplex) == 0x000000, "Member 'CheatManager_DebugCapsuleSweepComplex::bTraceComplex' has a wrong offset!");

// Function Engine.CheatManager.DebugCapsuleSweepSize
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_DebugCapsuleSweepSize final
{
public:
	float                                         HalfHeight;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DebugCapsuleSweepSize) == 0x000004, "Wrong alignment on CheatManager_DebugCapsuleSweepSize");
static_assert(sizeof(CheatManager_DebugCapsuleSweepSize) == 0x000008, "Wrong size on CheatManager_DebugCapsuleSweepSize");
static_assert(offsetof(CheatManager_DebugCapsuleSweepSize, HalfHeight) == 0x000000, "Member 'CheatManager_DebugCapsuleSweepSize::HalfHeight' has a wrong offset!");
static_assert(offsetof(CheatManager_DebugCapsuleSweepSize, Radius) == 0x000004, "Member 'CheatManager_DebugCapsuleSweepSize::Radius' has a wrong offset!");

// Function Engine.CheatManager.DestroyAll
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_DestroyAll final
{
public:
	TSubclassOf<class AActor>                     AClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DestroyAll) == 0x000008, "Wrong alignment on CheatManager_DestroyAll");
static_assert(sizeof(CheatManager_DestroyAll) == 0x000008, "Wrong size on CheatManager_DestroyAll");
static_assert(offsetof(CheatManager_DestroyAll, AClass) == 0x000000, "Member 'CheatManager_DestroyAll::AClass' has a wrong offset!");

// Function Engine.CheatManager.DestroyPawns
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_DestroyPawns final
{
public:
	TSubclassOf<class APawn>                      AClass;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DestroyPawns) == 0x000008, "Wrong alignment on CheatManager_DestroyPawns");
static_assert(sizeof(CheatManager_DestroyPawns) == 0x000008, "Wrong size on CheatManager_DestroyPawns");
static_assert(offsetof(CheatManager_DestroyPawns, AClass) == 0x000000, "Member 'CheatManager_DestroyPawns::AClass' has a wrong offset!");

// Function Engine.CheatManager.DumpEnumList
// 0x0001 (0x0001 - 0x0000)
struct CheatManager_DumpEnumList final
{
public:
	bool                                          bDumpEnumContent;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DumpEnumList) == 0x000001, "Wrong alignment on CheatManager_DumpEnumList");
static_assert(sizeof(CheatManager_DumpEnumList) == 0x000001, "Wrong size on CheatManager_DumpEnumList");
static_assert(offsetof(CheatManager_DumpEnumList, bDumpEnumContent) == 0x000000, "Member 'CheatManager_DumpEnumList::bDumpEnumContent' has a wrong offset!");

// Function Engine.CheatManager.DumpFNameList
// 0x0001 (0x0001 - 0x0000)
struct CheatManager_DumpFNameList final
{
public:
	bool                                          bDumpNameHash;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_DumpFNameList) == 0x000001, "Wrong alignment on CheatManager_DumpFNameList");
static_assert(sizeof(CheatManager_DumpFNameList) == 0x000001, "Wrong size on CheatManager_DumpFNameList");
static_assert(offsetof(CheatManager_DumpFNameList, bDumpNameHash) == 0x000000, "Member 'CheatManager_DumpFNameList::bDumpNameHash' has a wrong offset!");

// Function Engine.CheatManager.FreezeFrame
// 0x0004 (0x0004 - 0x0000)
struct CheatManager_FreezeFrame final
{
public:
	float                                         Delay;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_FreezeFrame) == 0x000004, "Wrong alignment on CheatManager_FreezeFrame");
static_assert(sizeof(CheatManager_FreezeFrame) == 0x000004, "Wrong size on CheatManager_FreezeFrame");
static_assert(offsetof(CheatManager_FreezeFrame, Delay) == 0x000000, "Member 'CheatManager_FreezeFrame::Delay' has a wrong offset!");

// Function Engine.CheatManager.OnlyLoadLevel
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_OnlyLoadLevel final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_OnlyLoadLevel) == 0x000004, "Wrong alignment on CheatManager_OnlyLoadLevel");
static_assert(sizeof(CheatManager_OnlyLoadLevel) == 0x000008, "Wrong size on CheatManager_OnlyLoadLevel");
static_assert(offsetof(CheatManager_OnlyLoadLevel, PackageName) == 0x000000, "Member 'CheatManager_OnlyLoadLevel::PackageName' has a wrong offset!");

// Function Engine.CheatManager.SetNavDrawDistance
// 0x0004 (0x0004 - 0x0000)
struct CheatManager_SetNavDrawDistance final
{
public:
	float                                         DrawDistance;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_SetNavDrawDistance) == 0x000004, "Wrong alignment on CheatManager_SetNavDrawDistance");
static_assert(sizeof(CheatManager_SetNavDrawDistance) == 0x000004, "Wrong size on CheatManager_SetNavDrawDistance");
static_assert(offsetof(CheatManager_SetNavDrawDistance, DrawDistance) == 0x000000, "Member 'CheatManager_SetNavDrawDistance::DrawDistance' has a wrong offset!");

// Function Engine.CheatManager.Slomo
// 0x0004 (0x0004 - 0x0000)
struct CheatManager_Slomo final
{
public:
	float                                         NewTimeDilation;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_Slomo) == 0x000004, "Wrong alignment on CheatManager_Slomo");
static_assert(sizeof(CheatManager_Slomo) == 0x000004, "Wrong size on CheatManager_Slomo");
static_assert(offsetof(CheatManager_Slomo, NewTimeDilation) == 0x000000, "Member 'CheatManager_Slomo::NewTimeDilation' has a wrong offset!");

// Function Engine.CheatManager.StreamLevelIn
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_StreamLevelIn final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_StreamLevelIn) == 0x000004, "Wrong alignment on CheatManager_StreamLevelIn");
static_assert(sizeof(CheatManager_StreamLevelIn) == 0x000008, "Wrong size on CheatManager_StreamLevelIn");
static_assert(offsetof(CheatManager_StreamLevelIn, PackageName) == 0x000000, "Member 'CheatManager_StreamLevelIn::PackageName' has a wrong offset!");

// Function Engine.CheatManager.StreamLevelOut
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_StreamLevelOut final
{
public:
	class FName                                   PackageName;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_StreamLevelOut) == 0x000004, "Wrong alignment on CheatManager_StreamLevelOut");
static_assert(sizeof(CheatManager_StreamLevelOut) == 0x000008, "Wrong size on CheatManager_StreamLevelOut");
static_assert(offsetof(CheatManager_StreamLevelOut, PackageName) == 0x000000, "Member 'CheatManager_StreamLevelOut::PackageName' has a wrong offset!");

// Function Engine.CheatManager.Summon
// 0x0010 (0x0010 - 0x0000)
struct CheatManager_Summon final
{
public:
	class FString                                 ClassName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_Summon) == 0x000008, "Wrong alignment on CheatManager_Summon");
static_assert(sizeof(CheatManager_Summon) == 0x000010, "Wrong size on CheatManager_Summon");
static_assert(offsetof(CheatManager_Summon, ClassName) == 0x000000, "Member 'CheatManager_Summon::ClassName' has a wrong offset!");

// Function Engine.CheatManager.ViewActor
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_ViewActor final
{
public:
	class FName                                   ActorName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_ViewActor) == 0x000004, "Wrong alignment on CheatManager_ViewActor");
static_assert(sizeof(CheatManager_ViewActor) == 0x000008, "Wrong size on CheatManager_ViewActor");
static_assert(offsetof(CheatManager_ViewActor, ActorName) == 0x000000, "Member 'CheatManager_ViewActor::ActorName' has a wrong offset!");

// Function Engine.CheatManager.ViewClass
// 0x0008 (0x0008 - 0x0000)
struct CheatManager_ViewClass final
{
public:
	TSubclassOf<class AActor>                     DesiredClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_ViewClass) == 0x000008, "Wrong alignment on CheatManager_ViewClass");
static_assert(sizeof(CheatManager_ViewClass) == 0x000008, "Wrong size on CheatManager_ViewClass");
static_assert(offsetof(CheatManager_ViewClass, DesiredClass) == 0x000000, "Member 'CheatManager_ViewClass::DesiredClass' has a wrong offset!");

// Function Engine.CheatManager.ViewPlayer
// 0x0010 (0x0010 - 0x0000)
struct CheatManager_ViewPlayer final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CheatManager_ViewPlayer) == 0x000008, "Wrong alignment on CheatManager_ViewPlayer");
static_assert(sizeof(CheatManager_ViewPlayer) == 0x000010, "Wrong size on CheatManager_ViewPlayer");
static_assert(offsetof(CheatManager_ViewPlayer, S) == 0x000000, "Member 'CheatManager_ViewPlayer::S' has a wrong offset!");

// Function Engine.SpotLightComponent.SetInnerConeAngle
// 0x0004 (0x0004 - 0x0000)
struct SpotLightComponent_SetInnerConeAngle final
{
public:
	float                                         NewInnerConeAngle;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpotLightComponent_SetInnerConeAngle) == 0x000004, "Wrong alignment on SpotLightComponent_SetInnerConeAngle");
static_assert(sizeof(SpotLightComponent_SetInnerConeAngle) == 0x000004, "Wrong size on SpotLightComponent_SetInnerConeAngle");
static_assert(offsetof(SpotLightComponent_SetInnerConeAngle, NewInnerConeAngle) == 0x000000, "Member 'SpotLightComponent_SetInnerConeAngle::NewInnerConeAngle' has a wrong offset!");

// Function Engine.SpotLightComponent.SetOuterConeAngle
// 0x0004 (0x0004 - 0x0000)
struct SpotLightComponent_SetOuterConeAngle final
{
public:
	float                                         NewOuterConeAngle;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpotLightComponent_SetOuterConeAngle) == 0x000004, "Wrong alignment on SpotLightComponent_SetOuterConeAngle");
static_assert(sizeof(SpotLightComponent_SetOuterConeAngle) == 0x000004, "Wrong size on SpotLightComponent_SetOuterConeAngle");
static_assert(offsetof(SpotLightComponent_SetOuterConeAngle, NewOuterConeAngle) == 0x000000, "Member 'SpotLightComponent_SetOuterConeAngle::NewOuterConeAngle' has a wrong offset!");

// Function Engine.GameInstance.DebugCreatePlayer
// 0x0004 (0x0004 - 0x0000)
struct GameInstance_DebugCreatePlayer final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstance_DebugCreatePlayer) == 0x000004, "Wrong alignment on GameInstance_DebugCreatePlayer");
static_assert(sizeof(GameInstance_DebugCreatePlayer) == 0x000004, "Wrong size on GameInstance_DebugCreatePlayer");
static_assert(offsetof(GameInstance_DebugCreatePlayer, ControllerId) == 0x000000, "Member 'GameInstance_DebugCreatePlayer::ControllerId' has a wrong offset!");

// Function Engine.GameInstance.DebugRemovePlayer
// 0x0004 (0x0004 - 0x0000)
struct GameInstance_DebugRemovePlayer final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstance_DebugRemovePlayer) == 0x000004, "Wrong alignment on GameInstance_DebugRemovePlayer");
static_assert(sizeof(GameInstance_DebugRemovePlayer) == 0x000004, "Wrong size on GameInstance_DebugRemovePlayer");
static_assert(offsetof(GameInstance_DebugRemovePlayer, ControllerId) == 0x000000, "Member 'GameInstance_DebugRemovePlayer::ControllerId' has a wrong offset!");

// Function Engine.GameInstance.HandleNetworkError
// 0x0002 (0x0002 - 0x0000)
struct GameInstance_HandleNetworkError final
{
public:
	ENetworkFailure                               FailureType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsServer;                                         // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstance_HandleNetworkError) == 0x000001, "Wrong alignment on GameInstance_HandleNetworkError");
static_assert(sizeof(GameInstance_HandleNetworkError) == 0x000002, "Wrong size on GameInstance_HandleNetworkError");
static_assert(offsetof(GameInstance_HandleNetworkError, FailureType) == 0x000000, "Member 'GameInstance_HandleNetworkError::FailureType' has a wrong offset!");
static_assert(offsetof(GameInstance_HandleNetworkError, bIsServer) == 0x000001, "Member 'GameInstance_HandleNetworkError::bIsServer' has a wrong offset!");

// Function Engine.GameInstance.HandleTravelError
// 0x0001 (0x0001 - 0x0000)
struct GameInstance_HandleTravelError final
{
public:
	ETravelFailure                                FailureType;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameInstance_HandleTravelError) == 0x000001, "Wrong alignment on GameInstance_HandleTravelError");
static_assert(sizeof(GameInstance_HandleTravelError) == 0x000001, "Wrong size on GameInstance_HandleTravelError");
static_assert(offsetof(GameInstance_HandleTravelError, FailureType) == 0x000000, "Member 'GameInstance_HandleTravelError::FailureType' has a wrong offset!");

// Function Engine.VectorFieldComponent.SetIntensity
// 0x0004 (0x0004 - 0x0000)
struct VectorFieldComponent_SetIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VectorFieldComponent_SetIntensity) == 0x000004, "Wrong alignment on VectorFieldComponent_SetIntensity");
static_assert(sizeof(VectorFieldComponent_SetIntensity) == 0x000004, "Wrong size on VectorFieldComponent_SetIntensity");
static_assert(offsetof(VectorFieldComponent_SetIntensity, NewIntensity) == 0x000000, "Member 'VectorFieldComponent_SetIntensity::NewIntensity' has a wrong offset!");

// Function Engine.GameUserSettings.GetDefaultResolution
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetDefaultResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetDefaultResolution) == 0x000004, "Wrong alignment on GameUserSettings_GetDefaultResolution");
static_assert(sizeof(GameUserSettings_GetDefaultResolution) == 0x000008, "Wrong size on GameUserSettings_GetDefaultResolution");
static_assert(offsetof(GameUserSettings_GetDefaultResolution, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetDefaultResolution::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetDefaultWindowMode
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_GetDefaultWindowMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetDefaultWindowMode) == 0x000001, "Wrong alignment on GameUserSettings_GetDefaultWindowMode");
static_assert(sizeof(GameUserSettings_GetDefaultWindowMode) == 0x000001, "Wrong size on GameUserSettings_GetDefaultWindowMode");
static_assert(offsetof(GameUserSettings_GetDefaultWindowMode, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetDefaultWindowMode::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetDefaultWindowPosition
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetDefaultWindowPosition final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetDefaultWindowPosition) == 0x000004, "Wrong alignment on GameUserSettings_GetDefaultWindowPosition");
static_assert(sizeof(GameUserSettings_GetDefaultWindowPosition) == 0x000008, "Wrong size on GameUserSettings_GetDefaultWindowPosition");
static_assert(offsetof(GameUserSettings_GetDefaultWindowPosition, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetDefaultWindowPosition::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetGameUserSettings
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetGameUserSettings final
{
public:
	class UGameUserSettings*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetGameUserSettings) == 0x000008, "Wrong alignment on GameUserSettings_GetGameUserSettings");
static_assert(sizeof(GameUserSettings_GetGameUserSettings) == 0x000008, "Wrong size on GameUserSettings_GetGameUserSettings");
static_assert(offsetof(GameUserSettings_GetGameUserSettings, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetGameUserSettings::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.ApplyResolutionSettings
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_ApplyResolutionSettings final
{
public:
	bool                                          bCheckForCommandLineOverrides;                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_ApplyResolutionSettings) == 0x000001, "Wrong alignment on GameUserSettings_ApplyResolutionSettings");
static_assert(sizeof(GameUserSettings_ApplyResolutionSettings) == 0x000001, "Wrong size on GameUserSettings_ApplyResolutionSettings");
static_assert(offsetof(GameUserSettings_ApplyResolutionSettings, bCheckForCommandLineOverrides) == 0x000000, "Member 'GameUserSettings_ApplyResolutionSettings::bCheckForCommandLineOverrides' has a wrong offset!");

// Function Engine.GameUserSettings.ApplySettings
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_ApplySettings final
{
public:
	bool                                          bCheckForCommandLineOverrides;                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_ApplySettings) == 0x000001, "Wrong alignment on GameUserSettings_ApplySettings");
static_assert(sizeof(GameUserSettings_ApplySettings) == 0x000001, "Wrong size on GameUserSettings_ApplySettings");
static_assert(offsetof(GameUserSettings_ApplySettings, bCheckForCommandLineOverrides) == 0x000000, "Member 'GameUserSettings_ApplySettings::bCheckForCommandLineOverrides' has a wrong offset!");

// Function Engine.GameUserSettings.EnableHDRDisplayOutput
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_EnableHDRDisplayOutput final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DisplayNits;                                       // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_EnableHDRDisplayOutput) == 0x000004, "Wrong alignment on GameUserSettings_EnableHDRDisplayOutput");
static_assert(sizeof(GameUserSettings_EnableHDRDisplayOutput) == 0x000008, "Wrong size on GameUserSettings_EnableHDRDisplayOutput");
static_assert(offsetof(GameUserSettings_EnableHDRDisplayOutput, bEnable) == 0x000000, "Member 'GameUserSettings_EnableHDRDisplayOutput::bEnable' has a wrong offset!");
static_assert(offsetof(GameUserSettings_EnableHDRDisplayOutput, DisplayNits) == 0x000004, "Member 'GameUserSettings_EnableHDRDisplayOutput::DisplayNits' has a wrong offset!");

// Function Engine.GameUserSettings.GetDefaultResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetDefaultResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetDefaultResolutionScale) == 0x000004, "Wrong alignment on GameUserSettings_GetDefaultResolutionScale");
static_assert(sizeof(GameUserSettings_GetDefaultResolutionScale) == 0x000004, "Wrong size on GameUserSettings_GetDefaultResolutionScale");
static_assert(offsetof(GameUserSettings_GetDefaultResolutionScale, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetDefaultResolutionScale::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetRecommendedResolutionScale
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetRecommendedResolutionScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetRecommendedResolutionScale) == 0x000004, "Wrong alignment on GameUserSettings_GetRecommendedResolutionScale");
static_assert(sizeof(GameUserSettings_GetRecommendedResolutionScale) == 0x000004, "Wrong size on GameUserSettings_GetRecommendedResolutionScale");
static_assert(offsetof(GameUserSettings_GetRecommendedResolutionScale, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetRecommendedResolutionScale::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.LoadSettings
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_LoadSettings final
{
public:
	bool                                          bForceReload;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_LoadSettings) == 0x000001, "Wrong alignment on GameUserSettings_LoadSettings");
static_assert(sizeof(GameUserSettings_LoadSettings) == 0x000001, "Wrong size on GameUserSettings_LoadSettings");
static_assert(offsetof(GameUserSettings_LoadSettings, bForceReload) == 0x000000, "Member 'GameUserSettings_LoadSettings::bForceReload' has a wrong offset!");

// Function Engine.GameUserSettings.RunHardwareBenchmark
// 0x000C (0x000C - 0x0000)
struct GameUserSettings_RunHardwareBenchmark final
{
public:
	int32                                         WorkScale;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CPUMultiplier;                                     // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GPUMultiplier;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_RunHardwareBenchmark) == 0x000004, "Wrong alignment on GameUserSettings_RunHardwareBenchmark");
static_assert(sizeof(GameUserSettings_RunHardwareBenchmark) == 0x00000C, "Wrong size on GameUserSettings_RunHardwareBenchmark");
static_assert(offsetof(GameUserSettings_RunHardwareBenchmark, WorkScale) == 0x000000, "Member 'GameUserSettings_RunHardwareBenchmark::WorkScale' has a wrong offset!");
static_assert(offsetof(GameUserSettings_RunHardwareBenchmark, CPUMultiplier) == 0x000004, "Member 'GameUserSettings_RunHardwareBenchmark::CPUMultiplier' has a wrong offset!");
static_assert(offsetof(GameUserSettings_RunHardwareBenchmark, GPUMultiplier) == 0x000008, "Member 'GameUserSettings_RunHardwareBenchmark::GPUMultiplier' has a wrong offset!");

// Function Engine.GameUserSettings.SetAntiAliasingQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetAntiAliasingQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetAntiAliasingQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetAntiAliasingQuality");
static_assert(sizeof(GameUserSettings_SetAntiAliasingQuality) == 0x000004, "Wrong size on GameUserSettings_SetAntiAliasingQuality");
static_assert(offsetof(GameUserSettings_SetAntiAliasingQuality, Value) == 0x000000, "Member 'GameUserSettings_SetAntiAliasingQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetAudioQualityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetAudioQualityLevel final
{
public:
	int32                                         QualityLevel;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetAudioQualityLevel) == 0x000004, "Wrong alignment on GameUserSettings_SetAudioQualityLevel");
static_assert(sizeof(GameUserSettings_SetAudioQualityLevel) == 0x000004, "Wrong size on GameUserSettings_SetAudioQualityLevel");
static_assert(offsetof(GameUserSettings_SetAudioQualityLevel, QualityLevel) == 0x000000, "Member 'GameUserSettings_SetAudioQualityLevel::QualityLevel' has a wrong offset!");

// Function Engine.GameUserSettings.SetFoliageQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetFoliageQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetFoliageQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetFoliageQuality");
static_assert(sizeof(GameUserSettings_SetFoliageQuality) == 0x000004, "Wrong size on GameUserSettings_SetFoliageQuality");
static_assert(offsetof(GameUserSettings_SetFoliageQuality, Value) == 0x000000, "Member 'GameUserSettings_SetFoliageQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetFrameRateLimit final
{
public:
	float                                         NewLimit;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetFrameRateLimit) == 0x000004, "Wrong alignment on GameUserSettings_SetFrameRateLimit");
static_assert(sizeof(GameUserSettings_SetFrameRateLimit) == 0x000004, "Wrong size on GameUserSettings_SetFrameRateLimit");
static_assert(offsetof(GameUserSettings_SetFrameRateLimit, NewLimit) == 0x000000, "Member 'GameUserSettings_SetFrameRateLimit::NewLimit' has a wrong offset!");

// Function Engine.GameUserSettings.SetFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_SetFullscreenMode final
{
public:
	EWindowMode                                   InFullscreenMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetFullscreenMode) == 0x000001, "Wrong alignment on GameUserSettings_SetFullscreenMode");
static_assert(sizeof(GameUserSettings_SetFullscreenMode) == 0x000001, "Wrong size on GameUserSettings_SetFullscreenMode");
static_assert(offsetof(GameUserSettings_SetFullscreenMode, InFullscreenMode) == 0x000000, "Member 'GameUserSettings_SetFullscreenMode::InFullscreenMode' has a wrong offset!");

// Function Engine.GameUserSettings.SetOverallScalabilityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetOverallScalabilityLevel final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetOverallScalabilityLevel) == 0x000004, "Wrong alignment on GameUserSettings_SetOverallScalabilityLevel");
static_assert(sizeof(GameUserSettings_SetOverallScalabilityLevel) == 0x000004, "Wrong size on GameUserSettings_SetOverallScalabilityLevel");
static_assert(offsetof(GameUserSettings_SetOverallScalabilityLevel, Value) == 0x000000, "Member 'GameUserSettings_SetOverallScalabilityLevel::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetPostProcessingQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetPostProcessingQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetPostProcessingQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetPostProcessingQuality");
static_assert(sizeof(GameUserSettings_SetPostProcessingQuality) == 0x000004, "Wrong size on GameUserSettings_SetPostProcessingQuality");
static_assert(offsetof(GameUserSettings_SetPostProcessingQuality, Value) == 0x000000, "Member 'GameUserSettings_SetPostProcessingQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetResolutionScaleNormalized
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetResolutionScaleNormalized final
{
public:
	float                                         NewScaleNormalized;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetResolutionScaleNormalized) == 0x000004, "Wrong alignment on GameUserSettings_SetResolutionScaleNormalized");
static_assert(sizeof(GameUserSettings_SetResolutionScaleNormalized) == 0x000004, "Wrong size on GameUserSettings_SetResolutionScaleNormalized");
static_assert(offsetof(GameUserSettings_SetResolutionScaleNormalized, NewScaleNormalized) == 0x000000, "Member 'GameUserSettings_SetResolutionScaleNormalized::NewScaleNormalized' has a wrong offset!");

// Function Engine.GameUserSettings.SetResolutionScaleValue
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetResolutionScaleValue final
{
public:
	int32                                         NewScaleValue;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetResolutionScaleValue) == 0x000004, "Wrong alignment on GameUserSettings_SetResolutionScaleValue");
static_assert(sizeof(GameUserSettings_SetResolutionScaleValue) == 0x000004, "Wrong size on GameUserSettings_SetResolutionScaleValue");
static_assert(offsetof(GameUserSettings_SetResolutionScaleValue, NewScaleValue) == 0x000000, "Member 'GameUserSettings_SetResolutionScaleValue::NewScaleValue' has a wrong offset!");

// Function Engine.GameUserSettings.SetResolutionScaleValueEx
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetResolutionScaleValueEx final
{
public:
	float                                         NewScaleValue;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetResolutionScaleValueEx) == 0x000004, "Wrong alignment on GameUserSettings_SetResolutionScaleValueEx");
static_assert(sizeof(GameUserSettings_SetResolutionScaleValueEx) == 0x000004, "Wrong size on GameUserSettings_SetResolutionScaleValueEx");
static_assert(offsetof(GameUserSettings_SetResolutionScaleValueEx, NewScaleValue) == 0x000000, "Member 'GameUserSettings_SetResolutionScaleValueEx::NewScaleValue' has a wrong offset!");

// Function Engine.GameUserSettings.SetScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_SetScreenResolution final
{
public:
	struct FIntPoint                              Resolution;                                        // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetScreenResolution) == 0x000004, "Wrong alignment on GameUserSettings_SetScreenResolution");
static_assert(sizeof(GameUserSettings_SetScreenResolution) == 0x000008, "Wrong size on GameUserSettings_SetScreenResolution");
static_assert(offsetof(GameUserSettings_SetScreenResolution, Resolution) == 0x000000, "Member 'GameUserSettings_SetScreenResolution::Resolution' has a wrong offset!");

// Function Engine.GameUserSettings.SetShadowQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetShadowQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetShadowQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetShadowQuality");
static_assert(sizeof(GameUserSettings_SetShadowQuality) == 0x000004, "Wrong size on GameUserSettings_SetShadowQuality");
static_assert(offsetof(GameUserSettings_SetShadowQuality, Value) == 0x000000, "Member 'GameUserSettings_SetShadowQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetTextureQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetTextureQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetTextureQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetTextureQuality");
static_assert(sizeof(GameUserSettings_SetTextureQuality) == 0x000004, "Wrong size on GameUserSettings_SetTextureQuality");
static_assert(offsetof(GameUserSettings_SetTextureQuality, Value) == 0x000000, "Member 'GameUserSettings_SetTextureQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetViewDistanceQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetViewDistanceQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetViewDistanceQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetViewDistanceQuality");
static_assert(sizeof(GameUserSettings_SetViewDistanceQuality) == 0x000004, "Wrong size on GameUserSettings_SetViewDistanceQuality");
static_assert(offsetof(GameUserSettings_SetViewDistanceQuality, Value) == 0x000000, "Member 'GameUserSettings_SetViewDistanceQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetVisualEffectQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_SetVisualEffectQuality final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetVisualEffectQuality) == 0x000004, "Wrong alignment on GameUserSettings_SetVisualEffectQuality");
static_assert(sizeof(GameUserSettings_SetVisualEffectQuality) == 0x000004, "Wrong size on GameUserSettings_SetVisualEffectQuality");
static_assert(offsetof(GameUserSettings_SetVisualEffectQuality, Value) == 0x000000, "Member 'GameUserSettings_SetVisualEffectQuality::Value' has a wrong offset!");

// Function Engine.GameUserSettings.SetVSyncEnabled
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_SetVSyncEnabled final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SetVSyncEnabled) == 0x000001, "Wrong alignment on GameUserSettings_SetVSyncEnabled");
static_assert(sizeof(GameUserSettings_SetVSyncEnabled) == 0x000001, "Wrong size on GameUserSettings_SetVSyncEnabled");
static_assert(offsetof(GameUserSettings_SetVSyncEnabled, bEnable) == 0x000000, "Member 'GameUserSettings_SetVSyncEnabled::bEnable' has a wrong offset!");

// Function Engine.GameUserSettings.GetAntiAliasingQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetAntiAliasingQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetAntiAliasingQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetAntiAliasingQuality");
static_assert(sizeof(GameUserSettings_GetAntiAliasingQuality) == 0x000004, "Wrong size on GameUserSettings_GetAntiAliasingQuality");
static_assert(offsetof(GameUserSettings_GetAntiAliasingQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetAntiAliasingQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetAudioQualityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetAudioQualityLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetAudioQualityLevel) == 0x000004, "Wrong alignment on GameUserSettings_GetAudioQualityLevel");
static_assert(sizeof(GameUserSettings_GetAudioQualityLevel) == 0x000004, "Wrong size on GameUserSettings_GetAudioQualityLevel");
static_assert(offsetof(GameUserSettings_GetAudioQualityLevel, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetAudioQualityLevel::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetCurrentHDRDisplayNits
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetCurrentHDRDisplayNits final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetCurrentHDRDisplayNits) == 0x000004, "Wrong alignment on GameUserSettings_GetCurrentHDRDisplayNits");
static_assert(sizeof(GameUserSettings_GetCurrentHDRDisplayNits) == 0x000004, "Wrong size on GameUserSettings_GetCurrentHDRDisplayNits");
static_assert(offsetof(GameUserSettings_GetCurrentHDRDisplayNits, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetCurrentHDRDisplayNits::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetDesktopResolution
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetDesktopResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetDesktopResolution) == 0x000004, "Wrong alignment on GameUserSettings_GetDesktopResolution");
static_assert(sizeof(GameUserSettings_GetDesktopResolution) == 0x000008, "Wrong size on GameUserSettings_GetDesktopResolution");
static_assert(offsetof(GameUserSettings_GetDesktopResolution, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetDesktopResolution::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetFoliageQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetFoliageQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetFoliageQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetFoliageQuality");
static_assert(sizeof(GameUserSettings_GetFoliageQuality) == 0x000004, "Wrong size on GameUserSettings_GetFoliageQuality");
static_assert(offsetof(GameUserSettings_GetFoliageQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetFoliageQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetFrameRateLimit
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetFrameRateLimit final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetFrameRateLimit) == 0x000004, "Wrong alignment on GameUserSettings_GetFrameRateLimit");
static_assert(sizeof(GameUserSettings_GetFrameRateLimit) == 0x000004, "Wrong size on GameUserSettings_GetFrameRateLimit");
static_assert(offsetof(GameUserSettings_GetFrameRateLimit, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetFrameRateLimit::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_GetFullscreenMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetFullscreenMode) == 0x000001, "Wrong alignment on GameUserSettings_GetFullscreenMode");
static_assert(sizeof(GameUserSettings_GetFullscreenMode) == 0x000001, "Wrong size on GameUserSettings_GetFullscreenMode");
static_assert(offsetof(GameUserSettings_GetFullscreenMode, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetFullscreenMode::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetLastConfirmedFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_GetLastConfirmedFullscreenMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetLastConfirmedFullscreenMode) == 0x000001, "Wrong alignment on GameUserSettings_GetLastConfirmedFullscreenMode");
static_assert(sizeof(GameUserSettings_GetLastConfirmedFullscreenMode) == 0x000001, "Wrong size on GameUserSettings_GetLastConfirmedFullscreenMode");
static_assert(offsetof(GameUserSettings_GetLastConfirmedFullscreenMode, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetLastConfirmedFullscreenMode::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetLastConfirmedScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetLastConfirmedScreenResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetLastConfirmedScreenResolution) == 0x000004, "Wrong alignment on GameUserSettings_GetLastConfirmedScreenResolution");
static_assert(sizeof(GameUserSettings_GetLastConfirmedScreenResolution) == 0x000008, "Wrong size on GameUserSettings_GetLastConfirmedScreenResolution");
static_assert(offsetof(GameUserSettings_GetLastConfirmedScreenResolution, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetLastConfirmedScreenResolution::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetOverallScalabilityLevel
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetOverallScalabilityLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetOverallScalabilityLevel) == 0x000004, "Wrong alignment on GameUserSettings_GetOverallScalabilityLevel");
static_assert(sizeof(GameUserSettings_GetOverallScalabilityLevel) == 0x000004, "Wrong size on GameUserSettings_GetOverallScalabilityLevel");
static_assert(offsetof(GameUserSettings_GetOverallScalabilityLevel, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetOverallScalabilityLevel::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetPostProcessingQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetPostProcessingQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetPostProcessingQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetPostProcessingQuality");
static_assert(sizeof(GameUserSettings_GetPostProcessingQuality) == 0x000004, "Wrong size on GameUserSettings_GetPostProcessingQuality");
static_assert(offsetof(GameUserSettings_GetPostProcessingQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetPostProcessingQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetPreferredFullscreenMode
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_GetPreferredFullscreenMode final
{
public:
	EWindowMode                                   ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetPreferredFullscreenMode) == 0x000001, "Wrong alignment on GameUserSettings_GetPreferredFullscreenMode");
static_assert(sizeof(GameUserSettings_GetPreferredFullscreenMode) == 0x000001, "Wrong size on GameUserSettings_GetPreferredFullscreenMode");
static_assert(offsetof(GameUserSettings_GetPreferredFullscreenMode, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetPreferredFullscreenMode::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetResolutionScaleInformation
// 0x0010 (0x0010 - 0x0000)
struct GameUserSettings_GetResolutionScaleInformation final
{
public:
	float                                         CurrentScaleNormalized;                            // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CurrentScaleValue;                                 // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinScaleValue;                                     // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScaleValue;                                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetResolutionScaleInformation) == 0x000004, "Wrong alignment on GameUserSettings_GetResolutionScaleInformation");
static_assert(sizeof(GameUserSettings_GetResolutionScaleInformation) == 0x000010, "Wrong size on GameUserSettings_GetResolutionScaleInformation");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformation, CurrentScaleNormalized) == 0x000000, "Member 'GameUserSettings_GetResolutionScaleInformation::CurrentScaleNormalized' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformation, CurrentScaleValue) == 0x000004, "Member 'GameUserSettings_GetResolutionScaleInformation::CurrentScaleValue' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformation, MinScaleValue) == 0x000008, "Member 'GameUserSettings_GetResolutionScaleInformation::MinScaleValue' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformation, MaxScaleValue) == 0x00000C, "Member 'GameUserSettings_GetResolutionScaleInformation::MaxScaleValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetResolutionScaleInformationEx
// 0x0010 (0x0010 - 0x0000)
struct GameUserSettings_GetResolutionScaleInformationEx final
{
public:
	float                                         CurrentScaleNormalized;                            // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         CurrentScaleValue;                                 // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinScaleValue;                                     // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxScaleValue;                                     // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetResolutionScaleInformationEx) == 0x000004, "Wrong alignment on GameUserSettings_GetResolutionScaleInformationEx");
static_assert(sizeof(GameUserSettings_GetResolutionScaleInformationEx) == 0x000010, "Wrong size on GameUserSettings_GetResolutionScaleInformationEx");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformationEx, CurrentScaleNormalized) == 0x000000, "Member 'GameUserSettings_GetResolutionScaleInformationEx::CurrentScaleNormalized' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformationEx, CurrentScaleValue) == 0x000004, "Member 'GameUserSettings_GetResolutionScaleInformationEx::CurrentScaleValue' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformationEx, MinScaleValue) == 0x000008, "Member 'GameUserSettings_GetResolutionScaleInformationEx::MinScaleValue' has a wrong offset!");
static_assert(offsetof(GameUserSettings_GetResolutionScaleInformationEx, MaxScaleValue) == 0x00000C, "Member 'GameUserSettings_GetResolutionScaleInformationEx::MaxScaleValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetScreenResolution
// 0x0008 (0x0008 - 0x0000)
struct GameUserSettings_GetScreenResolution final
{
public:
	struct FIntPoint                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetScreenResolution) == 0x000004, "Wrong alignment on GameUserSettings_GetScreenResolution");
static_assert(sizeof(GameUserSettings_GetScreenResolution) == 0x000008, "Wrong size on GameUserSettings_GetScreenResolution");
static_assert(offsetof(GameUserSettings_GetScreenResolution, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetScreenResolution::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetShadowQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetShadowQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetShadowQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetShadowQuality");
static_assert(sizeof(GameUserSettings_GetShadowQuality) == 0x000004, "Wrong size on GameUserSettings_GetShadowQuality");
static_assert(offsetof(GameUserSettings_GetShadowQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetShadowQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetTextureQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetTextureQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetTextureQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetTextureQuality");
static_assert(sizeof(GameUserSettings_GetTextureQuality) == 0x000004, "Wrong size on GameUserSettings_GetTextureQuality");
static_assert(offsetof(GameUserSettings_GetTextureQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetTextureQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetViewDistanceQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetViewDistanceQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetViewDistanceQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetViewDistanceQuality");
static_assert(sizeof(GameUserSettings_GetViewDistanceQuality) == 0x000004, "Wrong size on GameUserSettings_GetViewDistanceQuality");
static_assert(offsetof(GameUserSettings_GetViewDistanceQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetViewDistanceQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.GetVisualEffectQuality
// 0x0004 (0x0004 - 0x0000)
struct GameUserSettings_GetVisualEffectQuality final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_GetVisualEffectQuality) == 0x000004, "Wrong alignment on GameUserSettings_GetVisualEffectQuality");
static_assert(sizeof(GameUserSettings_GetVisualEffectQuality) == 0x000004, "Wrong size on GameUserSettings_GetVisualEffectQuality");
static_assert(offsetof(GameUserSettings_GetVisualEffectQuality, ReturnValue) == 0x000000, "Member 'GameUserSettings_GetVisualEffectQuality::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsDirty
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsDirty) == 0x000001, "Wrong alignment on GameUserSettings_IsDirty");
static_assert(sizeof(GameUserSettings_IsDirty) == 0x000001, "Wrong size on GameUserSettings_IsDirty");
static_assert(offsetof(GameUserSettings_IsDirty, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsDirty::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsFullscreenModeDirty
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsFullscreenModeDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsFullscreenModeDirty) == 0x000001, "Wrong alignment on GameUserSettings_IsFullscreenModeDirty");
static_assert(sizeof(GameUserSettings_IsFullscreenModeDirty) == 0x000001, "Wrong size on GameUserSettings_IsFullscreenModeDirty");
static_assert(offsetof(GameUserSettings_IsFullscreenModeDirty, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsFullscreenModeDirty::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsHDREnabled
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsHDREnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsHDREnabled) == 0x000001, "Wrong alignment on GameUserSettings_IsHDREnabled");
static_assert(sizeof(GameUserSettings_IsHDREnabled) == 0x000001, "Wrong size on GameUserSettings_IsHDREnabled");
static_assert(offsetof(GameUserSettings_IsHDREnabled, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsHDREnabled::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsScreenResolutionDirty
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsScreenResolutionDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsScreenResolutionDirty) == 0x000001, "Wrong alignment on GameUserSettings_IsScreenResolutionDirty");
static_assert(sizeof(GameUserSettings_IsScreenResolutionDirty) == 0x000001, "Wrong size on GameUserSettings_IsScreenResolutionDirty");
static_assert(offsetof(GameUserSettings_IsScreenResolutionDirty, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsScreenResolutionDirty::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsVSyncDirty
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsVSyncDirty final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsVSyncDirty) == 0x000001, "Wrong alignment on GameUserSettings_IsVSyncDirty");
static_assert(sizeof(GameUserSettings_IsVSyncDirty) == 0x000001, "Wrong size on GameUserSettings_IsVSyncDirty");
static_assert(offsetof(GameUserSettings_IsVSyncDirty, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsVSyncDirty::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.IsVSyncEnabled
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_IsVSyncEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_IsVSyncEnabled) == 0x000001, "Wrong alignment on GameUserSettings_IsVSyncEnabled");
static_assert(sizeof(GameUserSettings_IsVSyncEnabled) == 0x000001, "Wrong size on GameUserSettings_IsVSyncEnabled");
static_assert(offsetof(GameUserSettings_IsVSyncEnabled, ReturnValue) == 0x000000, "Member 'GameUserSettings_IsVSyncEnabled::ReturnValue' has a wrong offset!");

// Function Engine.GameUserSettings.SupportsHDRDisplayOutput
// 0x0001 (0x0001 - 0x0000)
struct GameUserSettings_SupportsHDRDisplayOutput final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameUserSettings_SupportsHDRDisplayOutput) == 0x000001, "Wrong alignment on GameUserSettings_SupportsHDRDisplayOutput");
static_assert(sizeof(GameUserSettings_SupportsHDRDisplayOutput) == 0x000001, "Wrong size on GameUserSettings_SupportsHDRDisplayOutput");
static_assert(offsetof(GameUserSettings_SupportsHDRDisplayOutput, ReturnValue) == 0x000000, "Member 'GameUserSettings_SupportsHDRDisplayOutput::ReturnValue' has a wrong offset!");

// Function Engine.GameViewportClient.SetConsoleTarget
// 0x0004 (0x0004 - 0x0000)
struct GameViewportClient_SetConsoleTarget final
{
public:
	int32                                         PlayerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameViewportClient_SetConsoleTarget) == 0x000004, "Wrong alignment on GameViewportClient_SetConsoleTarget");
static_assert(sizeof(GameViewportClient_SetConsoleTarget) == 0x000004, "Wrong size on GameViewportClient_SetConsoleTarget");
static_assert(offsetof(GameViewportClient_SetConsoleTarget, PlayerIndex) == 0x000000, "Member 'GameViewportClient_SetConsoleTarget::PlayerIndex' has a wrong offset!");

// Function Engine.CurveVector.GetVectorValue
// 0x0010 (0x0010 - 0x0000)
struct CurveVector_GetVectorValue final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveVector_GetVectorValue) == 0x000004, "Wrong alignment on CurveVector_GetVectorValue");
static_assert(sizeof(CurveVector_GetVectorValue) == 0x000010, "Wrong size on CurveVector_GetVectorValue");
static_assert(offsetof(CurveVector_GetVectorValue, InTime) == 0x000000, "Member 'CurveVector_GetVectorValue::InTime' has a wrong offset!");
static_assert(offsetof(CurveVector_GetVectorValue, ReturnValue) == 0x000004, "Member 'CurveVector_GetVectorValue::ReturnValue' has a wrong offset!");

// Function Engine.NavRelevantComponent.SetNavigationRelevancy
// 0x0001 (0x0001 - 0x0000)
struct NavRelevantComponent_SetNavigationRelevancy final
{
public:
	bool                                          bRelevant;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavRelevantComponent_SetNavigationRelevancy) == 0x000001, "Wrong alignment on NavRelevantComponent_SetNavigationRelevancy");
static_assert(sizeof(NavRelevantComponent_SetNavigationRelevancy) == 0x000001, "Wrong size on NavRelevantComponent_SetNavigationRelevancy");
static_assert(offsetof(NavRelevantComponent_SetNavigationRelevancy, bRelevant) == 0x000000, "Member 'NavRelevantComponent_SetNavigationRelevancy::bRelevant' has a wrong offset!");

// Function Engine.CameraComponent.AddOrUpdateBlendable
// 0x0018 (0x0018 - 0x0000)
struct CameraComponent_AddOrUpdateBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CameraComponent_AddOrUpdateBlendable) == 0x000008, "Wrong alignment on CameraComponent_AddOrUpdateBlendable");
static_assert(sizeof(CameraComponent_AddOrUpdateBlendable) == 0x000018, "Wrong size on CameraComponent_AddOrUpdateBlendable");
static_assert(offsetof(CameraComponent_AddOrUpdateBlendable, InBlendableObject) == 0x000000, "Member 'CameraComponent_AddOrUpdateBlendable::InBlendableObject' has a wrong offset!");
static_assert(offsetof(CameraComponent_AddOrUpdateBlendable, InWeight) == 0x000010, "Member 'CameraComponent_AddOrUpdateBlendable::InWeight' has a wrong offset!");

// Function Engine.CameraComponent.GetCameraView
// 0x0560 (0x0560 - 0x0000)
struct CameraComponent_GetCameraView final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       DesiredView;                                       // 0x0010(0x0550)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_GetCameraView) == 0x000010, "Wrong alignment on CameraComponent_GetCameraView");
static_assert(sizeof(CameraComponent_GetCameraView) == 0x000560, "Wrong size on CameraComponent_GetCameraView");
static_assert(offsetof(CameraComponent_GetCameraView, DeltaTime) == 0x000000, "Member 'CameraComponent_GetCameraView::DeltaTime' has a wrong offset!");
static_assert(offsetof(CameraComponent_GetCameraView, DesiredView) == 0x000010, "Member 'CameraComponent_GetCameraView::DesiredView' has a wrong offset!");

// Function Engine.CameraComponent.RemoveBlendable
// 0x0010 (0x0010 - 0x0000)
struct CameraComponent_RemoveBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_RemoveBlendable) == 0x000008, "Wrong alignment on CameraComponent_RemoveBlendable");
static_assert(sizeof(CameraComponent_RemoveBlendable) == 0x000010, "Wrong size on CameraComponent_RemoveBlendable");
static_assert(offsetof(CameraComponent_RemoveBlendable, InBlendableObject) == 0x000000, "Member 'CameraComponent_RemoveBlendable::InBlendableObject' has a wrong offset!");

// Function Engine.CameraComponent.SetAspectRatio
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetAspectRatio final
{
public:
	float                                         InAspectRatio;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetAspectRatio) == 0x000004, "Wrong alignment on CameraComponent_SetAspectRatio");
static_assert(sizeof(CameraComponent_SetAspectRatio) == 0x000004, "Wrong size on CameraComponent_SetAspectRatio");
static_assert(offsetof(CameraComponent_SetAspectRatio, InAspectRatio) == 0x000000, "Member 'CameraComponent_SetAspectRatio::InAspectRatio' has a wrong offset!");

// Function Engine.CameraComponent.SetConstraintAspectRatio
// 0x0001 (0x0001 - 0x0000)
struct CameraComponent_SetConstraintAspectRatio final
{
public:
	bool                                          bInConstrainAspectRatio;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetConstraintAspectRatio) == 0x000001, "Wrong alignment on CameraComponent_SetConstraintAspectRatio");
static_assert(sizeof(CameraComponent_SetConstraintAspectRatio) == 0x000001, "Wrong size on CameraComponent_SetConstraintAspectRatio");
static_assert(offsetof(CameraComponent_SetConstraintAspectRatio, bInConstrainAspectRatio) == 0x000000, "Member 'CameraComponent_SetConstraintAspectRatio::bInConstrainAspectRatio' has a wrong offset!");

// Function Engine.CameraComponent.SetFieldOfView
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetFieldOfView final
{
public:
	float                                         InFieldOfView;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetFieldOfView) == 0x000004, "Wrong alignment on CameraComponent_SetFieldOfView");
static_assert(sizeof(CameraComponent_SetFieldOfView) == 0x000004, "Wrong size on CameraComponent_SetFieldOfView");
static_assert(offsetof(CameraComponent_SetFieldOfView, InFieldOfView) == 0x000000, "Member 'CameraComponent_SetFieldOfView::InFieldOfView' has a wrong offset!");

// Function Engine.CameraComponent.SetOrthoFarClipPlane
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetOrthoFarClipPlane final
{
public:
	float                                         InOrthoFarClipPlane;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetOrthoFarClipPlane) == 0x000004, "Wrong alignment on CameraComponent_SetOrthoFarClipPlane");
static_assert(sizeof(CameraComponent_SetOrthoFarClipPlane) == 0x000004, "Wrong size on CameraComponent_SetOrthoFarClipPlane");
static_assert(offsetof(CameraComponent_SetOrthoFarClipPlane, InOrthoFarClipPlane) == 0x000000, "Member 'CameraComponent_SetOrthoFarClipPlane::InOrthoFarClipPlane' has a wrong offset!");

// Function Engine.CameraComponent.SetOrthoNearClipPlane
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetOrthoNearClipPlane final
{
public:
	float                                         InOrthoNearClipPlane;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetOrthoNearClipPlane) == 0x000004, "Wrong alignment on CameraComponent_SetOrthoNearClipPlane");
static_assert(sizeof(CameraComponent_SetOrthoNearClipPlane) == 0x000004, "Wrong size on CameraComponent_SetOrthoNearClipPlane");
static_assert(offsetof(CameraComponent_SetOrthoNearClipPlane, InOrthoNearClipPlane) == 0x000000, "Member 'CameraComponent_SetOrthoNearClipPlane::InOrthoNearClipPlane' has a wrong offset!");

// Function Engine.CameraComponent.SetOrthoWidth
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetOrthoWidth final
{
public:
	float                                         InOrthoWidth;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetOrthoWidth) == 0x000004, "Wrong alignment on CameraComponent_SetOrthoWidth");
static_assert(sizeof(CameraComponent_SetOrthoWidth) == 0x000004, "Wrong size on CameraComponent_SetOrthoWidth");
static_assert(offsetof(CameraComponent_SetOrthoWidth, InOrthoWidth) == 0x000000, "Member 'CameraComponent_SetOrthoWidth::InOrthoWidth' has a wrong offset!");

// Function Engine.CameraComponent.SetPostProcessBlendWeight
// 0x0004 (0x0004 - 0x0000)
struct CameraComponent_SetPostProcessBlendWeight final
{
public:
	float                                         InPostProcessBlendWeight;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetPostProcessBlendWeight) == 0x000004, "Wrong alignment on CameraComponent_SetPostProcessBlendWeight");
static_assert(sizeof(CameraComponent_SetPostProcessBlendWeight) == 0x000004, "Wrong size on CameraComponent_SetPostProcessBlendWeight");
static_assert(offsetof(CameraComponent_SetPostProcessBlendWeight, InPostProcessBlendWeight) == 0x000000, "Member 'CameraComponent_SetPostProcessBlendWeight::InPostProcessBlendWeight' has a wrong offset!");

// Function Engine.CameraComponent.SetProjectionMode
// 0x0001 (0x0001 - 0x0000)
struct CameraComponent_SetProjectionMode final
{
public:
	ECameraProjectionMode                         InProjectionMode;                                  // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetProjectionMode) == 0x000001, "Wrong alignment on CameraComponent_SetProjectionMode");
static_assert(sizeof(CameraComponent_SetProjectionMode) == 0x000001, "Wrong size on CameraComponent_SetProjectionMode");
static_assert(offsetof(CameraComponent_SetProjectionMode, InProjectionMode) == 0x000000, "Member 'CameraComponent_SetProjectionMode::InProjectionMode' has a wrong offset!");

// Function Engine.CameraComponent.SetUseFieldOfViewForLOD
// 0x0001 (0x0001 - 0x0000)
struct CameraComponent_SetUseFieldOfViewForLOD final
{
public:
	bool                                          bInUseFieldOfViewForLOD;                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraComponent_SetUseFieldOfViewForLOD) == 0x000001, "Wrong alignment on CameraComponent_SetUseFieldOfViewForLOD");
static_assert(sizeof(CameraComponent_SetUseFieldOfViewForLOD) == 0x000001, "Wrong size on CameraComponent_SetUseFieldOfViewForLOD");
static_assert(offsetof(CameraComponent_SetUseFieldOfViewForLOD, bInUseFieldOfViewForLOD) == 0x000000, "Member 'CameraComponent_SetUseFieldOfViewForLOD::bInUseFieldOfViewForLOD' has a wrong offset!");

// Function Engine.PlayerCameraManager.AddCameraLensEffect
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_AddCameraLensEffect final
{
public:
	TSubclassOf<class AEmitterCameraLensEffectBase> LensEffectEmitterClass;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEmitterCameraLensEffectBase*           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_AddCameraLensEffect) == 0x000008, "Wrong alignment on PlayerCameraManager_AddCameraLensEffect");
static_assert(sizeof(PlayerCameraManager_AddCameraLensEffect) == 0x000010, "Wrong size on PlayerCameraManager_AddCameraLensEffect");
static_assert(offsetof(PlayerCameraManager_AddCameraLensEffect, LensEffectEmitterClass) == 0x000000, "Member 'PlayerCameraManager_AddCameraLensEffect::LensEffectEmitterClass' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_AddCameraLensEffect, ReturnValue) == 0x000008, "Member 'PlayerCameraManager_AddCameraLensEffect::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.AddNewCameraModifier
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_AddNewCameraModifier final
{
public:
	TSubclassOf<class UCameraModifier>            ModifierClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraModifier*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_AddNewCameraModifier) == 0x000008, "Wrong alignment on PlayerCameraManager_AddNewCameraModifier");
static_assert(sizeof(PlayerCameraManager_AddNewCameraModifier) == 0x000010, "Wrong size on PlayerCameraManager_AddNewCameraModifier");
static_assert(offsetof(PlayerCameraManager_AddNewCameraModifier, ModifierClass) == 0x000000, "Member 'PlayerCameraManager_AddNewCameraModifier::ModifierClass' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_AddNewCameraModifier, ReturnValue) == 0x000008, "Member 'PlayerCameraManager_AddNewCameraModifier::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.BlueprintUpdateCamera
// 0x0028 (0x0028 - 0x0000)
struct PlayerCameraManager_BlueprintUpdateCamera final
{
public:
	class AActor*                                 CameraTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewCameraLocation;                                 // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewCameraRotation;                                 // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NewCameraFOV;                                      // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0024(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_BlueprintUpdateCamera) == 0x000008, "Wrong alignment on PlayerCameraManager_BlueprintUpdateCamera");
static_assert(sizeof(PlayerCameraManager_BlueprintUpdateCamera) == 0x000028, "Wrong size on PlayerCameraManager_BlueprintUpdateCamera");
static_assert(offsetof(PlayerCameraManager_BlueprintUpdateCamera, CameraTarget) == 0x000000, "Member 'PlayerCameraManager_BlueprintUpdateCamera::CameraTarget' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_BlueprintUpdateCamera, NewCameraLocation) == 0x000008, "Member 'PlayerCameraManager_BlueprintUpdateCamera::NewCameraLocation' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_BlueprintUpdateCamera, NewCameraRotation) == 0x000014, "Member 'PlayerCameraManager_BlueprintUpdateCamera::NewCameraRotation' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_BlueprintUpdateCamera, NewCameraFOV) == 0x000020, "Member 'PlayerCameraManager_BlueprintUpdateCamera::NewCameraFOV' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_BlueprintUpdateCamera, ReturnValue) == 0x000024, "Member 'PlayerCameraManager_BlueprintUpdateCamera::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.FindCameraModifierByClass
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_FindCameraModifierByClass final
{
public:
	TSubclassOf<class UCameraModifier>            ModifierClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCameraModifier*                        ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_FindCameraModifierByClass) == 0x000008, "Wrong alignment on PlayerCameraManager_FindCameraModifierByClass");
static_assert(sizeof(PlayerCameraManager_FindCameraModifierByClass) == 0x000010, "Wrong size on PlayerCameraManager_FindCameraModifierByClass");
static_assert(offsetof(PlayerCameraManager_FindCameraModifierByClass, ModifierClass) == 0x000000, "Member 'PlayerCameraManager_FindCameraModifierByClass::ModifierClass' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_FindCameraModifierByClass, ReturnValue) == 0x000008, "Member 'PlayerCameraManager_FindCameraModifierByClass::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.PhotographyCameraModify
// 0x0030 (0x0030 - 0x0000)
struct PlayerCameraManager_PhotographyCameraModify final
{
public:
	struct FVector                                NewCameraLocation;                                 // 0x0000(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousCameraLocation;                            // 0x000C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OriginalCameraLocation;                            // 0x0018(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ResultCameraLocation;                              // 0x0024(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_PhotographyCameraModify) == 0x000004, "Wrong alignment on PlayerCameraManager_PhotographyCameraModify");
static_assert(sizeof(PlayerCameraManager_PhotographyCameraModify) == 0x000030, "Wrong size on PlayerCameraManager_PhotographyCameraModify");
static_assert(offsetof(PlayerCameraManager_PhotographyCameraModify, NewCameraLocation) == 0x000000, "Member 'PlayerCameraManager_PhotographyCameraModify::NewCameraLocation' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PhotographyCameraModify, PreviousCameraLocation) == 0x00000C, "Member 'PlayerCameraManager_PhotographyCameraModify::PreviousCameraLocation' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PhotographyCameraModify, OriginalCameraLocation) == 0x000018, "Member 'PlayerCameraManager_PhotographyCameraModify::OriginalCameraLocation' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PhotographyCameraModify, ResultCameraLocation) == 0x000024, "Member 'PlayerCameraManager_PhotographyCameraModify::ResultCameraLocation' has a wrong offset!");

// Function Engine.PlayerCameraManager.PlayCameraAnim
// 0x0038 (0x0038 - 0x0000)
struct PlayerCameraManager_PlayCameraAnim final
{
public:
	class UCameraAnim*                            Anim;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rate;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendInTime;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BlendOutTime;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLoop;                                             // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandomStartTime;                                  // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Duration;                                          // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRot;                                  // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class UCameraAnimInst*                        ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_PlayCameraAnim) == 0x000008, "Wrong alignment on PlayerCameraManager_PlayCameraAnim");
static_assert(sizeof(PlayerCameraManager_PlayCameraAnim) == 0x000038, "Wrong size on PlayerCameraManager_PlayCameraAnim");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, Anim) == 0x000000, "Member 'PlayerCameraManager_PlayCameraAnim::Anim' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, Rate) == 0x000008, "Member 'PlayerCameraManager_PlayCameraAnim::Rate' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, Scale) == 0x00000C, "Member 'PlayerCameraManager_PlayCameraAnim::Scale' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, BlendInTime) == 0x000010, "Member 'PlayerCameraManager_PlayCameraAnim::BlendInTime' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, BlendOutTime) == 0x000014, "Member 'PlayerCameraManager_PlayCameraAnim::BlendOutTime' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, bLoop) == 0x000018, "Member 'PlayerCameraManager_PlayCameraAnim::bLoop' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, bRandomStartTime) == 0x000019, "Member 'PlayerCameraManager_PlayCameraAnim::bRandomStartTime' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, Duration) == 0x00001C, "Member 'PlayerCameraManager_PlayCameraAnim::Duration' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, PlaySpace) == 0x000020, "Member 'PlayerCameraManager_PlayCameraAnim::PlaySpace' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, UserPlaySpaceRot) == 0x000024, "Member 'PlayerCameraManager_PlayCameraAnim::UserPlaySpaceRot' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraAnim, ReturnValue) == 0x000030, "Member 'PlayerCameraManager_PlayCameraAnim::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.PlayCameraShake
// 0x0028 (0x0028 - 0x0000)
struct PlayerCameraManager_PlayCameraShake final
{
public:
	TSubclassOf<class UCameraShake>               ShakeClass;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECameraAnimPlaySpace                          PlaySpace;                                         // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               UserPlaySpaceRot;                                  // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCameraShake*                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_PlayCameraShake) == 0x000008, "Wrong alignment on PlayerCameraManager_PlayCameraShake");
static_assert(sizeof(PlayerCameraManager_PlayCameraShake) == 0x000028, "Wrong size on PlayerCameraManager_PlayCameraShake");
static_assert(offsetof(PlayerCameraManager_PlayCameraShake, ShakeClass) == 0x000000, "Member 'PlayerCameraManager_PlayCameraShake::ShakeClass' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraShake, Scale) == 0x000008, "Member 'PlayerCameraManager_PlayCameraShake::Scale' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraShake, PlaySpace) == 0x00000C, "Member 'PlayerCameraManager_PlayCameraShake::PlaySpace' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraShake, UserPlaySpaceRot) == 0x000010, "Member 'PlayerCameraManager_PlayCameraShake::UserPlaySpaceRot' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_PlayCameraShake, ReturnValue) == 0x000020, "Member 'PlayerCameraManager_PlayCameraShake::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.RemoveCameraLensEffect
// 0x0008 (0x0008 - 0x0000)
struct PlayerCameraManager_RemoveCameraLensEffect final
{
public:
	class AEmitterCameraLensEffectBase*           Emitter;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_RemoveCameraLensEffect) == 0x000008, "Wrong alignment on PlayerCameraManager_RemoveCameraLensEffect");
static_assert(sizeof(PlayerCameraManager_RemoveCameraLensEffect) == 0x000008, "Wrong size on PlayerCameraManager_RemoveCameraLensEffect");
static_assert(offsetof(PlayerCameraManager_RemoveCameraLensEffect, Emitter) == 0x000000, "Member 'PlayerCameraManager_RemoveCameraLensEffect::Emitter' has a wrong offset!");

// Function Engine.PlayerCameraManager.RemoveCameraModifier
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_RemoveCameraModifier final
{
public:
	class UCameraModifier*                        ModifierToRemove;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_RemoveCameraModifier) == 0x000008, "Wrong alignment on PlayerCameraManager_RemoveCameraModifier");
static_assert(sizeof(PlayerCameraManager_RemoveCameraModifier) == 0x000010, "Wrong size on PlayerCameraManager_RemoveCameraModifier");
static_assert(offsetof(PlayerCameraManager_RemoveCameraModifier, ModifierToRemove) == 0x000000, "Member 'PlayerCameraManager_RemoveCameraModifier::ModifierToRemove' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_RemoveCameraModifier, ReturnValue) == 0x000008, "Member 'PlayerCameraManager_RemoveCameraModifier::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.SetManualCameraFade
// 0x0018 (0x0018 - 0x0000)
struct PlayerCameraManager_SetManualCameraFade final
{
public:
	float                                         InFadeAmount;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x0004(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInFadeAudio;                                      // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_SetManualCameraFade) == 0x000004, "Wrong alignment on PlayerCameraManager_SetManualCameraFade");
static_assert(sizeof(PlayerCameraManager_SetManualCameraFade) == 0x000018, "Wrong size on PlayerCameraManager_SetManualCameraFade");
static_assert(offsetof(PlayerCameraManager_SetManualCameraFade, InFadeAmount) == 0x000000, "Member 'PlayerCameraManager_SetManualCameraFade::InFadeAmount' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_SetManualCameraFade, Color) == 0x000004, "Member 'PlayerCameraManager_SetManualCameraFade::Color' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_SetManualCameraFade, bInFadeAudio) == 0x000014, "Member 'PlayerCameraManager_SetManualCameraFade::bInFadeAudio' has a wrong offset!");

// Function Engine.PlayerCameraManager.StartCameraFade
// 0x0020 (0x0020 - 0x0000)
struct PlayerCameraManager_StartCameraFade final
{
public:
	float                                         FromAlpha;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ToAlpha;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Color;                                             // 0x000C(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldFadeAudio;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHoldWhenFinished;                                 // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_StartCameraFade) == 0x000004, "Wrong alignment on PlayerCameraManager_StartCameraFade");
static_assert(sizeof(PlayerCameraManager_StartCameraFade) == 0x000020, "Wrong size on PlayerCameraManager_StartCameraFade");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, FromAlpha) == 0x000000, "Member 'PlayerCameraManager_StartCameraFade::FromAlpha' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, ToAlpha) == 0x000004, "Member 'PlayerCameraManager_StartCameraFade::ToAlpha' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, Duration) == 0x000008, "Member 'PlayerCameraManager_StartCameraFade::Duration' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, Color) == 0x00000C, "Member 'PlayerCameraManager_StartCameraFade::Color' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, bShouldFadeAudio) == 0x00001C, "Member 'PlayerCameraManager_StartCameraFade::bShouldFadeAudio' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StartCameraFade, bHoldWhenFinished) == 0x00001D, "Member 'PlayerCameraManager_StartCameraFade::bHoldWhenFinished' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopAllCameraAnims
// 0x0001 (0x0001 - 0x0000)
struct PlayerCameraManager_StopAllCameraAnims final
{
public:
	bool                                          bImmediate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_StopAllCameraAnims) == 0x000001, "Wrong alignment on PlayerCameraManager_StopAllCameraAnims");
static_assert(sizeof(PlayerCameraManager_StopAllCameraAnims) == 0x000001, "Wrong size on PlayerCameraManager_StopAllCameraAnims");
static_assert(offsetof(PlayerCameraManager_StopAllCameraAnims, bImmediate) == 0x000000, "Member 'PlayerCameraManager_StopAllCameraAnims::bImmediate' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopAllCameraShakes
// 0x0001 (0x0001 - 0x0000)
struct PlayerCameraManager_StopAllCameraShakes final
{
public:
	bool                                          bImmediately;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_StopAllCameraShakes) == 0x000001, "Wrong alignment on PlayerCameraManager_StopAllCameraShakes");
static_assert(sizeof(PlayerCameraManager_StopAllCameraShakes) == 0x000001, "Wrong size on PlayerCameraManager_StopAllCameraShakes");
static_assert(offsetof(PlayerCameraManager_StopAllCameraShakes, bImmediately) == 0x000000, "Member 'PlayerCameraManager_StopAllCameraShakes::bImmediately' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraAnim
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_StopAllInstancesOfCameraAnim final
{
public:
	class UCameraAnim*                            Anim;                                              // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_StopAllInstancesOfCameraAnim) == 0x000008, "Wrong alignment on PlayerCameraManager_StopAllInstancesOfCameraAnim");
static_assert(sizeof(PlayerCameraManager_StopAllInstancesOfCameraAnim) == 0x000010, "Wrong size on PlayerCameraManager_StopAllInstancesOfCameraAnim");
static_assert(offsetof(PlayerCameraManager_StopAllInstancesOfCameraAnim, Anim) == 0x000000, "Member 'PlayerCameraManager_StopAllInstancesOfCameraAnim::Anim' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StopAllInstancesOfCameraAnim, bImmediate) == 0x000008, "Member 'PlayerCameraManager_StopAllInstancesOfCameraAnim::bImmediate' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopAllInstancesOfCameraShake
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_StopAllInstancesOfCameraShake final
{
public:
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_StopAllInstancesOfCameraShake) == 0x000008, "Wrong alignment on PlayerCameraManager_StopAllInstancesOfCameraShake");
static_assert(sizeof(PlayerCameraManager_StopAllInstancesOfCameraShake) == 0x000010, "Wrong size on PlayerCameraManager_StopAllInstancesOfCameraShake");
static_assert(offsetof(PlayerCameraManager_StopAllInstancesOfCameraShake, Shake) == 0x000000, "Member 'PlayerCameraManager_StopAllInstancesOfCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StopAllInstancesOfCameraShake, bImmediately) == 0x000008, "Member 'PlayerCameraManager_StopAllInstancesOfCameraShake::bImmediately' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopCameraAnimInst
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_StopCameraAnimInst final
{
public:
	class UCameraAnimInst*                        AnimInst;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediate;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_StopCameraAnimInst) == 0x000008, "Wrong alignment on PlayerCameraManager_StopCameraAnimInst");
static_assert(sizeof(PlayerCameraManager_StopCameraAnimInst) == 0x000010, "Wrong size on PlayerCameraManager_StopCameraAnimInst");
static_assert(offsetof(PlayerCameraManager_StopCameraAnimInst, AnimInst) == 0x000000, "Member 'PlayerCameraManager_StopCameraAnimInst::AnimInst' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StopCameraAnimInst, bImmediate) == 0x000008, "Member 'PlayerCameraManager_StopCameraAnimInst::bImmediate' has a wrong offset!");

// Function Engine.PlayerCameraManager.StopCameraShake
// 0x0010 (0x0010 - 0x0000)
struct PlayerCameraManager_StopCameraShake final
{
public:
	class UCameraShake*                           ShakeInstance;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bImmediately;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PlayerCameraManager_StopCameraShake) == 0x000008, "Wrong alignment on PlayerCameraManager_StopCameraShake");
static_assert(sizeof(PlayerCameraManager_StopCameraShake) == 0x000010, "Wrong size on PlayerCameraManager_StopCameraShake");
static_assert(offsetof(PlayerCameraManager_StopCameraShake, ShakeInstance) == 0x000000, "Member 'PlayerCameraManager_StopCameraShake::ShakeInstance' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_StopCameraShake, bImmediately) == 0x000008, "Member 'PlayerCameraManager_StopCameraShake::bImmediately' has a wrong offset!");

// Function Engine.PlayerCameraManager.GetCameraLocation
// 0x000C (0x000C - 0x0000)
struct PlayerCameraManager_GetCameraLocation final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_GetCameraLocation) == 0x000004, "Wrong alignment on PlayerCameraManager_GetCameraLocation");
static_assert(sizeof(PlayerCameraManager_GetCameraLocation) == 0x00000C, "Wrong size on PlayerCameraManager_GetCameraLocation");
static_assert(offsetof(PlayerCameraManager_GetCameraLocation, ReturnValue) == 0x000000, "Member 'PlayerCameraManager_GetCameraLocation::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.GetCameraRotation
// 0x000C (0x000C - 0x0000)
struct PlayerCameraManager_GetCameraRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_GetCameraRotation) == 0x000004, "Wrong alignment on PlayerCameraManager_GetCameraRotation");
static_assert(sizeof(PlayerCameraManager_GetCameraRotation) == 0x00000C, "Wrong size on PlayerCameraManager_GetCameraRotation");
static_assert(offsetof(PlayerCameraManager_GetCameraRotation, ReturnValue) == 0x000000, "Member 'PlayerCameraManager_GetCameraRotation::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.GetCameraViewPoint
// 0x0018 (0x0018 - 0x0000)
struct PlayerCameraManager_GetCameraViewPoint final
{
public:
	struct FVector                                OutCamLoc;                                         // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutCamRot;                                         // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_GetCameraViewPoint) == 0x000004, "Wrong alignment on PlayerCameraManager_GetCameraViewPoint");
static_assert(sizeof(PlayerCameraManager_GetCameraViewPoint) == 0x000018, "Wrong size on PlayerCameraManager_GetCameraViewPoint");
static_assert(offsetof(PlayerCameraManager_GetCameraViewPoint, OutCamLoc) == 0x000000, "Member 'PlayerCameraManager_GetCameraViewPoint::OutCamLoc' has a wrong offset!");
static_assert(offsetof(PlayerCameraManager_GetCameraViewPoint, OutCamRot) == 0x00000C, "Member 'PlayerCameraManager_GetCameraViewPoint::OutCamRot' has a wrong offset!");

// Function Engine.PlayerCameraManager.GetFOVAngle
// 0x0004 (0x0004 - 0x0000)
struct PlayerCameraManager_GetFOVAngle final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_GetFOVAngle) == 0x000004, "Wrong alignment on PlayerCameraManager_GetFOVAngle");
static_assert(sizeof(PlayerCameraManager_GetFOVAngle) == 0x000004, "Wrong size on PlayerCameraManager_GetFOVAngle");
static_assert(offsetof(PlayerCameraManager_GetFOVAngle, ReturnValue) == 0x000000, "Member 'PlayerCameraManager_GetFOVAngle::ReturnValue' has a wrong offset!");

// Function Engine.PlayerCameraManager.GetOwningPlayerController
// 0x0008 (0x0008 - 0x0000)
struct PlayerCameraManager_GetOwningPlayerController final
{
public:
	class APlayerController*                      ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerCameraManager_GetOwningPlayerController) == 0x000008, "Wrong alignment on PlayerCameraManager_GetOwningPlayerController");
static_assert(sizeof(PlayerCameraManager_GetOwningPlayerController) == 0x000008, "Wrong size on PlayerCameraManager_GetOwningPlayerController");
static_assert(offsetof(PlayerCameraManager_GetOwningPlayerController, ReturnValue) == 0x000000, "Member 'PlayerCameraManager_GetOwningPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.PlayerInput.InvertAxis
// 0x0008 (0x0008 - 0x0000)
struct PlayerInput_InvertAxis final
{
public:
	class FName                                   AxisName;                                          // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInput_InvertAxis) == 0x000004, "Wrong alignment on PlayerInput_InvertAxis");
static_assert(sizeof(PlayerInput_InvertAxis) == 0x000008, "Wrong size on PlayerInput_InvertAxis");
static_assert(offsetof(PlayerInput_InvertAxis, AxisName) == 0x000000, "Member 'PlayerInput_InvertAxis::AxisName' has a wrong offset!");

// Function Engine.PlayerInput.InvertAxisKey
// 0x0018 (0x0018 - 0x0000)
struct PlayerInput_InvertAxisKey final
{
public:
	struct FKey                                   AxisKey;                                           // 0x0000(0x0018)(ConstParm, Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInput_InvertAxisKey) == 0x000008, "Wrong alignment on PlayerInput_InvertAxisKey");
static_assert(sizeof(PlayerInput_InvertAxisKey) == 0x000018, "Wrong size on PlayerInput_InvertAxisKey");
static_assert(offsetof(PlayerInput_InvertAxisKey, AxisKey) == 0x000000, "Member 'PlayerInput_InvertAxisKey::AxisKey' has a wrong offset!");

// Function Engine.PlayerInput.SetBind
// 0x0018 (0x0018 - 0x0000)
struct PlayerInput_SetBind final
{
public:
	class FName                                   BindName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInput_SetBind) == 0x000008, "Wrong alignment on PlayerInput_SetBind");
static_assert(sizeof(PlayerInput_SetBind) == 0x000018, "Wrong size on PlayerInput_SetBind");
static_assert(offsetof(PlayerInput_SetBind, BindName) == 0x000000, "Member 'PlayerInput_SetBind::BindName' has a wrong offset!");
static_assert(offsetof(PlayerInput_SetBind, Command) == 0x000008, "Member 'PlayerInput_SetBind::Command' has a wrong offset!");

// Function Engine.PlayerInput.SetMouseSensitivity
// 0x0004 (0x0004 - 0x0000)
struct PlayerInput_SetMouseSensitivity final
{
public:
	float                                         Sensitivity;                                       // 0x0000(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerInput_SetMouseSensitivity) == 0x000004, "Wrong alignment on PlayerInput_SetMouseSensitivity");
static_assert(sizeof(PlayerInput_SetMouseSensitivity) == 0x000004, "Wrong size on PlayerInput_SetMouseSensitivity");
static_assert(offsetof(PlayerInput_SetMouseSensitivity, Sensitivity) == 0x000000, "Member 'PlayerInput_SetMouseSensitivity::Sensitivity' has a wrong offset!");

// Function Engine.CullDistanceVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct CullDistanceVolume_SetEnabled final
{
public:
	bool                                          bNewEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CullDistanceVolume_SetEnabled) == 0x000001, "Wrong alignment on CullDistanceVolume_SetEnabled");
static_assert(sizeof(CullDistanceVolume_SetEnabled) == 0x000001, "Wrong size on CullDistanceVolume_SetEnabled");
static_assert(offsetof(CullDistanceVolume_SetEnabled, bNewEnabled) == 0x000000, "Member 'CullDistanceVolume_SetEnabled::bNewEnabled' has a wrong offset!");

// Function Engine.PlayerState.ReceiveCopyProperties
// 0x0008 (0x0008 - 0x0000)
struct PlayerState_ReceiveCopyProperties final
{
public:
	class APlayerState*                           NewPlayerState;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerState_ReceiveCopyProperties) == 0x000008, "Wrong alignment on PlayerState_ReceiveCopyProperties");
static_assert(sizeof(PlayerState_ReceiveCopyProperties) == 0x000008, "Wrong size on PlayerState_ReceiveCopyProperties");
static_assert(offsetof(PlayerState_ReceiveCopyProperties, NewPlayerState) == 0x000000, "Member 'PlayerState_ReceiveCopyProperties::NewPlayerState' has a wrong offset!");

// Function Engine.PlayerState.ReceiveOverrideWith
// 0x0008 (0x0008 - 0x0000)
struct PlayerState_ReceiveOverrideWith final
{
public:
	class APlayerState*                           OldPlayerState;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlayerState_ReceiveOverrideWith) == 0x000008, "Wrong alignment on PlayerState_ReceiveOverrideWith");
static_assert(sizeof(PlayerState_ReceiveOverrideWith) == 0x000008, "Wrong size on PlayerState_ReceiveOverrideWith");
static_assert(offsetof(PlayerState_ReceiveOverrideWith, OldPlayerState) == 0x000000, "Member 'PlayerState_ReceiveOverrideWith::OldPlayerState' has a wrong offset!");

// Function Engine.PostProcessVolume.AddOrUpdateBlendable
// 0x0018 (0x0018 - 0x0000)
struct PostProcessVolume_AddOrUpdateBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PostProcessVolume_AddOrUpdateBlendable) == 0x000008, "Wrong alignment on PostProcessVolume_AddOrUpdateBlendable");
static_assert(sizeof(PostProcessVolume_AddOrUpdateBlendable) == 0x000018, "Wrong size on PostProcessVolume_AddOrUpdateBlendable");
static_assert(offsetof(PostProcessVolume_AddOrUpdateBlendable, InBlendableObject) == 0x000000, "Member 'PostProcessVolume_AddOrUpdateBlendable::InBlendableObject' has a wrong offset!");
static_assert(offsetof(PostProcessVolume_AddOrUpdateBlendable, InWeight) == 0x000010, "Member 'PostProcessVolume_AddOrUpdateBlendable::InWeight' has a wrong offset!");

// Function Engine.PostProcessVolume.RemoveBlendable
// 0x0010 (0x0010 - 0x0000)
struct PostProcessVolume_RemoveBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(PostProcessVolume_RemoveBlendable) == 0x000008, "Wrong alignment on PostProcessVolume_RemoveBlendable");
static_assert(sizeof(PostProcessVolume_RemoveBlendable) == 0x000010, "Wrong size on PostProcessVolume_RemoveBlendable");
static_assert(offsetof(PostProcessVolume_RemoveBlendable, InBlendableObject) == 0x000000, "Member 'PostProcessVolume_RemoveBlendable::InBlendableObject' has a wrong offset!");

// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesLerpAlongAxis
// 0x0030 (0x0030 - 0x0000)
struct MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           StartColor;                                        // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           EndColor;                                          // 0x0018(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EVertexPaintAxis                              Axis;                                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConvertToSRGB;                                    // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis) == 0x000008, "Wrong alignment on MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis");
static_assert(sizeof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis) == 0x000030, "Wrong size on MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis, StaticMeshComponent) == 0x000000, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis, StartColor) == 0x000008, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis::StartColor' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis, EndColor) == 0x000018, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis::EndColor' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis, Axis) == 0x000028, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis::Axis' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis, bConvertToSRGB) == 0x000029, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesLerpAlongAxis::bConvertToSRGB' has a wrong offset!");

// Function Engine.MeshVertexPainterKismetLibrary.PaintVerticesSingleColor
// 0x0020 (0x0020 - 0x0000)
struct MeshVertexPainterKismetLibrary_PaintVerticesSingleColor final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           FillColor;                                         // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConvertToSRGB;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MeshVertexPainterKismetLibrary_PaintVerticesSingleColor) == 0x000008, "Wrong alignment on MeshVertexPainterKismetLibrary_PaintVerticesSingleColor");
static_assert(sizeof(MeshVertexPainterKismetLibrary_PaintVerticesSingleColor) == 0x000020, "Wrong size on MeshVertexPainterKismetLibrary_PaintVerticesSingleColor");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesSingleColor, StaticMeshComponent) == 0x000000, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesSingleColor::StaticMeshComponent' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesSingleColor, FillColor) == 0x000008, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesSingleColor::FillColor' has a wrong offset!");
static_assert(offsetof(MeshVertexPainterKismetLibrary_PaintVerticesSingleColor, bConvertToSRGB) == 0x000018, "Member 'MeshVertexPainterKismetLibrary_PaintVerticesSingleColor::bConvertToSRGB' has a wrong offset!");

// Function Engine.MeshVertexPainterKismetLibrary.RemovePaintedVertices
// 0x0008 (0x0008 - 0x0000)
struct MeshVertexPainterKismetLibrary_RemovePaintedVertices final
{
public:
	class UStaticMeshComponent*                   StaticMeshComponent;                               // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MeshVertexPainterKismetLibrary_RemovePaintedVertices) == 0x000008, "Wrong alignment on MeshVertexPainterKismetLibrary_RemovePaintedVertices");
static_assert(sizeof(MeshVertexPainterKismetLibrary_RemovePaintedVertices) == 0x000008, "Wrong size on MeshVertexPainterKismetLibrary_RemovePaintedVertices");
static_assert(offsetof(MeshVertexPainterKismetLibrary_RemovePaintedVertices, StaticMeshComponent) == 0x000000, "Member 'MeshVertexPainterKismetLibrary_RemovePaintedVertices::StaticMeshComponent' has a wrong offset!");

// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileBounceDelegate__DelegateSignature
// 0x0098 (0x0098 - 0x0000)
struct ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	struct FVector                                ImpactVelocity;                                    // 0x0088(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_94[0x4];                                       // 0x0094(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature) == 0x000008, "Wrong alignment on ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature");
static_assert(sizeof(ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature) == 0x000098, "Wrong size on ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature");
static_assert(offsetof(ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature, ImpactVelocity) == 0x000088, "Member 'ProjectileMovementComponent_OnProjectileBounceDelegate__DelegateSignature::ImpactVelocity' has a wrong offset!");

// DelegateFunction Engine.ProjectileMovementComponent.OnProjectileStopDelegate__DelegateSignature
// 0x0088 (0x0088 - 0x0000)
struct ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature) == 0x000008, "Wrong alignment on ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature");
static_assert(sizeof(ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature) == 0x000088, "Wrong size on ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature");
static_assert(offsetof(ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'ProjectileMovementComponent_OnProjectileStopDelegate__DelegateSignature::ImpactResult' has a wrong offset!");

// Function Engine.ProjectileMovementComponent.SetVelocityInLocalSpace
// 0x000C (0x000C - 0x0000)
struct ProjectileMovementComponent_SetVelocityInLocalSpace final
{
public:
	struct FVector                                NewVelocity;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileMovementComponent_SetVelocityInLocalSpace) == 0x000004, "Wrong alignment on ProjectileMovementComponent_SetVelocityInLocalSpace");
static_assert(sizeof(ProjectileMovementComponent_SetVelocityInLocalSpace) == 0x00000C, "Wrong size on ProjectileMovementComponent_SetVelocityInLocalSpace");
static_assert(offsetof(ProjectileMovementComponent_SetVelocityInLocalSpace, NewVelocity) == 0x000000, "Member 'ProjectileMovementComponent_SetVelocityInLocalSpace::NewVelocity' has a wrong offset!");

// Function Engine.ProjectileMovementComponent.StopSimulating
// 0x0088 (0x0088 - 0x0000)
struct ProjectileMovementComponent_StopSimulating final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileMovementComponent_StopSimulating) == 0x000008, "Wrong alignment on ProjectileMovementComponent_StopSimulating");
static_assert(sizeof(ProjectileMovementComponent_StopSimulating) == 0x000088, "Wrong size on ProjectileMovementComponent_StopSimulating");
static_assert(offsetof(ProjectileMovementComponent_StopSimulating, HitResult) == 0x000000, "Member 'ProjectileMovementComponent_StopSimulating::HitResult' has a wrong offset!");

// Function Engine.ProjectileMovementComponent.LimitVelocity
// 0x0018 (0x0018 - 0x0000)
struct ProjectileMovementComponent_LimitVelocity final
{
public:
	struct FVector                                NewVelocity;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ProjectileMovementComponent_LimitVelocity) == 0x000004, "Wrong alignment on ProjectileMovementComponent_LimitVelocity");
static_assert(sizeof(ProjectileMovementComponent_LimitVelocity) == 0x000018, "Wrong size on ProjectileMovementComponent_LimitVelocity");
static_assert(offsetof(ProjectileMovementComponent_LimitVelocity, NewVelocity) == 0x000000, "Member 'ProjectileMovementComponent_LimitVelocity::NewVelocity' has a wrong offset!");
static_assert(offsetof(ProjectileMovementComponent_LimitVelocity, ReturnValue) == 0x00000C, "Member 'ProjectileMovementComponent_LimitVelocity::ReturnValue' has a wrong offset!");

// Function Engine.SphereComponent.SetSphereRadius
// 0x0008 (0x0008 - 0x0000)
struct SphereComponent_SetSphereRadius final
{
public:
	float                                         InSphereRadius;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateOverlaps;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SphereComponent_SetSphereRadius) == 0x000004, "Wrong alignment on SphereComponent_SetSphereRadius");
static_assert(sizeof(SphereComponent_SetSphereRadius) == 0x000008, "Wrong size on SphereComponent_SetSphereRadius");
static_assert(offsetof(SphereComponent_SetSphereRadius, InSphereRadius) == 0x000000, "Member 'SphereComponent_SetSphereRadius::InSphereRadius' has a wrong offset!");
static_assert(offsetof(SphereComponent_SetSphereRadius, bUpdateOverlaps) == 0x000004, "Member 'SphereComponent_SetSphereRadius::bUpdateOverlaps' has a wrong offset!");

// Function Engine.SphereComponent.GetScaledSphereRadius
// 0x0004 (0x0004 - 0x0000)
struct SphereComponent_GetScaledSphereRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SphereComponent_GetScaledSphereRadius) == 0x000004, "Wrong alignment on SphereComponent_GetScaledSphereRadius");
static_assert(sizeof(SphereComponent_GetScaledSphereRadius) == 0x000004, "Wrong size on SphereComponent_GetScaledSphereRadius");
static_assert(offsetof(SphereComponent_GetScaledSphereRadius, ReturnValue) == 0x000000, "Member 'SphereComponent_GetScaledSphereRadius::ReturnValue' has a wrong offset!");

// Function Engine.SphereComponent.GetShapeScale
// 0x0004 (0x0004 - 0x0000)
struct SphereComponent_GetShapeScale final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SphereComponent_GetShapeScale) == 0x000004, "Wrong alignment on SphereComponent_GetShapeScale");
static_assert(sizeof(SphereComponent_GetShapeScale) == 0x000004, "Wrong size on SphereComponent_GetShapeScale");
static_assert(offsetof(SphereComponent_GetShapeScale, ReturnValue) == 0x000000, "Member 'SphereComponent_GetShapeScale::ReturnValue' has a wrong offset!");

// Function Engine.SphereComponent.GetUnscaledSphereRadius
// 0x0004 (0x0004 - 0x0000)
struct SphereComponent_GetUnscaledSphereRadius final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SphereComponent_GetUnscaledSphereRadius) == 0x000004, "Wrong alignment on SphereComponent_GetUnscaledSphereRadius");
static_assert(sizeof(SphereComponent_GetUnscaledSphereRadius) == 0x000004, "Wrong size on SphereComponent_GetUnscaledSphereRadius");
static_assert(offsetof(SphereComponent_GetUnscaledSphereRadius, ReturnValue) == 0x000000, "Member 'SphereComponent_GetUnscaledSphereRadius::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Add
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Add final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewItem;                                           // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Add) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Add");
static_assert(sizeof(KismetArrayLibrary_Array_Add) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Add");
static_assert(offsetof(KismetArrayLibrary_Array_Add, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Add::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Add, NewItem) == 0x000010, "Member 'KismetArrayLibrary_Array_Add::NewItem' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Add, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_Add::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_AddUnique
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_AddUnique final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewItem;                                           // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_AddUnique) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_AddUnique");
static_assert(sizeof(KismetArrayLibrary_Array_AddUnique) == 0x000018, "Wrong size on KismetArrayLibrary_Array_AddUnique");
static_assert(offsetof(KismetArrayLibrary_Array_AddUnique, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_AddUnique::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_AddUnique, NewItem) == 0x000010, "Member 'KismetArrayLibrary_Array_AddUnique::NewItem' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_AddUnique, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_AddUnique::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Append
// 0x0020 (0x0020 - 0x0000)
struct KismetArrayLibrary_Array_Append final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 SourceArray;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Append) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Append");
static_assert(sizeof(KismetArrayLibrary_Array_Append) == 0x000020, "Wrong size on KismetArrayLibrary_Array_Append");
static_assert(offsetof(KismetArrayLibrary_Array_Append, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Append::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Append, SourceArray) == 0x000010, "Member 'KismetArrayLibrary_Array_Append::SourceArray' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Clear
// 0x0010 (0x0010 - 0x0000)
struct KismetArrayLibrary_Array_Clear final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Clear) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Clear");
static_assert(sizeof(KismetArrayLibrary_Array_Clear) == 0x000010, "Wrong size on KismetArrayLibrary_Array_Clear");
static_assert(offsetof(KismetArrayLibrary_Array_Clear, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Clear::TargetArray' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Contains
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Contains final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ItemToFind;                                        // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_Contains) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Contains");
static_assert(sizeof(KismetArrayLibrary_Array_Contains) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Contains");
static_assert(offsetof(KismetArrayLibrary_Array_Contains, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Contains::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Contains, ItemToFind) == 0x000010, "Member 'KismetArrayLibrary_Array_Contains::ItemToFind' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Contains, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_Contains::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Find
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Find final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ItemToFind;                                        // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Find) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Find");
static_assert(sizeof(KismetArrayLibrary_Array_Find) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Find");
static_assert(offsetof(KismetArrayLibrary_Array_Find, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Find::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Find, ItemToFind) == 0x000010, "Member 'KismetArrayLibrary_Array_Find::ItemToFind' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Find, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_Find::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Get
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Get final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Get) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Get");
static_assert(sizeof(KismetArrayLibrary_Array_Get) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Get");
static_assert(offsetof(KismetArrayLibrary_Array_Get, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Get::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Get, Index_0) == 0x000010, "Member 'KismetArrayLibrary_Array_Get::Index_0' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Get, Item) == 0x000014, "Member 'KismetArrayLibrary_Array_Get::Item' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Insert
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Insert final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewItem;                                           // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Insert) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Insert");
static_assert(sizeof(KismetArrayLibrary_Array_Insert) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Insert");
static_assert(offsetof(KismetArrayLibrary_Array_Insert, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Insert::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Insert, NewItem) == 0x000010, "Member 'KismetArrayLibrary_Array_Insert::NewItem' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Insert, Index_0) == 0x000014, "Member 'KismetArrayLibrary_Array_Insert::Index_0' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_IsValidIndex
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_IsValidIndex final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexToTest;                                       // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_IsValidIndex) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_IsValidIndex");
static_assert(sizeof(KismetArrayLibrary_Array_IsValidIndex) == 0x000018, "Wrong size on KismetArrayLibrary_Array_IsValidIndex");
static_assert(offsetof(KismetArrayLibrary_Array_IsValidIndex, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_IsValidIndex::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_IsValidIndex, IndexToTest) == 0x000010, "Member 'KismetArrayLibrary_Array_IsValidIndex::IndexToTest' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_IsValidIndex, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_IsValidIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_LastIndex
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_LastIndex final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_LastIndex) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_LastIndex");
static_assert(sizeof(KismetArrayLibrary_Array_LastIndex) == 0x000018, "Wrong size on KismetArrayLibrary_Array_LastIndex");
static_assert(offsetof(KismetArrayLibrary_Array_LastIndex, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_LastIndex::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_LastIndex, ReturnValue) == 0x000010, "Member 'KismetArrayLibrary_Array_LastIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Length
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Length final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_Length) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Length");
static_assert(sizeof(KismetArrayLibrary_Array_Length) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Length");
static_assert(offsetof(KismetArrayLibrary_Array_Length, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Length::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Length, ReturnValue) == 0x000010, "Member 'KismetArrayLibrary_Array_Length::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Remove
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Remove final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         IndexToRemove;                                     // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_Remove) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Remove");
static_assert(sizeof(KismetArrayLibrary_Array_Remove) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Remove");
static_assert(offsetof(KismetArrayLibrary_Array_Remove, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Remove::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Remove, IndexToRemove) == 0x000010, "Member 'KismetArrayLibrary_Array_Remove::IndexToRemove' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_RemoveItem
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_RemoveItem final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0010(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_RemoveItem) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_RemoveItem");
static_assert(sizeof(KismetArrayLibrary_Array_RemoveItem) == 0x000018, "Wrong size on KismetArrayLibrary_Array_RemoveItem");
static_assert(offsetof(KismetArrayLibrary_Array_RemoveItem, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_RemoveItem::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_RemoveItem, Item) == 0x000010, "Member 'KismetArrayLibrary_Array_RemoveItem::Item' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_RemoveItem, ReturnValue) == 0x000014, "Member 'KismetArrayLibrary_Array_RemoveItem::ReturnValue' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Resize
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Resize final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Size;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_Resize) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Resize");
static_assert(sizeof(KismetArrayLibrary_Array_Resize) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Resize");
static_assert(offsetof(KismetArrayLibrary_Array_Resize, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Resize::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Resize, Size) == 0x000010, "Member 'KismetArrayLibrary_Array_Resize::Size' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Set
// 0x0020 (0x0020 - 0x0000)
struct KismetArrayLibrary_Array_Set final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0014(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSizeToFit;                                        // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetArrayLibrary_Array_Set) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Set");
static_assert(sizeof(KismetArrayLibrary_Array_Set) == 0x000020, "Wrong size on KismetArrayLibrary_Array_Set");
static_assert(offsetof(KismetArrayLibrary_Array_Set, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Set::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Set, Index_0) == 0x000010, "Member 'KismetArrayLibrary_Array_Set::Index_0' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Set, Item) == 0x000014, "Member 'KismetArrayLibrary_Array_Set::Item' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Set, bSizeToFit) == 0x000018, "Member 'KismetArrayLibrary_Array_Set::bSizeToFit' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Shuffle
// 0x0010 (0x0010 - 0x0000)
struct KismetArrayLibrary_Array_Shuffle final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Shuffle) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Shuffle");
static_assert(sizeof(KismetArrayLibrary_Array_Shuffle) == 0x000010, "Wrong size on KismetArrayLibrary_Array_Shuffle");
static_assert(offsetof(KismetArrayLibrary_Array_Shuffle, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Shuffle::TargetArray' has a wrong offset!");

// Function Engine.KismetArrayLibrary.Array_Swap
// 0x0018 (0x0018 - 0x0000)
struct KismetArrayLibrary_Array_Swap final
{
public:
	TArray<int32>                                 TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         FirstIndex;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SecondIndex;                                       // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_Array_Swap) == 0x000008, "Wrong alignment on KismetArrayLibrary_Array_Swap");
static_assert(sizeof(KismetArrayLibrary_Array_Swap) == 0x000018, "Wrong size on KismetArrayLibrary_Array_Swap");
static_assert(offsetof(KismetArrayLibrary_Array_Swap, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_Array_Swap::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Swap, FirstIndex) == 0x000010, "Member 'KismetArrayLibrary_Array_Swap::FirstIndex' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_Array_Swap, SecondIndex) == 0x000014, "Member 'KismetArrayLibrary_Array_Swap::SecondIndex' has a wrong offset!");

// Function Engine.KismetArrayLibrary.FilterArray
// 0x0028 (0x0028 - 0x0000)
struct KismetArrayLibrary_FilterArray final
{
public:
	TArray<class AActor*>                         TargetArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     FilterClass;                                       // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         FilteredArray;                                     // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_FilterArray) == 0x000008, "Wrong alignment on KismetArrayLibrary_FilterArray");
static_assert(sizeof(KismetArrayLibrary_FilterArray) == 0x000028, "Wrong size on KismetArrayLibrary_FilterArray");
static_assert(offsetof(KismetArrayLibrary_FilterArray, TargetArray) == 0x000000, "Member 'KismetArrayLibrary_FilterArray::TargetArray' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_FilterArray, FilterClass) == 0x000010, "Member 'KismetArrayLibrary_FilterArray::FilterClass' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_FilterArray, FilteredArray) == 0x000018, "Member 'KismetArrayLibrary_FilterArray::FilteredArray' has a wrong offset!");

// Function Engine.KismetArrayLibrary.SetArrayPropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetArrayLibrary_SetArrayPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 Value;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetArrayLibrary_SetArrayPropertyByName) == 0x000008, "Wrong alignment on KismetArrayLibrary_SetArrayPropertyByName");
static_assert(sizeof(KismetArrayLibrary_SetArrayPropertyByName) == 0x000020, "Wrong size on KismetArrayLibrary_SetArrayPropertyByName");
static_assert(offsetof(KismetArrayLibrary_SetArrayPropertyByName, Object) == 0x000000, "Member 'KismetArrayLibrary_SetArrayPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_SetArrayPropertyByName, PropertyName) == 0x000008, "Member 'KismetArrayLibrary_SetArrayPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetArrayLibrary_SetArrayPropertyByName, Value) == 0x000010, "Member 'KismetArrayLibrary_SetArrayPropertyByName::Value' has a wrong offset!");

// Function Engine.CameraModifier.BlueprintModifyCamera
// 0x003C (0x003C - 0x0000)
struct CameraModifier_BlueprintModifyCamera final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ViewLocation;                                      // 0x0004(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ViewRotation;                                      // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         FOV;                                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NewViewLocation;                                   // 0x0020(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewViewRotation;                                   // 0x002C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         NewFOV;                                            // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_BlueprintModifyCamera) == 0x000004, "Wrong alignment on CameraModifier_BlueprintModifyCamera");
static_assert(sizeof(CameraModifier_BlueprintModifyCamera) == 0x00003C, "Wrong size on CameraModifier_BlueprintModifyCamera");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, DeltaTime) == 0x000000, "Member 'CameraModifier_BlueprintModifyCamera::DeltaTime' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, ViewLocation) == 0x000004, "Member 'CameraModifier_BlueprintModifyCamera::ViewLocation' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, ViewRotation) == 0x000010, "Member 'CameraModifier_BlueprintModifyCamera::ViewRotation' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, FOV) == 0x00001C, "Member 'CameraModifier_BlueprintModifyCamera::FOV' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, NewViewLocation) == 0x000020, "Member 'CameraModifier_BlueprintModifyCamera::NewViewLocation' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, NewViewRotation) == 0x00002C, "Member 'CameraModifier_BlueprintModifyCamera::NewViewRotation' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyCamera, NewFOV) == 0x000038, "Member 'CameraModifier_BlueprintModifyCamera::NewFOV' has a wrong offset!");

// Function Engine.CameraModifier.BlueprintModifyPostProcess
// 0x0510 (0x0510 - 0x0000)
struct CameraModifier_BlueprintModifyPostProcess final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PostProcessBlendWeight;                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPostProcessSettings                   PostProcessSettings;                               // 0x0010(0x0500)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_BlueprintModifyPostProcess) == 0x000010, "Wrong alignment on CameraModifier_BlueprintModifyPostProcess");
static_assert(sizeof(CameraModifier_BlueprintModifyPostProcess) == 0x000510, "Wrong size on CameraModifier_BlueprintModifyPostProcess");
static_assert(offsetof(CameraModifier_BlueprintModifyPostProcess, DeltaTime) == 0x000000, "Member 'CameraModifier_BlueprintModifyPostProcess::DeltaTime' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyPostProcess, PostProcessBlendWeight) == 0x000004, "Member 'CameraModifier_BlueprintModifyPostProcess::PostProcessBlendWeight' has a wrong offset!");
static_assert(offsetof(CameraModifier_BlueprintModifyPostProcess, PostProcessSettings) == 0x000010, "Member 'CameraModifier_BlueprintModifyPostProcess::PostProcessSettings' has a wrong offset!");

// Function Engine.CameraModifier.DisableModifier
// 0x0001 (0x0001 - 0x0000)
struct CameraModifier_DisableModifier final
{
public:
	bool                                          bImmediate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_DisableModifier) == 0x000001, "Wrong alignment on CameraModifier_DisableModifier");
static_assert(sizeof(CameraModifier_DisableModifier) == 0x000001, "Wrong size on CameraModifier_DisableModifier");
static_assert(offsetof(CameraModifier_DisableModifier, bImmediate) == 0x000000, "Member 'CameraModifier_DisableModifier::bImmediate' has a wrong offset!");

// Function Engine.CameraModifier.GetViewTarget
// 0x0008 (0x0008 - 0x0000)
struct CameraModifier_GetViewTarget final
{
public:
	class AActor*                                 ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_GetViewTarget) == 0x000008, "Wrong alignment on CameraModifier_GetViewTarget");
static_assert(sizeof(CameraModifier_GetViewTarget) == 0x000008, "Wrong size on CameraModifier_GetViewTarget");
static_assert(offsetof(CameraModifier_GetViewTarget, ReturnValue) == 0x000000, "Member 'CameraModifier_GetViewTarget::ReturnValue' has a wrong offset!");

// Function Engine.CameraModifier.IsDisabled
// 0x0001 (0x0001 - 0x0000)
struct CameraModifier_IsDisabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraModifier_IsDisabled) == 0x000001, "Wrong alignment on CameraModifier_IsDisabled");
static_assert(sizeof(CameraModifier_IsDisabled) == 0x000001, "Wrong size on CameraModifier_IsDisabled");
static_assert(offsetof(CameraModifier_IsDisabled, ReturnValue) == 0x000000, "Member 'CameraModifier_IsDisabled::ReturnValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.OnRep_StaticMesh
// 0x0008 (0x0008 - 0x0000)
struct StaticMeshComponent_OnRep_StaticMesh final
{
public:
	class UStaticMesh*                            OldStaticMesh;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_OnRep_StaticMesh) == 0x000008, "Wrong alignment on StaticMeshComponent_OnRep_StaticMesh");
static_assert(sizeof(StaticMeshComponent_OnRep_StaticMesh) == 0x000008, "Wrong size on StaticMeshComponent_OnRep_StaticMesh");
static_assert(offsetof(StaticMeshComponent_OnRep_StaticMesh, OldStaticMesh) == 0x000000, "Member 'StaticMeshComponent_OnRep_StaticMesh::OldStaticMesh' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetDistanceFieldSelfShadowBias
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_SetDistanceFieldSelfShadowBias final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetDistanceFieldSelfShadowBias) == 0x000004, "Wrong alignment on StaticMeshComponent_SetDistanceFieldSelfShadowBias");
static_assert(sizeof(StaticMeshComponent_SetDistanceFieldSelfShadowBias) == 0x000004, "Wrong size on StaticMeshComponent_SetDistanceFieldSelfShadowBias");
static_assert(offsetof(StaticMeshComponent_SetDistanceFieldSelfShadowBias, NewValue) == 0x000000, "Member 'StaticMeshComponent_SetDistanceFieldSelfShadowBias::NewValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetForcedLodModel
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_SetForcedLodModel final
{
public:
	int32                                         NewForcedLodModel;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetForcedLodModel) == 0x000004, "Wrong alignment on StaticMeshComponent_SetForcedLodModel");
static_assert(sizeof(StaticMeshComponent_SetForcedLodModel) == 0x000004, "Wrong size on StaticMeshComponent_SetForcedLodModel");
static_assert(offsetof(StaticMeshComponent_SetForcedLodModel, NewForcedLodModel) == 0x000000, "Member 'StaticMeshComponent_SetForcedLodModel::NewForcedLodModel' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetLightmassSettingsDiffuseBoost
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_SetLightmassSettingsDiffuseBoost final
{
public:
	float                                         DiffuseBoost;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetLightmassSettingsDiffuseBoost) == 0x000004, "Wrong alignment on StaticMeshComponent_SetLightmassSettingsDiffuseBoost");
static_assert(sizeof(StaticMeshComponent_SetLightmassSettingsDiffuseBoost) == 0x000004, "Wrong size on StaticMeshComponent_SetLightmassSettingsDiffuseBoost");
static_assert(offsetof(StaticMeshComponent_SetLightmassSettingsDiffuseBoost, DiffuseBoost) == 0x000000, "Member 'StaticMeshComponent_SetLightmassSettingsDiffuseBoost::DiffuseBoost' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetLightmassSettingsEmissiveBoost
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_SetLightmassSettingsEmissiveBoost final
{
public:
	float                                         EmissiveBoost;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetLightmassSettingsEmissiveBoost) == 0x000004, "Wrong alignment on StaticMeshComponent_SetLightmassSettingsEmissiveBoost");
static_assert(sizeof(StaticMeshComponent_SetLightmassSettingsEmissiveBoost) == 0x000004, "Wrong size on StaticMeshComponent_SetLightmassSettingsEmissiveBoost");
static_assert(offsetof(StaticMeshComponent_SetLightmassSettingsEmissiveBoost, EmissiveBoost) == 0x000000, "Member 'StaticMeshComponent_SetLightmassSettingsEmissiveBoost::EmissiveBoost' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetLightmassSettingsShadowIndirectOnly
// 0x0001 (0x0001 - 0x0000)
struct StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly final
{
public:
	bool                                          bShadowIndirectOnly;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly) == 0x000001, "Wrong alignment on StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly");
static_assert(sizeof(StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly) == 0x000001, "Wrong size on StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly");
static_assert(offsetof(StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly, bShadowIndirectOnly) == 0x000000, "Member 'StaticMeshComponent_SetLightmassSettingsShadowIndirectOnly::bShadowIndirectOnly' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetLODDistanceScale
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_SetLODDistanceScale final
{
public:
	float                                         NewLODDistanceScale;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_SetLODDistanceScale) == 0x000004, "Wrong alignment on StaticMeshComponent_SetLODDistanceScale");
static_assert(sizeof(StaticMeshComponent_SetLODDistanceScale) == 0x000004, "Wrong size on StaticMeshComponent_SetLODDistanceScale");
static_assert(offsetof(StaticMeshComponent_SetLODDistanceScale, NewLODDistanceScale) == 0x000000, "Member 'StaticMeshComponent_SetLODDistanceScale::NewLODDistanceScale' has a wrong offset!");

// Function Engine.StaticMeshComponent.SetStaticMesh
// 0x0010 (0x0010 - 0x0000)
struct StaticMeshComponent_SetStaticMesh final
{
public:
	class UStaticMesh*                            NewMesh;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticMeshComponent_SetStaticMesh) == 0x000008, "Wrong alignment on StaticMeshComponent_SetStaticMesh");
static_assert(sizeof(StaticMeshComponent_SetStaticMesh) == 0x000010, "Wrong size on StaticMeshComponent_SetStaticMesh");
static_assert(offsetof(StaticMeshComponent_SetStaticMesh, NewMesh) == 0x000000, "Member 'StaticMeshComponent_SetStaticMesh::NewMesh' has a wrong offset!");
static_assert(offsetof(StaticMeshComponent_SetStaticMesh, ReturnValue) == 0x000008, "Member 'StaticMeshComponent_SetStaticMesh::ReturnValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.GetLightmassSettingsDiffuseBoost
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_GetLightmassSettingsDiffuseBoost final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_GetLightmassSettingsDiffuseBoost) == 0x000004, "Wrong alignment on StaticMeshComponent_GetLightmassSettingsDiffuseBoost");
static_assert(sizeof(StaticMeshComponent_GetLightmassSettingsDiffuseBoost) == 0x000004, "Wrong size on StaticMeshComponent_GetLightmassSettingsDiffuseBoost");
static_assert(offsetof(StaticMeshComponent_GetLightmassSettingsDiffuseBoost, ReturnValue) == 0x000000, "Member 'StaticMeshComponent_GetLightmassSettingsDiffuseBoost::ReturnValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.GetLightmassSettingsEmissiveBoost
// 0x0004 (0x0004 - 0x0000)
struct StaticMeshComponent_GetLightmassSettingsEmissiveBoost final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_GetLightmassSettingsEmissiveBoost) == 0x000004, "Wrong alignment on StaticMeshComponent_GetLightmassSettingsEmissiveBoost");
static_assert(sizeof(StaticMeshComponent_GetLightmassSettingsEmissiveBoost) == 0x000004, "Wrong size on StaticMeshComponent_GetLightmassSettingsEmissiveBoost");
static_assert(offsetof(StaticMeshComponent_GetLightmassSettingsEmissiveBoost, ReturnValue) == 0x000000, "Member 'StaticMeshComponent_GetLightmassSettingsEmissiveBoost::ReturnValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.GetLightmassSettingsShadowIndirectOnly
// 0x0001 (0x0001 - 0x0000)
struct StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly) == 0x000001, "Wrong alignment on StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly");
static_assert(sizeof(StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly) == 0x000001, "Wrong size on StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly");
static_assert(offsetof(StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly, ReturnValue) == 0x000000, "Member 'StaticMeshComponent_GetLightmassSettingsShadowIndirectOnly::ReturnValue' has a wrong offset!");

// Function Engine.StaticMeshComponent.GetLocalBounds
// 0x0018 (0x0018 - 0x0000)
struct StaticMeshComponent_GetLocalBounds final
{
public:
	struct FVector                                Min;                                               // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMeshComponent_GetLocalBounds) == 0x000004, "Wrong alignment on StaticMeshComponent_GetLocalBounds");
static_assert(sizeof(StaticMeshComponent_GetLocalBounds) == 0x000018, "Wrong size on StaticMeshComponent_GetLocalBounds");
static_assert(offsetof(StaticMeshComponent_GetLocalBounds, Min) == 0x000000, "Member 'StaticMeshComponent_GetLocalBounds::Min' has a wrong offset!");
static_assert(offsetof(StaticMeshComponent_GetLocalBounds, Max) == 0x00000C, "Member 'StaticMeshComponent_GetLocalBounds::Max' has a wrong offset!");

// Function Engine.SceneCaptureComponent.AddOffscreenRenderActorComponents
// 0x0018 (0x0018 - 0x0000)
struct SceneCaptureComponent_AddOffscreenRenderActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_AddOffscreenRenderActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_AddOffscreenRenderActorComponents");
static_assert(sizeof(SceneCaptureComponent_AddOffscreenRenderActorComponents) == 0x000018, "Wrong size on SceneCaptureComponent_AddOffscreenRenderActorComponents");
static_assert(offsetof(SceneCaptureComponent_AddOffscreenRenderActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_AddOffscreenRenderActorComponents::InActor' has a wrong offset!");
static_assert(offsetof(SceneCaptureComponent_AddOffscreenRenderActorComponents, ReturnValue) == 0x000008, "Member 'SceneCaptureComponent_AddOffscreenRenderActorComponents::ReturnValue' has a wrong offset!");

// Function Engine.SceneCaptureComponent.AddOffscreenRenderOnlyComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_AddOffscreenRenderOnlyComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_AddOffscreenRenderOnlyComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_AddOffscreenRenderOnlyComponent");
static_assert(sizeof(SceneCaptureComponent_AddOffscreenRenderOnlyComponent) == 0x000008, "Wrong size on SceneCaptureComponent_AddOffscreenRenderOnlyComponent");
static_assert(offsetof(SceneCaptureComponent_AddOffscreenRenderOnlyComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_AddOffscreenRenderOnlyComponent::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.ClearShowOnlyComponents
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_ClearShowOnlyComponents final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_ClearShowOnlyComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_ClearShowOnlyComponents");
static_assert(sizeof(SceneCaptureComponent_ClearShowOnlyComponents) == 0x000008, "Wrong size on SceneCaptureComponent_ClearShowOnlyComponents");
static_assert(offsetof(SceneCaptureComponent_ClearShowOnlyComponents, InComponent) == 0x000000, "Member 'SceneCaptureComponent_ClearShowOnlyComponents::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.HideActorComponents
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_HideActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_HideActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_HideActorComponents");
static_assert(sizeof(SceneCaptureComponent_HideActorComponents) == 0x000008, "Wrong size on SceneCaptureComponent_HideActorComponents");
static_assert(offsetof(SceneCaptureComponent_HideActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_HideActorComponents::InActor' has a wrong offset!");

// Function Engine.SceneCaptureComponent.HideComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_HideComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_HideComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_HideComponent");
static_assert(sizeof(SceneCaptureComponent_HideComponent) == 0x000008, "Wrong size on SceneCaptureComponent_HideComponent");
static_assert(offsetof(SceneCaptureComponent_HideComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_HideComponent::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveHideActorComponents
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_RemoveHideActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveHideActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveHideActorComponents");
static_assert(sizeof(SceneCaptureComponent_RemoveHideActorComponents) == 0x000008, "Wrong size on SceneCaptureComponent_RemoveHideActorComponents");
static_assert(offsetof(SceneCaptureComponent_RemoveHideActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_RemoveHideActorComponents::InActor' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveHideComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_RemoveHideComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveHideComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveHideComponent");
static_assert(sizeof(SceneCaptureComponent_RemoveHideComponent) == 0x000008, "Wrong size on SceneCaptureComponent_RemoveHideComponent");
static_assert(offsetof(SceneCaptureComponent_RemoveHideComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_RemoveHideComponent::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveOffscreenRenderActorComponents
// 0x0018 (0x0018 - 0x0000)
struct SceneCaptureComponent_RemoveOffscreenRenderActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            ReturnValue;                                       // 0x0008(0x0010)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveOffscreenRenderActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveOffscreenRenderActorComponents");
static_assert(sizeof(SceneCaptureComponent_RemoveOffscreenRenderActorComponents) == 0x000018, "Wrong size on SceneCaptureComponent_RemoveOffscreenRenderActorComponents");
static_assert(offsetof(SceneCaptureComponent_RemoveOffscreenRenderActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_RemoveOffscreenRenderActorComponents::InActor' has a wrong offset!");
static_assert(offsetof(SceneCaptureComponent_RemoveOffscreenRenderActorComponents, ReturnValue) == 0x000008, "Member 'SceneCaptureComponent_RemoveOffscreenRenderActorComponents::ReturnValue' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveOffscreenRenderOnlyComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent");
static_assert(sizeof(SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent) == 0x000008, "Wrong size on SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent");
static_assert(offsetof(SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_RemoveOffscreenRenderOnlyComponent::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveShowOnlyActorComponents
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_RemoveShowOnlyActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveShowOnlyActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveShowOnlyActorComponents");
static_assert(sizeof(SceneCaptureComponent_RemoveShowOnlyActorComponents) == 0x000008, "Wrong size on SceneCaptureComponent_RemoveShowOnlyActorComponents");
static_assert(offsetof(SceneCaptureComponent_RemoveShowOnlyActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_RemoveShowOnlyActorComponents::InActor' has a wrong offset!");

// Function Engine.SceneCaptureComponent.RemoveShowOnlyComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_RemoveShowOnlyComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_RemoveShowOnlyComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_RemoveShowOnlyComponent");
static_assert(sizeof(SceneCaptureComponent_RemoveShowOnlyComponent) == 0x000008, "Wrong size on SceneCaptureComponent_RemoveShowOnlyComponent");
static_assert(offsetof(SceneCaptureComponent_RemoveShowOnlyComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_RemoveShowOnlyComponent::InComponent' has a wrong offset!");

// Function Engine.SceneCaptureComponent.SetCaptureSortPriority
// 0x0004 (0x0004 - 0x0000)
struct SceneCaptureComponent_SetCaptureSortPriority final
{
public:
	int32                                         NewCaptureSortPriority;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_SetCaptureSortPriority) == 0x000004, "Wrong alignment on SceneCaptureComponent_SetCaptureSortPriority");
static_assert(sizeof(SceneCaptureComponent_SetCaptureSortPriority) == 0x000004, "Wrong size on SceneCaptureComponent_SetCaptureSortPriority");
static_assert(offsetof(SceneCaptureComponent_SetCaptureSortPriority, NewCaptureSortPriority) == 0x000000, "Member 'SceneCaptureComponent_SetCaptureSortPriority::NewCaptureSortPriority' has a wrong offset!");

// Function Engine.SceneCaptureComponent.ShowOnlyActorComponents
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_ShowOnlyActorComponents final
{
public:
	class AActor*                                 InActor;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_ShowOnlyActorComponents) == 0x000008, "Wrong alignment on SceneCaptureComponent_ShowOnlyActorComponents");
static_assert(sizeof(SceneCaptureComponent_ShowOnlyActorComponents) == 0x000008, "Wrong size on SceneCaptureComponent_ShowOnlyActorComponents");
static_assert(offsetof(SceneCaptureComponent_ShowOnlyActorComponents, InActor) == 0x000000, "Member 'SceneCaptureComponent_ShowOnlyActorComponents::InActor' has a wrong offset!");

// Function Engine.SceneCaptureComponent.ShowOnlyComponent
// 0x0008 (0x0008 - 0x0000)
struct SceneCaptureComponent_ShowOnlyComponent final
{
public:
	class UPrimitiveComponent*                    InComponent;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureComponent_ShowOnlyComponent) == 0x000008, "Wrong alignment on SceneCaptureComponent_ShowOnlyComponent");
static_assert(sizeof(SceneCaptureComponent_ShowOnlyComponent) == 0x000008, "Wrong size on SceneCaptureComponent_ShowOnlyComponent");
static_assert(offsetof(SceneCaptureComponent_ShowOnlyComponent, InComponent) == 0x000000, "Member 'SceneCaptureComponent_ShowOnlyComponent::InComponent' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.AddInstance
// 0x0040 (0x0040 - 0x0000)
struct InstancedStaticMeshComponent_AddInstance final
{
public:
	struct FTransform                             InstanceTransform;                                 // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InstancedStaticMeshComponent_AddInstance) == 0x000010, "Wrong alignment on InstancedStaticMeshComponent_AddInstance");
static_assert(sizeof(InstancedStaticMeshComponent_AddInstance) == 0x000040, "Wrong size on InstancedStaticMeshComponent_AddInstance");
static_assert(offsetof(InstancedStaticMeshComponent_AddInstance, InstanceTransform) == 0x000000, "Member 'InstancedStaticMeshComponent_AddInstance::InstanceTransform' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_AddInstance, ReturnValue) == 0x000030, "Member 'InstancedStaticMeshComponent_AddInstance::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.AddInstanceWorldSpace
// 0x0040 (0x0040 - 0x0000)
struct InstancedStaticMeshComponent_AddInstanceWorldSpace final
{
public:
	struct FTransform                             WorldTransform;                                    // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0xC];                                       // 0x0034(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InstancedStaticMeshComponent_AddInstanceWorldSpace) == 0x000010, "Wrong alignment on InstancedStaticMeshComponent_AddInstanceWorldSpace");
static_assert(sizeof(InstancedStaticMeshComponent_AddInstanceWorldSpace) == 0x000040, "Wrong size on InstancedStaticMeshComponent_AddInstanceWorldSpace");
static_assert(offsetof(InstancedStaticMeshComponent_AddInstanceWorldSpace, WorldTransform) == 0x000000, "Member 'InstancedStaticMeshComponent_AddInstanceWorldSpace::WorldTransform' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_AddInstanceWorldSpace, ReturnValue) == 0x000030, "Member 'InstancedStaticMeshComponent_AddInstanceWorldSpace::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.RemoveInstance
// 0x0008 (0x0008 - 0x0000)
struct InstancedStaticMeshComponent_RemoveInstance final
{
public:
	int32                                         InstanceIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InstancedStaticMeshComponent_RemoveInstance) == 0x000004, "Wrong alignment on InstancedStaticMeshComponent_RemoveInstance");
static_assert(sizeof(InstancedStaticMeshComponent_RemoveInstance) == 0x000008, "Wrong size on InstancedStaticMeshComponent_RemoveInstance");
static_assert(offsetof(InstancedStaticMeshComponent_RemoveInstance, InstanceIndex) == 0x000000, "Member 'InstancedStaticMeshComponent_RemoveInstance::InstanceIndex' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_RemoveInstance, ReturnValue) == 0x000004, "Member 'InstancedStaticMeshComponent_RemoveInstance::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.SetCullDistances
// 0x0008 (0x0008 - 0x0000)
struct InstancedStaticMeshComponent_SetCullDistances final
{
public:
	int32                                         StartCullDistance;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EndCullDistance;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InstancedStaticMeshComponent_SetCullDistances) == 0x000004, "Wrong alignment on InstancedStaticMeshComponent_SetCullDistances");
static_assert(sizeof(InstancedStaticMeshComponent_SetCullDistances) == 0x000008, "Wrong size on InstancedStaticMeshComponent_SetCullDistances");
static_assert(offsetof(InstancedStaticMeshComponent_SetCullDistances, StartCullDistance) == 0x000000, "Member 'InstancedStaticMeshComponent_SetCullDistances::StartCullDistance' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_SetCullDistances, EndCullDistance) == 0x000004, "Member 'InstancedStaticMeshComponent_SetCullDistances::EndCullDistance' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.UpdateInstanceTransform
// 0x0050 (0x0050 - 0x0000)
struct InstancedStaticMeshComponent_UpdateInstanceTransform final
{
public:
	int32                                         InstanceIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             NewInstanceTransform;                              // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWorldSpace;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMarkRenderStateDirty;                             // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTeleport;                                         // 0x0042(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0043(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InstancedStaticMeshComponent_UpdateInstanceTransform) == 0x000010, "Wrong alignment on InstancedStaticMeshComponent_UpdateInstanceTransform");
static_assert(sizeof(InstancedStaticMeshComponent_UpdateInstanceTransform) == 0x000050, "Wrong size on InstancedStaticMeshComponent_UpdateInstanceTransform");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, InstanceIndex) == 0x000000, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::InstanceIndex' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, NewInstanceTransform) == 0x000010, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::NewInstanceTransform' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, bWorldSpace) == 0x000040, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::bWorldSpace' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, bMarkRenderStateDirty) == 0x000041, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::bMarkRenderStateDirty' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, bTeleport) == 0x000042, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::bTeleport' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_UpdateInstanceTransform, ReturnValue) == 0x000043, "Member 'InstancedStaticMeshComponent_UpdateInstanceTransform::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.GetInstanceCount
// 0x0004 (0x0004 - 0x0000)
struct InstancedStaticMeshComponent_GetInstanceCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InstancedStaticMeshComponent_GetInstanceCount) == 0x000004, "Wrong alignment on InstancedStaticMeshComponent_GetInstanceCount");
static_assert(sizeof(InstancedStaticMeshComponent_GetInstanceCount) == 0x000004, "Wrong size on InstancedStaticMeshComponent_GetInstanceCount");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstanceCount, ReturnValue) == 0x000000, "Member 'InstancedStaticMeshComponent_GetInstanceCount::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingBox
// 0x0030 (0x0030 - 0x0000)
struct InstancedStaticMeshComponent_GetInstancesOverlappingBox final
{
public:
	struct FBox                                   Box;                                               // 0x0000(0x001C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bBoxInWorldSpace;                                  // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InstancedStaticMeshComponent_GetInstancesOverlappingBox) == 0x000008, "Wrong alignment on InstancedStaticMeshComponent_GetInstancesOverlappingBox");
static_assert(sizeof(InstancedStaticMeshComponent_GetInstancesOverlappingBox) == 0x000030, "Wrong size on InstancedStaticMeshComponent_GetInstancesOverlappingBox");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingBox, Box) == 0x000000, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingBox::Box' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingBox, bBoxInWorldSpace) == 0x00001C, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingBox::bBoxInWorldSpace' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingBox, ReturnValue) == 0x000020, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingBox::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.GetInstancesOverlappingSphere
// 0x0028 (0x0028 - 0x0000)
struct InstancedStaticMeshComponent_GetInstancesOverlappingSphere final
{
public:
	struct FVector                                Center;                                            // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSphereInWorldSpace;                               // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere) == 0x000008, "Wrong alignment on InstancedStaticMeshComponent_GetInstancesOverlappingSphere");
static_assert(sizeof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere) == 0x000028, "Wrong size on InstancedStaticMeshComponent_GetInstancesOverlappingSphere");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere, Center) == 0x000000, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingSphere::Center' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere, Radius) == 0x00000C, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingSphere::Radius' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere, bSphereInWorldSpace) == 0x000010, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingSphere::bSphereInWorldSpace' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstancesOverlappingSphere, ReturnValue) == 0x000018, "Member 'InstancedStaticMeshComponent_GetInstancesOverlappingSphere::ReturnValue' has a wrong offset!");

// Function Engine.InstancedStaticMeshComponent.GetInstanceTransform
// 0x0050 (0x0050 - 0x0000)
struct InstancedStaticMeshComponent_GetInstanceTransform final
{
public:
	int32                                         InstanceIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0xC];                                        // 0x0004(0x000C)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             OutInstanceTransform;                              // 0x0010(0x0030)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bWorldSpace;                                       // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0041(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_42[0xE];                                       // 0x0042(0x000E)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InstancedStaticMeshComponent_GetInstanceTransform) == 0x000010, "Wrong alignment on InstancedStaticMeshComponent_GetInstanceTransform");
static_assert(sizeof(InstancedStaticMeshComponent_GetInstanceTransform) == 0x000050, "Wrong size on InstancedStaticMeshComponent_GetInstanceTransform");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstanceTransform, InstanceIndex) == 0x000000, "Member 'InstancedStaticMeshComponent_GetInstanceTransform::InstanceIndex' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstanceTransform, OutInstanceTransform) == 0x000010, "Member 'InstancedStaticMeshComponent_GetInstanceTransform::OutInstanceTransform' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstanceTransform, bWorldSpace) == 0x000040, "Member 'InstancedStaticMeshComponent_GetInstanceTransform::bWorldSpace' has a wrong offset!");
static_assert(offsetof(InstancedStaticMeshComponent_GetInstanceTransform, ReturnValue) == 0x000041, "Member 'InstancedStaticMeshComponent_GetInstanceTransform::ReturnValue' has a wrong offset!");

// Function Engine.HierarchicalInstancedStaticMeshComponent.RemoveInstances
// 0x0018 (0x0018 - 0x0000)
struct HierarchicalInstancedStaticMeshComponent_RemoveInstances final
{
public:
	TArray<int32>                                 InstancesToRemove;                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(HierarchicalInstancedStaticMeshComponent_RemoveInstances) == 0x000008, "Wrong alignment on HierarchicalInstancedStaticMeshComponent_RemoveInstances");
static_assert(sizeof(HierarchicalInstancedStaticMeshComponent_RemoveInstances) == 0x000018, "Wrong size on HierarchicalInstancedStaticMeshComponent_RemoveInstances");
static_assert(offsetof(HierarchicalInstancedStaticMeshComponent_RemoveInstances, InstancesToRemove) == 0x000000, "Member 'HierarchicalInstancedStaticMeshComponent_RemoveInstances::InstancesToRemove' has a wrong offset!");
static_assert(offsetof(HierarchicalInstancedStaticMeshComponent_RemoveInstances, ReturnValue) == 0x000010, "Member 'HierarchicalInstancedStaticMeshComponent_RemoveInstances::ReturnValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringColor
// 0x0010 (0x0010 - 0x0000)
struct ExponentialHeightFogComponent_SetDirectionalInscatteringColor final
{
public:
	struct FLinearColor                           Value;                                             // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetDirectionalInscatteringColor) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetDirectionalInscatteringColor");
static_assert(sizeof(ExponentialHeightFogComponent_SetDirectionalInscatteringColor) == 0x000010, "Wrong size on ExponentialHeightFogComponent_SetDirectionalInscatteringColor");
static_assert(offsetof(ExponentialHeightFogComponent_SetDirectionalInscatteringColor, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetDirectionalInscatteringColor::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringExponent
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetDirectionalInscatteringExponent final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetDirectionalInscatteringExponent) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetDirectionalInscatteringExponent");
static_assert(sizeof(ExponentialHeightFogComponent_SetDirectionalInscatteringExponent) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetDirectionalInscatteringExponent");
static_assert(offsetof(ExponentialHeightFogComponent_SetDirectionalInscatteringExponent, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetDirectionalInscatteringExponent::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetDirectionalInscatteringStartDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetDirectionalInscatteringStartDistance::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFogCutoffDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetFogCutoffDistance final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFogCutoffDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFogCutoffDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetFogCutoffDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetFogCutoffDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetFogCutoffDistance, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFogCutoffDistance::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFogDensity
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetFogDensity final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFogDensity) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFogDensity");
static_assert(sizeof(ExponentialHeightFogComponent_SetFogDensity) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetFogDensity");
static_assert(offsetof(ExponentialHeightFogComponent_SetFogDensity, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFogDensity::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFogHeightFalloff
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetFogHeightFalloff final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFogHeightFalloff) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFogHeightFalloff");
static_assert(sizeof(ExponentialHeightFogComponent_SetFogHeightFalloff) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetFogHeightFalloff");
static_assert(offsetof(ExponentialHeightFogComponent_SetFogHeightFalloff, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFogHeightFalloff::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFogInscatteringColor
// 0x0010 (0x0010 - 0x0000)
struct ExponentialHeightFogComponent_SetFogInscatteringColor final
{
public:
	struct FLinearColor                           Value;                                             // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFogInscatteringColor) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFogInscatteringColor");
static_assert(sizeof(ExponentialHeightFogComponent_SetFogInscatteringColor) == 0x000010, "Wrong size on ExponentialHeightFogComponent_SetFogInscatteringColor");
static_assert(offsetof(ExponentialHeightFogComponent_SetFogInscatteringColor, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFogInscatteringColor::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFogMaxOpacity
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetFogMaxOpacity final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFogMaxOpacity) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFogMaxOpacity");
static_assert(sizeof(ExponentialHeightFogComponent_SetFogMaxOpacity) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetFogMaxOpacity");
static_assert(offsetof(ExponentialHeightFogComponent_SetFogMaxOpacity, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFogMaxOpacity::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetFullyDirectionalInscatteringColorDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetFullyDirectionalInscatteringColorDistance::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemap
// 0x0008 (0x0008 - 0x0000)
struct ExponentialHeightFogComponent_SetInscatteringColorCubemap final
{
public:
	class UTextureCube*                           Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetInscatteringColorCubemap) == 0x000008, "Wrong alignment on ExponentialHeightFogComponent_SetInscatteringColorCubemap");
static_assert(sizeof(ExponentialHeightFogComponent_SetInscatteringColorCubemap) == 0x000008, "Wrong size on ExponentialHeightFogComponent_SetInscatteringColorCubemap");
static_assert(offsetof(ExponentialHeightFogComponent_SetInscatteringColorCubemap, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetInscatteringColorCubemap::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetInscatteringColorCubemapAngle
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle");
static_assert(sizeof(ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle");
static_assert(offsetof(ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetInscatteringColorCubemapAngle::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetInscatteringTextureTint
// 0x0010 (0x0010 - 0x0000)
struct ExponentialHeightFogComponent_SetInscatteringTextureTint final
{
public:
	struct FLinearColor                           Value;                                             // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetInscatteringTextureTint) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetInscatteringTextureTint");
static_assert(sizeof(ExponentialHeightFogComponent_SetInscatteringTextureTint) == 0x000010, "Wrong size on ExponentialHeightFogComponent_SetInscatteringTextureTint");
static_assert(offsetof(ExponentialHeightFogComponent_SetInscatteringTextureTint, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetInscatteringTextureTint::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetNonDirectionalInscatteringColorDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetNonDirectionalInscatteringColorDistance::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetStartDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetStartDistance final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetStartDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetStartDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetStartDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetStartDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetStartDistance, Value) == 0x000000, "Member 'ExponentialHeightFogComponent_SetStartDistance::Value' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFog
// 0x0001 (0x0001 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFog final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFog) == 0x000001, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFog");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFog) == 0x000001, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFog");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFog, bNewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFog::bNewValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogAlbedo
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFogAlbedo final
{
public:
	struct FColor                                 NewValue;                                          // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFogAlbedo) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFogAlbedo");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFogAlbedo) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFogAlbedo");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFogAlbedo, NewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFogAlbedo::NewValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogDistance
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFogDistance final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFogDistance) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFogDistance");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFogDistance) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFogDistance");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFogDistance, NewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFogDistance::NewValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogEmissive
// 0x0010 (0x0010 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFogEmissive final
{
public:
	struct FLinearColor                           NewValue;                                          // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFogEmissive) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFogEmissive");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFogEmissive) == 0x000010, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFogEmissive");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFogEmissive, NewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFogEmissive::NewValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogExtinctionScale
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale, NewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFogExtinctionScale::NewValue' has a wrong offset!");

// Function Engine.ExponentialHeightFogComponent.SetVolumetricFogScatteringDistribution
// 0x0004 (0x0004 - 0x0000)
struct ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution) == 0x000004, "Wrong alignment on ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution");
static_assert(sizeof(ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution) == 0x000004, "Wrong size on ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution");
static_assert(offsetof(ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution, NewValue) == 0x000000, "Member 'ExponentialHeightFogComponent_SetVolumetricFogScatteringDistribution::NewValue' has a wrong offset!");

// Function Engine.PhysicsSpringComponent.GetNormalizedCompressionScalar
// 0x0004 (0x0004 - 0x0000)
struct PhysicsSpringComponent_GetNormalizedCompressionScalar final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsSpringComponent_GetNormalizedCompressionScalar) == 0x000004, "Wrong alignment on PhysicsSpringComponent_GetNormalizedCompressionScalar");
static_assert(sizeof(PhysicsSpringComponent_GetNormalizedCompressionScalar) == 0x000004, "Wrong size on PhysicsSpringComponent_GetNormalizedCompressionScalar");
static_assert(offsetof(PhysicsSpringComponent_GetNormalizedCompressionScalar, ReturnValue) == 0x000000, "Member 'PhysicsSpringComponent_GetNormalizedCompressionScalar::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsSpringComponent.GetSpringCurrentEndPoint
// 0x000C (0x000C - 0x0000)
struct PhysicsSpringComponent_GetSpringCurrentEndPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsSpringComponent_GetSpringCurrentEndPoint) == 0x000004, "Wrong alignment on PhysicsSpringComponent_GetSpringCurrentEndPoint");
static_assert(sizeof(PhysicsSpringComponent_GetSpringCurrentEndPoint) == 0x00000C, "Wrong size on PhysicsSpringComponent_GetSpringCurrentEndPoint");
static_assert(offsetof(PhysicsSpringComponent_GetSpringCurrentEndPoint, ReturnValue) == 0x000000, "Member 'PhysicsSpringComponent_GetSpringCurrentEndPoint::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsSpringComponent.GetSpringDirection
// 0x000C (0x000C - 0x0000)
struct PhysicsSpringComponent_GetSpringDirection final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsSpringComponent_GetSpringDirection) == 0x000004, "Wrong alignment on PhysicsSpringComponent_GetSpringDirection");
static_assert(sizeof(PhysicsSpringComponent_GetSpringDirection) == 0x00000C, "Wrong size on PhysicsSpringComponent_GetSpringDirection");
static_assert(offsetof(PhysicsSpringComponent_GetSpringDirection, ReturnValue) == 0x000000, "Member 'PhysicsSpringComponent_GetSpringDirection::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsSpringComponent.GetSpringRestingPoint
// 0x000C (0x000C - 0x0000)
struct PhysicsSpringComponent_GetSpringRestingPoint final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsSpringComponent_GetSpringRestingPoint) == 0x000004, "Wrong alignment on PhysicsSpringComponent_GetSpringRestingPoint");
static_assert(sizeof(PhysicsSpringComponent_GetSpringRestingPoint) == 0x00000C, "Wrong size on PhysicsSpringComponent_GetSpringRestingPoint");
static_assert(offsetof(PhysicsSpringComponent_GetSpringRestingPoint, ReturnValue) == 0x000000, "Member 'PhysicsSpringComponent_GetSpringRestingPoint::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.GrabComponent
// 0x0020 (0x0020 - 0x0000)
struct PhysicsHandleComponent_GrabComponent final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrabLocation;                                      // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bConstrainRotation;                                // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhysicsHandleComponent_GrabComponent) == 0x000008, "Wrong alignment on PhysicsHandleComponent_GrabComponent");
static_assert(sizeof(PhysicsHandleComponent_GrabComponent) == 0x000020, "Wrong size on PhysicsHandleComponent_GrabComponent");
static_assert(offsetof(PhysicsHandleComponent_GrabComponent, Component) == 0x000000, "Member 'PhysicsHandleComponent_GrabComponent::Component' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponent, InBoneName) == 0x000008, "Member 'PhysicsHandleComponent_GrabComponent::InBoneName' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponent, GrabLocation) == 0x000010, "Member 'PhysicsHandleComponent_GrabComponent::GrabLocation' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponent, bConstrainRotation) == 0x00001C, "Member 'PhysicsHandleComponent_GrabComponent::bConstrainRotation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.GrabComponentAtLocation
// 0x0020 (0x0020 - 0x0000)
struct PhysicsHandleComponent_GrabComponentAtLocation final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                GrabLocation;                                      // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhysicsHandleComponent_GrabComponentAtLocation) == 0x000008, "Wrong alignment on PhysicsHandleComponent_GrabComponentAtLocation");
static_assert(sizeof(PhysicsHandleComponent_GrabComponentAtLocation) == 0x000020, "Wrong size on PhysicsHandleComponent_GrabComponentAtLocation");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocation, Component) == 0x000000, "Member 'PhysicsHandleComponent_GrabComponentAtLocation::Component' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocation, InBoneName) == 0x000008, "Member 'PhysicsHandleComponent_GrabComponentAtLocation::InBoneName' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocation, GrabLocation) == 0x000010, "Member 'PhysicsHandleComponent_GrabComponentAtLocation::GrabLocation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.GrabComponentAtLocationWithRotation
// 0x0028 (0x0028 - 0x0000)
struct PhysicsHandleComponent_GrabComponentAtLocationWithRotation final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InBoneName;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation) == 0x000008, "Wrong alignment on PhysicsHandleComponent_GrabComponentAtLocationWithRotation");
static_assert(sizeof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation) == 0x000028, "Wrong size on PhysicsHandleComponent_GrabComponentAtLocationWithRotation");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation, Component) == 0x000000, "Member 'PhysicsHandleComponent_GrabComponentAtLocationWithRotation::Component' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation, InBoneName) == 0x000008, "Member 'PhysicsHandleComponent_GrabComponentAtLocationWithRotation::InBoneName' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation, Location) == 0x000010, "Member 'PhysicsHandleComponent_GrabComponentAtLocationWithRotation::Location' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GrabComponentAtLocationWithRotation, Rotation) == 0x00001C, "Member 'PhysicsHandleComponent_GrabComponentAtLocationWithRotation::Rotation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetAngularDamping
// 0x0004 (0x0004 - 0x0000)
struct PhysicsHandleComponent_SetAngularDamping final
{
public:
	float                                         NewAngularDamping;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetAngularDamping) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetAngularDamping");
static_assert(sizeof(PhysicsHandleComponent_SetAngularDamping) == 0x000004, "Wrong size on PhysicsHandleComponent_SetAngularDamping");
static_assert(offsetof(PhysicsHandleComponent_SetAngularDamping, NewAngularDamping) == 0x000000, "Member 'PhysicsHandleComponent_SetAngularDamping::NewAngularDamping' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetAngularStiffness
// 0x0004 (0x0004 - 0x0000)
struct PhysicsHandleComponent_SetAngularStiffness final
{
public:
	float                                         NewAngularStiffness;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetAngularStiffness) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetAngularStiffness");
static_assert(sizeof(PhysicsHandleComponent_SetAngularStiffness) == 0x000004, "Wrong size on PhysicsHandleComponent_SetAngularStiffness");
static_assert(offsetof(PhysicsHandleComponent_SetAngularStiffness, NewAngularStiffness) == 0x000000, "Member 'PhysicsHandleComponent_SetAngularStiffness::NewAngularStiffness' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetInterpolationSpeed
// 0x0004 (0x0004 - 0x0000)
struct PhysicsHandleComponent_SetInterpolationSpeed final
{
public:
	float                                         NewInterpolationSpeed;                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetInterpolationSpeed) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetInterpolationSpeed");
static_assert(sizeof(PhysicsHandleComponent_SetInterpolationSpeed) == 0x000004, "Wrong size on PhysicsHandleComponent_SetInterpolationSpeed");
static_assert(offsetof(PhysicsHandleComponent_SetInterpolationSpeed, NewInterpolationSpeed) == 0x000000, "Member 'PhysicsHandleComponent_SetInterpolationSpeed::NewInterpolationSpeed' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetLinearDamping
// 0x0004 (0x0004 - 0x0000)
struct PhysicsHandleComponent_SetLinearDamping final
{
public:
	float                                         NewLinearDamping;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetLinearDamping) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetLinearDamping");
static_assert(sizeof(PhysicsHandleComponent_SetLinearDamping) == 0x000004, "Wrong size on PhysicsHandleComponent_SetLinearDamping");
static_assert(offsetof(PhysicsHandleComponent_SetLinearDamping, NewLinearDamping) == 0x000000, "Member 'PhysicsHandleComponent_SetLinearDamping::NewLinearDamping' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetLinearStiffness
// 0x0004 (0x0004 - 0x0000)
struct PhysicsHandleComponent_SetLinearStiffness final
{
public:
	float                                         NewLinearStiffness;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetLinearStiffness) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetLinearStiffness");
static_assert(sizeof(PhysicsHandleComponent_SetLinearStiffness) == 0x000004, "Wrong size on PhysicsHandleComponent_SetLinearStiffness");
static_assert(offsetof(PhysicsHandleComponent_SetLinearStiffness, NewLinearStiffness) == 0x000000, "Member 'PhysicsHandleComponent_SetLinearStiffness::NewLinearStiffness' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetTargetLocation
// 0x000C (0x000C - 0x0000)
struct PhysicsHandleComponent_SetTargetLocation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetTargetLocation) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetTargetLocation");
static_assert(sizeof(PhysicsHandleComponent_SetTargetLocation) == 0x00000C, "Wrong size on PhysicsHandleComponent_SetTargetLocation");
static_assert(offsetof(PhysicsHandleComponent_SetTargetLocation, NewLocation) == 0x000000, "Member 'PhysicsHandleComponent_SetTargetLocation::NewLocation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetTargetLocationAndRotation
// 0x0018 (0x0018 - 0x0000)
struct PhysicsHandleComponent_SetTargetLocationAndRotation final
{
public:
	struct FVector                                NewLocation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               NewRotation;                                       // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetTargetLocationAndRotation) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetTargetLocationAndRotation");
static_assert(sizeof(PhysicsHandleComponent_SetTargetLocationAndRotation) == 0x000018, "Wrong size on PhysicsHandleComponent_SetTargetLocationAndRotation");
static_assert(offsetof(PhysicsHandleComponent_SetTargetLocationAndRotation, NewLocation) == 0x000000, "Member 'PhysicsHandleComponent_SetTargetLocationAndRotation::NewLocation' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_SetTargetLocationAndRotation, NewRotation) == 0x00000C, "Member 'PhysicsHandleComponent_SetTargetLocationAndRotation::NewRotation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.SetTargetRotation
// 0x000C (0x000C - 0x0000)
struct PhysicsHandleComponent_SetTargetRotation final
{
public:
	struct FRotator                               NewRotation;                                       // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_SetTargetRotation) == 0x000004, "Wrong alignment on PhysicsHandleComponent_SetTargetRotation");
static_assert(sizeof(PhysicsHandleComponent_SetTargetRotation) == 0x00000C, "Wrong size on PhysicsHandleComponent_SetTargetRotation");
static_assert(offsetof(PhysicsHandleComponent_SetTargetRotation, NewRotation) == 0x000000, "Member 'PhysicsHandleComponent_SetTargetRotation::NewRotation' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.GetGrabbedComponent
// 0x0008 (0x0008 - 0x0000)
struct PhysicsHandleComponent_GetGrabbedComponent final
{
public:
	class UPrimitiveComponent*                    ReturnValue;                                       // 0x0000(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_GetGrabbedComponent) == 0x000008, "Wrong alignment on PhysicsHandleComponent_GetGrabbedComponent");
static_assert(sizeof(PhysicsHandleComponent_GetGrabbedComponent) == 0x000008, "Wrong size on PhysicsHandleComponent_GetGrabbedComponent");
static_assert(offsetof(PhysicsHandleComponent_GetGrabbedComponent, ReturnValue) == 0x000000, "Member 'PhysicsHandleComponent_GetGrabbedComponent::ReturnValue' has a wrong offset!");

// Function Engine.PhysicsHandleComponent.GetTargetLocationAndRotation
// 0x0018 (0x0018 - 0x0000)
struct PhysicsHandleComponent_GetTargetLocationAndRotation final
{
public:
	struct FVector                                TargetLocation;                                    // 0x0000(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRotation;                                    // 0x000C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicsHandleComponent_GetTargetLocationAndRotation) == 0x000004, "Wrong alignment on PhysicsHandleComponent_GetTargetLocationAndRotation");
static_assert(sizeof(PhysicsHandleComponent_GetTargetLocationAndRotation) == 0x000018, "Wrong size on PhysicsHandleComponent_GetTargetLocationAndRotation");
static_assert(offsetof(PhysicsHandleComponent_GetTargetLocationAndRotation, TargetLocation) == 0x000000, "Member 'PhysicsHandleComponent_GetTargetLocationAndRotation::TargetLocation' has a wrong offset!");
static_assert(offsetof(PhysicsHandleComponent_GetTargetLocationAndRotation, TargetRotation) == 0x00000C, "Member 'PhysicsHandleComponent_GetTargetLocationAndRotation::TargetRotation' has a wrong offset!");

// Function Engine.AmbientSound.AdjustVolume
// 0x0008 (0x0008 - 0x0000)
struct AmbientSound_AdjustVolume final
{
public:
	float                                         AdjustVolumeDuration;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustVolumeLevel;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AmbientSound_AdjustVolume) == 0x000004, "Wrong alignment on AmbientSound_AdjustVolume");
static_assert(sizeof(AmbientSound_AdjustVolume) == 0x000008, "Wrong size on AmbientSound_AdjustVolume");
static_assert(offsetof(AmbientSound_AdjustVolume, AdjustVolumeDuration) == 0x000000, "Member 'AmbientSound_AdjustVolume::AdjustVolumeDuration' has a wrong offset!");
static_assert(offsetof(AmbientSound_AdjustVolume, AdjustVolumeLevel) == 0x000004, "Member 'AmbientSound_AdjustVolume::AdjustVolumeLevel' has a wrong offset!");

// Function Engine.AmbientSound.FadeIn
// 0x0008 (0x0008 - 0x0000)
struct AmbientSound_FadeIn final
{
public:
	float                                         FadeInDuration;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AmbientSound_FadeIn) == 0x000004, "Wrong alignment on AmbientSound_FadeIn");
static_assert(sizeof(AmbientSound_FadeIn) == 0x000008, "Wrong size on AmbientSound_FadeIn");
static_assert(offsetof(AmbientSound_FadeIn, FadeInDuration) == 0x000000, "Member 'AmbientSound_FadeIn::FadeInDuration' has a wrong offset!");
static_assert(offsetof(AmbientSound_FadeIn, FadeVolumeLevel) == 0x000004, "Member 'AmbientSound_FadeIn::FadeVolumeLevel' has a wrong offset!");

// Function Engine.AmbientSound.FadeOut
// 0x0008 (0x0008 - 0x0000)
struct AmbientSound_FadeOut final
{
public:
	float                                         FadeOutDuration;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AmbientSound_FadeOut) == 0x000004, "Wrong alignment on AmbientSound_FadeOut");
static_assert(sizeof(AmbientSound_FadeOut) == 0x000008, "Wrong size on AmbientSound_FadeOut");
static_assert(offsetof(AmbientSound_FadeOut, FadeOutDuration) == 0x000000, "Member 'AmbientSound_FadeOut::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(AmbientSound_FadeOut, FadeVolumeLevel) == 0x000004, "Member 'AmbientSound_FadeOut::FadeVolumeLevel' has a wrong offset!");

// Function Engine.AmbientSound.Play
// 0x0004 (0x0004 - 0x0000)
struct AmbientSound_Play final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AmbientSound_Play) == 0x000004, "Wrong alignment on AmbientSound_Play");
static_assert(sizeof(AmbientSound_Play) == 0x000004, "Wrong size on AmbientSound_Play");
static_assert(offsetof(AmbientSound_Play, StartTime) == 0x000000, "Member 'AmbientSound_Play::StartTime' has a wrong offset!");

// Function Engine.Light.SetAffectTranslucentLighting
// 0x0001 (0x0001 - 0x0000)
struct Light_SetAffectTranslucentLighting final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetAffectTranslucentLighting) == 0x000001, "Wrong alignment on Light_SetAffectTranslucentLighting");
static_assert(sizeof(Light_SetAffectTranslucentLighting) == 0x000001, "Wrong size on Light_SetAffectTranslucentLighting");
static_assert(offsetof(Light_SetAffectTranslucentLighting, bNewValue) == 0x000000, "Member 'Light_SetAffectTranslucentLighting::bNewValue' has a wrong offset!");

// Function Engine.Light.SetBrightness
// 0x0004 (0x0004 - 0x0000)
struct Light_SetBrightness final
{
public:
	float                                         NewBrightness;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetBrightness) == 0x000004, "Wrong alignment on Light_SetBrightness");
static_assert(sizeof(Light_SetBrightness) == 0x000004, "Wrong size on Light_SetBrightness");
static_assert(offsetof(Light_SetBrightness, NewBrightness) == 0x000000, "Member 'Light_SetBrightness::NewBrightness' has a wrong offset!");

// Function Engine.Light.SetCastShadows
// 0x0001 (0x0001 - 0x0000)
struct Light_SetCastShadows final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetCastShadows) == 0x000001, "Wrong alignment on Light_SetCastShadows");
static_assert(sizeof(Light_SetCastShadows) == 0x000001, "Wrong size on Light_SetCastShadows");
static_assert(offsetof(Light_SetCastShadows, bNewValue) == 0x000000, "Member 'Light_SetCastShadows::bNewValue' has a wrong offset!");

// Function Engine.Light.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct Light_SetEnabled final
{
public:
	bool                                          bSetEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetEnabled) == 0x000001, "Wrong alignment on Light_SetEnabled");
static_assert(sizeof(Light_SetEnabled) == 0x000001, "Wrong size on Light_SetEnabled");
static_assert(offsetof(Light_SetEnabled, bSetEnabled) == 0x000000, "Member 'Light_SetEnabled::bSetEnabled' has a wrong offset!");

// Function Engine.Light.SetLightColor
// 0x0010 (0x0010 - 0x0000)
struct Light_SetLightColor final
{
public:
	struct FLinearColor                           NewLightColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetLightColor) == 0x000004, "Wrong alignment on Light_SetLightColor");
static_assert(sizeof(Light_SetLightColor) == 0x000010, "Wrong size on Light_SetLightColor");
static_assert(offsetof(Light_SetLightColor, NewLightColor) == 0x000000, "Member 'Light_SetLightColor::NewLightColor' has a wrong offset!");

// Function Engine.Light.SetLightFunctionFadeDistance
// 0x0004 (0x0004 - 0x0000)
struct Light_SetLightFunctionFadeDistance final
{
public:
	float                                         NewLightFunctionFadeDistance;                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetLightFunctionFadeDistance) == 0x000004, "Wrong alignment on Light_SetLightFunctionFadeDistance");
static_assert(sizeof(Light_SetLightFunctionFadeDistance) == 0x000004, "Wrong size on Light_SetLightFunctionFadeDistance");
static_assert(offsetof(Light_SetLightFunctionFadeDistance, NewLightFunctionFadeDistance) == 0x000000, "Member 'Light_SetLightFunctionFadeDistance::NewLightFunctionFadeDistance' has a wrong offset!");

// Function Engine.Light.SetLightFunctionMaterial
// 0x0008 (0x0008 - 0x0000)
struct Light_SetLightFunctionMaterial final
{
public:
	class UMaterialInterface*                     NewLightFunctionMaterial;                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetLightFunctionMaterial) == 0x000008, "Wrong alignment on Light_SetLightFunctionMaterial");
static_assert(sizeof(Light_SetLightFunctionMaterial) == 0x000008, "Wrong size on Light_SetLightFunctionMaterial");
static_assert(offsetof(Light_SetLightFunctionMaterial, NewLightFunctionMaterial) == 0x000000, "Member 'Light_SetLightFunctionMaterial::NewLightFunctionMaterial' has a wrong offset!");

// Function Engine.Light.SetLightFunctionScale
// 0x000C (0x000C - 0x0000)
struct Light_SetLightFunctionScale final
{
public:
	struct FVector                                NewLightFunctionScale;                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_SetLightFunctionScale) == 0x000004, "Wrong alignment on Light_SetLightFunctionScale");
static_assert(sizeof(Light_SetLightFunctionScale) == 0x00000C, "Wrong size on Light_SetLightFunctionScale");
static_assert(offsetof(Light_SetLightFunctionScale, NewLightFunctionScale) == 0x000000, "Member 'Light_SetLightFunctionScale::NewLightFunctionScale' has a wrong offset!");

// Function Engine.Light.GetBrightness
// 0x0004 (0x0004 - 0x0000)
struct Light_GetBrightness final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_GetBrightness) == 0x000004, "Wrong alignment on Light_GetBrightness");
static_assert(sizeof(Light_GetBrightness) == 0x000004, "Wrong size on Light_GetBrightness");
static_assert(offsetof(Light_GetBrightness, ReturnValue) == 0x000000, "Member 'Light_GetBrightness::ReturnValue' has a wrong offset!");

// Function Engine.Light.GetLightColor
// 0x0010 (0x0010 - 0x0000)
struct Light_GetLightColor final
{
public:
	struct FLinearColor                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_GetLightColor) == 0x000004, "Wrong alignment on Light_GetLightColor");
static_assert(sizeof(Light_GetLightColor) == 0x000010, "Wrong size on Light_GetLightColor");
static_assert(offsetof(Light_GetLightColor, ReturnValue) == 0x000000, "Member 'Light_GetLightColor::ReturnValue' has a wrong offset!");

// Function Engine.Light.IsEnabled
// 0x0001 (0x0001 - 0x0000)
struct Light_IsEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Light_IsEnabled) == 0x000001, "Wrong alignment on Light_IsEnabled");
static_assert(sizeof(Light_IsEnabled) == 0x000001, "Wrong size on Light_IsEnabled");
static_assert(offsetof(Light_IsEnabled, ReturnValue) == 0x000000, "Member 'Light_IsEnabled::ReturnValue' has a wrong offset!");

// Function Engine.AnimSequenceBase.GetPlayLength
// 0x0004 (0x0004 - 0x0000)
struct AnimSequenceBase_GetPlayLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSequenceBase_GetPlayLength) == 0x000004, "Wrong alignment on AnimSequenceBase_GetPlayLength");
static_assert(sizeof(AnimSequenceBase_GetPlayLength) == 0x000004, "Wrong size on AnimSequenceBase_GetPlayLength");
static_assert(offsetof(AnimSequenceBase_GetPlayLength, ReturnValue) == 0x000000, "Member 'AnimSequenceBase_GetPlayLength::ReturnValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetCascadeDistributionExponent
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetCascadeDistributionExponent final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetCascadeDistributionExponent) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetCascadeDistributionExponent");
static_assert(sizeof(DirectionalLightComponent_SetCascadeDistributionExponent) == 0x000004, "Wrong size on DirectionalLightComponent_SetCascadeDistributionExponent");
static_assert(offsetof(DirectionalLightComponent_SetCascadeDistributionExponent, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetCascadeDistributionExponent::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetCascadeTransitionFraction
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetCascadeTransitionFraction final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetCascadeTransitionFraction) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetCascadeTransitionFraction");
static_assert(sizeof(DirectionalLightComponent_SetCascadeTransitionFraction) == 0x000004, "Wrong size on DirectionalLightComponent_SetCascadeTransitionFraction");
static_assert(offsetof(DirectionalLightComponent_SetCascadeTransitionFraction, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetCascadeTransitionFraction::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetDynamicShadowCascades
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetDynamicShadowCascades final
{
public:
	int32                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetDynamicShadowCascades) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetDynamicShadowCascades");
static_assert(sizeof(DirectionalLightComponent_SetDynamicShadowCascades) == 0x000004, "Wrong size on DirectionalLightComponent_SetDynamicShadowCascades");
static_assert(offsetof(DirectionalLightComponent_SetDynamicShadowCascades, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetDynamicShadowCascades::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceMovableLight
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetDynamicShadowDistanceMovableLight final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetDynamicShadowDistanceMovableLight) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetDynamicShadowDistanceMovableLight");
static_assert(sizeof(DirectionalLightComponent_SetDynamicShadowDistanceMovableLight) == 0x000004, "Wrong size on DirectionalLightComponent_SetDynamicShadowDistanceMovableLight");
static_assert(offsetof(DirectionalLightComponent_SetDynamicShadowDistanceMovableLight, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetDynamicShadowDistanceMovableLight::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetDynamicShadowDistanceStationaryLight
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight");
static_assert(sizeof(DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight) == 0x000004, "Wrong size on DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight");
static_assert(offsetof(DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetDynamicShadowDistanceStationaryLight::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetEnableLightShaftOcclusion
// 0x0001 (0x0001 - 0x0000)
struct DirectionalLightComponent_SetEnableLightShaftOcclusion final
{
public:
	bool                                          bNewValue;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetEnableLightShaftOcclusion) == 0x000001, "Wrong alignment on DirectionalLightComponent_SetEnableLightShaftOcclusion");
static_assert(sizeof(DirectionalLightComponent_SetEnableLightShaftOcclusion) == 0x000001, "Wrong size on DirectionalLightComponent_SetEnableLightShaftOcclusion");
static_assert(offsetof(DirectionalLightComponent_SetEnableLightShaftOcclusion, bNewValue) == 0x000000, "Member 'DirectionalLightComponent_SetEnableLightShaftOcclusion::bNewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetLightShaftOverrideDirection
// 0x000C (0x000C - 0x0000)
struct DirectionalLightComponent_SetLightShaftOverrideDirection final
{
public:
	struct FVector                                NewValue;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetLightShaftOverrideDirection) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetLightShaftOverrideDirection");
static_assert(sizeof(DirectionalLightComponent_SetLightShaftOverrideDirection) == 0x00000C, "Wrong size on DirectionalLightComponent_SetLightShaftOverrideDirection");
static_assert(offsetof(DirectionalLightComponent_SetLightShaftOverrideDirection, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetLightShaftOverrideDirection::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetOcclusionMaskDarkness
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetOcclusionMaskDarkness final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetOcclusionMaskDarkness) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetOcclusionMaskDarkness");
static_assert(sizeof(DirectionalLightComponent_SetOcclusionMaskDarkness) == 0x000004, "Wrong size on DirectionalLightComponent_SetOcclusionMaskDarkness");
static_assert(offsetof(DirectionalLightComponent_SetOcclusionMaskDarkness, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetOcclusionMaskDarkness::NewValue' has a wrong offset!");

// Function Engine.DirectionalLightComponent.SetShadowDistanceFadeoutFraction
// 0x0004 (0x0004 - 0x0000)
struct DirectionalLightComponent_SetShadowDistanceFadeoutFraction final
{
public:
	float                                         NewValue;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DirectionalLightComponent_SetShadowDistanceFadeoutFraction) == 0x000004, "Wrong alignment on DirectionalLightComponent_SetShadowDistanceFadeoutFraction");
static_assert(sizeof(DirectionalLightComponent_SetShadowDistanceFadeoutFraction) == 0x000004, "Wrong size on DirectionalLightComponent_SetShadowDistanceFadeoutFraction");
static_assert(offsetof(DirectionalLightComponent_SetShadowDistanceFadeoutFraction, NewValue) == 0x000000, "Member 'DirectionalLightComponent_SetShadowDistanceFadeoutFraction::NewValue' has a wrong offset!");

// Function Engine.AnimNotifyState_Trail.OverridePSTemplate
// 0x0018 (0x0018 - 0x0000)
struct AnimNotifyState_Trail_OverridePSTemplate final
{
public:
	class USkeletalMeshComponent*                 MeshComp;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAnimSequenceBase*                      Animation;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimNotifyState_Trail_OverridePSTemplate) == 0x000008, "Wrong alignment on AnimNotifyState_Trail_OverridePSTemplate");
static_assert(sizeof(AnimNotifyState_Trail_OverridePSTemplate) == 0x000018, "Wrong size on AnimNotifyState_Trail_OverridePSTemplate");
static_assert(offsetof(AnimNotifyState_Trail_OverridePSTemplate, MeshComp) == 0x000000, "Member 'AnimNotifyState_Trail_OverridePSTemplate::MeshComp' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Trail_OverridePSTemplate, Animation) == 0x000008, "Member 'AnimNotifyState_Trail_OverridePSTemplate::Animation' has a wrong offset!");
static_assert(offsetof(AnimNotifyState_Trail_OverridePSTemplate, ReturnValue) == 0x000010, "Member 'AnimNotifyState_Trail_OverridePSTemplate::ReturnValue' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.GetLength
// 0x0004 (0x0004 - 0x0000)
struct AnimSingleNodeInstance_GetLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_GetLength) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_GetLength");
static_assert(sizeof(AnimSingleNodeInstance_GetLength) == 0x000004, "Wrong size on AnimSingleNodeInstance_GetLength");
static_assert(offsetof(AnimSingleNodeInstance_GetLength, ReturnValue) == 0x000000, "Member 'AnimSingleNodeInstance_GetLength::ReturnValue' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.PlayAnim
// 0x000C (0x000C - 0x0000)
struct AnimSingleNodeInstance_PlayAnim final
{
public:
	bool                                          bIsLooping;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InPlayRate;                                        // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InStartPosition;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_PlayAnim) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_PlayAnim");
static_assert(sizeof(AnimSingleNodeInstance_PlayAnim) == 0x00000C, "Wrong size on AnimSingleNodeInstance_PlayAnim");
static_assert(offsetof(AnimSingleNodeInstance_PlayAnim, bIsLooping) == 0x000000, "Member 'AnimSingleNodeInstance_PlayAnim::bIsLooping' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_PlayAnim, InPlayRate) == 0x000004, "Member 'AnimSingleNodeInstance_PlayAnim::InPlayRate' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_PlayAnim, InStartPosition) == 0x000008, "Member 'AnimSingleNodeInstance_PlayAnim::InStartPosition' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetAnimationAsset
// 0x0010 (0x0010 - 0x0000)
struct AnimSingleNodeInstance_SetAnimationAsset final
{
public:
	class UAnimationAsset*                        NewAsset;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsLooping;                                        // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         InPlayRate;                                        // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetAnimationAsset) == 0x000008, "Wrong alignment on AnimSingleNodeInstance_SetAnimationAsset");
static_assert(sizeof(AnimSingleNodeInstance_SetAnimationAsset) == 0x000010, "Wrong size on AnimSingleNodeInstance_SetAnimationAsset");
static_assert(offsetof(AnimSingleNodeInstance_SetAnimationAsset, NewAsset) == 0x000000, "Member 'AnimSingleNodeInstance_SetAnimationAsset::NewAsset' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetAnimationAsset, bIsLooping) == 0x000008, "Member 'AnimSingleNodeInstance_SetAnimationAsset::bIsLooping' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetAnimationAsset, InPlayRate) == 0x00000C, "Member 'AnimSingleNodeInstance_SetAnimationAsset::InPlayRate' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetBlendSpaceInput
// 0x000C (0x000C - 0x0000)
struct AnimSingleNodeInstance_SetBlendSpaceInput final
{
public:
	struct FVector                                InBlendInput;                                      // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetBlendSpaceInput) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_SetBlendSpaceInput");
static_assert(sizeof(AnimSingleNodeInstance_SetBlendSpaceInput) == 0x00000C, "Wrong size on AnimSingleNodeInstance_SetBlendSpaceInput");
static_assert(offsetof(AnimSingleNodeInstance_SetBlendSpaceInput, InBlendInput) == 0x000000, "Member 'AnimSingleNodeInstance_SetBlendSpaceInput::InBlendInput' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetLooping
// 0x0001 (0x0001 - 0x0000)
struct AnimSingleNodeInstance_SetLooping final
{
public:
	bool                                          bIsLooping;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetLooping) == 0x000001, "Wrong alignment on AnimSingleNodeInstance_SetLooping");
static_assert(sizeof(AnimSingleNodeInstance_SetLooping) == 0x000001, "Wrong size on AnimSingleNodeInstance_SetLooping");
static_assert(offsetof(AnimSingleNodeInstance_SetLooping, bIsLooping) == 0x000000, "Member 'AnimSingleNodeInstance_SetLooping::bIsLooping' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetPlaying
// 0x0001 (0x0001 - 0x0000)
struct AnimSingleNodeInstance_SetPlaying final
{
public:
	bool                                          bIsPlaying;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetPlaying) == 0x000001, "Wrong alignment on AnimSingleNodeInstance_SetPlaying");
static_assert(sizeof(AnimSingleNodeInstance_SetPlaying) == 0x000001, "Wrong size on AnimSingleNodeInstance_SetPlaying");
static_assert(offsetof(AnimSingleNodeInstance_SetPlaying, bIsPlaying) == 0x000000, "Member 'AnimSingleNodeInstance_SetPlaying::bIsPlaying' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct AnimSingleNodeInstance_SetPlayRate final
{
public:
	float                                         InPlayRate;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetPlayRate) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_SetPlayRate");
static_assert(sizeof(AnimSingleNodeInstance_SetPlayRate) == 0x000004, "Wrong size on AnimSingleNodeInstance_SetPlayRate");
static_assert(offsetof(AnimSingleNodeInstance_SetPlayRate, InPlayRate) == 0x000000, "Member 'AnimSingleNodeInstance_SetPlayRate::InPlayRate' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetPosition
// 0x0008 (0x0008 - 0x0000)
struct AnimSingleNodeInstance_SetPosition final
{
public:
	float                                         InPosition;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireNotifies;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimSingleNodeInstance_SetPosition) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_SetPosition");
static_assert(sizeof(AnimSingleNodeInstance_SetPosition) == 0x000008, "Wrong size on AnimSingleNodeInstance_SetPosition");
static_assert(offsetof(AnimSingleNodeInstance_SetPosition, InPosition) == 0x000000, "Member 'AnimSingleNodeInstance_SetPosition::InPosition' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetPosition, bFireNotifies) == 0x000004, "Member 'AnimSingleNodeInstance_SetPosition::bFireNotifies' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetPositionWithPreviousTime
// 0x000C (0x000C - 0x0000)
struct AnimSingleNodeInstance_SetPositionWithPreviousTime final
{
public:
	float                                         InPosition;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InPreviousTime;                                    // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireNotifies;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimSingleNodeInstance_SetPositionWithPreviousTime) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_SetPositionWithPreviousTime");
static_assert(sizeof(AnimSingleNodeInstance_SetPositionWithPreviousTime) == 0x00000C, "Wrong size on AnimSingleNodeInstance_SetPositionWithPreviousTime");
static_assert(offsetof(AnimSingleNodeInstance_SetPositionWithPreviousTime, InPosition) == 0x000000, "Member 'AnimSingleNodeInstance_SetPositionWithPreviousTime::InPosition' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetPositionWithPreviousTime, InPreviousTime) == 0x000004, "Member 'AnimSingleNodeInstance_SetPositionWithPreviousTime::InPreviousTime' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetPositionWithPreviousTime, bFireNotifies) == 0x000008, "Member 'AnimSingleNodeInstance_SetPositionWithPreviousTime::bFireNotifies' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetPreviewCurveOverride
// 0x0010 (0x0010 - 0x0000)
struct AnimSingleNodeInstance_SetPreviewCurveOverride final
{
public:
	class FName                                   PoseName;                                          // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemoveIfZero;                                     // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AnimSingleNodeInstance_SetPreviewCurveOverride) == 0x000004, "Wrong alignment on AnimSingleNodeInstance_SetPreviewCurveOverride");
static_assert(sizeof(AnimSingleNodeInstance_SetPreviewCurveOverride) == 0x000010, "Wrong size on AnimSingleNodeInstance_SetPreviewCurveOverride");
static_assert(offsetof(AnimSingleNodeInstance_SetPreviewCurveOverride, PoseName) == 0x000000, "Member 'AnimSingleNodeInstance_SetPreviewCurveOverride::PoseName' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetPreviewCurveOverride, Value) == 0x000008, "Member 'AnimSingleNodeInstance_SetPreviewCurveOverride::Value' has a wrong offset!");
static_assert(offsetof(AnimSingleNodeInstance_SetPreviewCurveOverride, bRemoveIfZero) == 0x00000C, "Member 'AnimSingleNodeInstance_SetPreviewCurveOverride::bRemoveIfZero' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.SetReverse
// 0x0001 (0x0001 - 0x0000)
struct AnimSingleNodeInstance_SetReverse final
{
public:
	bool                                          bInReverse;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_SetReverse) == 0x000001, "Wrong alignment on AnimSingleNodeInstance_SetReverse");
static_assert(sizeof(AnimSingleNodeInstance_SetReverse) == 0x000001, "Wrong size on AnimSingleNodeInstance_SetReverse");
static_assert(offsetof(AnimSingleNodeInstance_SetReverse, bInReverse) == 0x000000, "Member 'AnimSingleNodeInstance_SetReverse::bInReverse' has a wrong offset!");

// Function Engine.AnimSingleNodeInstance.GetAnimationAsset
// 0x0008 (0x0008 - 0x0000)
struct AnimSingleNodeInstance_GetAnimationAsset final
{
public:
	class UAnimationAsset*                        ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AnimSingleNodeInstance_GetAnimationAsset) == 0x000008, "Wrong alignment on AnimSingleNodeInstance_GetAnimationAsset");
static_assert(sizeof(AnimSingleNodeInstance_GetAnimationAsset) == 0x000008, "Wrong size on AnimSingleNodeInstance_GetAnimationAsset");
static_assert(offsetof(AnimSingleNodeInstance_GetAnimationAsset, ReturnValue) == 0x000000, "Member 'AnimSingleNodeInstance_GetAnimationAsset::ReturnValue' has a wrong offset!");

// Function Engine.ArrowComponent.SetArrowColor
// 0x0010 (0x0010 - 0x0000)
struct ArrowComponent_SetArrowColor final
{
public:
	struct FLinearColor                           NewColor;                                          // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ArrowComponent_SetArrowColor) == 0x000004, "Wrong alignment on ArrowComponent_SetArrowColor");
static_assert(sizeof(ArrowComponent_SetArrowColor) == 0x000010, "Wrong size on ArrowComponent_SetArrowColor");
static_assert(offsetof(ArrowComponent_SetArrowColor, NewColor) == 0x000000, "Member 'ArrowComponent_SetArrowColor::NewColor' has a wrong offset!");

// Function Engine.Emitter.OnParticleSystemFinished
// 0x0008 (0x0008 - 0x0000)
struct Emitter_OnParticleSystemFinished final
{
public:
	class UParticleSystemComponent*               FinishedComponent;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_OnParticleSystemFinished) == 0x000008, "Wrong alignment on Emitter_OnParticleSystemFinished");
static_assert(sizeof(Emitter_OnParticleSystemFinished) == 0x000008, "Wrong size on Emitter_OnParticleSystemFinished");
static_assert(offsetof(Emitter_OnParticleSystemFinished, FinishedComponent) == 0x000000, "Member 'Emitter_OnParticleSystemFinished::FinishedComponent' has a wrong offset!");

// Function Engine.Emitter.SetActorParameter
// 0x0010 (0x0010 - 0x0000)
struct Emitter_SetActorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 Param;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_SetActorParameter) == 0x000008, "Wrong alignment on Emitter_SetActorParameter");
static_assert(sizeof(Emitter_SetActorParameter) == 0x000010, "Wrong size on Emitter_SetActorParameter");
static_assert(offsetof(Emitter_SetActorParameter, ParameterName) == 0x000000, "Member 'Emitter_SetActorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(Emitter_SetActorParameter, Param) == 0x000008, "Member 'Emitter_SetActorParameter::Param' has a wrong offset!");

// Function Engine.Emitter.SetColorParameter
// 0x0018 (0x0018 - 0x0000)
struct Emitter_SetColorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Param;                                             // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_SetColorParameter) == 0x000004, "Wrong alignment on Emitter_SetColorParameter");
static_assert(sizeof(Emitter_SetColorParameter) == 0x000018, "Wrong size on Emitter_SetColorParameter");
static_assert(offsetof(Emitter_SetColorParameter, ParameterName) == 0x000000, "Member 'Emitter_SetColorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(Emitter_SetColorParameter, Param) == 0x000008, "Member 'Emitter_SetColorParameter::Param' has a wrong offset!");

// Function Engine.Emitter.SetFloatParameter
// 0x0010 (0x0010 - 0x0000)
struct Emitter_SetFloatParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Param;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Emitter_SetFloatParameter) == 0x000004, "Wrong alignment on Emitter_SetFloatParameter");
static_assert(sizeof(Emitter_SetFloatParameter) == 0x000010, "Wrong size on Emitter_SetFloatParameter");
static_assert(offsetof(Emitter_SetFloatParameter, ParameterName) == 0x000000, "Member 'Emitter_SetFloatParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(Emitter_SetFloatParameter, Param) == 0x000008, "Member 'Emitter_SetFloatParameter::Param' has a wrong offset!");

// Function Engine.Emitter.SetMaterialParameter
// 0x0010 (0x0010 - 0x0000)
struct Emitter_SetMaterialParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Param;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_SetMaterialParameter) == 0x000008, "Wrong alignment on Emitter_SetMaterialParameter");
static_assert(sizeof(Emitter_SetMaterialParameter) == 0x000010, "Wrong size on Emitter_SetMaterialParameter");
static_assert(offsetof(Emitter_SetMaterialParameter, ParameterName) == 0x000000, "Member 'Emitter_SetMaterialParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(Emitter_SetMaterialParameter, Param) == 0x000008, "Member 'Emitter_SetMaterialParameter::Param' has a wrong offset!");

// Function Engine.Emitter.SetTemplate
// 0x0008 (0x0008 - 0x0000)
struct Emitter_SetTemplate final
{
public:
	class UParticleSystem*                        NewTemplate;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_SetTemplate) == 0x000008, "Wrong alignment on Emitter_SetTemplate");
static_assert(sizeof(Emitter_SetTemplate) == 0x000008, "Wrong size on Emitter_SetTemplate");
static_assert(offsetof(Emitter_SetTemplate, NewTemplate) == 0x000000, "Member 'Emitter_SetTemplate::NewTemplate' has a wrong offset!");

// Function Engine.Emitter.SetVectorParameter
// 0x0018 (0x0018 - 0x0000)
struct Emitter_SetVectorParameter final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Param;                                             // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Emitter_SetVectorParameter) == 0x000004, "Wrong alignment on Emitter_SetVectorParameter");
static_assert(sizeof(Emitter_SetVectorParameter) == 0x000018, "Wrong size on Emitter_SetVectorParameter");
static_assert(offsetof(Emitter_SetVectorParameter, ParameterName) == 0x000000, "Member 'Emitter_SetVectorParameter::ParameterName' has a wrong offset!");
static_assert(offsetof(Emitter_SetVectorParameter, Param) == 0x000008, "Member 'Emitter_SetVectorParameter::Param' has a wrong offset!");

// Function Engine.Emitter.IsActive
// 0x0001 (0x0001 - 0x0000)
struct Emitter_IsActive final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Emitter_IsActive) == 0x000001, "Wrong alignment on Emitter_IsActive");
static_assert(sizeof(Emitter_IsActive) == 0x000001, "Wrong size on Emitter_IsActive");
static_assert(offsetof(Emitter_IsActive, ReturnValue) == 0x000000, "Member 'Emitter_IsActive::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionLoadPrimaryAsset.AsyncLoadPrimaryAsset
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset final
{
public:
	struct FPrimaryAssetId                        PrimaryAsset;                                      // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LoadBundles;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionLoadPrimaryAsset*           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset) == 0x000008, "Wrong alignment on AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset");
static_assert(sizeof(AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset) == 0x000028, "Wrong size on AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset");
static_assert(offsetof(AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset, PrimaryAsset) == 0x000000, "Member 'AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset::PrimaryAsset' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset, LoadBundles) == 0x000010, "Member 'AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset::LoadBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset, ReturnValue) == 0x000020, "Member 'AsyncActionLoadPrimaryAsset_AsyncLoadPrimaryAsset::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionLoadPrimaryAssetClass.AsyncLoadPrimaryAssetClass
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass final
{
public:
	struct FPrimaryAssetId                        PrimaryAsset;                                      // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           LoadBundles;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionLoadPrimaryAssetClass*      ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass) == 0x000008, "Wrong alignment on AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass");
static_assert(sizeof(AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass) == 0x000028, "Wrong size on AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass, PrimaryAsset) == 0x000000, "Member 'AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass::PrimaryAsset' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass, LoadBundles) == 0x000010, "Member 'AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass::LoadBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass, ReturnValue) == 0x000020, "Member 'AsyncActionLoadPrimaryAssetClass_AsyncLoadPrimaryAssetClass::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionLoadPrimaryAssetList.AsyncLoadPrimaryAssetList
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList final
{
public:
	TArray<struct FPrimaryAssetId>                PrimaryAssetList;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           LoadBundles;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionLoadPrimaryAssetList*       ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList) == 0x000008, "Wrong alignment on AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList");
static_assert(sizeof(AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList) == 0x000028, "Wrong size on AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList");
static_assert(offsetof(AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList, PrimaryAssetList) == 0x000000, "Member 'AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList::PrimaryAssetList' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList, LoadBundles) == 0x000010, "Member 'AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList::LoadBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList, ReturnValue) == 0x000020, "Member 'AsyncActionLoadPrimaryAssetList_AsyncLoadPrimaryAssetList::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionLoadPrimaryAssetClassList.AsyncLoadPrimaryAssetClassList
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList final
{
public:
	TArray<struct FPrimaryAssetId>                PrimaryAssetList;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           LoadBundles;                                       // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionLoadPrimaryAssetClassList*  ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList) == 0x000008, "Wrong alignment on AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList");
static_assert(sizeof(AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList) == 0x000028, "Wrong size on AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList, PrimaryAssetList) == 0x000000, "Member 'AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList::PrimaryAssetList' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList, LoadBundles) == 0x000010, "Member 'AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList::LoadBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList, ReturnValue) == 0x000020, "Member 'AsyncActionLoadPrimaryAssetClassList_AsyncLoadPrimaryAssetClassList::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForMatchingPrimaryAssets
// 0x0028 (0x0028 - 0x0000)
struct AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets final
{
public:
	TArray<class FName>                           NewBundles;                                        // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           OldBundles;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionChangePrimaryAssetBundles*  ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets) == 0x000008, "Wrong alignment on AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets");
static_assert(sizeof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets) == 0x000028, "Wrong size on AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets, NewBundles) == 0x000000, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets::NewBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets, OldBundles) == 0x000010, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets::OldBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets, ReturnValue) == 0x000020, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForMatchingPrimaryAssets::ReturnValue' has a wrong offset!");

// Function Engine.AsyncActionChangePrimaryAssetBundles.AsyncChangeBundleStateForPrimaryAssetList
// 0x0038 (0x0038 - 0x0000)
struct AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList final
{
public:
	TArray<struct FPrimaryAssetId>                PrimaryAssetList;                                  // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           AddBundles;                                        // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           RemoveBundles;                                     // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UAsyncActionChangePrimaryAssetBundles*  ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList) == 0x000008, "Wrong alignment on AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList");
static_assert(sizeof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList) == 0x000038, "Wrong size on AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList, PrimaryAssetList) == 0x000000, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList::PrimaryAssetList' has a wrong offset!");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList, AddBundles) == 0x000010, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList::AddBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList, RemoveBundles) == 0x000020, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList::RemoveBundles' has a wrong offset!");
static_assert(offsetof(AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList, ReturnValue) == 0x000030, "Member 'AsyncActionChangePrimaryAssetBundles_AsyncChangeBundleStateForPrimaryAssetList::ReturnValue' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.DisableGroundScattering
// 0x0001 (0x0001 - 0x0000)
struct AtmosphericFogComponent_DisableGroundScattering final
{
public:
	bool                                          NewGroundScattering;                               // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_DisableGroundScattering) == 0x000001, "Wrong alignment on AtmosphericFogComponent_DisableGroundScattering");
static_assert(sizeof(AtmosphericFogComponent_DisableGroundScattering) == 0x000001, "Wrong size on AtmosphericFogComponent_DisableGroundScattering");
static_assert(offsetof(AtmosphericFogComponent_DisableGroundScattering, NewGroundScattering) == 0x000000, "Member 'AtmosphericFogComponent_DisableGroundScattering::NewGroundScattering' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.DisableSunDisk
// 0x0001 (0x0001 - 0x0000)
struct AtmosphericFogComponent_DisableSunDisk final
{
public:
	bool                                          NewSunDisk;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_DisableSunDisk) == 0x000001, "Wrong alignment on AtmosphericFogComponent_DisableSunDisk");
static_assert(sizeof(AtmosphericFogComponent_DisableSunDisk) == 0x000001, "Wrong size on AtmosphericFogComponent_DisableSunDisk");
static_assert(offsetof(AtmosphericFogComponent_DisableSunDisk, NewSunDisk) == 0x000000, "Member 'AtmosphericFogComponent_DisableSunDisk::NewSunDisk' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetAltitudeScale
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetAltitudeScale final
{
public:
	float                                         NewAltitudeScale;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetAltitudeScale) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetAltitudeScale");
static_assert(sizeof(AtmosphericFogComponent_SetAltitudeScale) == 0x000004, "Wrong size on AtmosphericFogComponent_SetAltitudeScale");
static_assert(offsetof(AtmosphericFogComponent_SetAltitudeScale, NewAltitudeScale) == 0x000000, "Member 'AtmosphericFogComponent_SetAltitudeScale::NewAltitudeScale' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDefaultBrightness
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetDefaultBrightness final
{
public:
	float                                         NewBrightness;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDefaultBrightness) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDefaultBrightness");
static_assert(sizeof(AtmosphericFogComponent_SetDefaultBrightness) == 0x000004, "Wrong size on AtmosphericFogComponent_SetDefaultBrightness");
static_assert(offsetof(AtmosphericFogComponent_SetDefaultBrightness, NewBrightness) == 0x000000, "Member 'AtmosphericFogComponent_SetDefaultBrightness::NewBrightness' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDefaultLightColor
// 0x0010 (0x0010 - 0x0000)
struct AtmosphericFogComponent_SetDefaultLightColor final
{
public:
	struct FLinearColor                           NewLightColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDefaultLightColor) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDefaultLightColor");
static_assert(sizeof(AtmosphericFogComponent_SetDefaultLightColor) == 0x000010, "Wrong size on AtmosphericFogComponent_SetDefaultLightColor");
static_assert(offsetof(AtmosphericFogComponent_SetDefaultLightColor, NewLightColor) == 0x000000, "Member 'AtmosphericFogComponent_SetDefaultLightColor::NewLightColor' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDensityMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetDensityMultiplier final
{
public:
	float                                         NewDensityMultiplier;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDensityMultiplier) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDensityMultiplier");
static_assert(sizeof(AtmosphericFogComponent_SetDensityMultiplier) == 0x000004, "Wrong size on AtmosphericFogComponent_SetDensityMultiplier");
static_assert(offsetof(AtmosphericFogComponent_SetDensityMultiplier, NewDensityMultiplier) == 0x000000, "Member 'AtmosphericFogComponent_SetDensityMultiplier::NewDensityMultiplier' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDensityOffset
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetDensityOffset final
{
public:
	float                                         NewDensityOffset;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDensityOffset) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDensityOffset");
static_assert(sizeof(AtmosphericFogComponent_SetDensityOffset) == 0x000004, "Wrong size on AtmosphericFogComponent_SetDensityOffset");
static_assert(offsetof(AtmosphericFogComponent_SetDensityOffset, NewDensityOffset) == 0x000000, "Member 'AtmosphericFogComponent_SetDensityOffset::NewDensityOffset' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDistanceOffset
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetDistanceOffset final
{
public:
	float                                         NewDistanceOffset;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDistanceOffset) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDistanceOffset");
static_assert(sizeof(AtmosphericFogComponent_SetDistanceOffset) == 0x000004, "Wrong size on AtmosphericFogComponent_SetDistanceOffset");
static_assert(offsetof(AtmosphericFogComponent_SetDistanceOffset, NewDistanceOffset) == 0x000000, "Member 'AtmosphericFogComponent_SetDistanceOffset::NewDistanceOffset' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetDistanceScale
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetDistanceScale final
{
public:
	float                                         NewDistanceScale;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetDistanceScale) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetDistanceScale");
static_assert(sizeof(AtmosphericFogComponent_SetDistanceScale) == 0x000004, "Wrong size on AtmosphericFogComponent_SetDistanceScale");
static_assert(offsetof(AtmosphericFogComponent_SetDistanceScale, NewDistanceScale) == 0x000000, "Member 'AtmosphericFogComponent_SetDistanceScale::NewDistanceScale' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetFogMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetFogMultiplier final
{
public:
	float                                         NewFogMultiplier;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetFogMultiplier) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetFogMultiplier");
static_assert(sizeof(AtmosphericFogComponent_SetFogMultiplier) == 0x000004, "Wrong size on AtmosphericFogComponent_SetFogMultiplier");
static_assert(offsetof(AtmosphericFogComponent_SetFogMultiplier, NewFogMultiplier) == 0x000000, "Member 'AtmosphericFogComponent_SetFogMultiplier::NewFogMultiplier' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetPrecomputeParams
// 0x000C (0x000C - 0x0000)
struct AtmosphericFogComponent_SetPrecomputeParams final
{
public:
	float                                         DensityHeight;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxScatteringOrder;                                // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InscatterAltitudeSampleNum;                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetPrecomputeParams) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetPrecomputeParams");
static_assert(sizeof(AtmosphericFogComponent_SetPrecomputeParams) == 0x00000C, "Wrong size on AtmosphericFogComponent_SetPrecomputeParams");
static_assert(offsetof(AtmosphericFogComponent_SetPrecomputeParams, DensityHeight) == 0x000000, "Member 'AtmosphericFogComponent_SetPrecomputeParams::DensityHeight' has a wrong offset!");
static_assert(offsetof(AtmosphericFogComponent_SetPrecomputeParams, MaxScatteringOrder) == 0x000004, "Member 'AtmosphericFogComponent_SetPrecomputeParams::MaxScatteringOrder' has a wrong offset!");
static_assert(offsetof(AtmosphericFogComponent_SetPrecomputeParams, InscatterAltitudeSampleNum) == 0x000008, "Member 'AtmosphericFogComponent_SetPrecomputeParams::InscatterAltitudeSampleNum' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetStartDistance
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetStartDistance final
{
public:
	float                                         NewStartDistance;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetStartDistance) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetStartDistance");
static_assert(sizeof(AtmosphericFogComponent_SetStartDistance) == 0x000004, "Wrong size on AtmosphericFogComponent_SetStartDistance");
static_assert(offsetof(AtmosphericFogComponent_SetStartDistance, NewStartDistance) == 0x000000, "Member 'AtmosphericFogComponent_SetStartDistance::NewStartDistance' has a wrong offset!");

// Function Engine.AtmosphericFogComponent.SetSunMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AtmosphericFogComponent_SetSunMultiplier final
{
public:
	float                                         NewSunMultiplier;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AtmosphericFogComponent_SetSunMultiplier) == 0x000004, "Wrong alignment on AtmosphericFogComponent_SetSunMultiplier");
static_assert(sizeof(AtmosphericFogComponent_SetSunMultiplier) == 0x000004, "Wrong size on AtmosphericFogComponent_SetSunMultiplier");
static_assert(offsetof(AtmosphericFogComponent_SetSunMultiplier, NewSunMultiplier) == 0x000000, "Member 'AtmosphericFogComponent_SetSunMultiplier::NewSunMultiplier' has a wrong offset!");

// Function Engine.AudioComponent.AdjustAttenuation
// 0x02C0 (0x02C0 - 0x0000)
struct AudioComponent_AdjustAttenuation final
{
public:
	struct FSoundAttenuationSettings              InAttenuationSettings;                             // 0x0000(0x02C0)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_AdjustAttenuation) == 0x000008, "Wrong alignment on AudioComponent_AdjustAttenuation");
static_assert(sizeof(AudioComponent_AdjustAttenuation) == 0x0002C0, "Wrong size on AudioComponent_AdjustAttenuation");
static_assert(offsetof(AudioComponent_AdjustAttenuation, InAttenuationSettings) == 0x000000, "Member 'AudioComponent_AdjustAttenuation::InAttenuationSettings' has a wrong offset!");

// Function Engine.AudioComponent.AdjustVolume
// 0x0008 (0x0008 - 0x0000)
struct AudioComponent_AdjustVolume final
{
public:
	float                                         AdjustVolumeDuration;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AdjustVolumeLevel;                                 // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_AdjustVolume) == 0x000004, "Wrong alignment on AudioComponent_AdjustVolume");
static_assert(sizeof(AudioComponent_AdjustVolume) == 0x000008, "Wrong size on AudioComponent_AdjustVolume");
static_assert(offsetof(AudioComponent_AdjustVolume, AdjustVolumeDuration) == 0x000000, "Member 'AudioComponent_AdjustVolume::AdjustVolumeDuration' has a wrong offset!");
static_assert(offsetof(AudioComponent_AdjustVolume, AdjustVolumeLevel) == 0x000004, "Member 'AudioComponent_AdjustVolume::AdjustVolumeLevel' has a wrong offset!");

// Function Engine.AudioComponent.BP_GetAttenuationSettingsToApply
// 0x02C8 (0x02C8 - 0x0000)
struct AudioComponent_BP_GetAttenuationSettingsToApply final
{
public:
	struct FSoundAttenuationSettings              OutAttenuationSettings;                            // 0x0000(0x02C0)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x02C0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C1[0x7];                                      // 0x02C1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AudioComponent_BP_GetAttenuationSettingsToApply) == 0x000008, "Wrong alignment on AudioComponent_BP_GetAttenuationSettingsToApply");
static_assert(sizeof(AudioComponent_BP_GetAttenuationSettingsToApply) == 0x0002C8, "Wrong size on AudioComponent_BP_GetAttenuationSettingsToApply");
static_assert(offsetof(AudioComponent_BP_GetAttenuationSettingsToApply, OutAttenuationSettings) == 0x000000, "Member 'AudioComponent_BP_GetAttenuationSettingsToApply::OutAttenuationSettings' has a wrong offset!");
static_assert(offsetof(AudioComponent_BP_GetAttenuationSettingsToApply, ReturnValue) == 0x0002C0, "Member 'AudioComponent_BP_GetAttenuationSettingsToApply::ReturnValue' has a wrong offset!");

// Function Engine.AudioComponent.FadeIn
// 0x000C (0x000C - 0x0000)
struct AudioComponent_FadeIn final
{
public:
	float                                         FadeInDuration;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_FadeIn) == 0x000004, "Wrong alignment on AudioComponent_FadeIn");
static_assert(sizeof(AudioComponent_FadeIn) == 0x00000C, "Wrong size on AudioComponent_FadeIn");
static_assert(offsetof(AudioComponent_FadeIn, FadeInDuration) == 0x000000, "Member 'AudioComponent_FadeIn::FadeInDuration' has a wrong offset!");
static_assert(offsetof(AudioComponent_FadeIn, FadeVolumeLevel) == 0x000004, "Member 'AudioComponent_FadeIn::FadeVolumeLevel' has a wrong offset!");
static_assert(offsetof(AudioComponent_FadeIn, StartTime) == 0x000008, "Member 'AudioComponent_FadeIn::StartTime' has a wrong offset!");

// Function Engine.AudioComponent.FadeOut
// 0x0008 (0x0008 - 0x0000)
struct AudioComponent_FadeOut final
{
public:
	float                                         FadeOutDuration;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeVolumeLevel;                                   // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_FadeOut) == 0x000004, "Wrong alignment on AudioComponent_FadeOut");
static_assert(sizeof(AudioComponent_FadeOut) == 0x000008, "Wrong size on AudioComponent_FadeOut");
static_assert(offsetof(AudioComponent_FadeOut, FadeOutDuration) == 0x000000, "Member 'AudioComponent_FadeOut::FadeOutDuration' has a wrong offset!");
static_assert(offsetof(AudioComponent_FadeOut, FadeVolumeLevel) == 0x000004, "Member 'AudioComponent_FadeOut::FadeVolumeLevel' has a wrong offset!");

// Function Engine.AudioComponent.Play
// 0x0004 (0x0004 - 0x0000)
struct AudioComponent_Play final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_Play) == 0x000004, "Wrong alignment on AudioComponent_Play");
static_assert(sizeof(AudioComponent_Play) == 0x000004, "Wrong size on AudioComponent_Play");
static_assert(offsetof(AudioComponent_Play, StartTime) == 0x000000, "Member 'AudioComponent_Play::StartTime' has a wrong offset!");

// Function Engine.AudioComponent.SetBoolParameter
// 0x0010 (0x0010 - 0x0000)
struct AudioComponent_SetBoolParameter final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InBool;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AudioComponent_SetBoolParameter) == 0x000004, "Wrong alignment on AudioComponent_SetBoolParameter");
static_assert(sizeof(AudioComponent_SetBoolParameter) == 0x000010, "Wrong size on AudioComponent_SetBoolParameter");
static_assert(offsetof(AudioComponent_SetBoolParameter, InName) == 0x000000, "Member 'AudioComponent_SetBoolParameter::InName' has a wrong offset!");
static_assert(offsetof(AudioComponent_SetBoolParameter, InBool) == 0x000008, "Member 'AudioComponent_SetBoolParameter::InBool' has a wrong offset!");

// Function Engine.AudioComponent.SetFloatParameter
// 0x0010 (0x0010 - 0x0000)
struct AudioComponent_SetFloatParameter final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloat;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AudioComponent_SetFloatParameter) == 0x000004, "Wrong alignment on AudioComponent_SetFloatParameter");
static_assert(sizeof(AudioComponent_SetFloatParameter) == 0x000010, "Wrong size on AudioComponent_SetFloatParameter");
static_assert(offsetof(AudioComponent_SetFloatParameter, InName) == 0x000000, "Member 'AudioComponent_SetFloatParameter::InName' has a wrong offset!");
static_assert(offsetof(AudioComponent_SetFloatParameter, InFloat) == 0x000008, "Member 'AudioComponent_SetFloatParameter::InFloat' has a wrong offset!");

// Function Engine.AudioComponent.SetIgnoreForFlushing
// 0x0001 (0x0001 - 0x0000)
struct AudioComponent_SetIgnoreForFlushing final
{
public:
	bool                                          bInIgnoreForFlushing;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetIgnoreForFlushing) == 0x000001, "Wrong alignment on AudioComponent_SetIgnoreForFlushing");
static_assert(sizeof(AudioComponent_SetIgnoreForFlushing) == 0x000001, "Wrong size on AudioComponent_SetIgnoreForFlushing");
static_assert(offsetof(AudioComponent_SetIgnoreForFlushing, bInIgnoreForFlushing) == 0x000000, "Member 'AudioComponent_SetIgnoreForFlushing::bInIgnoreForFlushing' has a wrong offset!");

// Function Engine.AudioComponent.SetIntParameter
// 0x0010 (0x0010 - 0x0000)
struct AudioComponent_SetIntParameter final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InInt;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AudioComponent_SetIntParameter) == 0x000004, "Wrong alignment on AudioComponent_SetIntParameter");
static_assert(sizeof(AudioComponent_SetIntParameter) == 0x000010, "Wrong size on AudioComponent_SetIntParameter");
static_assert(offsetof(AudioComponent_SetIntParameter, InName) == 0x000000, "Member 'AudioComponent_SetIntParameter::InName' has a wrong offset!");
static_assert(offsetof(AudioComponent_SetIntParameter, InInt) == 0x000008, "Member 'AudioComponent_SetIntParameter::InInt' has a wrong offset!");

// Function Engine.AudioComponent.SetLowPassFilterEnabled
// 0x0001 (0x0001 - 0x0000)
struct AudioComponent_SetLowPassFilterEnabled final
{
public:
	bool                                          InLowPassFilterEnabled;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetLowPassFilterEnabled) == 0x000001, "Wrong alignment on AudioComponent_SetLowPassFilterEnabled");
static_assert(sizeof(AudioComponent_SetLowPassFilterEnabled) == 0x000001, "Wrong size on AudioComponent_SetLowPassFilterEnabled");
static_assert(offsetof(AudioComponent_SetLowPassFilterEnabled, InLowPassFilterEnabled) == 0x000000, "Member 'AudioComponent_SetLowPassFilterEnabled::InLowPassFilterEnabled' has a wrong offset!");

// Function Engine.AudioComponent.SetLowPassFilterFrequency
// 0x0004 (0x0004 - 0x0000)
struct AudioComponent_SetLowPassFilterFrequency final
{
public:
	float                                         InLowPassFilterFrequency;                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetLowPassFilterFrequency) == 0x000004, "Wrong alignment on AudioComponent_SetLowPassFilterFrequency");
static_assert(sizeof(AudioComponent_SetLowPassFilterFrequency) == 0x000004, "Wrong size on AudioComponent_SetLowPassFilterFrequency");
static_assert(offsetof(AudioComponent_SetLowPassFilterFrequency, InLowPassFilterFrequency) == 0x000000, "Member 'AudioComponent_SetLowPassFilterFrequency::InLowPassFilterFrequency' has a wrong offset!");

// Function Engine.AudioComponent.SetPaused
// 0x0001 (0x0001 - 0x0000)
struct AudioComponent_SetPaused final
{
public:
	bool                                          bPause;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetPaused) == 0x000001, "Wrong alignment on AudioComponent_SetPaused");
static_assert(sizeof(AudioComponent_SetPaused) == 0x000001, "Wrong size on AudioComponent_SetPaused");
static_assert(offsetof(AudioComponent_SetPaused, bPause) == 0x000000, "Member 'AudioComponent_SetPaused::bPause' has a wrong offset!");

// Function Engine.AudioComponent.SetPitchMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AudioComponent_SetPitchMultiplier final
{
public:
	float                                         NewPitchMultiplier;                                // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetPitchMultiplier) == 0x000004, "Wrong alignment on AudioComponent_SetPitchMultiplier");
static_assert(sizeof(AudioComponent_SetPitchMultiplier) == 0x000004, "Wrong size on AudioComponent_SetPitchMultiplier");
static_assert(offsetof(AudioComponent_SetPitchMultiplier, NewPitchMultiplier) == 0x000000, "Member 'AudioComponent_SetPitchMultiplier::NewPitchMultiplier' has a wrong offset!");

// Function Engine.AudioComponent.SetSound
// 0x0008 (0x0008 - 0x0000)
struct AudioComponent_SetSound final
{
public:
	class USoundBase*                             NewSound;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetSound) == 0x000008, "Wrong alignment on AudioComponent_SetSound");
static_assert(sizeof(AudioComponent_SetSound) == 0x000008, "Wrong size on AudioComponent_SetSound");
static_assert(offsetof(AudioComponent_SetSound, NewSound) == 0x000000, "Member 'AudioComponent_SetSound::NewSound' has a wrong offset!");

// Function Engine.AudioComponent.SetSubmixSend
// 0x0010 (0x0010 - 0x0000)
struct AudioComponent_SetSubmixSend final
{
public:
	class USoundSubmix*                           Submix;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AudioComponent_SetSubmixSend) == 0x000008, "Wrong alignment on AudioComponent_SetSubmixSend");
static_assert(sizeof(AudioComponent_SetSubmixSend) == 0x000010, "Wrong size on AudioComponent_SetSubmixSend");
static_assert(offsetof(AudioComponent_SetSubmixSend, Submix) == 0x000000, "Member 'AudioComponent_SetSubmixSend::Submix' has a wrong offset!");
static_assert(offsetof(AudioComponent_SetSubmixSend, SendLevel) == 0x000008, "Member 'AudioComponent_SetSubmixSend::SendLevel' has a wrong offset!");

// Function Engine.AudioComponent.SetUISound
// 0x0001 (0x0001 - 0x0000)
struct AudioComponent_SetUISound final
{
public:
	bool                                          bInUISound;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetUISound) == 0x000001, "Wrong alignment on AudioComponent_SetUISound");
static_assert(sizeof(AudioComponent_SetUISound) == 0x000001, "Wrong size on AudioComponent_SetUISound");
static_assert(offsetof(AudioComponent_SetUISound, bInUISound) == 0x000000, "Member 'AudioComponent_SetUISound::bInUISound' has a wrong offset!");

// Function Engine.AudioComponent.SetVolumeMultiplier
// 0x0004 (0x0004 - 0x0000)
struct AudioComponent_SetVolumeMultiplier final
{
public:
	float                                         NewVolumeMultiplier;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetVolumeMultiplier) == 0x000004, "Wrong alignment on AudioComponent_SetVolumeMultiplier");
static_assert(sizeof(AudioComponent_SetVolumeMultiplier) == 0x000004, "Wrong size on AudioComponent_SetVolumeMultiplier");
static_assert(offsetof(AudioComponent_SetVolumeMultiplier, NewVolumeMultiplier) == 0x000000, "Member 'AudioComponent_SetVolumeMultiplier::NewVolumeMultiplier' has a wrong offset!");

// Function Engine.AudioComponent.SetWaveParameter
// 0x0010 (0x0010 - 0x0000)
struct AudioComponent_SetWaveParameter final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundWave*                             InWave;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_SetWaveParameter) == 0x000008, "Wrong alignment on AudioComponent_SetWaveParameter");
static_assert(sizeof(AudioComponent_SetWaveParameter) == 0x000010, "Wrong size on AudioComponent_SetWaveParameter");
static_assert(offsetof(AudioComponent_SetWaveParameter, InName) == 0x000000, "Member 'AudioComponent_SetWaveParameter::InName' has a wrong offset!");
static_assert(offsetof(AudioComponent_SetWaveParameter, InWave) == 0x000008, "Member 'AudioComponent_SetWaveParameter::InWave' has a wrong offset!");

// Function Engine.AudioComponent.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct AudioComponent_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioComponent_IsPlaying) == 0x000001, "Wrong alignment on AudioComponent_IsPlaying");
static_assert(sizeof(AudioComponent_IsPlaying) == 0x000001, "Wrong size on AudioComponent_IsPlaying");
static_assert(offsetof(AudioComponent_IsPlaying, ReturnValue) == 0x000000, "Member 'AudioComponent_IsPlaying::ReturnValue' has a wrong offset!");

// Function Engine.AudioVolume.SetEnabled
// 0x0001 (0x0001 - 0x0000)
struct AudioVolume_SetEnabled final
{
public:
	bool                                          bNewEnabled;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioVolume_SetEnabled) == 0x000001, "Wrong alignment on AudioVolume_SetEnabled");
static_assert(sizeof(AudioVolume_SetEnabled) == 0x000001, "Wrong size on AudioVolume_SetEnabled");
static_assert(offsetof(AudioVolume_SetEnabled, bNewEnabled) == 0x000000, "Member 'AudioVolume_SetEnabled::bNewEnabled' has a wrong offset!");

// Function Engine.AudioVolume.SetInteriorSettings
// 0x0024 (0x0024 - 0x0000)
struct AudioVolume_SetInteriorSettings final
{
public:
	struct FInteriorSettings                      NewInteriorSettings;                               // 0x0000(0x0024)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioVolume_SetInteriorSettings) == 0x000004, "Wrong alignment on AudioVolume_SetInteriorSettings");
static_assert(sizeof(AudioVolume_SetInteriorSettings) == 0x000024, "Wrong size on AudioVolume_SetInteriorSettings");
static_assert(offsetof(AudioVolume_SetInteriorSettings, NewInteriorSettings) == 0x000000, "Member 'AudioVolume_SetInteriorSettings::NewInteriorSettings' has a wrong offset!");

// Function Engine.AudioVolume.SetPriority
// 0x0004 (0x0004 - 0x0000)
struct AudioVolume_SetPriority final
{
public:
	float                                         NewPriority;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioVolume_SetPriority) == 0x000004, "Wrong alignment on AudioVolume_SetPriority");
static_assert(sizeof(AudioVolume_SetPriority) == 0x000004, "Wrong size on AudioVolume_SetPriority");
static_assert(offsetof(AudioVolume_SetPriority, NewPriority) == 0x000000, "Member 'AudioVolume_SetPriority::NewPriority' has a wrong offset!");

// Function Engine.AudioVolume.SetReverbSettings
// 0x0018 (0x0018 - 0x0000)
struct AudioVolume_SetReverbSettings final
{
public:
	struct FReverbSettings                        NewReverbSettings;                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(AudioVolume_SetReverbSettings) == 0x000008, "Wrong alignment on AudioVolume_SetReverbSettings");
static_assert(sizeof(AudioVolume_SetReverbSettings) == 0x000018, "Wrong size on AudioVolume_SetReverbSettings");
static_assert(offsetof(AudioVolume_SetReverbSettings, NewReverbSettings) == 0x000000, "Member 'AudioVolume_SetReverbSettings::NewReverbSettings' has a wrong offset!");

// Function Engine.AvoidanceManager.GetAvoidanceVelocityForComponent
// 0x0018 (0x0018 - 0x0000)
struct AvoidanceManager_GetAvoidanceVelocityForComponent final
{
public:
	class UMovementComponent*                     MovementComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AvoidanceManager_GetAvoidanceVelocityForComponent) == 0x000008, "Wrong alignment on AvoidanceManager_GetAvoidanceVelocityForComponent");
static_assert(sizeof(AvoidanceManager_GetAvoidanceVelocityForComponent) == 0x000018, "Wrong size on AvoidanceManager_GetAvoidanceVelocityForComponent");
static_assert(offsetof(AvoidanceManager_GetAvoidanceVelocityForComponent, MovementComp) == 0x000000, "Member 'AvoidanceManager_GetAvoidanceVelocityForComponent::MovementComp' has a wrong offset!");
static_assert(offsetof(AvoidanceManager_GetAvoidanceVelocityForComponent, ReturnValue) == 0x000008, "Member 'AvoidanceManager_GetAvoidanceVelocityForComponent::ReturnValue' has a wrong offset!");

// Function Engine.AvoidanceManager.GetNewAvoidanceUID
// 0x0004 (0x0004 - 0x0000)
struct AvoidanceManager_GetNewAvoidanceUID final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvoidanceManager_GetNewAvoidanceUID) == 0x000004, "Wrong alignment on AvoidanceManager_GetNewAvoidanceUID");
static_assert(sizeof(AvoidanceManager_GetNewAvoidanceUID) == 0x000004, "Wrong size on AvoidanceManager_GetNewAvoidanceUID");
static_assert(offsetof(AvoidanceManager_GetNewAvoidanceUID, ReturnValue) == 0x000000, "Member 'AvoidanceManager_GetNewAvoidanceUID::ReturnValue' has a wrong offset!");

// Function Engine.AvoidanceManager.GetObjectCount
// 0x0004 (0x0004 - 0x0000)
struct AvoidanceManager_GetObjectCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(AvoidanceManager_GetObjectCount) == 0x000004, "Wrong alignment on AvoidanceManager_GetObjectCount");
static_assert(sizeof(AvoidanceManager_GetObjectCount) == 0x000004, "Wrong size on AvoidanceManager_GetObjectCount");
static_assert(offsetof(AvoidanceManager_GetObjectCount, ReturnValue) == 0x000000, "Member 'AvoidanceManager_GetObjectCount::ReturnValue' has a wrong offset!");

// Function Engine.AvoidanceManager.RegisterMovementComponent
// 0x0010 (0x0010 - 0x0000)
struct AvoidanceManager_RegisterMovementComponent final
{
public:
	class UMovementComponent*                     MovementComp;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AvoidanceWeight;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(AvoidanceManager_RegisterMovementComponent) == 0x000008, "Wrong alignment on AvoidanceManager_RegisterMovementComponent");
static_assert(sizeof(AvoidanceManager_RegisterMovementComponent) == 0x000010, "Wrong size on AvoidanceManager_RegisterMovementComponent");
static_assert(offsetof(AvoidanceManager_RegisterMovementComponent, MovementComp) == 0x000000, "Member 'AvoidanceManager_RegisterMovementComponent::MovementComp' has a wrong offset!");
static_assert(offsetof(AvoidanceManager_RegisterMovementComponent, AvoidanceWeight) == 0x000008, "Member 'AvoidanceManager_RegisterMovementComponent::AvoidanceWeight' has a wrong offset!");
static_assert(offsetof(AvoidanceManager_RegisterMovementComponent, ReturnValue) == 0x00000C, "Member 'AvoidanceManager_RegisterMovementComponent::ReturnValue' has a wrong offset!");

// Function Engine.BillboardComponent.SetSprite
// 0x0008 (0x0008 - 0x0000)
struct BillboardComponent_SetSprite final
{
public:
	class UTexture2D*                             NewSprite;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BillboardComponent_SetSprite) == 0x000008, "Wrong alignment on BillboardComponent_SetSprite");
static_assert(sizeof(BillboardComponent_SetSprite) == 0x000008, "Wrong size on BillboardComponent_SetSprite");
static_assert(offsetof(BillboardComponent_SetSprite, NewSprite) == 0x000000, "Member 'BillboardComponent_SetSprite::NewSprite' has a wrong offset!");

// Function Engine.BillboardComponent.SetSpriteAndUV
// 0x0018 (0x0018 - 0x0000)
struct BillboardComponent_SetSpriteAndUV final
{
public:
	class UTexture2D*                             NewSprite;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewU;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewUL;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewV;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewVL;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BillboardComponent_SetSpriteAndUV) == 0x000008, "Wrong alignment on BillboardComponent_SetSpriteAndUV");
static_assert(sizeof(BillboardComponent_SetSpriteAndUV) == 0x000018, "Wrong size on BillboardComponent_SetSpriteAndUV");
static_assert(offsetof(BillboardComponent_SetSpriteAndUV, NewSprite) == 0x000000, "Member 'BillboardComponent_SetSpriteAndUV::NewSprite' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetSpriteAndUV, NewU) == 0x000008, "Member 'BillboardComponent_SetSpriteAndUV::NewU' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetSpriteAndUV, NewUL) == 0x00000C, "Member 'BillboardComponent_SetSpriteAndUV::NewUL' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetSpriteAndUV, NewV) == 0x000010, "Member 'BillboardComponent_SetSpriteAndUV::NewV' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetSpriteAndUV, NewVL) == 0x000014, "Member 'BillboardComponent_SetSpriteAndUV::NewVL' has a wrong offset!");

// Function Engine.BillboardComponent.SetUV
// 0x0010 (0x0010 - 0x0000)
struct BillboardComponent_SetUV final
{
public:
	int32                                         NewU;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewUL;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewV;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NewVL;                                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BillboardComponent_SetUV) == 0x000004, "Wrong alignment on BillboardComponent_SetUV");
static_assert(sizeof(BillboardComponent_SetUV) == 0x000010, "Wrong size on BillboardComponent_SetUV");
static_assert(offsetof(BillboardComponent_SetUV, NewU) == 0x000000, "Member 'BillboardComponent_SetUV::NewU' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetUV, NewUL) == 0x000004, "Member 'BillboardComponent_SetUV::NewUL' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetUV, NewV) == 0x000008, "Member 'BillboardComponent_SetUV::NewV' has a wrong offset!");
static_assert(offsetof(BillboardComponent_SetUV, NewVL) == 0x00000C, "Member 'BillboardComponent_SetUV::NewVL' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Add
// 0x0058 (0x0058 - 0x0000)
struct BlueprintMapLibrary_Map_Add final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Key;                                               // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0054(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintMapLibrary_Map_Add) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Add");
static_assert(sizeof(BlueprintMapLibrary_Map_Add) == 0x000058, "Wrong size on BlueprintMapLibrary_Map_Add");
static_assert(offsetof(BlueprintMapLibrary_Map_Add, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Add::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Add, Key) == 0x000050, "Member 'BlueprintMapLibrary_Map_Add::Key' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Add, Value) == 0x000054, "Member 'BlueprintMapLibrary_Map_Add::Value' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Clear
// 0x0050 (0x0050 - 0x0000)
struct BlueprintMapLibrary_Map_Clear final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintMapLibrary_Map_Clear) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Clear");
static_assert(sizeof(BlueprintMapLibrary_Map_Clear) == 0x000050, "Wrong size on BlueprintMapLibrary_Map_Clear");
static_assert(offsetof(BlueprintMapLibrary_Map_Clear, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Clear::TargetMap' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Contains
// 0x0058 (0x0058 - 0x0000)
struct BlueprintMapLibrary_Map_Contains final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Key;                                               // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0054(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintMapLibrary_Map_Contains) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Contains");
static_assert(sizeof(BlueprintMapLibrary_Map_Contains) == 0x000058, "Wrong size on BlueprintMapLibrary_Map_Contains");
static_assert(offsetof(BlueprintMapLibrary_Map_Contains, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Contains::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Contains, Key) == 0x000050, "Member 'BlueprintMapLibrary_Map_Contains::Key' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Contains, ReturnValue) == 0x000054, "Member 'BlueprintMapLibrary_Map_Contains::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Find
// 0x0060 (0x0060 - 0x0000)
struct BlueprintMapLibrary_Map_Find final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Key;                                               // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0054(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintMapLibrary_Map_Find) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Find");
static_assert(sizeof(BlueprintMapLibrary_Map_Find) == 0x000060, "Wrong size on BlueprintMapLibrary_Map_Find");
static_assert(offsetof(BlueprintMapLibrary_Map_Find, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Find::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Find, Key) == 0x000050, "Member 'BlueprintMapLibrary_Map_Find::Key' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Find, Value) == 0x000054, "Member 'BlueprintMapLibrary_Map_Find::Value' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Find, ReturnValue) == 0x000058, "Member 'BlueprintMapLibrary_Map_Find::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Keys
// 0x0060 (0x0060 - 0x0000)
struct BlueprintMapLibrary_Map_Keys final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Keys;                                              // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintMapLibrary_Map_Keys) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Keys");
static_assert(sizeof(BlueprintMapLibrary_Map_Keys) == 0x000060, "Wrong size on BlueprintMapLibrary_Map_Keys");
static_assert(offsetof(BlueprintMapLibrary_Map_Keys, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Keys::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Keys, Keys) == 0x000050, "Member 'BlueprintMapLibrary_Map_Keys::Keys' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Length
// 0x0058 (0x0058 - 0x0000)
struct BlueprintMapLibrary_Map_Length final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintMapLibrary_Map_Length) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Length");
static_assert(sizeof(BlueprintMapLibrary_Map_Length) == 0x000058, "Wrong size on BlueprintMapLibrary_Map_Length");
static_assert(offsetof(BlueprintMapLibrary_Map_Length, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Length::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Length, ReturnValue) == 0x000050, "Member 'BlueprintMapLibrary_Map_Length::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Remove
// 0x0058 (0x0058 - 0x0000)
struct BlueprintMapLibrary_Map_Remove final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Key;                                               // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0054(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintMapLibrary_Map_Remove) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Remove");
static_assert(sizeof(BlueprintMapLibrary_Map_Remove) == 0x000058, "Wrong size on BlueprintMapLibrary_Map_Remove");
static_assert(offsetof(BlueprintMapLibrary_Map_Remove, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Remove::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Remove, Key) == 0x000050, "Member 'BlueprintMapLibrary_Map_Remove::Key' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Remove, ReturnValue) == 0x000054, "Member 'BlueprintMapLibrary_Map_Remove::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.Map_Values
// 0x0060 (0x0060 - 0x0000)
struct BlueprintMapLibrary_Map_Values final
{
public:
	TMap<int32, int32>                            TargetMap;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Values;                                            // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintMapLibrary_Map_Values) == 0x000008, "Wrong alignment on BlueprintMapLibrary_Map_Values");
static_assert(sizeof(BlueprintMapLibrary_Map_Values) == 0x000060, "Wrong size on BlueprintMapLibrary_Map_Values");
static_assert(offsetof(BlueprintMapLibrary_Map_Values, TargetMap) == 0x000000, "Member 'BlueprintMapLibrary_Map_Values::TargetMap' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_Map_Values, Values) == 0x000050, "Member 'BlueprintMapLibrary_Map_Values::Values' has a wrong offset!");

// Function Engine.BlueprintMapLibrary.SetMapPropertyByName
// 0x0060 (0x0060 - 0x0000)
struct BlueprintMapLibrary_SetMapPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<int32, int32>                            Value;                                             // 0x0010(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintMapLibrary_SetMapPropertyByName) == 0x000008, "Wrong alignment on BlueprintMapLibrary_SetMapPropertyByName");
static_assert(sizeof(BlueprintMapLibrary_SetMapPropertyByName) == 0x000060, "Wrong size on BlueprintMapLibrary_SetMapPropertyByName");
static_assert(offsetof(BlueprintMapLibrary_SetMapPropertyByName, Object) == 0x000000, "Member 'BlueprintMapLibrary_SetMapPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_SetMapPropertyByName, PropertyName) == 0x000008, "Member 'BlueprintMapLibrary_SetMapPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(BlueprintMapLibrary_SetMapPropertyByName, Value) == 0x000010, "Member 'BlueprintMapLibrary_SetMapPropertyByName::Value' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.CancelLocalNotification
// 0x0010 (0x0010 - 0x0000)
struct BlueprintPlatformLibrary_CancelLocalNotification final
{
public:
	class FString                                 ActivationEvent;                                   // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintPlatformLibrary_CancelLocalNotification) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_CancelLocalNotification");
static_assert(sizeof(BlueprintPlatformLibrary_CancelLocalNotification) == 0x000010, "Wrong size on BlueprintPlatformLibrary_CancelLocalNotification");
static_assert(offsetof(BlueprintPlatformLibrary_CancelLocalNotification, ActivationEvent) == 0x000000, "Member 'BlueprintPlatformLibrary_CancelLocalNotification::ActivationEvent' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.GetLaunchNotification
// 0x0020 (0x0020 - 0x0000)
struct BlueprintPlatformLibrary_GetLaunchNotification final
{
public:
	bool                                          NotificationLaunchedApp;                           // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActivationEvent;                                   // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FireDate;                                          // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintPlatformLibrary_GetLaunchNotification) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_GetLaunchNotification");
static_assert(sizeof(BlueprintPlatformLibrary_GetLaunchNotification) == 0x000020, "Wrong size on BlueprintPlatformLibrary_GetLaunchNotification");
static_assert(offsetof(BlueprintPlatformLibrary_GetLaunchNotification, NotificationLaunchedApp) == 0x000000, "Member 'BlueprintPlatformLibrary_GetLaunchNotification::NotificationLaunchedApp' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_GetLaunchNotification, ActivationEvent) == 0x000008, "Member 'BlueprintPlatformLibrary_GetLaunchNotification::ActivationEvent' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_GetLaunchNotification, FireDate) == 0x000018, "Member 'BlueprintPlatformLibrary_GetLaunchNotification::FireDate' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationAtTime
// 0x0068 (0x0068 - 0x0000)
struct BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime final
{
public:
	struct FDateTime                              FireDateTime;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocalTime;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0028(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Action;                                            // 0x0040(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ActivationEvent;                                   // 0x0058(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime");
static_assert(sizeof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime) == 0x000068, "Wrong size on BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, FireDateTime) == 0x000000, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::FireDateTime' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, LocalTime) == 0x000008, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::LocalTime' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, Title) == 0x000010, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::Title' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, Body) == 0x000028, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::Body' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, Action) == 0x000040, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::Action' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime, ActivationEvent) == 0x000058, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationAtTime::ActivationEvent' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeAtTime
// 0x0020 (0x0020 - 0x0000)
struct BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime final
{
public:
	struct FDateTime                              FireDateTime;                                      // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          LocalTime;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActivationEvent;                                   // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime");
static_assert(sizeof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime) == 0x000020, "Wrong size on BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime, FireDateTime) == 0x000000, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime::FireDateTime' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime, LocalTime) == 0x000008, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime::LocalTime' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime, ActivationEvent) == 0x000010, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeAtTime::ActivationEvent' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationBadgeFromNow
// 0x0018 (0x0018 - 0x0000)
struct BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow final
{
public:
	int32                                         InSecondsFromNow;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ActivationEvent;                                   // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow");
static_assert(sizeof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow) == 0x000018, "Wrong size on BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow, InSecondsFromNow) == 0x000000, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow::InSecondsFromNow' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow, ActivationEvent) == 0x000008, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationBadgeFromNow::ActivationEvent' has a wrong offset!");

// Function Engine.BlueprintPlatformLibrary.ScheduleLocalNotificationFromNow
// 0x0060 (0x0060 - 0x0000)
struct BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow final
{
public:
	int32                                         InSecondsFromNow;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   Title;                                             // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Body;                                              // 0x0020(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   Action;                                            // 0x0038(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ActivationEvent;                                   // 0x0050(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow) == 0x000008, "Wrong alignment on BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow");
static_assert(sizeof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow) == 0x000060, "Wrong size on BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow, InSecondsFromNow) == 0x000000, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow::InSecondsFromNow' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow, Title) == 0x000008, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow::Title' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow, Body) == 0x000020, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow::Body' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow, Action) == 0x000038, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow::Action' has a wrong offset!");
static_assert(offsetof(BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow, ActivationEvent) == 0x000050, "Member 'BlueprintPlatformLibrary_ScheduleLocalNotificationFromNow::ActivationEvent' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Add
// 0x0058 (0x0058 - 0x0000)
struct BlueprintSetLibrary_Set_Add final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         NewItem;                                           // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintSetLibrary_Set_Add) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Add");
static_assert(sizeof(BlueprintSetLibrary_Set_Add) == 0x000058, "Wrong size on BlueprintSetLibrary_Set_Add");
static_assert(offsetof(BlueprintSetLibrary_Set_Add, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_Add::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Add, NewItem) == 0x000050, "Member 'BlueprintSetLibrary_Set_Add::NewItem' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_AddItems
// 0x0060 (0x0060 - 0x0000)
struct BlueprintSetLibrary_Set_AddItems final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 NewItems;                                          // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_AddItems) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_AddItems");
static_assert(sizeof(BlueprintSetLibrary_Set_AddItems) == 0x000060, "Wrong size on BlueprintSetLibrary_Set_AddItems");
static_assert(offsetof(BlueprintSetLibrary_Set_AddItems, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_AddItems::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_AddItems, NewItems) == 0x000050, "Member 'BlueprintSetLibrary_Set_AddItems::NewItems' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Clear
// 0x0050 (0x0050 - 0x0000)
struct BlueprintSetLibrary_Set_Clear final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_Clear) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Clear");
static_assert(sizeof(BlueprintSetLibrary_Set_Clear) == 0x000050, "Wrong size on BlueprintSetLibrary_Set_Clear");
static_assert(offsetof(BlueprintSetLibrary_Set_Clear, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_Clear::TargetSet' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Contains
// 0x0058 (0x0058 - 0x0000)
struct BlueprintSetLibrary_Set_Contains final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ItemToFind;                                        // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0054(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintSetLibrary_Set_Contains) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Contains");
static_assert(sizeof(BlueprintSetLibrary_Set_Contains) == 0x000058, "Wrong size on BlueprintSetLibrary_Set_Contains");
static_assert(offsetof(BlueprintSetLibrary_Set_Contains, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_Contains::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Contains, ItemToFind) == 0x000050, "Member 'BlueprintSetLibrary_Set_Contains::ItemToFind' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Contains, ReturnValue) == 0x000054, "Member 'BlueprintSetLibrary_Set_Contains::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Difference
// 0x00F0 (0x00F0 - 0x0000)
struct BlueprintSetLibrary_Set_Difference final
{
public:
	TSet<int32>                                   A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   Result;                                            // 0x00A0(0x0050)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_Difference) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Difference");
static_assert(sizeof(BlueprintSetLibrary_Set_Difference) == 0x0000F0, "Wrong size on BlueprintSetLibrary_Set_Difference");
static_assert(offsetof(BlueprintSetLibrary_Set_Difference, A) == 0x000000, "Member 'BlueprintSetLibrary_Set_Difference::A' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Difference, B) == 0x000050, "Member 'BlueprintSetLibrary_Set_Difference::B' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Difference, Result) == 0x0000A0, "Member 'BlueprintSetLibrary_Set_Difference::Result' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Intersection
// 0x00F0 (0x00F0 - 0x0000)
struct BlueprintSetLibrary_Set_Intersection final
{
public:
	TSet<int32>                                   A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   Result;                                            // 0x00A0(0x0050)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_Intersection) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Intersection");
static_assert(sizeof(BlueprintSetLibrary_Set_Intersection) == 0x0000F0, "Wrong size on BlueprintSetLibrary_Set_Intersection");
static_assert(offsetof(BlueprintSetLibrary_Set_Intersection, A) == 0x000000, "Member 'BlueprintSetLibrary_Set_Intersection::A' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Intersection, B) == 0x000050, "Member 'BlueprintSetLibrary_Set_Intersection::B' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Intersection, Result) == 0x0000A0, "Member 'BlueprintSetLibrary_Set_Intersection::Result' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Length
// 0x0058 (0x0058 - 0x0000)
struct BlueprintSetLibrary_Set_Length final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0050(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintSetLibrary_Set_Length) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Length");
static_assert(sizeof(BlueprintSetLibrary_Set_Length) == 0x000058, "Wrong size on BlueprintSetLibrary_Set_Length");
static_assert(offsetof(BlueprintSetLibrary_Set_Length, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_Length::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Length, ReturnValue) == 0x000050, "Member 'BlueprintSetLibrary_Set_Length::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Remove
// 0x0058 (0x0058 - 0x0000)
struct BlueprintSetLibrary_Set_Remove final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         Item;                                              // 0x0050(0x0004)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0054(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_55[0x3];                                       // 0x0055(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(BlueprintSetLibrary_Set_Remove) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Remove");
static_assert(sizeof(BlueprintSetLibrary_Set_Remove) == 0x000058, "Wrong size on BlueprintSetLibrary_Set_Remove");
static_assert(offsetof(BlueprintSetLibrary_Set_Remove, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_Remove::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Remove, Item) == 0x000050, "Member 'BlueprintSetLibrary_Set_Remove::Item' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Remove, ReturnValue) == 0x000054, "Member 'BlueprintSetLibrary_Set_Remove::ReturnValue' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_RemoveItems
// 0x0060 (0x0060 - 0x0000)
struct BlueprintSetLibrary_Set_RemoveItems final
{
public:
	TSet<int32>                                   TargetSet;                                         // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Items;                                             // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_RemoveItems) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_RemoveItems");
static_assert(sizeof(BlueprintSetLibrary_Set_RemoveItems) == 0x000060, "Wrong size on BlueprintSetLibrary_Set_RemoveItems");
static_assert(offsetof(BlueprintSetLibrary_Set_RemoveItems, TargetSet) == 0x000000, "Member 'BlueprintSetLibrary_Set_RemoveItems::TargetSet' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_RemoveItems, Items) == 0x000050, "Member 'BlueprintSetLibrary_Set_RemoveItems::Items' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_ToArray
// 0x0060 (0x0060 - 0x0000)
struct BlueprintSetLibrary_Set_ToArray final
{
public:
	TSet<int32>                                   A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<int32>                                 Result;                                            // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_ToArray) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_ToArray");
static_assert(sizeof(BlueprintSetLibrary_Set_ToArray) == 0x000060, "Wrong size on BlueprintSetLibrary_Set_ToArray");
static_assert(offsetof(BlueprintSetLibrary_Set_ToArray, A) == 0x000000, "Member 'BlueprintSetLibrary_Set_ToArray::A' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_ToArray, Result) == 0x000050, "Member 'BlueprintSetLibrary_Set_ToArray::Result' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.Set_Union
// 0x00F0 (0x00F0 - 0x0000)
struct BlueprintSetLibrary_Set_Union final
{
public:
	TSet<int32>                                   A;                                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   B;                                                 // 0x0050(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TSet<int32>                                   Result;                                            // 0x00A0(0x0050)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_Set_Union) == 0x000008, "Wrong alignment on BlueprintSetLibrary_Set_Union");
static_assert(sizeof(BlueprintSetLibrary_Set_Union) == 0x0000F0, "Wrong size on BlueprintSetLibrary_Set_Union");
static_assert(offsetof(BlueprintSetLibrary_Set_Union, A) == 0x000000, "Member 'BlueprintSetLibrary_Set_Union::A' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Union, B) == 0x000050, "Member 'BlueprintSetLibrary_Set_Union::B' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_Set_Union, Result) == 0x0000A0, "Member 'BlueprintSetLibrary_Set_Union::Result' has a wrong offset!");

// Function Engine.BlueprintSetLibrary.SetSetPropertyByName
// 0x0060 (0x0060 - 0x0000)
struct BlueprintSetLibrary_SetSetPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSet<int32>                                   Value;                                             // 0x0010(0x0050)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(BlueprintSetLibrary_SetSetPropertyByName) == 0x000008, "Wrong alignment on BlueprintSetLibrary_SetSetPropertyByName");
static_assert(sizeof(BlueprintSetLibrary_SetSetPropertyByName) == 0x000060, "Wrong size on BlueprintSetLibrary_SetSetPropertyByName");
static_assert(offsetof(BlueprintSetLibrary_SetSetPropertyByName, Object) == 0x000000, "Member 'BlueprintSetLibrary_SetSetPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_SetSetPropertyByName, PropertyName) == 0x000008, "Member 'BlueprintSetLibrary_SetSetPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(BlueprintSetLibrary_SetSetPropertyByName, Value) == 0x000010, "Member 'BlueprintSetLibrary_SetSetPropertyByName::Value' has a wrong offset!");

// Function Engine.SpringArmComponent.GetTargetRotation
// 0x000C (0x000C - 0x0000)
struct SpringArmComponent_GetTargetRotation final
{
public:
	struct FRotator                               ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpringArmComponent_GetTargetRotation) == 0x000004, "Wrong alignment on SpringArmComponent_GetTargetRotation");
static_assert(sizeof(SpringArmComponent_GetTargetRotation) == 0x00000C, "Wrong size on SpringArmComponent_GetTargetRotation");
static_assert(offsetof(SpringArmComponent_GetTargetRotation, ReturnValue) == 0x000000, "Member 'SpringArmComponent_GetTargetRotation::ReturnValue' has a wrong offset!");

// Function Engine.CameraAnimInst.SetDuration
// 0x0004 (0x0004 - 0x0000)
struct CameraAnimInst_SetDuration final
{
public:
	float                                         NewDuration;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraAnimInst_SetDuration) == 0x000004, "Wrong alignment on CameraAnimInst_SetDuration");
static_assert(sizeof(CameraAnimInst_SetDuration) == 0x000004, "Wrong size on CameraAnimInst_SetDuration");
static_assert(offsetof(CameraAnimInst_SetDuration, NewDuration) == 0x000000, "Member 'CameraAnimInst_SetDuration::NewDuration' has a wrong offset!");

// Function Engine.CameraAnimInst.SetScale
// 0x0004 (0x0004 - 0x0000)
struct CameraAnimInst_SetScale final
{
public:
	float                                         NewDuration;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraAnimInst_SetScale) == 0x000004, "Wrong alignment on CameraAnimInst_SetScale");
static_assert(sizeof(CameraAnimInst_SetScale) == 0x000004, "Wrong size on CameraAnimInst_SetScale");
static_assert(offsetof(CameraAnimInst_SetScale, NewDuration) == 0x000000, "Member 'CameraAnimInst_SetScale::NewDuration' has a wrong offset!");

// Function Engine.CameraAnimInst.Stop
// 0x0001 (0x0001 - 0x0000)
struct CameraAnimInst_Stop final
{
public:
	bool                                          bImmediate;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraAnimInst_Stop) == 0x000001, "Wrong alignment on CameraAnimInst_Stop");
static_assert(sizeof(CameraAnimInst_Stop) == 0x000001, "Wrong size on CameraAnimInst_Stop");
static_assert(offsetof(CameraAnimInst_Stop, bImmediate) == 0x000000, "Member 'CameraAnimInst_Stop::bImmediate' has a wrong offset!");

// Function Engine.CameraShake.BlueprintUpdateCameraShake
// 0x0AB0 (0x0AB0 - 0x0000)
struct CameraShake_BlueprintUpdateCameraShake final
{
public:
	float                                         DeltaTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FMinimalViewInfo                       POV;                                               // 0x0010(0x0550)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FMinimalViewInfo                       ModifiedPOV;                                       // 0x0560(0x0550)(Parm, OutParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraShake_BlueprintUpdateCameraShake) == 0x000010, "Wrong alignment on CameraShake_BlueprintUpdateCameraShake");
static_assert(sizeof(CameraShake_BlueprintUpdateCameraShake) == 0x000AB0, "Wrong size on CameraShake_BlueprintUpdateCameraShake");
static_assert(offsetof(CameraShake_BlueprintUpdateCameraShake, DeltaTime) == 0x000000, "Member 'CameraShake_BlueprintUpdateCameraShake::DeltaTime' has a wrong offset!");
static_assert(offsetof(CameraShake_BlueprintUpdateCameraShake, Alpha) == 0x000004, "Member 'CameraShake_BlueprintUpdateCameraShake::Alpha' has a wrong offset!");
static_assert(offsetof(CameraShake_BlueprintUpdateCameraShake, POV) == 0x000010, "Member 'CameraShake_BlueprintUpdateCameraShake::POV' has a wrong offset!");
static_assert(offsetof(CameraShake_BlueprintUpdateCameraShake, ModifiedPOV) == 0x000560, "Member 'CameraShake_BlueprintUpdateCameraShake::ModifiedPOV' has a wrong offset!");

// Function Engine.CameraShake.ReceivePlayShake
// 0x0004 (0x0004 - 0x0000)
struct CameraShake_ReceivePlayShake final
{
public:
	float                                         Scale;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraShake_ReceivePlayShake) == 0x000004, "Wrong alignment on CameraShake_ReceivePlayShake");
static_assert(sizeof(CameraShake_ReceivePlayShake) == 0x000004, "Wrong size on CameraShake_ReceivePlayShake");
static_assert(offsetof(CameraShake_ReceivePlayShake, Scale) == 0x000000, "Member 'CameraShake_ReceivePlayShake::Scale' has a wrong offset!");

// Function Engine.CameraShake.ReceiveStopShake
// 0x0001 (0x0001 - 0x0000)
struct CameraShake_ReceiveStopShake final
{
public:
	bool                                          bImmediately;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraShake_ReceiveStopShake) == 0x000001, "Wrong alignment on CameraShake_ReceiveStopShake");
static_assert(sizeof(CameraShake_ReceiveStopShake) == 0x000001, "Wrong size on CameraShake_ReceiveStopShake");
static_assert(offsetof(CameraShake_ReceiveStopShake, bImmediately) == 0x000000, "Member 'CameraShake_ReceiveStopShake::bImmediately' has a wrong offset!");

// Function Engine.CameraShake.ReceiveIsFinished
// 0x0001 (0x0001 - 0x0000)
struct CameraShake_ReceiveIsFinished final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CameraShake_ReceiveIsFinished) == 0x000001, "Wrong alignment on CameraShake_ReceiveIsFinished");
static_assert(sizeof(CameraShake_ReceiveIsFinished) == 0x000001, "Wrong size on CameraShake_ReceiveIsFinished");
static_assert(offsetof(CameraShake_ReceiveIsFinished, ReturnValue) == 0x000000, "Member 'CameraShake_ReceiveIsFinished::ReturnValue' has a wrong offset!");

// Function Engine.Canvas.K2_Deproject
// 0x0020 (0x0020 - 0x0000)
struct Canvas_K2_Deproject final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldOrigin;                                       // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_Deproject) == 0x000004, "Wrong alignment on Canvas_K2_Deproject");
static_assert(sizeof(Canvas_K2_Deproject) == 0x000020, "Wrong size on Canvas_K2_Deproject");
static_assert(offsetof(Canvas_K2_Deproject, ScreenPosition) == 0x000000, "Member 'Canvas_K2_Deproject::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_Deproject, WorldOrigin) == 0x000008, "Member 'Canvas_K2_Deproject::WorldOrigin' has a wrong offset!");
static_assert(offsetof(Canvas_K2_Deproject, WorldDirection) == 0x000014, "Member 'Canvas_K2_Deproject::WorldDirection' has a wrong offset!");

// Function Engine.Canvas.K2_DrawBorder
// 0x0088 (0x0088 - 0x0000)
struct Canvas_K2_DrawBorder final
{
public:
	class UTexture*                               BorderTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               BackgroundTexture;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               LeftBorderTexture;                                 // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               RightBorderTexture;                                // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               TopBorderTexture;                                  // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               BottomBorderTexture;                               // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0030(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0038(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinatePosition;                                // 0x0040(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinateSize;                                    // 0x0048(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderColor;                                       // 0x0050(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BorderScale;                                       // 0x0060(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              BackgroundScale;                                   // 0x0068(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0070(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PivotPoint;                                        // 0x0074(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CornerSize;                                        // 0x007C(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_84[0x4];                                       // 0x0084(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Canvas_K2_DrawBorder) == 0x000008, "Wrong alignment on Canvas_K2_DrawBorder");
static_assert(sizeof(Canvas_K2_DrawBorder) == 0x000088, "Wrong size on Canvas_K2_DrawBorder");
static_assert(offsetof(Canvas_K2_DrawBorder, BorderTexture) == 0x000000, "Member 'Canvas_K2_DrawBorder::BorderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, BackgroundTexture) == 0x000008, "Member 'Canvas_K2_DrawBorder::BackgroundTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, LeftBorderTexture) == 0x000010, "Member 'Canvas_K2_DrawBorder::LeftBorderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, RightBorderTexture) == 0x000018, "Member 'Canvas_K2_DrawBorder::RightBorderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, TopBorderTexture) == 0x000020, "Member 'Canvas_K2_DrawBorder::TopBorderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, BottomBorderTexture) == 0x000028, "Member 'Canvas_K2_DrawBorder::BottomBorderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, ScreenPosition) == 0x000030, "Member 'Canvas_K2_DrawBorder::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, ScreenSize) == 0x000038, "Member 'Canvas_K2_DrawBorder::ScreenSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, CoordinatePosition) == 0x000040, "Member 'Canvas_K2_DrawBorder::CoordinatePosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, CoordinateSize) == 0x000048, "Member 'Canvas_K2_DrawBorder::CoordinateSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, RenderColor) == 0x000050, "Member 'Canvas_K2_DrawBorder::RenderColor' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, BorderScale) == 0x000060, "Member 'Canvas_K2_DrawBorder::BorderScale' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, BackgroundScale) == 0x000068, "Member 'Canvas_K2_DrawBorder::BackgroundScale' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, Rotation) == 0x000070, "Member 'Canvas_K2_DrawBorder::Rotation' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, PivotPoint) == 0x000074, "Member 'Canvas_K2_DrawBorder::PivotPoint' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBorder, CornerSize) == 0x00007C, "Member 'Canvas_K2_DrawBorder::CornerSize' has a wrong offset!");

// Function Engine.Canvas.K2_DrawBox
// 0x0014 (0x0014 - 0x0000)
struct Canvas_K2_DrawBox final
{
public:
	struct FVector2D                              ScreenPosition;                                    // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawBox) == 0x000004, "Wrong alignment on Canvas_K2_DrawBox");
static_assert(sizeof(Canvas_K2_DrawBox) == 0x000014, "Wrong size on Canvas_K2_DrawBox");
static_assert(offsetof(Canvas_K2_DrawBox, ScreenPosition) == 0x000000, "Member 'Canvas_K2_DrawBox::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBox, ScreenSize) == 0x000008, "Member 'Canvas_K2_DrawBox::ScreenSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawBox, Thickness) == 0x000010, "Member 'Canvas_K2_DrawBox::Thickness' has a wrong offset!");

// Function Engine.Canvas.K2_DrawLine
// 0x0024 (0x0024 - 0x0000)
struct Canvas_K2_DrawLine final
{
public:
	struct FVector2D                              ScreenPositionA;                                   // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPositionB;                                   // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderColor;                                       // 0x0014(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawLine) == 0x000004, "Wrong alignment on Canvas_K2_DrawLine");
static_assert(sizeof(Canvas_K2_DrawLine) == 0x000024, "Wrong size on Canvas_K2_DrawLine");
static_assert(offsetof(Canvas_K2_DrawLine, ScreenPositionA) == 0x000000, "Member 'Canvas_K2_DrawLine::ScreenPositionA' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawLine, ScreenPositionB) == 0x000008, "Member 'Canvas_K2_DrawLine::ScreenPositionB' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawLine, Thickness) == 0x000010, "Member 'Canvas_K2_DrawLine::Thickness' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawLine, RenderColor) == 0x000014, "Member 'Canvas_K2_DrawLine::RenderColor' has a wrong offset!");

// Function Engine.Canvas.K2_DrawMaterial
// 0x0038 (0x0038 - 0x0000)
struct Canvas_K2_DrawMaterial final
{
public:
	class UMaterialInterface*                     RenderMaterial;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinatePosition;                                // 0x0018(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinateSize;                                    // 0x0020(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Rotation;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PivotPoint;                                        // 0x002C(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Canvas_K2_DrawMaterial) == 0x000008, "Wrong alignment on Canvas_K2_DrawMaterial");
static_assert(sizeof(Canvas_K2_DrawMaterial) == 0x000038, "Wrong size on Canvas_K2_DrawMaterial");
static_assert(offsetof(Canvas_K2_DrawMaterial, RenderMaterial) == 0x000000, "Member 'Canvas_K2_DrawMaterial::RenderMaterial' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, ScreenPosition) == 0x000008, "Member 'Canvas_K2_DrawMaterial::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, ScreenSize) == 0x000010, "Member 'Canvas_K2_DrawMaterial::ScreenSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, CoordinatePosition) == 0x000018, "Member 'Canvas_K2_DrawMaterial::CoordinatePosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, CoordinateSize) == 0x000020, "Member 'Canvas_K2_DrawMaterial::CoordinateSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, Rotation) == 0x000028, "Member 'Canvas_K2_DrawMaterial::Rotation' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterial, PivotPoint) == 0x00002C, "Member 'Canvas_K2_DrawMaterial::PivotPoint' has a wrong offset!");

// Function Engine.Canvas.K2_DrawMaterialTriangle
// 0x0018 (0x0018 - 0x0000)
struct Canvas_K2_DrawMaterialTriangle final
{
public:
	class UMaterialInterface*                     RenderMaterial;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCanvasUVTri>                   Triangles;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawMaterialTriangle) == 0x000008, "Wrong alignment on Canvas_K2_DrawMaterialTriangle");
static_assert(sizeof(Canvas_K2_DrawMaterialTriangle) == 0x000018, "Wrong size on Canvas_K2_DrawMaterialTriangle");
static_assert(offsetof(Canvas_K2_DrawMaterialTriangle, RenderMaterial) == 0x000000, "Member 'Canvas_K2_DrawMaterialTriangle::RenderMaterial' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawMaterialTriangle, Triangles) == 0x000008, "Member 'Canvas_K2_DrawMaterialTriangle::Triangles' has a wrong offset!");

// Function Engine.Canvas.K2_DrawPolygon
// 0x0030 (0x0030 - 0x0000)
struct Canvas_K2_DrawPolygon final
{
public:
	class UTexture*                               RenderTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Radius;                                            // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumberOfSides;                                     // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderColor;                                       // 0x001C(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(Canvas_K2_DrawPolygon) == 0x000008, "Wrong alignment on Canvas_K2_DrawPolygon");
static_assert(sizeof(Canvas_K2_DrawPolygon) == 0x000030, "Wrong size on Canvas_K2_DrawPolygon");
static_assert(offsetof(Canvas_K2_DrawPolygon, RenderTexture) == 0x000000, "Member 'Canvas_K2_DrawPolygon::RenderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawPolygon, ScreenPosition) == 0x000008, "Member 'Canvas_K2_DrawPolygon::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawPolygon, Radius) == 0x000010, "Member 'Canvas_K2_DrawPolygon::Radius' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawPolygon, NumberOfSides) == 0x000018, "Member 'Canvas_K2_DrawPolygon::NumberOfSides' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawPolygon, RenderColor) == 0x00001C, "Member 'Canvas_K2_DrawPolygon::RenderColor' has a wrong offset!");

// Function Engine.Canvas.K2_DrawText
// 0x0060 (0x0060 - 0x0000)
struct Canvas_K2_DrawText final
{
public:
	class UFont*                                  RenderFont;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RenderText;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0018(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderColor;                                       // 0x0020(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Kerning;                                           // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ShadowColor;                                       // 0x0034(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ShadowOffset;                                      // 0x0044(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCentreX;                                          // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCentreY;                                          // 0x004D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOutlined;                                         // 0x004E(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4F[0x1];                                       // 0x004F(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           OutlineColor;                                      // 0x0050(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawText) == 0x000008, "Wrong alignment on Canvas_K2_DrawText");
static_assert(sizeof(Canvas_K2_DrawText) == 0x000060, "Wrong size on Canvas_K2_DrawText");
static_assert(offsetof(Canvas_K2_DrawText, RenderFont) == 0x000000, "Member 'Canvas_K2_DrawText::RenderFont' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, RenderText) == 0x000008, "Member 'Canvas_K2_DrawText::RenderText' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, ScreenPosition) == 0x000018, "Member 'Canvas_K2_DrawText::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, RenderColor) == 0x000020, "Member 'Canvas_K2_DrawText::RenderColor' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, Kerning) == 0x000030, "Member 'Canvas_K2_DrawText::Kerning' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, ShadowColor) == 0x000034, "Member 'Canvas_K2_DrawText::ShadowColor' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, ShadowOffset) == 0x000044, "Member 'Canvas_K2_DrawText::ShadowOffset' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, bCentreX) == 0x00004C, "Member 'Canvas_K2_DrawText::bCentreX' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, bCentreY) == 0x00004D, "Member 'Canvas_K2_DrawText::bCentreY' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, bOutlined) == 0x00004E, "Member 'Canvas_K2_DrawText::bOutlined' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawText, OutlineColor) == 0x000050, "Member 'Canvas_K2_DrawText::OutlineColor' has a wrong offset!");

// Function Engine.Canvas.K2_DrawTexture
// 0x0048 (0x0048 - 0x0000)
struct Canvas_K2_DrawTexture final
{
public:
	class UTexture*                               RenderTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenSize;                                        // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinatePosition;                                // 0x0018(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              CoordinateSize;                                    // 0x0020(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           RenderColor;                                       // 0x0028(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBlendMode                                    BlendMode;                                         // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x3];                                       // 0x0039(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Rotation;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PivotPoint;                                        // 0x0040(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawTexture) == 0x000008, "Wrong alignment on Canvas_K2_DrawTexture");
static_assert(sizeof(Canvas_K2_DrawTexture) == 0x000048, "Wrong size on Canvas_K2_DrawTexture");
static_assert(offsetof(Canvas_K2_DrawTexture, RenderTexture) == 0x000000, "Member 'Canvas_K2_DrawTexture::RenderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, ScreenPosition) == 0x000008, "Member 'Canvas_K2_DrawTexture::ScreenPosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, ScreenSize) == 0x000010, "Member 'Canvas_K2_DrawTexture::ScreenSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, CoordinatePosition) == 0x000018, "Member 'Canvas_K2_DrawTexture::CoordinatePosition' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, CoordinateSize) == 0x000020, "Member 'Canvas_K2_DrawTexture::CoordinateSize' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, RenderColor) == 0x000028, "Member 'Canvas_K2_DrawTexture::RenderColor' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, BlendMode) == 0x000038, "Member 'Canvas_K2_DrawTexture::BlendMode' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, Rotation) == 0x00003C, "Member 'Canvas_K2_DrawTexture::Rotation' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTexture, PivotPoint) == 0x000040, "Member 'Canvas_K2_DrawTexture::PivotPoint' has a wrong offset!");

// Function Engine.Canvas.K2_DrawTriangle
// 0x0018 (0x0018 - 0x0000)
struct Canvas_K2_DrawTriangle final
{
public:
	class UTexture*                               RenderTexture;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCanvasUVTri>                   Triangles;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_DrawTriangle) == 0x000008, "Wrong alignment on Canvas_K2_DrawTriangle");
static_assert(sizeof(Canvas_K2_DrawTriangle) == 0x000018, "Wrong size on Canvas_K2_DrawTriangle");
static_assert(offsetof(Canvas_K2_DrawTriangle, RenderTexture) == 0x000000, "Member 'Canvas_K2_DrawTriangle::RenderTexture' has a wrong offset!");
static_assert(offsetof(Canvas_K2_DrawTriangle, Triangles) == 0x000008, "Member 'Canvas_K2_DrawTriangle::Triangles' has a wrong offset!");

// Function Engine.Canvas.K2_Project
// 0x0018 (0x0018 - 0x0000)
struct Canvas_K2_Project final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_Project) == 0x000004, "Wrong alignment on Canvas_K2_Project");
static_assert(sizeof(Canvas_K2_Project) == 0x000018, "Wrong size on Canvas_K2_Project");
static_assert(offsetof(Canvas_K2_Project, WorldLocation) == 0x000000, "Member 'Canvas_K2_Project::WorldLocation' has a wrong offset!");
static_assert(offsetof(Canvas_K2_Project, ReturnValue) == 0x00000C, "Member 'Canvas_K2_Project::ReturnValue' has a wrong offset!");

// Function Engine.Canvas.K2_StrLen
// 0x0020 (0x0020 - 0x0000)
struct Canvas_K2_StrLen final
{
public:
	class UFont*                                  RenderFont;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RenderText;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_StrLen) == 0x000008, "Wrong alignment on Canvas_K2_StrLen");
static_assert(sizeof(Canvas_K2_StrLen) == 0x000020, "Wrong size on Canvas_K2_StrLen");
static_assert(offsetof(Canvas_K2_StrLen, RenderFont) == 0x000000, "Member 'Canvas_K2_StrLen::RenderFont' has a wrong offset!");
static_assert(offsetof(Canvas_K2_StrLen, RenderText) == 0x000008, "Member 'Canvas_K2_StrLen::RenderText' has a wrong offset!");
static_assert(offsetof(Canvas_K2_StrLen, ReturnValue) == 0x000018, "Member 'Canvas_K2_StrLen::ReturnValue' has a wrong offset!");

// Function Engine.Canvas.K2_TextSize
// 0x0028 (0x0028 - 0x0000)
struct Canvas_K2_TextSize final
{
public:
	class UFont*                                  RenderFont;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RenderText;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0018(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Canvas_K2_TextSize) == 0x000008, "Wrong alignment on Canvas_K2_TextSize");
static_assert(sizeof(Canvas_K2_TextSize) == 0x000028, "Wrong size on Canvas_K2_TextSize");
static_assert(offsetof(Canvas_K2_TextSize, RenderFont) == 0x000000, "Member 'Canvas_K2_TextSize::RenderFont' has a wrong offset!");
static_assert(offsetof(Canvas_K2_TextSize, RenderText) == 0x000008, "Member 'Canvas_K2_TextSize::RenderText' has a wrong offset!");
static_assert(offsetof(Canvas_K2_TextSize, Scale) == 0x000018, "Member 'Canvas_K2_TextSize::Scale' has a wrong offset!");
static_assert(offsetof(Canvas_K2_TextSize, ReturnValue) == 0x000020, "Member 'Canvas_K2_TextSize::ReturnValue' has a wrong offset!");

// Function Engine.TextureRenderTarget2D.GetSizeX
// 0x0004 (0x0004 - 0x0000)
struct TextureRenderTarget2D_GetSizeX final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextureRenderTarget2D_GetSizeX) == 0x000004, "Wrong alignment on TextureRenderTarget2D_GetSizeX");
static_assert(sizeof(TextureRenderTarget2D_GetSizeX) == 0x000004, "Wrong size on TextureRenderTarget2D_GetSizeX");
static_assert(offsetof(TextureRenderTarget2D_GetSizeX, ReturnValue) == 0x000000, "Member 'TextureRenderTarget2D_GetSizeX::ReturnValue' has a wrong offset!");

// Function Engine.TextureRenderTarget2D.GetSizeY
// 0x0004 (0x0004 - 0x0000)
struct TextureRenderTarget2D_GetSizeY final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextureRenderTarget2D_GetSizeY) == 0x000004, "Wrong alignment on TextureRenderTarget2D_GetSizeY");
static_assert(sizeof(TextureRenderTarget2D_GetSizeY) == 0x000004, "Wrong size on TextureRenderTarget2D_GetSizeY");
static_assert(offsetof(TextureRenderTarget2D_GetSizeY, ReturnValue) == 0x000000, "Member 'TextureRenderTarget2D_GetSizeY::ReturnValue' has a wrong offset!");

// Function Engine.CanvasRenderTarget2D.CreateCanvasRenderTarget2D
// 0x0020 (0x0020 - 0x0000)
struct CanvasRenderTarget2D_CreateCanvasRenderTarget2D final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCanvasRenderTarget2D>      CanvasRenderTarget2DClass;                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvasRenderTarget2D*                  ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D) == 0x000008, "Wrong alignment on CanvasRenderTarget2D_CreateCanvasRenderTarget2D");
static_assert(sizeof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D) == 0x000020, "Wrong size on CanvasRenderTarget2D_CreateCanvasRenderTarget2D");
static_assert(offsetof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D, WorldContextObject) == 0x000000, "Member 'CanvasRenderTarget2D_CreateCanvasRenderTarget2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D, CanvasRenderTarget2DClass) == 0x000008, "Member 'CanvasRenderTarget2D_CreateCanvasRenderTarget2D::CanvasRenderTarget2DClass' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D, Width) == 0x000010, "Member 'CanvasRenderTarget2D_CreateCanvasRenderTarget2D::Width' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D, Height) == 0x000014, "Member 'CanvasRenderTarget2D_CreateCanvasRenderTarget2D::Height' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_CreateCanvasRenderTarget2D, ReturnValue) == 0x000018, "Member 'CanvasRenderTarget2D_CreateCanvasRenderTarget2D::ReturnValue' has a wrong offset!");

// Function Engine.CanvasRenderTarget2D.GetSize
// 0x0008 (0x0008 - 0x0000)
struct CanvasRenderTarget2D_GetSize final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanvasRenderTarget2D_GetSize) == 0x000004, "Wrong alignment on CanvasRenderTarget2D_GetSize");
static_assert(sizeof(CanvasRenderTarget2D_GetSize) == 0x000008, "Wrong size on CanvasRenderTarget2D_GetSize");
static_assert(offsetof(CanvasRenderTarget2D_GetSize, Width) == 0x000000, "Member 'CanvasRenderTarget2D_GetSize::Width' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_GetSize, Height) == 0x000004, "Member 'CanvasRenderTarget2D_GetSize::Height' has a wrong offset!");

// Function Engine.CanvasRenderTarget2D.ReceiveUpdate
// 0x0010 (0x0010 - 0x0000)
struct CanvasRenderTarget2D_ReceiveUpdate final
{
public:
	class UCanvas*                                Canvas;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CanvasRenderTarget2D_ReceiveUpdate) == 0x000008, "Wrong alignment on CanvasRenderTarget2D_ReceiveUpdate");
static_assert(sizeof(CanvasRenderTarget2D_ReceiveUpdate) == 0x000010, "Wrong size on CanvasRenderTarget2D_ReceiveUpdate");
static_assert(offsetof(CanvasRenderTarget2D_ReceiveUpdate, Canvas) == 0x000000, "Member 'CanvasRenderTarget2D_ReceiveUpdate::Canvas' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_ReceiveUpdate, Width) == 0x000008, "Member 'CanvasRenderTarget2D_ReceiveUpdate::Width' has a wrong offset!");
static_assert(offsetof(CanvasRenderTarget2D_ReceiveUpdate, Height) == 0x00000C, "Member 'CanvasRenderTarget2D_ReceiveUpdate::Height' has a wrong offset!");

// Function Engine.ChildActorComponent.SetChildActorClass
// 0x0008 (0x0008 - 0x0000)
struct ChildActorComponent_SetChildActorClass final
{
public:
	TSubclassOf<class AActor>                     InClass;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ChildActorComponent_SetChildActorClass) == 0x000008, "Wrong alignment on ChildActorComponent_SetChildActorClass");
static_assert(sizeof(ChildActorComponent_SetChildActorClass) == 0x000008, "Wrong size on ChildActorComponent_SetChildActorClass");
static_assert(offsetof(ChildActorComponent_SetChildActorClass, InClass) == 0x000000, "Member 'ChildActorComponent_SetChildActorClass::InClass' has a wrong offset!");

// Function Engine.TextRenderComponent.K2_SetText
// 0x0018 (0x0018 - 0x0000)
struct TextRenderComponent_K2_SetText final
{
public:
	class FText                                   Value;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_K2_SetText) == 0x000008, "Wrong alignment on TextRenderComponent_K2_SetText");
static_assert(sizeof(TextRenderComponent_K2_SetText) == 0x000018, "Wrong size on TextRenderComponent_K2_SetText");
static_assert(offsetof(TextRenderComponent_K2_SetText, Value) == 0x000000, "Member 'TextRenderComponent_K2_SetText::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetFont
// 0x0008 (0x0008 - 0x0000)
struct TextRenderComponent_SetFont final
{
public:
	class UFont*                                  Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetFont) == 0x000008, "Wrong alignment on TextRenderComponent_SetFont");
static_assert(sizeof(TextRenderComponent_SetFont) == 0x000008, "Wrong size on TextRenderComponent_SetFont");
static_assert(offsetof(TextRenderComponent_SetFont, Value) == 0x000000, "Member 'TextRenderComponent_SetFont::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetHorizontalAlignment
// 0x0001 (0x0001 - 0x0000)
struct TextRenderComponent_SetHorizontalAlignment final
{
public:
	EHorizTextAligment                            Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetHorizontalAlignment) == 0x000001, "Wrong alignment on TextRenderComponent_SetHorizontalAlignment");
static_assert(sizeof(TextRenderComponent_SetHorizontalAlignment) == 0x000001, "Wrong size on TextRenderComponent_SetHorizontalAlignment");
static_assert(offsetof(TextRenderComponent_SetHorizontalAlignment, Value) == 0x000000, "Member 'TextRenderComponent_SetHorizontalAlignment::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetHorizSpacingAdjust
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetHorizSpacingAdjust final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetHorizSpacingAdjust) == 0x000004, "Wrong alignment on TextRenderComponent_SetHorizSpacingAdjust");
static_assert(sizeof(TextRenderComponent_SetHorizSpacingAdjust) == 0x000004, "Wrong size on TextRenderComponent_SetHorizSpacingAdjust");
static_assert(offsetof(TextRenderComponent_SetHorizSpacingAdjust, Value) == 0x000000, "Member 'TextRenderComponent_SetHorizSpacingAdjust::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetText
// 0x0010 (0x0010 - 0x0000)
struct TextRenderComponent_SetText final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetText) == 0x000008, "Wrong alignment on TextRenderComponent_SetText");
static_assert(sizeof(TextRenderComponent_SetText) == 0x000010, "Wrong size on TextRenderComponent_SetText");
static_assert(offsetof(TextRenderComponent_SetText, Value) == 0x000000, "Member 'TextRenderComponent_SetText::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetTextMaterial
// 0x0008 (0x0008 - 0x0000)
struct TextRenderComponent_SetTextMaterial final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetTextMaterial) == 0x000008, "Wrong alignment on TextRenderComponent_SetTextMaterial");
static_assert(sizeof(TextRenderComponent_SetTextMaterial) == 0x000008, "Wrong size on TextRenderComponent_SetTextMaterial");
static_assert(offsetof(TextRenderComponent_SetTextMaterial, Material) == 0x000000, "Member 'TextRenderComponent_SetTextMaterial::Material' has a wrong offset!");

// Function Engine.TextRenderComponent.SetTextRenderColor
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetTextRenderColor final
{
public:
	struct FColor                                 Value;                                             // 0x0000(0x0004)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetTextRenderColor) == 0x000004, "Wrong alignment on TextRenderComponent_SetTextRenderColor");
static_assert(sizeof(TextRenderComponent_SetTextRenderColor) == 0x000004, "Wrong size on TextRenderComponent_SetTextRenderColor");
static_assert(offsetof(TextRenderComponent_SetTextRenderColor, Value) == 0x000000, "Member 'TextRenderComponent_SetTextRenderColor::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetVerticalAlignment
// 0x0001 (0x0001 - 0x0000)
struct TextRenderComponent_SetVerticalAlignment final
{
public:
	EVerticalTextAligment                         Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetVerticalAlignment) == 0x000001, "Wrong alignment on TextRenderComponent_SetVerticalAlignment");
static_assert(sizeof(TextRenderComponent_SetVerticalAlignment) == 0x000001, "Wrong size on TextRenderComponent_SetVerticalAlignment");
static_assert(offsetof(TextRenderComponent_SetVerticalAlignment, Value) == 0x000000, "Member 'TextRenderComponent_SetVerticalAlignment::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetVertSpacingAdjust
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetVertSpacingAdjust final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetVertSpacingAdjust) == 0x000004, "Wrong alignment on TextRenderComponent_SetVertSpacingAdjust");
static_assert(sizeof(TextRenderComponent_SetVertSpacingAdjust) == 0x000004, "Wrong size on TextRenderComponent_SetVertSpacingAdjust");
static_assert(offsetof(TextRenderComponent_SetVertSpacingAdjust, Value) == 0x000000, "Member 'TextRenderComponent_SetVertSpacingAdjust::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetWorldSize
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetWorldSize final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetWorldSize) == 0x000004, "Wrong alignment on TextRenderComponent_SetWorldSize");
static_assert(sizeof(TextRenderComponent_SetWorldSize) == 0x000004, "Wrong size on TextRenderComponent_SetWorldSize");
static_assert(offsetof(TextRenderComponent_SetWorldSize, Value) == 0x000000, "Member 'TextRenderComponent_SetWorldSize::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetXScale
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetXScale final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetXScale) == 0x000004, "Wrong alignment on TextRenderComponent_SetXScale");
static_assert(sizeof(TextRenderComponent_SetXScale) == 0x000004, "Wrong size on TextRenderComponent_SetXScale");
static_assert(offsetof(TextRenderComponent_SetXScale, Value) == 0x000000, "Member 'TextRenderComponent_SetXScale::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.SetYScale
// 0x0004 (0x0004 - 0x0000)
struct TextRenderComponent_SetYScale final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_SetYScale) == 0x000004, "Wrong alignment on TextRenderComponent_SetYScale");
static_assert(sizeof(TextRenderComponent_SetYScale) == 0x000004, "Wrong size on TextRenderComponent_SetYScale");
static_assert(offsetof(TextRenderComponent_SetYScale, Value) == 0x000000, "Member 'TextRenderComponent_SetYScale::Value' has a wrong offset!");

// Function Engine.TextRenderComponent.GetTextLocalSize
// 0x000C (0x000C - 0x0000)
struct TextRenderComponent_GetTextLocalSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_GetTextLocalSize) == 0x000004, "Wrong alignment on TextRenderComponent_GetTextLocalSize");
static_assert(sizeof(TextRenderComponent_GetTextLocalSize) == 0x00000C, "Wrong size on TextRenderComponent_GetTextLocalSize");
static_assert(offsetof(TextRenderComponent_GetTextLocalSize, ReturnValue) == 0x000000, "Member 'TextRenderComponent_GetTextLocalSize::ReturnValue' has a wrong offset!");

// Function Engine.TextRenderComponent.GetTextWorldSize
// 0x000C (0x000C - 0x0000)
struct TextRenderComponent_GetTextWorldSize final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TextRenderComponent_GetTextWorldSize) == 0x000004, "Wrong alignment on TextRenderComponent_GetTextWorldSize");
static_assert(sizeof(TextRenderComponent_GetTextWorldSize) == 0x00000C, "Wrong size on TextRenderComponent_GetTextWorldSize");
static_assert(offsetof(TextRenderComponent_GetTextWorldSize, ReturnValue) == 0x000000, "Member 'TextRenderComponent_GetTextWorldSize::ReturnValue' has a wrong offset!");

// Function Engine.CurveFloat.GetFloatValue
// 0x0008 (0x0008 - 0x0000)
struct CurveFloat_GetFloatValue final
{
public:
	float                                         InTime;                                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveFloat_GetFloatValue) == 0x000004, "Wrong alignment on CurveFloat_GetFloatValue");
static_assert(sizeof(CurveFloat_GetFloatValue) == 0x000008, "Wrong size on CurveFloat_GetFloatValue");
static_assert(offsetof(CurveFloat_GetFloatValue, InTime) == 0x000000, "Member 'CurveFloat_GetFloatValue::InTime' has a wrong offset!");
static_assert(offsetof(CurveFloat_GetFloatValue, ReturnValue) == 0x000004, "Member 'CurveFloat_GetFloatValue::ReturnValue' has a wrong offset!");

// Function Engine.CurveSourceInterface.GetBindingName
// 0x0008 (0x0008 - 0x0000)
struct CurveSourceInterface_GetBindingName final
{
public:
	class FName                                   ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveSourceInterface_GetBindingName) == 0x000004, "Wrong alignment on CurveSourceInterface_GetBindingName");
static_assert(sizeof(CurveSourceInterface_GetBindingName) == 0x000008, "Wrong size on CurveSourceInterface_GetBindingName");
static_assert(offsetof(CurveSourceInterface_GetBindingName, ReturnValue) == 0x000000, "Member 'CurveSourceInterface_GetBindingName::ReturnValue' has a wrong offset!");

// Function Engine.CurveSourceInterface.GetCurves
// 0x0010 (0x0010 - 0x0000)
struct CurveSourceInterface_GetCurves final
{
public:
	TArray<struct FNamedCurveValue>               OutValues;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(CurveSourceInterface_GetCurves) == 0x000008, "Wrong alignment on CurveSourceInterface_GetCurves");
static_assert(sizeof(CurveSourceInterface_GetCurves) == 0x000010, "Wrong size on CurveSourceInterface_GetCurves");
static_assert(offsetof(CurveSourceInterface_GetCurves, OutValues) == 0x000000, "Member 'CurveSourceInterface_GetCurves::OutValues' has a wrong offset!");

// Function Engine.CurveSourceInterface.GetCurveValue
// 0x0010 (0x0010 - 0x0000)
struct CurveSourceInterface_GetCurveValue final
{
public:
	class FName                                   CurveName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(CurveSourceInterface_GetCurveValue) == 0x000004, "Wrong alignment on CurveSourceInterface_GetCurveValue");
static_assert(sizeof(CurveSourceInterface_GetCurveValue) == 0x000010, "Wrong size on CurveSourceInterface_GetCurveValue");
static_assert(offsetof(CurveSourceInterface_GetCurveValue, CurveName) == 0x000000, "Member 'CurveSourceInterface_GetCurveValue::CurveName' has a wrong offset!");
static_assert(offsetof(CurveSourceInterface_GetCurveValue, ReturnValue) == 0x000008, "Member 'CurveSourceInterface_GetCurveValue::ReturnValue' has a wrong offset!");

// Function Engine.DataTableFunctionLibrary.EvaluateCurveTableRow
// 0x0030 (0x0030 - 0x0000)
struct DataTableFunctionLibrary_EvaluateCurveTableRow final
{
public:
	class UCurveTable*                            CurveTable;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InXY;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EEvaluateCurveTableResult                     OutResult;                                         // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OutXY;                                             // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ContextString;                                     // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DataTableFunctionLibrary_EvaluateCurveTableRow) == 0x000008, "Wrong alignment on DataTableFunctionLibrary_EvaluateCurveTableRow");
static_assert(sizeof(DataTableFunctionLibrary_EvaluateCurveTableRow) == 0x000030, "Wrong size on DataTableFunctionLibrary_EvaluateCurveTableRow");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, CurveTable) == 0x000000, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::CurveTable' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, RowName) == 0x000008, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::RowName' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, InXY) == 0x000010, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::InXY' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, OutResult) == 0x000014, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::OutResult' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, OutXY) == 0x000018, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::OutXY' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_EvaluateCurveTableRow, ContextString) == 0x000020, "Member 'DataTableFunctionLibrary_EvaluateCurveTableRow::ContextString' has a wrong offset!");

// Function Engine.DataTableFunctionLibrary.GetDataTableRowFromName
// 0x0020 (0x0020 - 0x0000)
struct DataTableFunctionLibrary_GetDataTableRowFromName final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTableRowBase                          OutRow;                                            // 0x0010(0x0008)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DataTableFunctionLibrary_GetDataTableRowFromName) == 0x000008, "Wrong alignment on DataTableFunctionLibrary_GetDataTableRowFromName");
static_assert(sizeof(DataTableFunctionLibrary_GetDataTableRowFromName) == 0x000020, "Wrong size on DataTableFunctionLibrary_GetDataTableRowFromName");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowFromName, Table) == 0x000000, "Member 'DataTableFunctionLibrary_GetDataTableRowFromName::Table' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowFromName, RowName) == 0x000008, "Member 'DataTableFunctionLibrary_GetDataTableRowFromName::RowName' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowFromName, OutRow) == 0x000010, "Member 'DataTableFunctionLibrary_GetDataTableRowFromName::OutRow' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowFromName, ReturnValue) == 0x000018, "Member 'DataTableFunctionLibrary_GetDataTableRowFromName::ReturnValue' has a wrong offset!");

// Function Engine.DataTableFunctionLibrary.GetDataTableRowNames
// 0x0018 (0x0018 - 0x0000)
struct DataTableFunctionLibrary_GetDataTableRowNames final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           OutRowNames;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(DataTableFunctionLibrary_GetDataTableRowNames) == 0x000008, "Wrong alignment on DataTableFunctionLibrary_GetDataTableRowNames");
static_assert(sizeof(DataTableFunctionLibrary_GetDataTableRowNames) == 0x000018, "Wrong size on DataTableFunctionLibrary_GetDataTableRowNames");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowNames, Table) == 0x000000, "Member 'DataTableFunctionLibrary_GetDataTableRowNames::Table' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_GetDataTableRowNames, OutRowNames) == 0x000008, "Member 'DataTableFunctionLibrary_GetDataTableRowNames::OutRowNames' has a wrong offset!");

// Function Engine.DataTableFunctionLibrary.VerifyDataTableRowName
// 0x0018 (0x0018 - 0x0000)
struct DataTableFunctionLibrary_VerifyDataTableRowName final
{
public:
	class UDataTable*                             Table;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   RowName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DataTableFunctionLibrary_VerifyDataTableRowName) == 0x000008, "Wrong alignment on DataTableFunctionLibrary_VerifyDataTableRowName");
static_assert(sizeof(DataTableFunctionLibrary_VerifyDataTableRowName) == 0x000018, "Wrong size on DataTableFunctionLibrary_VerifyDataTableRowName");
static_assert(offsetof(DataTableFunctionLibrary_VerifyDataTableRowName, Table) == 0x000000, "Member 'DataTableFunctionLibrary_VerifyDataTableRowName::Table' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_VerifyDataTableRowName, RowName) == 0x000008, "Member 'DataTableFunctionLibrary_VerifyDataTableRowName::RowName' has a wrong offset!");
static_assert(offsetof(DataTableFunctionLibrary_VerifyDataTableRowName, ReturnValue) == 0x000010, "Member 'DataTableFunctionLibrary_VerifyDataTableRowName::ReturnValue' has a wrong offset!");

// Function Engine.DecalActor.CreateDynamicMaterialInstance
// 0x0008 (0x0008 - 0x0000)
struct DecalActor_CreateDynamicMaterialInstance final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalActor_CreateDynamicMaterialInstance) == 0x000008, "Wrong alignment on DecalActor_CreateDynamicMaterialInstance");
static_assert(sizeof(DecalActor_CreateDynamicMaterialInstance) == 0x000008, "Wrong size on DecalActor_CreateDynamicMaterialInstance");
static_assert(offsetof(DecalActor_CreateDynamicMaterialInstance, ReturnValue) == 0x000000, "Member 'DecalActor_CreateDynamicMaterialInstance::ReturnValue' has a wrong offset!");

// Function Engine.DecalActor.SetDecalMaterial
// 0x0008 (0x0008 - 0x0000)
struct DecalActor_SetDecalMaterial final
{
public:
	class UMaterialInterface*                     NewDecalMaterial;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalActor_SetDecalMaterial) == 0x000008, "Wrong alignment on DecalActor_SetDecalMaterial");
static_assert(sizeof(DecalActor_SetDecalMaterial) == 0x000008, "Wrong size on DecalActor_SetDecalMaterial");
static_assert(offsetof(DecalActor_SetDecalMaterial, NewDecalMaterial) == 0x000000, "Member 'DecalActor_SetDecalMaterial::NewDecalMaterial' has a wrong offset!");

// Function Engine.DecalActor.GetDecalMaterial
// 0x0008 (0x0008 - 0x0000)
struct DecalActor_GetDecalMaterial final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalActor_GetDecalMaterial) == 0x000008, "Wrong alignment on DecalActor_GetDecalMaterial");
static_assert(sizeof(DecalActor_GetDecalMaterial) == 0x000008, "Wrong size on DecalActor_GetDecalMaterial");
static_assert(offsetof(DecalActor_GetDecalMaterial, ReturnValue) == 0x000000, "Member 'DecalActor_GetDecalMaterial::ReturnValue' has a wrong offset!");

// Function Engine.DecalComponent.CreateDynamicMaterialInstance
// 0x0008 (0x0008 - 0x0000)
struct DecalComponent_CreateDynamicMaterialInstance final
{
public:
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_CreateDynamicMaterialInstance) == 0x000008, "Wrong alignment on DecalComponent_CreateDynamicMaterialInstance");
static_assert(sizeof(DecalComponent_CreateDynamicMaterialInstance) == 0x000008, "Wrong size on DecalComponent_CreateDynamicMaterialInstance");
static_assert(offsetof(DecalComponent_CreateDynamicMaterialInstance, ReturnValue) == 0x000000, "Member 'DecalComponent_CreateDynamicMaterialInstance::ReturnValue' has a wrong offset!");

// Function Engine.DecalComponent.SetDecalMaterial
// 0x0008 (0x0008 - 0x0000)
struct DecalComponent_SetDecalMaterial final
{
public:
	class UMaterialInterface*                     NewDecalMaterial;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_SetDecalMaterial) == 0x000008, "Wrong alignment on DecalComponent_SetDecalMaterial");
static_assert(sizeof(DecalComponent_SetDecalMaterial) == 0x000008, "Wrong size on DecalComponent_SetDecalMaterial");
static_assert(offsetof(DecalComponent_SetDecalMaterial, NewDecalMaterial) == 0x000000, "Member 'DecalComponent_SetDecalMaterial::NewDecalMaterial' has a wrong offset!");

// Function Engine.DecalComponent.SetFadeOut
// 0x000C (0x000C - 0x0000)
struct DecalComponent_SetFadeOut final
{
public:
	float                                         StartDelay;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          DestroyOwnerAfterFade;                             // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(DecalComponent_SetFadeOut) == 0x000004, "Wrong alignment on DecalComponent_SetFadeOut");
static_assert(sizeof(DecalComponent_SetFadeOut) == 0x00000C, "Wrong size on DecalComponent_SetFadeOut");
static_assert(offsetof(DecalComponent_SetFadeOut, StartDelay) == 0x000000, "Member 'DecalComponent_SetFadeOut::StartDelay' has a wrong offset!");
static_assert(offsetof(DecalComponent_SetFadeOut, Duration) == 0x000004, "Member 'DecalComponent_SetFadeOut::Duration' has a wrong offset!");
static_assert(offsetof(DecalComponent_SetFadeOut, DestroyOwnerAfterFade) == 0x000008, "Member 'DecalComponent_SetFadeOut::DestroyOwnerAfterFade' has a wrong offset!");

// Function Engine.DecalComponent.SetFadeScreenSize
// 0x0004 (0x0004 - 0x0000)
struct DecalComponent_SetFadeScreenSize final
{
public:
	float                                         NewFadeScreenSize;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_SetFadeScreenSize) == 0x000004, "Wrong alignment on DecalComponent_SetFadeScreenSize");
static_assert(sizeof(DecalComponent_SetFadeScreenSize) == 0x000004, "Wrong size on DecalComponent_SetFadeScreenSize");
static_assert(offsetof(DecalComponent_SetFadeScreenSize, NewFadeScreenSize) == 0x000000, "Member 'DecalComponent_SetFadeScreenSize::NewFadeScreenSize' has a wrong offset!");

// Function Engine.DecalComponent.SetSortOrder
// 0x0004 (0x0004 - 0x0000)
struct DecalComponent_SetSortOrder final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_SetSortOrder) == 0x000004, "Wrong alignment on DecalComponent_SetSortOrder");
static_assert(sizeof(DecalComponent_SetSortOrder) == 0x000004, "Wrong size on DecalComponent_SetSortOrder");
static_assert(offsetof(DecalComponent_SetSortOrder, Value) == 0x000000, "Member 'DecalComponent_SetSortOrder::Value' has a wrong offset!");

// Function Engine.DecalComponent.GetDecalMaterial
// 0x0008 (0x0008 - 0x0000)
struct DecalComponent_GetDecalMaterial final
{
public:
	class UMaterialInterface*                     ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_GetDecalMaterial) == 0x000008, "Wrong alignment on DecalComponent_GetDecalMaterial");
static_assert(sizeof(DecalComponent_GetDecalMaterial) == 0x000008, "Wrong size on DecalComponent_GetDecalMaterial");
static_assert(offsetof(DecalComponent_GetDecalMaterial, ReturnValue) == 0x000000, "Member 'DecalComponent_GetDecalMaterial::ReturnValue' has a wrong offset!");

// Function Engine.DecalComponent.GetFadeDuration
// 0x0004 (0x0004 - 0x0000)
struct DecalComponent_GetFadeDuration final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_GetFadeDuration) == 0x000004, "Wrong alignment on DecalComponent_GetFadeDuration");
static_assert(sizeof(DecalComponent_GetFadeDuration) == 0x000004, "Wrong size on DecalComponent_GetFadeDuration");
static_assert(offsetof(DecalComponent_GetFadeDuration, ReturnValue) == 0x000000, "Member 'DecalComponent_GetFadeDuration::ReturnValue' has a wrong offset!");

// Function Engine.DecalComponent.GetFadeStartDelay
// 0x0004 (0x0004 - 0x0000)
struct DecalComponent_GetFadeStartDelay final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DecalComponent_GetFadeStartDelay) == 0x000004, "Wrong alignment on DecalComponent_GetFadeStartDelay");
static_assert(sizeof(DecalComponent_GetFadeStartDelay) == 0x000004, "Wrong size on DecalComponent_GetFadeStartDelay");
static_assert(offsetof(DecalComponent_GetFadeStartDelay, ReturnValue) == 0x000000, "Member 'DecalComponent_GetFadeStartDelay::ReturnValue' has a wrong offset!");

// Function Engine.DefaultPawn.LookUpAtRate
// 0x0004 (0x0004 - 0x0000)
struct DefaultPawn_LookUpAtRate final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultPawn_LookUpAtRate) == 0x000004, "Wrong alignment on DefaultPawn_LookUpAtRate");
static_assert(sizeof(DefaultPawn_LookUpAtRate) == 0x000004, "Wrong size on DefaultPawn_LookUpAtRate");
static_assert(offsetof(DefaultPawn_LookUpAtRate, Rate) == 0x000000, "Member 'DefaultPawn_LookUpAtRate::Rate' has a wrong offset!");

// Function Engine.DefaultPawn.MoveForward
// 0x0004 (0x0004 - 0x0000)
struct DefaultPawn_MoveForward final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultPawn_MoveForward) == 0x000004, "Wrong alignment on DefaultPawn_MoveForward");
static_assert(sizeof(DefaultPawn_MoveForward) == 0x000004, "Wrong size on DefaultPawn_MoveForward");
static_assert(offsetof(DefaultPawn_MoveForward, Val) == 0x000000, "Member 'DefaultPawn_MoveForward::Val' has a wrong offset!");

// Function Engine.DefaultPawn.MoveRight
// 0x0004 (0x0004 - 0x0000)
struct DefaultPawn_MoveRight final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultPawn_MoveRight) == 0x000004, "Wrong alignment on DefaultPawn_MoveRight");
static_assert(sizeof(DefaultPawn_MoveRight) == 0x000004, "Wrong size on DefaultPawn_MoveRight");
static_assert(offsetof(DefaultPawn_MoveRight, Val) == 0x000000, "Member 'DefaultPawn_MoveRight::Val' has a wrong offset!");

// Function Engine.DefaultPawn.MoveUp_World
// 0x0004 (0x0004 - 0x0000)
struct DefaultPawn_MoveUp_World final
{
public:
	float                                         Val;                                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultPawn_MoveUp_World) == 0x000004, "Wrong alignment on DefaultPawn_MoveUp_World");
static_assert(sizeof(DefaultPawn_MoveUp_World) == 0x000004, "Wrong size on DefaultPawn_MoveUp_World");
static_assert(offsetof(DefaultPawn_MoveUp_World, Val) == 0x000000, "Member 'DefaultPawn_MoveUp_World::Val' has a wrong offset!");

// Function Engine.DefaultPawn.TurnAtRate
// 0x0004 (0x0004 - 0x0000)
struct DefaultPawn_TurnAtRate final
{
public:
	float                                         Rate;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(DefaultPawn_TurnAtRate) == 0x000004, "Wrong alignment on DefaultPawn_TurnAtRate");
static_assert(sizeof(DefaultPawn_TurnAtRate) == 0x000004, "Wrong size on DefaultPawn_TurnAtRate");
static_assert(offsetof(DefaultPawn_TurnAtRate, Rate) == 0x000000, "Member 'DefaultPawn_TurnAtRate::Rate' has a wrong offset!");

// Function Engine.MatineeActor.DebugTimelineJumpByCutName
// 0x0010 (0x0010 - 0x0000)
struct MatineeActor_DebugTimelineJumpByCutName final
{
public:
	class FString                                 CutName;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_DebugTimelineJumpByCutName) == 0x000008, "Wrong alignment on MatineeActor_DebugTimelineJumpByCutName");
static_assert(sizeof(MatineeActor_DebugTimelineJumpByCutName) == 0x000010, "Wrong size on MatineeActor_DebugTimelineJumpByCutName");
static_assert(offsetof(MatineeActor_DebugTimelineJumpByCutName, CutName) == 0x000000, "Member 'MatineeActor_DebugTimelineJumpByCutName::CutName' has a wrong offset!");

// Function Engine.MatineeActor.DebugTimelineJumpByTime
// 0x0004 (0x0004 - 0x0000)
struct MatineeActor_DebugTimelineJumpByTime final
{
public:
	float                                         JumpTimeSec;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_DebugTimelineJumpByTime) == 0x000004, "Wrong alignment on MatineeActor_DebugTimelineJumpByTime");
static_assert(sizeof(MatineeActor_DebugTimelineJumpByTime) == 0x000004, "Wrong size on MatineeActor_DebugTimelineJumpByTime");
static_assert(offsetof(MatineeActor_DebugTimelineJumpByTime, JumpTimeSec) == 0x000000, "Member 'MatineeActor_DebugTimelineJumpByTime::JumpTimeSec' has a wrong offset!");

// Function Engine.MatineeActor.EnableGroupByName
// 0x0018 (0x0018 - 0x0000)
struct MatineeActor_EnableGroupByName final
{
public:
	class FString                                 GroupName;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnable;                                           // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatineeActor_EnableGroupByName) == 0x000008, "Wrong alignment on MatineeActor_EnableGroupByName");
static_assert(sizeof(MatineeActor_EnableGroupByName) == 0x000018, "Wrong size on MatineeActor_EnableGroupByName");
static_assert(offsetof(MatineeActor_EnableGroupByName, GroupName) == 0x000000, "Member 'MatineeActor_EnableGroupByName::GroupName' has a wrong offset!");
static_assert(offsetof(MatineeActor_EnableGroupByName, bEnable) == 0x000010, "Member 'MatineeActor_EnableGroupByName::bEnable' has a wrong offset!");

// Function Engine.MatineeActor.LatentPrepare
// 0x0020 (0x0020 - 0x0000)
struct MatineeActor_LatentPrepare final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0008(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_LatentPrepare) == 0x000008, "Wrong alignment on MatineeActor_LatentPrepare");
static_assert(sizeof(MatineeActor_LatentPrepare) == 0x000020, "Wrong size on MatineeActor_LatentPrepare");
static_assert(offsetof(MatineeActor_LatentPrepare, WorldContextObject) == 0x000000, "Member 'MatineeActor_LatentPrepare::WorldContextObject' has a wrong offset!");
static_assert(offsetof(MatineeActor_LatentPrepare, LatentInfo) == 0x000008, "Member 'MatineeActor_LatentPrepare::LatentInfo' has a wrong offset!");

// Function Engine.MatineeActor.SetAttachLocation
// 0x0018 (0x0018 - 0x0000)
struct MatineeActor_SetAttachLocation final
{
public:
	struct FVector                                Translation;                                       // 0x0000(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x000C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_SetAttachLocation) == 0x000004, "Wrong alignment on MatineeActor_SetAttachLocation");
static_assert(sizeof(MatineeActor_SetAttachLocation) == 0x000018, "Wrong size on MatineeActor_SetAttachLocation");
static_assert(offsetof(MatineeActor_SetAttachLocation, Translation) == 0x000000, "Member 'MatineeActor_SetAttachLocation::Translation' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetAttachLocation, Rotation) == 0x00000C, "Member 'MatineeActor_SetAttachLocation::Rotation' has a wrong offset!");

// Function Engine.MatineeActor.SetGroupActor
// 0x0018 (0x0018 - 0x0000)
struct MatineeActor_SetGroupActor final
{
public:
	class FString                                 InGroupName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 NewActor;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_SetGroupActor) == 0x000008, "Wrong alignment on MatineeActor_SetGroupActor");
static_assert(sizeof(MatineeActor_SetGroupActor) == 0x000018, "Wrong size on MatineeActor_SetGroupActor");
static_assert(offsetof(MatineeActor_SetGroupActor, InGroupName) == 0x000000, "Member 'MatineeActor_SetGroupActor::InGroupName' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetGroupActor, NewActor) == 0x000010, "Member 'MatineeActor_SetGroupActor::NewActor' has a wrong offset!");

// Function Engine.MatineeActor.SetLoopingState
// 0x0001 (0x0001 - 0x0000)
struct MatineeActor_SetLoopingState final
{
public:
	bool                                          bNewLooping;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_SetLoopingState) == 0x000001, "Wrong alignment on MatineeActor_SetLoopingState");
static_assert(sizeof(MatineeActor_SetLoopingState) == 0x000001, "Wrong size on MatineeActor_SetLoopingState");
static_assert(offsetof(MatineeActor_SetLoopingState, bNewLooping) == 0x000000, "Member 'MatineeActor_SetLoopingState::bNewLooping' has a wrong offset!");

// Function Engine.MatineeActor.SetPosition
// 0x0008 (0x0008 - 0x0000)
struct MatineeActor_SetPosition final
{
public:
	float                                         NewPosition;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bJump;                                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatineeActor_SetPosition) == 0x000004, "Wrong alignment on MatineeActor_SetPosition");
static_assert(sizeof(MatineeActor_SetPosition) == 0x000008, "Wrong size on MatineeActor_SetPosition");
static_assert(offsetof(MatineeActor_SetPosition, NewPosition) == 0x000000, "Member 'MatineeActor_SetPosition::NewPosition' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetPosition, bJump) == 0x000004, "Member 'MatineeActor_SetPosition::bJump' has a wrong offset!");

// Function Engine.MatineeActor.SetPositionToReserveList
// 0x0004 (0x0004 - 0x0000)
struct MatineeActor_SetPositionToReserveList final
{
public:
	float                                         NewPosition;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_SetPositionToReserveList) == 0x000004, "Wrong alignment on MatineeActor_SetPositionToReserveList");
static_assert(sizeof(MatineeActor_SetPositionToReserveList) == 0x000004, "Wrong size on MatineeActor_SetPositionToReserveList");
static_assert(offsetof(MatineeActor_SetPositionToReserveList, NewPosition) == 0x000000, "Member 'MatineeActor_SetPositionToReserveList::NewPosition' has a wrong offset!");

// Function Engine.MatineeActor.SetTrackEnable
// 0x0028 (0x0028 - 0x0000)
struct MatineeActor_SetTrackEnable final
{
public:
	class FString                                 InGroupName;                                       // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTrackName;                                       // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InEnable;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MatineeActor_SetTrackEnable) == 0x000008, "Wrong alignment on MatineeActor_SetTrackEnable");
static_assert(sizeof(MatineeActor_SetTrackEnable) == 0x000028, "Wrong size on MatineeActor_SetTrackEnable");
static_assert(offsetof(MatineeActor_SetTrackEnable, InGroupName) == 0x000000, "Member 'MatineeActor_SetTrackEnable::InGroupName' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetTrackEnable, InTrackName) == 0x000010, "Member 'MatineeActor_SetTrackEnable::InTrackName' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetTrackEnable, InEnable) == 0x000020, "Member 'MatineeActor_SetTrackEnable::InEnable' has a wrong offset!");

// Function Engine.MatineeActor.SetValueByName
// 0x0010 (0x0010 - 0x0000)
struct MatineeActor_SetValueByName final
{
public:
	class FName                                   FlagName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FlagValue;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_SetValueByName) == 0x000004, "Wrong alignment on MatineeActor_SetValueByName");
static_assert(sizeof(MatineeActor_SetValueByName) == 0x000010, "Wrong size on MatineeActor_SetValueByName");
static_assert(offsetof(MatineeActor_SetValueByName, FlagName) == 0x000000, "Member 'MatineeActor_SetValueByName::FlagName' has a wrong offset!");
static_assert(offsetof(MatineeActor_SetValueByName, FlagValue) == 0x000008, "Member 'MatineeActor_SetValueByName::FlagValue' has a wrong offset!");

// Function Engine.MatineeActor.GetCurrentCutName
// 0x0010 (0x0010 - 0x0000)
struct MatineeActor_GetCurrentCutName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_GetCurrentCutName) == 0x000008, "Wrong alignment on MatineeActor_GetCurrentCutName");
static_assert(sizeof(MatineeActor_GetCurrentCutName) == 0x000010, "Wrong size on MatineeActor_GetCurrentCutName");
static_assert(offsetof(MatineeActor_GetCurrentCutName, ReturnValue) == 0x000000, "Member 'MatineeActor_GetCurrentCutName::ReturnValue' has a wrong offset!");

// Function Engine.MatineeActor.GetCurrentPosition
// 0x0004 (0x0004 - 0x0000)
struct MatineeActor_GetCurrentPosition final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_GetCurrentPosition) == 0x000004, "Wrong alignment on MatineeActor_GetCurrentPosition");
static_assert(sizeof(MatineeActor_GetCurrentPosition) == 0x000004, "Wrong size on MatineeActor_GetCurrentPosition");
static_assert(offsetof(MatineeActor_GetCurrentPosition, ReturnValue) == 0x000000, "Member 'MatineeActor_GetCurrentPosition::ReturnValue' has a wrong offset!");

// Function Engine.MatineeActor.GetCutNameList
// 0x0010 (0x0010 - 0x0000)
struct MatineeActor_GetCutNameList final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_GetCutNameList) == 0x000008, "Wrong alignment on MatineeActor_GetCutNameList");
static_assert(sizeof(MatineeActor_GetCutNameList) == 0x000010, "Wrong size on MatineeActor_GetCutNameList");
static_assert(offsetof(MatineeActor_GetCutNameList, ReturnValue) == 0x000000, "Member 'MatineeActor_GetCutNameList::ReturnValue' has a wrong offset!");

// Function Engine.MatineeActor.GetLastCutName
// 0x0010 (0x0010 - 0x0000)
struct MatineeActor_GetLastCutName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_GetLastCutName) == 0x000008, "Wrong alignment on MatineeActor_GetLastCutName");
static_assert(sizeof(MatineeActor_GetLastCutName) == 0x000010, "Wrong size on MatineeActor_GetLastCutName");
static_assert(offsetof(MatineeActor_GetLastCutName, ReturnValue) == 0x000000, "Member 'MatineeActor_GetLastCutName::ReturnValue' has a wrong offset!");

// Function Engine.MatineeActor.GetMatineeLength
// 0x0004 (0x0004 - 0x0000)
struct MatineeActor_GetMatineeLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MatineeActor_GetMatineeLength) == 0x000004, "Wrong alignment on MatineeActor_GetMatineeLength");
static_assert(sizeof(MatineeActor_GetMatineeLength) == 0x000004, "Wrong size on MatineeActor_GetMatineeLength");
static_assert(offsetof(MatineeActor_GetMatineeLength, ReturnValue) == 0x000000, "Member 'MatineeActor_GetMatineeLength::ReturnValue' has a wrong offset!");

// Function Engine.ForceFeedbackComponent.AdjustAttenuation
// 0x00A8 (0x00A8 - 0x0000)
struct ForceFeedbackComponent_AdjustAttenuation final
{
public:
	struct FForceFeedbackAttenuationSettings      InAttenuationSettings;                             // 0x0000(0x00A8)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ForceFeedbackComponent_AdjustAttenuation) == 0x000008, "Wrong alignment on ForceFeedbackComponent_AdjustAttenuation");
static_assert(sizeof(ForceFeedbackComponent_AdjustAttenuation) == 0x0000A8, "Wrong size on ForceFeedbackComponent_AdjustAttenuation");
static_assert(offsetof(ForceFeedbackComponent_AdjustAttenuation, InAttenuationSettings) == 0x000000, "Member 'ForceFeedbackComponent_AdjustAttenuation::InAttenuationSettings' has a wrong offset!");

// Function Engine.ForceFeedbackComponent.Play
// 0x0004 (0x0004 - 0x0000)
struct ForceFeedbackComponent_Play final
{
public:
	float                                         StartTime;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ForceFeedbackComponent_Play) == 0x000004, "Wrong alignment on ForceFeedbackComponent_Play");
static_assert(sizeof(ForceFeedbackComponent_Play) == 0x000004, "Wrong size on ForceFeedbackComponent_Play");
static_assert(offsetof(ForceFeedbackComponent_Play, StartTime) == 0x000000, "Member 'ForceFeedbackComponent_Play::StartTime' has a wrong offset!");

// Function Engine.ForceFeedbackComponent.SetForceFeedbackEffect
// 0x0008 (0x0008 - 0x0000)
struct ForceFeedbackComponent_SetForceFeedbackEffect final
{
public:
	class UForceFeedbackEffect*                   NewForceFeedbackEffect;                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ForceFeedbackComponent_SetForceFeedbackEffect) == 0x000008, "Wrong alignment on ForceFeedbackComponent_SetForceFeedbackEffect");
static_assert(sizeof(ForceFeedbackComponent_SetForceFeedbackEffect) == 0x000008, "Wrong size on ForceFeedbackComponent_SetForceFeedbackEffect");
static_assert(offsetof(ForceFeedbackComponent_SetForceFeedbackEffect, NewForceFeedbackEffect) == 0x000000, "Member 'ForceFeedbackComponent_SetForceFeedbackEffect::NewForceFeedbackEffect' has a wrong offset!");

// Function Engine.ForceFeedbackComponent.SetIntensityMultiplier
// 0x0004 (0x0004 - 0x0000)
struct ForceFeedbackComponent_SetIntensityMultiplier final
{
public:
	float                                         NewIntensityMultiplier;                            // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ForceFeedbackComponent_SetIntensityMultiplier) == 0x000004, "Wrong alignment on ForceFeedbackComponent_SetIntensityMultiplier");
static_assert(sizeof(ForceFeedbackComponent_SetIntensityMultiplier) == 0x000004, "Wrong size on ForceFeedbackComponent_SetIntensityMultiplier");
static_assert(offsetof(ForceFeedbackComponent_SetIntensityMultiplier, NewIntensityMultiplier) == 0x000000, "Member 'ForceFeedbackComponent_SetIntensityMultiplier::NewIntensityMultiplier' has a wrong offset!");

// Function Engine.ForceFeedbackComponent.BP_GetAttenuationSettingsToApply
// 0x00B0 (0x00B0 - 0x0000)
struct ForceFeedbackComponent_BP_GetAttenuationSettingsToApply final
{
public:
	struct FForceFeedbackAttenuationSettings      OutAttenuationSettings;                            // 0x0000(0x00A8)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A9[0x7];                                       // 0x00A9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ForceFeedbackComponent_BP_GetAttenuationSettingsToApply) == 0x000008, "Wrong alignment on ForceFeedbackComponent_BP_GetAttenuationSettingsToApply");
static_assert(sizeof(ForceFeedbackComponent_BP_GetAttenuationSettingsToApply) == 0x0000B0, "Wrong size on ForceFeedbackComponent_BP_GetAttenuationSettingsToApply");
static_assert(offsetof(ForceFeedbackComponent_BP_GetAttenuationSettingsToApply, OutAttenuationSettings) == 0x000000, "Member 'ForceFeedbackComponent_BP_GetAttenuationSettingsToApply::OutAttenuationSettings' has a wrong offset!");
static_assert(offsetof(ForceFeedbackComponent_BP_GetAttenuationSettingsToApply, ReturnValue) == 0x0000A8, "Member 'ForceFeedbackComponent_BP_GetAttenuationSettingsToApply::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.ActivateReverbEffect
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_ActivateReverbEffect final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReverbEffect*                          ReverbEffect;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeTime;                                          // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ActivateReverbEffect) == 0x000008, "Wrong alignment on GameplayStatics_ActivateReverbEffect");
static_assert(sizeof(GameplayStatics_ActivateReverbEffect) == 0x000028, "Wrong size on GameplayStatics_ActivateReverbEffect");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, WorldContextObject) == 0x000000, "Member 'GameplayStatics_ActivateReverbEffect::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, ReverbEffect) == 0x000008, "Member 'GameplayStatics_ActivateReverbEffect::ReverbEffect' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, TagName) == 0x000010, "Member 'GameplayStatics_ActivateReverbEffect::TagName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, Priority) == 0x000018, "Member 'GameplayStatics_ActivateReverbEffect::Priority' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, Volume) == 0x00001C, "Member 'GameplayStatics_ActivateReverbEffect::Volume' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ActivateReverbEffect, FadeTime) == 0x000020, "Member 'GameplayStatics_ActivateReverbEffect::FadeTime' has a wrong offset!");

// Function Engine.GameplayStatics.ApplyDamage
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_ApplyDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AController*                            EventInstigator;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ApplyDamage) == 0x000008, "Wrong alignment on GameplayStatics_ApplyDamage");
static_assert(sizeof(GameplayStatics_ApplyDamage) == 0x000030, "Wrong size on GameplayStatics_ApplyDamage");
static_assert(offsetof(GameplayStatics_ApplyDamage, DamagedActor) == 0x000000, "Member 'GameplayStatics_ApplyDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyDamage, BaseDamage) == 0x000008, "Member 'GameplayStatics_ApplyDamage::BaseDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyDamage, EventInstigator) == 0x000010, "Member 'GameplayStatics_ApplyDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyDamage, DamageCauser) == 0x000018, "Member 'GameplayStatics_ApplyDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyDamage, DamageTypeClass) == 0x000020, "Member 'GameplayStatics_ApplyDamage::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyDamage, ReturnValue) == 0x000028, "Member 'GameplayStatics_ApplyDamage::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.ApplyPointDamage
// 0x00C0 (0x00C0 - 0x0000)
struct GameplayStatics_ApplyPointDamage final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitFromDirection;                                  // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             HitInfo;                                           // 0x0018(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class AController*                            EventInstigator;                                   // 0x00A0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x00A8(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x00B0(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x00B8(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_BC[0x4];                                       // 0x00BC(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ApplyPointDamage) == 0x000008, "Wrong alignment on GameplayStatics_ApplyPointDamage");
static_assert(sizeof(GameplayStatics_ApplyPointDamage) == 0x0000C0, "Wrong size on GameplayStatics_ApplyPointDamage");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, DamagedActor) == 0x000000, "Member 'GameplayStatics_ApplyPointDamage::DamagedActor' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, BaseDamage) == 0x000008, "Member 'GameplayStatics_ApplyPointDamage::BaseDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, HitFromDirection) == 0x00000C, "Member 'GameplayStatics_ApplyPointDamage::HitFromDirection' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, HitInfo) == 0x000018, "Member 'GameplayStatics_ApplyPointDamage::HitInfo' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, EventInstigator) == 0x0000A0, "Member 'GameplayStatics_ApplyPointDamage::EventInstigator' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, DamageCauser) == 0x0000A8, "Member 'GameplayStatics_ApplyPointDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, DamageTypeClass) == 0x0000B0, "Member 'GameplayStatics_ApplyPointDamage::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyPointDamage, ReturnValue) == 0x0000B8, "Member 'GameplayStatics_ApplyPointDamage::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.ApplyRadialDamage
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_ApplyRadialDamage final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x000C(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageRadius;                                      // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDoFullDamage;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0049(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x004A(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B[0x5];                                       // 0x004B(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ApplyRadialDamage) == 0x000008, "Wrong alignment on GameplayStatics_ApplyRadialDamage");
static_assert(sizeof(GameplayStatics_ApplyRadialDamage) == 0x000050, "Wrong size on GameplayStatics_ApplyRadialDamage");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, WorldContextObject) == 0x000000, "Member 'GameplayStatics_ApplyRadialDamage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, BaseDamage) == 0x000008, "Member 'GameplayStatics_ApplyRadialDamage::BaseDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, Origin) == 0x00000C, "Member 'GameplayStatics_ApplyRadialDamage::Origin' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, DamageRadius) == 0x000018, "Member 'GameplayStatics_ApplyRadialDamage::DamageRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, DamageTypeClass) == 0x000020, "Member 'GameplayStatics_ApplyRadialDamage::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, IgnoreActors) == 0x000028, "Member 'GameplayStatics_ApplyRadialDamage::IgnoreActors' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, DamageCauser) == 0x000038, "Member 'GameplayStatics_ApplyRadialDamage::DamageCauser' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, InstigatedByController) == 0x000040, "Member 'GameplayStatics_ApplyRadialDamage::InstigatedByController' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, bDoFullDamage) == 0x000048, "Member 'GameplayStatics_ApplyRadialDamage::bDoFullDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, DamagePreventionChannel) == 0x000049, "Member 'GameplayStatics_ApplyRadialDamage::DamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamage, ReturnValue) == 0x00004A, "Member 'GameplayStatics_ApplyRadialDamage::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.ApplyRadialDamageWithFalloff
// 0x0058 (0x0058 - 0x0000)
struct GameplayStatics_ApplyRadialDamageWithFalloff final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseDamage;                                        // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MinimumDamage;                                     // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageInnerRadius;                                 // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageOuterRadius;                                 // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DamageFalloff;                                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UDamageType>                DamageTypeClass;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         IgnoreActors;                                      // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            InstigatedByController;                            // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DamagePreventionChannel;                           // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0051(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ApplyRadialDamageWithFalloff) == 0x000008, "Wrong alignment on GameplayStatics_ApplyRadialDamageWithFalloff");
static_assert(sizeof(GameplayStatics_ApplyRadialDamageWithFalloff) == 0x000058, "Wrong size on GameplayStatics_ApplyRadialDamageWithFalloff");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, WorldContextObject) == 0x000000, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, BaseDamage) == 0x000008, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::BaseDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, MinimumDamage) == 0x00000C, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::MinimumDamage' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, Origin) == 0x000010, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::Origin' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamageInnerRadius) == 0x00001C, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamageInnerRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamageOuterRadius) == 0x000020, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamageOuterRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamageFalloff) == 0x000024, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamageFalloff' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamageTypeClass) == 0x000028, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamageTypeClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, IgnoreActors) == 0x000030, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::IgnoreActors' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamageCauser) == 0x000040, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamageCauser' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, InstigatedByController) == 0x000048, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::InstigatedByController' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, DamagePreventionChannel) == 0x000050, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::DamagePreventionChannel' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ApplyRadialDamageWithFalloff, ReturnValue) == 0x000051, "Member 'GameplayStatics_ApplyRadialDamageWithFalloff::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.AreAnyListenersWithinRange
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_AreAnyListenersWithinRange final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumRange;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_AreAnyListenersWithinRange) == 0x000008, "Wrong alignment on GameplayStatics_AreAnyListenersWithinRange");
static_assert(sizeof(GameplayStatics_AreAnyListenersWithinRange) == 0x000020, "Wrong size on GameplayStatics_AreAnyListenersWithinRange");
static_assert(offsetof(GameplayStatics_AreAnyListenersWithinRange, WorldContextObject) == 0x000000, "Member 'GameplayStatics_AreAnyListenersWithinRange::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_AreAnyListenersWithinRange, Location) == 0x000008, "Member 'GameplayStatics_AreAnyListenersWithinRange::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_AreAnyListenersWithinRange, MaximumRange) == 0x000014, "Member 'GameplayStatics_AreAnyListenersWithinRange::MaximumRange' has a wrong offset!");
static_assert(offsetof(GameplayStatics_AreAnyListenersWithinRange, ReturnValue) == 0x000018, "Member 'GameplayStatics_AreAnyListenersWithinRange::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.AreSubtitlesEnabled
// 0x0001 (0x0001 - 0x0000)
struct GameplayStatics_AreSubtitlesEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_AreSubtitlesEnabled) == 0x000001, "Wrong alignment on GameplayStatics_AreSubtitlesEnabled");
static_assert(sizeof(GameplayStatics_AreSubtitlesEnabled) == 0x000001, "Wrong size on GameplayStatics_AreSubtitlesEnabled");
static_assert(offsetof(GameplayStatics_AreSubtitlesEnabled, ReturnValue) == 0x000000, "Member 'GameplayStatics_AreSubtitlesEnabled::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.BeginDeferredActorSpawnFromClass
// 0x0060 (0x0060 - 0x0000)
struct GameplayStatics_BeginDeferredActorSpawnFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ESpawnActorCollisionHandlingMethod            CollisionHandlingOverride;                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_BeginDeferredActorSpawnFromClass) == 0x000010, "Wrong alignment on GameplayStatics_BeginDeferredActorSpawnFromClass");
static_assert(sizeof(GameplayStatics_BeginDeferredActorSpawnFromClass) == 0x000060, "Wrong size on GameplayStatics_BeginDeferredActorSpawnFromClass");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, WorldContextObject) == 0x000000, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, ActorClass) == 0x000008, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, SpawnTransform) == 0x000010, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, CollisionHandlingOverride) == 0x000040, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::CollisionHandlingOverride' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, Owner) == 0x000048, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::Owner' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginDeferredActorSpawnFromClass, ReturnValue) == 0x000050, "Member 'GameplayStatics_BeginDeferredActorSpawnFromClass::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.BeginSpawningActorFromBlueprint
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_BeginSpawningActorFromBlueprint final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UBlueprint*                       Blueprint;                                         // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNoCollisionFail;                                  // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 ReturnValue;                                       // 0x0048(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_BeginSpawningActorFromBlueprint) == 0x000010, "Wrong alignment on GameplayStatics_BeginSpawningActorFromBlueprint");
static_assert(sizeof(GameplayStatics_BeginSpawningActorFromBlueprint) == 0x000050, "Wrong size on GameplayStatics_BeginSpawningActorFromBlueprint");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromBlueprint, WorldContextObject) == 0x000000, "Member 'GameplayStatics_BeginSpawningActorFromBlueprint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromBlueprint, Blueprint) == 0x000008, "Member 'GameplayStatics_BeginSpawningActorFromBlueprint::Blueprint' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromBlueprint, SpawnTransform) == 0x000010, "Member 'GameplayStatics_BeginSpawningActorFromBlueprint::SpawnTransform' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromBlueprint, bNoCollisionFail) == 0x000040, "Member 'GameplayStatics_BeginSpawningActorFromBlueprint::bNoCollisionFail' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromBlueprint, ReturnValue) == 0x000048, "Member 'GameplayStatics_BeginSpawningActorFromBlueprint::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.BeginSpawningActorFromClass
// 0x0060 (0x0060 - 0x0000)
struct GameplayStatics_BeginSpawningActorFromClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bNoCollisionFail;                                  // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 Owner;                                             // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_BeginSpawningActorFromClass) == 0x000010, "Wrong alignment on GameplayStatics_BeginSpawningActorFromClass");
static_assert(sizeof(GameplayStatics_BeginSpawningActorFromClass) == 0x000060, "Wrong size on GameplayStatics_BeginSpawningActorFromClass");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, WorldContextObject) == 0x000000, "Member 'GameplayStatics_BeginSpawningActorFromClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, ActorClass) == 0x000008, "Member 'GameplayStatics_BeginSpawningActorFromClass::ActorClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, SpawnTransform) == 0x000010, "Member 'GameplayStatics_BeginSpawningActorFromClass::SpawnTransform' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, bNoCollisionFail) == 0x000040, "Member 'GameplayStatics_BeginSpawningActorFromClass::bNoCollisionFail' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, Owner) == 0x000048, "Member 'GameplayStatics_BeginSpawningActorFromClass::Owner' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BeginSpawningActorFromClass, ReturnValue) == 0x000050, "Member 'GameplayStatics_BeginSpawningActorFromClass::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_Advanced
// 0x0128 (0x0128 - 0x0000)
struct GameplayStatics_Blueprint_PredictProjectilePath_Advanced final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathParams           PredictParams;                                     // 0x0008(0x0060)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FPredictProjectilePathResult           PredictResult;                                     // 0x0068(0x00B8)(Parm, OutParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0120(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_121[0x7];                                      // 0x0121(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced) == 0x000008, "Wrong alignment on GameplayStatics_Blueprint_PredictProjectilePath_Advanced");
static_assert(sizeof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced) == 0x000128, "Wrong size on GameplayStatics_Blueprint_PredictProjectilePath_Advanced");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced, WorldContextObject) == 0x000000, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_Advanced::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced, PredictParams) == 0x000008, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_Advanced::PredictParams' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced, PredictResult) == 0x000068, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_Advanced::PredictResult' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_Advanced, ReturnValue) == 0x000120, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_Advanced::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByObjectType
// 0x0110 (0x0110 - 0x0000)
struct GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        OutPathPositions;                                  // 0x0090(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                OutLastTraceDestination;                           // 0x00A0(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x00AC(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LaunchVelocity;                                    // 0x00B8(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracePath;                                        // 0x00C4(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileRadius;                                  // 0x00C8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CC[0x4];                                       // 0x00CC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x00D0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x00E0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x7];                                       // 0x00E1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x00E8(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x00F8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x3];                                       // 0x00F9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x00FC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x0100(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x0104(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x0108(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x010C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10D[0x3];                                      // 0x010D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType) == 0x000008, "Wrong alignment on GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType");
static_assert(sizeof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType) == 0x000110, "Wrong size on GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, WorldContextObject) == 0x000000, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, OutHit) == 0x000008, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::OutHit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, OutPathPositions) == 0x000090, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::OutPathPositions' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, OutLastTraceDestination) == 0x0000A0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::OutLastTraceDestination' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, StartPos) == 0x0000AC, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::StartPos' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, LaunchVelocity) == 0x0000B8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, bTracePath) == 0x0000C4, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::bTracePath' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, ProjectileRadius) == 0x0000C8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, ObjectTypes) == 0x0000D0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::ObjectTypes' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, bTraceComplex) == 0x0000E0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, ActorsToIgnore) == 0x0000E8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, DrawDebugType) == 0x0000F8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::DrawDebugType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, DrawDebugTime) == 0x0000FC, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::DrawDebugTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, SimFrequency) == 0x000100, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::SimFrequency' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, MaxSimTime) == 0x000104, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::MaxSimTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, OverrideGravityZ) == 0x000108, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::OverrideGravityZ' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType, ReturnValue) == 0x00010C, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByObjectType::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.Blueprint_PredictProjectilePath_ByTraceChannel
// 0x00F8 (0x00F8 - 0x0000)
struct GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             OutHit;                                            // 0x0008(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        OutPathPositions;                                  // 0x0090(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                OutLastTraceDestination;                           // 0x00A0(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x00AC(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LaunchVelocity;                                    // 0x00B8(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTracePath;                                        // 0x00C4(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C5[0x3];                                       // 0x00C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ProjectileRadius;                                  // 0x00C8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             TraceChannel;                                      // 0x00CC(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x00CD(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_CE[0x2];                                       // 0x00CE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x00D0(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x00E0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DrawDebugTime;                                     // 0x00E4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SimFrequency;                                      // 0x00E8(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxSimTime;                                        // 0x00EC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x00F0(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F4(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F5[0x3];                                       // 0x00F5(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel) == 0x000008, "Wrong alignment on GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel");
static_assert(sizeof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel) == 0x0000F8, "Wrong size on GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, WorldContextObject) == 0x000000, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, OutHit) == 0x000008, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::OutHit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, OutPathPositions) == 0x000090, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::OutPathPositions' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, OutLastTraceDestination) == 0x0000A0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::OutLastTraceDestination' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, StartPos) == 0x0000AC, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::StartPos' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, LaunchVelocity) == 0x0000B8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::LaunchVelocity' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, bTracePath) == 0x0000C4, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::bTracePath' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, ProjectileRadius) == 0x0000C8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::ProjectileRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, TraceChannel) == 0x0000CC, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::TraceChannel' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, bTraceComplex) == 0x0000CD, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::bTraceComplex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, ActorsToIgnore) == 0x0000D0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, DrawDebugType) == 0x0000E0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::DrawDebugType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, DrawDebugTime) == 0x0000E4, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::DrawDebugTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, SimFrequency) == 0x0000E8, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::SimFrequency' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, MaxSimTime) == 0x0000EC, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::MaxSimTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, OverrideGravityZ) == 0x0000F0, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::OverrideGravityZ' has a wrong offset!");
static_assert(offsetof(GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel, ReturnValue) == 0x0000F4, "Member 'GameplayStatics_Blueprint_PredictProjectilePath_ByTraceChannel::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.BlueprintSuggestProjectileVelocity
// 0x0040 (0x0040 - 0x0000)
struct GameplayStatics_BlueprintSuggestProjectileVelocity final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TossVelocity;                                      // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartLocation;                                     // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndLocation;                                       // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LaunchSpeed;                                       // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESuggestProjVelocityTraceOption               TraceOption;                                       // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         CollisionRadius;                                   // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFavorHighArc;                                     // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawDebug;                                        // 0x003D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003E(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F[0x1];                                       // 0x003F(0x0001)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_BlueprintSuggestProjectileVelocity) == 0x000008, "Wrong alignment on GameplayStatics_BlueprintSuggestProjectileVelocity");
static_assert(sizeof(GameplayStatics_BlueprintSuggestProjectileVelocity) == 0x000040, "Wrong size on GameplayStatics_BlueprintSuggestProjectileVelocity");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, WorldContextObject) == 0x000000, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, TossVelocity) == 0x000008, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::TossVelocity' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, StartLocation) == 0x000014, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::StartLocation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, EndLocation) == 0x000020, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::EndLocation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, LaunchSpeed) == 0x00002C, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::LaunchSpeed' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, OverrideGravityZ) == 0x000030, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::OverrideGravityZ' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, TraceOption) == 0x000034, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::TraceOption' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, CollisionRadius) == 0x000038, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::CollisionRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, bFavorHighArc) == 0x00003C, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::bFavorHighArc' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, bDrawDebug) == 0x00003D, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::bDrawDebug' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BlueprintSuggestProjectileVelocity, ReturnValue) == 0x00003E, "Member 'GameplayStatics_BlueprintSuggestProjectileVelocity::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.BreakHitResult
// 0x0108 (0x0108 - 0x0000)
struct GameplayStatics_BreakHitResult final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bBlockingHit;                                      // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialOverlap;                                   // 0x0089(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8A[0x2];                                       // 0x008A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x008C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0090(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0094(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x00A0(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x00AC(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x00B8(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C4[0x4];                                       // 0x00C4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMat;                                           // 0x00C8(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x00D0(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x00D8(0x0008)(Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoneName;                                       // 0x00E0(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitItem;                                           // 0x00E8(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceIndex;                                         // 0x00EC(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x00F0(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x00FC(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_BreakHitResult) == 0x000008, "Wrong alignment on GameplayStatics_BreakHitResult");
static_assert(sizeof(GameplayStatics_BreakHitResult) == 0x000108, "Wrong size on GameplayStatics_BreakHitResult");
static_assert(offsetof(GameplayStatics_BreakHitResult, Hit) == 0x000000, "Member 'GameplayStatics_BreakHitResult::Hit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, bBlockingHit) == 0x000088, "Member 'GameplayStatics_BreakHitResult::bBlockingHit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, bInitialOverlap) == 0x000089, "Member 'GameplayStatics_BreakHitResult::bInitialOverlap' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, Time) == 0x00008C, "Member 'GameplayStatics_BreakHitResult::Time' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, Distance) == 0x000090, "Member 'GameplayStatics_BreakHitResult::Distance' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, Location) == 0x000094, "Member 'GameplayStatics_BreakHitResult::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, ImpactPoint) == 0x0000A0, "Member 'GameplayStatics_BreakHitResult::ImpactPoint' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, Normal) == 0x0000AC, "Member 'GameplayStatics_BreakHitResult::Normal' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, ImpactNormal) == 0x0000B8, "Member 'GameplayStatics_BreakHitResult::ImpactNormal' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, PhysMat) == 0x0000C8, "Member 'GameplayStatics_BreakHitResult::PhysMat' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, HitActor) == 0x0000D0, "Member 'GameplayStatics_BreakHitResult::HitActor' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, HitComponent) == 0x0000D8, "Member 'GameplayStatics_BreakHitResult::HitComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, HitBoneName) == 0x0000E0, "Member 'GameplayStatics_BreakHitResult::HitBoneName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, HitItem) == 0x0000E8, "Member 'GameplayStatics_BreakHitResult::HitItem' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, FaceIndex) == 0x0000EC, "Member 'GameplayStatics_BreakHitResult::FaceIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, TraceStart) == 0x0000F0, "Member 'GameplayStatics_BreakHitResult::TraceStart' has a wrong offset!");
static_assert(offsetof(GameplayStatics_BreakHitResult, TraceEnd) == 0x0000FC, "Member 'GameplayStatics_BreakHitResult::TraceEnd' has a wrong offset!");

// Function Engine.GameplayStatics.ClearSoundMixClassOverride
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_ClearSoundMixClassOverride final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              InSoundMixModifier;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            InSoundClass;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeOutTime;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ClearSoundMixClassOverride) == 0x000008, "Wrong alignment on GameplayStatics_ClearSoundMixClassOverride");
static_assert(sizeof(GameplayStatics_ClearSoundMixClassOverride) == 0x000020, "Wrong size on GameplayStatics_ClearSoundMixClassOverride");
static_assert(offsetof(GameplayStatics_ClearSoundMixClassOverride, WorldContextObject) == 0x000000, "Member 'GameplayStatics_ClearSoundMixClassOverride::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ClearSoundMixClassOverride, InSoundMixModifier) == 0x000008, "Member 'GameplayStatics_ClearSoundMixClassOverride::InSoundMixModifier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ClearSoundMixClassOverride, InSoundClass) == 0x000010, "Member 'GameplayStatics_ClearSoundMixClassOverride::InSoundClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ClearSoundMixClassOverride, FadeOutTime) == 0x000018, "Member 'GameplayStatics_ClearSoundMixClassOverride::FadeOutTime' has a wrong offset!");

// Function Engine.GameplayStatics.ClearSoundMixModifiers
// 0x0008 (0x0008 - 0x0000)
struct GameplayStatics_ClearSoundMixModifiers final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_ClearSoundMixModifiers) == 0x000008, "Wrong alignment on GameplayStatics_ClearSoundMixModifiers");
static_assert(sizeof(GameplayStatics_ClearSoundMixModifiers) == 0x000008, "Wrong size on GameplayStatics_ClearSoundMixModifiers");
static_assert(offsetof(GameplayStatics_ClearSoundMixModifiers, WorldContextObject) == 0x000000, "Member 'GameplayStatics_ClearSoundMixModifiers::WorldContextObject' has a wrong offset!");

// Function Engine.GameplayStatics.CreatePlayer
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_CreatePlayer final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerId;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpawnPawn;                                        // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_CreatePlayer) == 0x000008, "Wrong alignment on GameplayStatics_CreatePlayer");
static_assert(sizeof(GameplayStatics_CreatePlayer) == 0x000018, "Wrong size on GameplayStatics_CreatePlayer");
static_assert(offsetof(GameplayStatics_CreatePlayer, WorldContextObject) == 0x000000, "Member 'GameplayStatics_CreatePlayer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreatePlayer, ControllerId) == 0x000008, "Member 'GameplayStatics_CreatePlayer::ControllerId' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreatePlayer, bSpawnPawn) == 0x00000C, "Member 'GameplayStatics_CreatePlayer::bSpawnPawn' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreatePlayer, ReturnValue) == 0x000010, "Member 'GameplayStatics_CreatePlayer::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.CreateSaveGameObject
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_CreateSaveGameObject final
{
public:
	TSubclassOf<class USaveGame>                  SaveGameClass;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_CreateSaveGameObject) == 0x000008, "Wrong alignment on GameplayStatics_CreateSaveGameObject");
static_assert(sizeof(GameplayStatics_CreateSaveGameObject) == 0x000010, "Wrong size on GameplayStatics_CreateSaveGameObject");
static_assert(offsetof(GameplayStatics_CreateSaveGameObject, SaveGameClass) == 0x000000, "Member 'GameplayStatics_CreateSaveGameObject::SaveGameClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSaveGameObject, ReturnValue) == 0x000008, "Member 'GameplayStatics_CreateSaveGameObject::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.CreateSaveGameObjectFromBlueprint
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_CreateSaveGameObjectFromBlueprint final
{
public:
	class UBlueprint*                             SaveGameBlueprint;                                 // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USaveGame*                              ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_CreateSaveGameObjectFromBlueprint) == 0x000008, "Wrong alignment on GameplayStatics_CreateSaveGameObjectFromBlueprint");
static_assert(sizeof(GameplayStatics_CreateSaveGameObjectFromBlueprint) == 0x000010, "Wrong size on GameplayStatics_CreateSaveGameObjectFromBlueprint");
static_assert(offsetof(GameplayStatics_CreateSaveGameObjectFromBlueprint, SaveGameBlueprint) == 0x000000, "Member 'GameplayStatics_CreateSaveGameObjectFromBlueprint::SaveGameBlueprint' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSaveGameObjectFromBlueprint, ReturnValue) == 0x000008, "Member 'GameplayStatics_CreateSaveGameObjectFromBlueprint::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.CreateSound2D
// 0x0038 (0x0038 - 0x0000)
struct GameplayStatics_CreateSound2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistAcrossLevelTransition;                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_CreateSound2D) == 0x000008, "Wrong alignment on GameplayStatics_CreateSound2D");
static_assert(sizeof(GameplayStatics_CreateSound2D) == 0x000038, "Wrong size on GameplayStatics_CreateSound2D");
static_assert(offsetof(GameplayStatics_CreateSound2D, WorldContextObject) == 0x000000, "Member 'GameplayStatics_CreateSound2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, Sound) == 0x000008, "Member 'GameplayStatics_CreateSound2D::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, VolumeMultiplier) == 0x000010, "Member 'GameplayStatics_CreateSound2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, PitchMultiplier) == 0x000014, "Member 'GameplayStatics_CreateSound2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, StartTime) == 0x000018, "Member 'GameplayStatics_CreateSound2D::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, ConcurrencySettings) == 0x000020, "Member 'GameplayStatics_CreateSound2D::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, bPersistAcrossLevelTransition) == 0x000028, "Member 'GameplayStatics_CreateSound2D::bPersistAcrossLevelTransition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, bAutoDestroy) == 0x000029, "Member 'GameplayStatics_CreateSound2D::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_CreateSound2D, ReturnValue) == 0x000030, "Member 'GameplayStatics_CreateSound2D::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.DeactivateReverbEffect
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_DeactivateReverbEffect final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   TagName;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_DeactivateReverbEffect) == 0x000008, "Wrong alignment on GameplayStatics_DeactivateReverbEffect");
static_assert(sizeof(GameplayStatics_DeactivateReverbEffect) == 0x000010, "Wrong size on GameplayStatics_DeactivateReverbEffect");
static_assert(offsetof(GameplayStatics_DeactivateReverbEffect, WorldContextObject) == 0x000000, "Member 'GameplayStatics_DeactivateReverbEffect::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeactivateReverbEffect, TagName) == 0x000008, "Member 'GameplayStatics_DeactivateReverbEffect::TagName' has a wrong offset!");

// Function Engine.GameplayStatics.DeleteGameInSlot
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_DeleteGameInSlot final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_DeleteGameInSlot) == 0x000008, "Wrong alignment on GameplayStatics_DeleteGameInSlot");
static_assert(sizeof(GameplayStatics_DeleteGameInSlot) == 0x000018, "Wrong size on GameplayStatics_DeleteGameInSlot");
static_assert(offsetof(GameplayStatics_DeleteGameInSlot, SlotName) == 0x000000, "Member 'GameplayStatics_DeleteGameInSlot::SlotName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeleteGameInSlot, UserIndex) == 0x000010, "Member 'GameplayStatics_DeleteGameInSlot::UserIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeleteGameInSlot, ReturnValue) == 0x000014, "Member 'GameplayStatics_DeleteGameInSlot::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.DeprojectScreenToWorld
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_DeprojectScreenToWorld final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0008(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldDirection;                                    // 0x001C(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_DeprojectScreenToWorld) == 0x000008, "Wrong alignment on GameplayStatics_DeprojectScreenToWorld");
static_assert(sizeof(GameplayStatics_DeprojectScreenToWorld) == 0x000030, "Wrong size on GameplayStatics_DeprojectScreenToWorld");
static_assert(offsetof(GameplayStatics_DeprojectScreenToWorld, Player) == 0x000000, "Member 'GameplayStatics_DeprojectScreenToWorld::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeprojectScreenToWorld, ScreenPosition) == 0x000008, "Member 'GameplayStatics_DeprojectScreenToWorld::ScreenPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeprojectScreenToWorld, WorldPosition) == 0x000010, "Member 'GameplayStatics_DeprojectScreenToWorld::WorldPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeprojectScreenToWorld, WorldDirection) == 0x00001C, "Member 'GameplayStatics_DeprojectScreenToWorld::WorldDirection' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DeprojectScreenToWorld, ReturnValue) == 0x000028, "Member 'GameplayStatics_DeprojectScreenToWorld::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.DoesSaveGameExist
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_DoesSaveGameExist final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0014(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_DoesSaveGameExist) == 0x000008, "Wrong alignment on GameplayStatics_DoesSaveGameExist");
static_assert(sizeof(GameplayStatics_DoesSaveGameExist) == 0x000018, "Wrong size on GameplayStatics_DoesSaveGameExist");
static_assert(offsetof(GameplayStatics_DoesSaveGameExist, SlotName) == 0x000000, "Member 'GameplayStatics_DoesSaveGameExist::SlotName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DoesSaveGameExist, UserIndex) == 0x000010, "Member 'GameplayStatics_DoesSaveGameExist::UserIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_DoesSaveGameExist, ReturnValue) == 0x000014, "Member 'GameplayStatics_DoesSaveGameExist::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.EnableLiveStreaming
// 0x0001 (0x0001 - 0x0000)
struct GameplayStatics_EnableLiveStreaming final
{
public:
	bool                                          Enable;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_EnableLiveStreaming) == 0x000001, "Wrong alignment on GameplayStatics_EnableLiveStreaming");
static_assert(sizeof(GameplayStatics_EnableLiveStreaming) == 0x000001, "Wrong size on GameplayStatics_EnableLiveStreaming");
static_assert(offsetof(GameplayStatics_EnableLiveStreaming, Enable) == 0x000000, "Member 'GameplayStatics_EnableLiveStreaming::Enable' has a wrong offset!");

// Function Engine.GameplayStatics.FindCollisionUV
// 0x0098 (0x0098 - 0x0000)
struct GameplayStatics_FindCollisionUV final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	int32                                         UVChannel;                                         // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              UV;                                                // 0x008C(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0094(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_95[0x3];                                       // 0x0095(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_FindCollisionUV) == 0x000008, "Wrong alignment on GameplayStatics_FindCollisionUV");
static_assert(sizeof(GameplayStatics_FindCollisionUV) == 0x000098, "Wrong size on GameplayStatics_FindCollisionUV");
static_assert(offsetof(GameplayStatics_FindCollisionUV, Hit) == 0x000000, "Member 'GameplayStatics_FindCollisionUV::Hit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_FindCollisionUV, UVChannel) == 0x000088, "Member 'GameplayStatics_FindCollisionUV::UVChannel' has a wrong offset!");
static_assert(offsetof(GameplayStatics_FindCollisionUV, UV) == 0x00008C, "Member 'GameplayStatics_FindCollisionUV::UV' has a wrong offset!");
static_assert(offsetof(GameplayStatics_FindCollisionUV, ReturnValue) == 0x000094, "Member 'GameplayStatics_FindCollisionUV::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.FinishSpawningActor
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_FinishSpawningActor final
{
public:
	class AActor*                                 Actor;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             SpawnTransform;                                    // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class AActor*                                 ReturnValue;                                       // 0x0040(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_FinishSpawningActor) == 0x000010, "Wrong alignment on GameplayStatics_FinishSpawningActor");
static_assert(sizeof(GameplayStatics_FinishSpawningActor) == 0x000050, "Wrong size on GameplayStatics_FinishSpawningActor");
static_assert(offsetof(GameplayStatics_FinishSpawningActor, Actor) == 0x000000, "Member 'GameplayStatics_FinishSpawningActor::Actor' has a wrong offset!");
static_assert(offsetof(GameplayStatics_FinishSpawningActor, SpawnTransform) == 0x000010, "Member 'GameplayStatics_FinishSpawningActor::SpawnTransform' has a wrong offset!");
static_assert(offsetof(GameplayStatics_FinishSpawningActor, ReturnValue) == 0x000040, "Member 'GameplayStatics_FinishSpawningActor::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.FlushLevelStreaming
// 0x0008 (0x0008 - 0x0000)
struct GameplayStatics_FlushLevelStreaming final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_FlushLevelStreaming) == 0x000008, "Wrong alignment on GameplayStatics_FlushLevelStreaming");
static_assert(sizeof(GameplayStatics_FlushLevelStreaming) == 0x000008, "Wrong size on GameplayStatics_FlushLevelStreaming");
static_assert(offsetof(GameplayStatics_FlushLevelStreaming, WorldContextObject) == 0x000000, "Member 'GameplayStatics_FlushLevelStreaming::WorldContextObject' has a wrong offset!");

// Function Engine.GameplayStatics.GetAccurateRealTime
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetAccurateRealTime final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Seconds;                                           // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PartialSeconds;                                    // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetAccurateRealTime) == 0x000008, "Wrong alignment on GameplayStatics_GetAccurateRealTime");
static_assert(sizeof(GameplayStatics_GetAccurateRealTime) == 0x000010, "Wrong size on GameplayStatics_GetAccurateRealTime");
static_assert(offsetof(GameplayStatics_GetAccurateRealTime, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetAccurateRealTime::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAccurateRealTime, Seconds) == 0x000008, "Member 'GameplayStatics_GetAccurateRealTime::Seconds' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAccurateRealTime, PartialSeconds) == 0x00000C, "Member 'GameplayStatics_GetAccurateRealTime::PartialSeconds' has a wrong offset!");

// Function Engine.GameplayStatics.GetActorArrayAverageLocation
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_GetActorArrayAverageLocation final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetActorArrayAverageLocation) == 0x000008, "Wrong alignment on GameplayStatics_GetActorArrayAverageLocation");
static_assert(sizeof(GameplayStatics_GetActorArrayAverageLocation) == 0x000020, "Wrong size on GameplayStatics_GetActorArrayAverageLocation");
static_assert(offsetof(GameplayStatics_GetActorArrayAverageLocation, Actors) == 0x000000, "Member 'GameplayStatics_GetActorArrayAverageLocation::Actors' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetActorArrayAverageLocation, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetActorArrayAverageLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetActorArrayBounds
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_GetActorArrayBounds final
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bOnlyCollidingComponents;                          // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Center;                                            // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0020(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetActorArrayBounds) == 0x000008, "Wrong alignment on GameplayStatics_GetActorArrayBounds");
static_assert(sizeof(GameplayStatics_GetActorArrayBounds) == 0x000030, "Wrong size on GameplayStatics_GetActorArrayBounds");
static_assert(offsetof(GameplayStatics_GetActorArrayBounds, Actors) == 0x000000, "Member 'GameplayStatics_GetActorArrayBounds::Actors' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetActorArrayBounds, bOnlyCollidingComponents) == 0x000010, "Member 'GameplayStatics_GetActorArrayBounds::bOnlyCollidingComponents' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetActorArrayBounds, Center) == 0x000014, "Member 'GameplayStatics_GetActorArrayBounds::Center' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetActorArrayBounds, BoxExtent) == 0x000020, "Member 'GameplayStatics_GetActorArrayBounds::BoxExtent' has a wrong offset!");

// Function Engine.GameplayStatics.GetAllActorsOfClass
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_GetAllActorsOfClass final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class AActor>                     ActorClass;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetAllActorsOfClass) == 0x000008, "Wrong alignment on GameplayStatics_GetAllActorsOfClass");
static_assert(sizeof(GameplayStatics_GetAllActorsOfClass) == 0x000020, "Wrong size on GameplayStatics_GetAllActorsOfClass");
static_assert(offsetof(GameplayStatics_GetAllActorsOfClass, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetAllActorsOfClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsOfClass, ActorClass) == 0x000008, "Member 'GameplayStatics_GetAllActorsOfClass::ActorClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsOfClass, OutActors) == 0x000010, "Member 'GameplayStatics_GetAllActorsOfClass::OutActors' has a wrong offset!");

// Function Engine.GameplayStatics.GetAllActorsWithInterface
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_GetAllActorsWithInterface final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetAllActorsWithInterface) == 0x000008, "Wrong alignment on GameplayStatics_GetAllActorsWithInterface");
static_assert(sizeof(GameplayStatics_GetAllActorsWithInterface) == 0x000020, "Wrong size on GameplayStatics_GetAllActorsWithInterface");
static_assert(offsetof(GameplayStatics_GetAllActorsWithInterface, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetAllActorsWithInterface::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsWithInterface, Interface) == 0x000008, "Member 'GameplayStatics_GetAllActorsWithInterface::Interface' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsWithInterface, OutActors) == 0x000010, "Member 'GameplayStatics_GetAllActorsWithInterface::OutActors' has a wrong offset!");

// Function Engine.GameplayStatics.GetAllActorsWithTag
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_GetAllActorsWithTag final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Tag;                                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetAllActorsWithTag) == 0x000008, "Wrong alignment on GameplayStatics_GetAllActorsWithTag");
static_assert(sizeof(GameplayStatics_GetAllActorsWithTag) == 0x000020, "Wrong size on GameplayStatics_GetAllActorsWithTag");
static_assert(offsetof(GameplayStatics_GetAllActorsWithTag, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetAllActorsWithTag::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsWithTag, Tag) == 0x000008, "Member 'GameplayStatics_GetAllActorsWithTag::Tag' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAllActorsWithTag, OutActors) == 0x000010, "Member 'GameplayStatics_GetAllActorsWithTag::OutActors' has a wrong offset!");

// Function Engine.GameplayStatics.GetAudioTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetAudioTimeSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetAudioTimeSeconds) == 0x000008, "Wrong alignment on GameplayStatics_GetAudioTimeSeconds");
static_assert(sizeof(GameplayStatics_GetAudioTimeSeconds) == 0x000010, "Wrong size on GameplayStatics_GetAudioTimeSeconds");
static_assert(offsetof(GameplayStatics_GetAudioTimeSeconds, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetAudioTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetAudioTimeSeconds, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetAudioTimeSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetCurrentLevelName
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_GetCurrentLevelName final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRemovePrefixString;                               // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetCurrentLevelName) == 0x000008, "Wrong alignment on GameplayStatics_GetCurrentLevelName");
static_assert(sizeof(GameplayStatics_GetCurrentLevelName) == 0x000020, "Wrong size on GameplayStatics_GetCurrentLevelName");
static_assert(offsetof(GameplayStatics_GetCurrentLevelName, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetCurrentLevelName::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetCurrentLevelName, bRemovePrefixString) == 0x000008, "Member 'GameplayStatics_GetCurrentLevelName::bRemovePrefixString' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetCurrentLevelName, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetCurrentLevelName::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetCurrentReverbEffect
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetCurrentReverbEffect final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UReverbEffect*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetCurrentReverbEffect) == 0x000008, "Wrong alignment on GameplayStatics_GetCurrentReverbEffect");
static_assert(sizeof(GameplayStatics_GetCurrentReverbEffect) == 0x000010, "Wrong size on GameplayStatics_GetCurrentReverbEffect");
static_assert(offsetof(GameplayStatics_GetCurrentReverbEffect, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetCurrentReverbEffect::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetCurrentReverbEffect, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetCurrentReverbEffect::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetGameInstance
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetGameInstance final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UGameInstance*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetGameInstance) == 0x000008, "Wrong alignment on GameplayStatics_GetGameInstance");
static_assert(sizeof(GameplayStatics_GetGameInstance) == 0x000010, "Wrong size on GameplayStatics_GetGameInstance");
static_assert(offsetof(GameplayStatics_GetGameInstance, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetGameInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetGameInstance, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetGameInstance::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetGameMode
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetGameMode final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameModeBase*                          ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetGameMode) == 0x000008, "Wrong alignment on GameplayStatics_GetGameMode");
static_assert(sizeof(GameplayStatics_GetGameMode) == 0x000010, "Wrong size on GameplayStatics_GetGameMode");
static_assert(offsetof(GameplayStatics_GetGameMode, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetGameMode::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetGameMode, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetGameMode::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetGameState
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetGameState final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AGameStateBase*                         ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetGameState) == 0x000008, "Wrong alignment on GameplayStatics_GetGameState");
static_assert(sizeof(GameplayStatics_GetGameState) == 0x000010, "Wrong size on GameplayStatics_GetGameState");
static_assert(offsetof(GameplayStatics_GetGameState, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetGameState::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetGameState, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetGameState::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetGlobalTimeDilation
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetGlobalTimeDilation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetGlobalTimeDilation) == 0x000008, "Wrong alignment on GameplayStatics_GetGlobalTimeDilation");
static_assert(sizeof(GameplayStatics_GetGlobalTimeDilation) == 0x000010, "Wrong size on GameplayStatics_GetGlobalTimeDilation");
static_assert(offsetof(GameplayStatics_GetGlobalTimeDilation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetGlobalTimeDilation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetGlobalTimeDilation, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetGlobalTimeDilation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetIntOption
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_GetIntOption final
{
public:
	class FString                                 Options;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DefaultValue;                                      // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0024(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetIntOption) == 0x000008, "Wrong alignment on GameplayStatics_GetIntOption");
static_assert(sizeof(GameplayStatics_GetIntOption) == 0x000028, "Wrong size on GameplayStatics_GetIntOption");
static_assert(offsetof(GameplayStatics_GetIntOption, Options) == 0x000000, "Member 'GameplayStatics_GetIntOption::Options' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetIntOption, Key) == 0x000010, "Member 'GameplayStatics_GetIntOption::Key' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetIntOption, DefaultValue) == 0x000020, "Member 'GameplayStatics_GetIntOption::DefaultValue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetIntOption, ReturnValue) == 0x000024, "Member 'GameplayStatics_GetIntOption::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetKeyValue
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_GetKeyValue final
{
public:
	class FString                                 Pair;                                              // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetKeyValue) == 0x000008, "Wrong alignment on GameplayStatics_GetKeyValue");
static_assert(sizeof(GameplayStatics_GetKeyValue) == 0x000030, "Wrong size on GameplayStatics_GetKeyValue");
static_assert(offsetof(GameplayStatics_GetKeyValue, Pair) == 0x000000, "Member 'GameplayStatics_GetKeyValue::Pair' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetKeyValue, Key) == 0x000010, "Member 'GameplayStatics_GetKeyValue::Key' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetKeyValue, Value) == 0x000020, "Member 'GameplayStatics_GetKeyValue::Value' has a wrong offset!");

// Function Engine.GameplayStatics.GetObjectClass
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetObjectClass final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UClass*                                 ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetObjectClass) == 0x000008, "Wrong alignment on GameplayStatics_GetObjectClass");
static_assert(sizeof(GameplayStatics_GetObjectClass) == 0x000010, "Wrong size on GameplayStatics_GetObjectClass");
static_assert(offsetof(GameplayStatics_GetObjectClass, Object) == 0x000000, "Member 'GameplayStatics_GetObjectClass::Object' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetObjectClass, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetObjectClass::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlatformName
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetPlatformName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetPlatformName) == 0x000008, "Wrong alignment on GameplayStatics_GetPlatformName");
static_assert(sizeof(GameplayStatics_GetPlatformName) == 0x000010, "Wrong size on GameplayStatics_GetPlatformName");
static_assert(offsetof(GameplayStatics_GetPlatformName, ReturnValue) == 0x000000, "Member 'GameplayStatics_GetPlatformName::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlayerCameraManager
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetPlayerCameraManager final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerCameraManager*                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetPlayerCameraManager) == 0x000008, "Wrong alignment on GameplayStatics_GetPlayerCameraManager");
static_assert(sizeof(GameplayStatics_GetPlayerCameraManager) == 0x000018, "Wrong size on GameplayStatics_GetPlayerCameraManager");
static_assert(offsetof(GameplayStatics_GetPlayerCameraManager, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetPlayerCameraManager::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerCameraManager, PlayerIndex) == 0x000008, "Member 'GameplayStatics_GetPlayerCameraManager::PlayerIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerCameraManager, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetPlayerCameraManager::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlayerCharacter
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetPlayerCharacter final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ACharacter*                             ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetPlayerCharacter) == 0x000008, "Wrong alignment on GameplayStatics_GetPlayerCharacter");
static_assert(sizeof(GameplayStatics_GetPlayerCharacter) == 0x000018, "Wrong size on GameplayStatics_GetPlayerCharacter");
static_assert(offsetof(GameplayStatics_GetPlayerCharacter, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetPlayerCharacter::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerCharacter, PlayerIndex) == 0x000008, "Member 'GameplayStatics_GetPlayerCharacter::PlayerIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerCharacter, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetPlayerCharacter::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlayerController
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetPlayerController final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APlayerController*                      ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetPlayerController) == 0x000008, "Wrong alignment on GameplayStatics_GetPlayerController");
static_assert(sizeof(GameplayStatics_GetPlayerController) == 0x000018, "Wrong size on GameplayStatics_GetPlayerController");
static_assert(offsetof(GameplayStatics_GetPlayerController, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetPlayerController::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerController, PlayerIndex) == 0x000008, "Member 'GameplayStatics_GetPlayerController::PlayerIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerController, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetPlayerController::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlayerControllerID
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetPlayerControllerID final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetPlayerControllerID) == 0x000008, "Wrong alignment on GameplayStatics_GetPlayerControllerID");
static_assert(sizeof(GameplayStatics_GetPlayerControllerID) == 0x000010, "Wrong size on GameplayStatics_GetPlayerControllerID");
static_assert(offsetof(GameplayStatics_GetPlayerControllerID, Player) == 0x000000, "Member 'GameplayStatics_GetPlayerControllerID::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerControllerID, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetPlayerControllerID::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetPlayerPawn
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetPlayerPawn final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIndex;                                       // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class APawn*                                  ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetPlayerPawn) == 0x000008, "Wrong alignment on GameplayStatics_GetPlayerPawn");
static_assert(sizeof(GameplayStatics_GetPlayerPawn) == 0x000018, "Wrong size on GameplayStatics_GetPlayerPawn");
static_assert(offsetof(GameplayStatics_GetPlayerPawn, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetPlayerPawn::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerPawn, PlayerIndex) == 0x000008, "Member 'GameplayStatics_GetPlayerPawn::PlayerIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetPlayerPawn, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetPlayerPawn::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetRealTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetRealTimeSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetRealTimeSeconds) == 0x000008, "Wrong alignment on GameplayStatics_GetRealTimeSeconds");
static_assert(sizeof(GameplayStatics_GetRealTimeSeconds) == 0x000010, "Wrong size on GameplayStatics_GetRealTimeSeconds");
static_assert(offsetof(GameplayStatics_GetRealTimeSeconds, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetRealTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetRealTimeSeconds, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetRealTimeSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetStreamingLevel
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetStreamingLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PackageName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ULevelStreaming*                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_GetStreamingLevel) == 0x000008, "Wrong alignment on GameplayStatics_GetStreamingLevel");
static_assert(sizeof(GameplayStatics_GetStreamingLevel) == 0x000018, "Wrong size on GameplayStatics_GetStreamingLevel");
static_assert(offsetof(GameplayStatics_GetStreamingLevel, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetStreamingLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetStreamingLevel, PackageName) == 0x000008, "Member 'GameplayStatics_GetStreamingLevel::PackageName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetStreamingLevel, ReturnValue) == 0x000010, "Member 'GameplayStatics_GetStreamingLevel::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetSurfaceType
// 0x0090 (0x0090 - 0x0000)
struct GameplayStatics_GetSurfaceType final
{
public:
	struct FHitResult                             Hit;                                               // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	EPhysicalSurface                              ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetSurfaceType) == 0x000008, "Wrong alignment on GameplayStatics_GetSurfaceType");
static_assert(sizeof(GameplayStatics_GetSurfaceType) == 0x000090, "Wrong size on GameplayStatics_GetSurfaceType");
static_assert(offsetof(GameplayStatics_GetSurfaceType, Hit) == 0x000000, "Member 'GameplayStatics_GetSurfaceType::Hit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetSurfaceType, ReturnValue) == 0x000088, "Member 'GameplayStatics_GetSurfaceType::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetTimeSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetTimeSeconds) == 0x000008, "Wrong alignment on GameplayStatics_GetTimeSeconds");
static_assert(sizeof(GameplayStatics_GetTimeSeconds) == 0x000010, "Wrong size on GameplayStatics_GetTimeSeconds");
static_assert(offsetof(GameplayStatics_GetTimeSeconds, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetTimeSeconds, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetTimeSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetUnpausedTimeSeconds
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetUnpausedTimeSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetUnpausedTimeSeconds) == 0x000008, "Wrong alignment on GameplayStatics_GetUnpausedTimeSeconds");
static_assert(sizeof(GameplayStatics_GetUnpausedTimeSeconds) == 0x000010, "Wrong size on GameplayStatics_GetUnpausedTimeSeconds");
static_assert(offsetof(GameplayStatics_GetUnpausedTimeSeconds, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetUnpausedTimeSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetUnpausedTimeSeconds, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetUnpausedTimeSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetWorldDeltaSeconds
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_GetWorldDeltaSeconds final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetWorldDeltaSeconds) == 0x000008, "Wrong alignment on GameplayStatics_GetWorldDeltaSeconds");
static_assert(sizeof(GameplayStatics_GetWorldDeltaSeconds) == 0x000010, "Wrong size on GameplayStatics_GetWorldDeltaSeconds");
static_assert(offsetof(GameplayStatics_GetWorldDeltaSeconds, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetWorldDeltaSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetWorldDeltaSeconds, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetWorldDeltaSeconds::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GetWorldOriginLocation
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_GetWorldOriginLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GetWorldOriginLocation) == 0x000008, "Wrong alignment on GameplayStatics_GetWorldOriginLocation");
static_assert(sizeof(GameplayStatics_GetWorldOriginLocation) == 0x000018, "Wrong size on GameplayStatics_GetWorldOriginLocation");
static_assert(offsetof(GameplayStatics_GetWorldOriginLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GetWorldOriginLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GetWorldOriginLocation, ReturnValue) == 0x000008, "Member 'GameplayStatics_GetWorldOriginLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.GrassOverlappingSphereCount
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_GrassOverlappingSphereCount final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class UStaticMesh*                      StaticMesh;                                        // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CenterPosition;                                    // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_GrassOverlappingSphereCount) == 0x000008, "Wrong alignment on GameplayStatics_GrassOverlappingSphereCount");
static_assert(sizeof(GameplayStatics_GrassOverlappingSphereCount) == 0x000028, "Wrong size on GameplayStatics_GrassOverlappingSphereCount");
static_assert(offsetof(GameplayStatics_GrassOverlappingSphereCount, WorldContextObject) == 0x000000, "Member 'GameplayStatics_GrassOverlappingSphereCount::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GrassOverlappingSphereCount, StaticMesh) == 0x000008, "Member 'GameplayStatics_GrassOverlappingSphereCount::StaticMesh' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GrassOverlappingSphereCount, CenterPosition) == 0x000010, "Member 'GameplayStatics_GrassOverlappingSphereCount::CenterPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GrassOverlappingSphereCount, Radius) == 0x00001C, "Member 'GameplayStatics_GrassOverlappingSphereCount::Radius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_GrassOverlappingSphereCount, ReturnValue) == 0x000020, "Member 'GameplayStatics_GrassOverlappingSphereCount::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.HasLaunchOption
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_HasLaunchOption final
{
public:
	class FString                                 OptionToCheck;                                     // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_HasLaunchOption) == 0x000008, "Wrong alignment on GameplayStatics_HasLaunchOption");
static_assert(sizeof(GameplayStatics_HasLaunchOption) == 0x000018, "Wrong size on GameplayStatics_HasLaunchOption");
static_assert(offsetof(GameplayStatics_HasLaunchOption, OptionToCheck) == 0x000000, "Member 'GameplayStatics_HasLaunchOption::OptionToCheck' has a wrong offset!");
static_assert(offsetof(GameplayStatics_HasLaunchOption, ReturnValue) == 0x000010, "Member 'GameplayStatics_HasLaunchOption::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.HasOption
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_HasOption final
{
public:
	class FString                                 Options;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InKey;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_HasOption) == 0x000008, "Wrong alignment on GameplayStatics_HasOption");
static_assert(sizeof(GameplayStatics_HasOption) == 0x000028, "Wrong size on GameplayStatics_HasOption");
static_assert(offsetof(GameplayStatics_HasOption, Options) == 0x000000, "Member 'GameplayStatics_HasOption::Options' has a wrong offset!");
static_assert(offsetof(GameplayStatics_HasOption, InKey) == 0x000010, "Member 'GameplayStatics_HasOption::InKey' has a wrong offset!");
static_assert(offsetof(GameplayStatics_HasOption, ReturnValue) == 0x000020, "Member 'GameplayStatics_HasOption::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.IsGamePaused
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_IsGamePaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_IsGamePaused) == 0x000008, "Wrong alignment on GameplayStatics_IsGamePaused");
static_assert(sizeof(GameplayStatics_IsGamePaused) == 0x000010, "Wrong size on GameplayStatics_IsGamePaused");
static_assert(offsetof(GameplayStatics_IsGamePaused, WorldContextObject) == 0x000000, "Member 'GameplayStatics_IsGamePaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_IsGamePaused, ReturnValue) == 0x000008, "Member 'GameplayStatics_IsGamePaused::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.LoadGameFromSlot
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_LoadGameFromSlot final
{
public:
	class FString                                 SlotName;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0010(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USaveGame*                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_LoadGameFromSlot) == 0x000008, "Wrong alignment on GameplayStatics_LoadGameFromSlot");
static_assert(sizeof(GameplayStatics_LoadGameFromSlot) == 0x000020, "Wrong size on GameplayStatics_LoadGameFromSlot");
static_assert(offsetof(GameplayStatics_LoadGameFromSlot, SlotName) == 0x000000, "Member 'GameplayStatics_LoadGameFromSlot::SlotName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadGameFromSlot, UserIndex) == 0x000010, "Member 'GameplayStatics_LoadGameFromSlot::UserIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadGameFromSlot, ReturnValue) == 0x000018, "Member 'GameplayStatics_LoadGameFromSlot::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.LoadStreamLevel
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_LoadStreamLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMakeVisibleAfterLoad;                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldBlockOnLoad;                                // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0018(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_LoadStreamLevel) == 0x000008, "Wrong alignment on GameplayStatics_LoadStreamLevel");
static_assert(sizeof(GameplayStatics_LoadStreamLevel) == 0x000030, "Wrong size on GameplayStatics_LoadStreamLevel");
static_assert(offsetof(GameplayStatics_LoadStreamLevel, WorldContextObject) == 0x000000, "Member 'GameplayStatics_LoadStreamLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadStreamLevel, LevelName) == 0x000008, "Member 'GameplayStatics_LoadStreamLevel::LevelName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadStreamLevel, bMakeVisibleAfterLoad) == 0x000010, "Member 'GameplayStatics_LoadStreamLevel::bMakeVisibleAfterLoad' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadStreamLevel, bShouldBlockOnLoad) == 0x000011, "Member 'GameplayStatics_LoadStreamLevel::bShouldBlockOnLoad' has a wrong offset!");
static_assert(offsetof(GameplayStatics_LoadStreamLevel, LatentInfo) == 0x000018, "Member 'GameplayStatics_LoadStreamLevel::LatentInfo' has a wrong offset!");

// Function Engine.GameplayStatics.MakeHitResult
// 0x0108 (0x0108 - 0x0000)
struct GameplayStatics_MakeHitResult final
{
public:
	bool                                          bBlockingHit;                                      // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInitialOverlap;                                   // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Time;                                              // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Distance;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactPoint;                                       // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Normal;                                            // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ImpactNormal;                                      // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UPhysicalMaterial*                      PhysMat;                                           // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 HitActor;                                          // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UPrimitiveComponent*                    HitComponent;                                      // 0x0050(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   HitBoneName;                                       // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HitItem;                                           // 0x0060(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FaceIndex;                                         // 0x0064(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceStart;                                        // 0x0068(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TraceEnd;                                          // 0x0074(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FHitResult                             ReturnValue;                                       // 0x0080(0x0088)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_MakeHitResult) == 0x000008, "Wrong alignment on GameplayStatics_MakeHitResult");
static_assert(sizeof(GameplayStatics_MakeHitResult) == 0x000108, "Wrong size on GameplayStatics_MakeHitResult");
static_assert(offsetof(GameplayStatics_MakeHitResult, bBlockingHit) == 0x000000, "Member 'GameplayStatics_MakeHitResult::bBlockingHit' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, bInitialOverlap) == 0x000001, "Member 'GameplayStatics_MakeHitResult::bInitialOverlap' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, Time) == 0x000004, "Member 'GameplayStatics_MakeHitResult::Time' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, Distance) == 0x000008, "Member 'GameplayStatics_MakeHitResult::Distance' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, Location) == 0x00000C, "Member 'GameplayStatics_MakeHitResult::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, ImpactPoint) == 0x000018, "Member 'GameplayStatics_MakeHitResult::ImpactPoint' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, Normal) == 0x000024, "Member 'GameplayStatics_MakeHitResult::Normal' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, ImpactNormal) == 0x000030, "Member 'GameplayStatics_MakeHitResult::ImpactNormal' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, PhysMat) == 0x000040, "Member 'GameplayStatics_MakeHitResult::PhysMat' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, HitActor) == 0x000048, "Member 'GameplayStatics_MakeHitResult::HitActor' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, HitComponent) == 0x000050, "Member 'GameplayStatics_MakeHitResult::HitComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, HitBoneName) == 0x000058, "Member 'GameplayStatics_MakeHitResult::HitBoneName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, HitItem) == 0x000060, "Member 'GameplayStatics_MakeHitResult::HitItem' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, FaceIndex) == 0x000064, "Member 'GameplayStatics_MakeHitResult::FaceIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, TraceStart) == 0x000068, "Member 'GameplayStatics_MakeHitResult::TraceStart' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, TraceEnd) == 0x000074, "Member 'GameplayStatics_MakeHitResult::TraceEnd' has a wrong offset!");
static_assert(offsetof(GameplayStatics_MakeHitResult, ReturnValue) == 0x000080, "Member 'GameplayStatics_MakeHitResult::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.OpenLevel
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_OpenLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAbsolute;                                         // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Options;                                           // 0x0018(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_OpenLevel) == 0x000008, "Wrong alignment on GameplayStatics_OpenLevel");
static_assert(sizeof(GameplayStatics_OpenLevel) == 0x000028, "Wrong size on GameplayStatics_OpenLevel");
static_assert(offsetof(GameplayStatics_OpenLevel, WorldContextObject) == 0x000000, "Member 'GameplayStatics_OpenLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_OpenLevel, LevelName) == 0x000008, "Member 'GameplayStatics_OpenLevel::LevelName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_OpenLevel, bAbsolute) == 0x000010, "Member 'GameplayStatics_OpenLevel::bAbsolute' has a wrong offset!");
static_assert(offsetof(GameplayStatics_OpenLevel, Options) == 0x000018, "Member 'GameplayStatics_OpenLevel::Options' has a wrong offset!");

// Function Engine.GameplayStatics.ParseOption
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_ParseOption final
{
public:
	class FString                                 Options;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_ParseOption) == 0x000008, "Wrong alignment on GameplayStatics_ParseOption");
static_assert(sizeof(GameplayStatics_ParseOption) == 0x000030, "Wrong size on GameplayStatics_ParseOption");
static_assert(offsetof(GameplayStatics_ParseOption, Options) == 0x000000, "Member 'GameplayStatics_ParseOption::Options' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ParseOption, Key) == 0x000010, "Member 'GameplayStatics_ParseOption::Key' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ParseOption, ReturnValue) == 0x000020, "Member 'GameplayStatics_ParseOption::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.PlayDialogue2D
// 0x0038 (0x0038 - 0x0000)
struct GameplayStatics_PlayDialogue2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueWave*                          Dialogue;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_PlayDialogue2D) == 0x000008, "Wrong alignment on GameplayStatics_PlayDialogue2D");
static_assert(sizeof(GameplayStatics_PlayDialogue2D) == 0x000038, "Wrong size on GameplayStatics_PlayDialogue2D");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PlayDialogue2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, Dialogue) == 0x000008, "Member 'GameplayStatics_PlayDialogue2D::Dialogue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, Context) == 0x000010, "Member 'GameplayStatics_PlayDialogue2D::Context' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, VolumeMultiplier) == 0x000028, "Member 'GameplayStatics_PlayDialogue2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, PitchMultiplier) == 0x00002C, "Member 'GameplayStatics_PlayDialogue2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogue2D, StartTime) == 0x000030, "Member 'GameplayStatics_PlayDialogue2D::StartTime' has a wrong offset!");

// Function Engine.GameplayStatics.PlayDialogueAtLocation
// 0x0058 (0x0058 - 0x0000)
struct GameplayStatics_PlayDialogueAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueWave*                          Dialogue;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_PlayDialogueAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_PlayDialogueAtLocation");
static_assert(sizeof(GameplayStatics_PlayDialogueAtLocation) == 0x000058, "Wrong size on GameplayStatics_PlayDialogueAtLocation");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PlayDialogueAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, Dialogue) == 0x000008, "Member 'GameplayStatics_PlayDialogueAtLocation::Dialogue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, Context) == 0x000010, "Member 'GameplayStatics_PlayDialogueAtLocation::Context' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, Location) == 0x000028, "Member 'GameplayStatics_PlayDialogueAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, Rotation) == 0x000034, "Member 'GameplayStatics_PlayDialogueAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, VolumeMultiplier) == 0x000040, "Member 'GameplayStatics_PlayDialogueAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, PitchMultiplier) == 0x000044, "Member 'GameplayStatics_PlayDialogueAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, StartTime) == 0x000048, "Member 'GameplayStatics_PlayDialogueAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayDialogueAtLocation, AttenuationSettings) == 0x000050, "Member 'GameplayStatics_PlayDialogueAtLocation::AttenuationSettings' has a wrong offset!");

// Function Engine.GameplayStatics.PlaySound2D
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_PlaySound2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_PlaySound2D) == 0x000008, "Wrong alignment on GameplayStatics_PlaySound2D");
static_assert(sizeof(GameplayStatics_PlaySound2D) == 0x000030, "Wrong size on GameplayStatics_PlaySound2D");
static_assert(offsetof(GameplayStatics_PlaySound2D, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PlaySound2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, Sound) == 0x000008, "Member 'GameplayStatics_PlaySound2D::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, VolumeMultiplier) == 0x000010, "Member 'GameplayStatics_PlaySound2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, PitchMultiplier) == 0x000014, "Member 'GameplayStatics_PlaySound2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, StartTime) == 0x000018, "Member 'GameplayStatics_PlaySound2D::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, ConcurrencySettings) == 0x000020, "Member 'GameplayStatics_PlaySound2D::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySound2D, OwningActor) == 0x000028, "Member 'GameplayStatics_PlaySound2D::OwningActor' has a wrong offset!");

// Function Engine.GameplayStatics.PlaySoundAtLocation
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_PlaySoundAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 OwningActor;                                       // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_PlaySoundAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_PlaySoundAtLocation");
static_assert(sizeof(GameplayStatics_PlaySoundAtLocation) == 0x000050, "Wrong size on GameplayStatics_PlaySoundAtLocation");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PlaySoundAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, Sound) == 0x000008, "Member 'GameplayStatics_PlaySoundAtLocation::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, Location) == 0x000010, "Member 'GameplayStatics_PlaySoundAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, Rotation) == 0x00001C, "Member 'GameplayStatics_PlaySoundAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, VolumeMultiplier) == 0x000028, "Member 'GameplayStatics_PlaySoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, PitchMultiplier) == 0x00002C, "Member 'GameplayStatics_PlaySoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, StartTime) == 0x000030, "Member 'GameplayStatics_PlaySoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, AttenuationSettings) == 0x000038, "Member 'GameplayStatics_PlaySoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, ConcurrencySettings) == 0x000040, "Member 'GameplayStatics_PlaySoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlaySoundAtLocation, OwningActor) == 0x000048, "Member 'GameplayStatics_PlaySoundAtLocation::OwningActor' has a wrong offset!");

// Function Engine.GameplayStatics.PlayWorldCameraShake
// 0x0030 (0x0030 - 0x0000)
struct GameplayStatics_PlayWorldCameraShake final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UCameraShake>               Shake;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Epicenter;                                         // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InnerRadius;                                       // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OuterRadius;                                       // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Falloff;                                           // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bOrientShakeTowardsEpicenter;                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_PlayWorldCameraShake) == 0x000008, "Wrong alignment on GameplayStatics_PlayWorldCameraShake");
static_assert(sizeof(GameplayStatics_PlayWorldCameraShake) == 0x000030, "Wrong size on GameplayStatics_PlayWorldCameraShake");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PlayWorldCameraShake::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, Shake) == 0x000008, "Member 'GameplayStatics_PlayWorldCameraShake::Shake' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, Epicenter) == 0x000010, "Member 'GameplayStatics_PlayWorldCameraShake::Epicenter' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, InnerRadius) == 0x00001C, "Member 'GameplayStatics_PlayWorldCameraShake::InnerRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, OuterRadius) == 0x000020, "Member 'GameplayStatics_PlayWorldCameraShake::OuterRadius' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, Falloff) == 0x000024, "Member 'GameplayStatics_PlayWorldCameraShake::Falloff' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PlayWorldCameraShake, bOrientShakeTowardsEpicenter) == 0x000028, "Member 'GameplayStatics_PlayWorldCameraShake::bOrientShakeTowardsEpicenter' has a wrong offset!");

// Function Engine.GameplayStatics.PopSoundMixModifier
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_PopSoundMixModifier final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              InSoundMixModifier;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_PopSoundMixModifier) == 0x000008, "Wrong alignment on GameplayStatics_PopSoundMixModifier");
static_assert(sizeof(GameplayStatics_PopSoundMixModifier) == 0x000010, "Wrong size on GameplayStatics_PopSoundMixModifier");
static_assert(offsetof(GameplayStatics_PopSoundMixModifier, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PopSoundMixModifier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PopSoundMixModifier, InSoundMixModifier) == 0x000008, "Member 'GameplayStatics_PopSoundMixModifier::InSoundMixModifier' has a wrong offset!");

// Function Engine.GameplayStatics.ProjectWorldToScreen
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_ProjectWorldToScreen final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ScreenPosition;                                    // 0x0014(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerViewportRelative;                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001D(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ProjectWorldToScreen) == 0x000008, "Wrong alignment on GameplayStatics_ProjectWorldToScreen");
static_assert(sizeof(GameplayStatics_ProjectWorldToScreen) == 0x000020, "Wrong size on GameplayStatics_ProjectWorldToScreen");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreen, Player) == 0x000000, "Member 'GameplayStatics_ProjectWorldToScreen::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreen, WorldPosition) == 0x000008, "Member 'GameplayStatics_ProjectWorldToScreen::WorldPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreen, ScreenPosition) == 0x000014, "Member 'GameplayStatics_ProjectWorldToScreen::ScreenPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreen, bPlayerViewportRelative) == 0x00001C, "Member 'GameplayStatics_ProjectWorldToScreen::bPlayerViewportRelative' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreen, ReturnValue) == 0x00001D, "Member 'GameplayStatics_ProjectWorldToScreen::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.ProjectWorldToScreenWithDeviceZ
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_ProjectWorldToScreenWithDeviceZ final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldPosition;                                     // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ScreenPosition;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPlayerViewportRelative;                           // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_ProjectWorldToScreenWithDeviceZ) == 0x000008, "Wrong alignment on GameplayStatics_ProjectWorldToScreenWithDeviceZ");
static_assert(sizeof(GameplayStatics_ProjectWorldToScreenWithDeviceZ) == 0x000028, "Wrong size on GameplayStatics_ProjectWorldToScreenWithDeviceZ");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreenWithDeviceZ, Player) == 0x000000, "Member 'GameplayStatics_ProjectWorldToScreenWithDeviceZ::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreenWithDeviceZ, WorldPosition) == 0x000008, "Member 'GameplayStatics_ProjectWorldToScreenWithDeviceZ::WorldPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreenWithDeviceZ, ScreenPosition) == 0x000014, "Member 'GameplayStatics_ProjectWorldToScreenWithDeviceZ::ScreenPosition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreenWithDeviceZ, bPlayerViewportRelative) == 0x000020, "Member 'GameplayStatics_ProjectWorldToScreenWithDeviceZ::bPlayerViewportRelative' has a wrong offset!");
static_assert(offsetof(GameplayStatics_ProjectWorldToScreenWithDeviceZ, ReturnValue) == 0x000021, "Member 'GameplayStatics_ProjectWorldToScreenWithDeviceZ::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.PushSoundMixModifier
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_PushSoundMixModifier final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              InSoundMixModifier;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_PushSoundMixModifier) == 0x000008, "Wrong alignment on GameplayStatics_PushSoundMixModifier");
static_assert(sizeof(GameplayStatics_PushSoundMixModifier) == 0x000010, "Wrong size on GameplayStatics_PushSoundMixModifier");
static_assert(offsetof(GameplayStatics_PushSoundMixModifier, WorldContextObject) == 0x000000, "Member 'GameplayStatics_PushSoundMixModifier::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_PushSoundMixModifier, InSoundMixModifier) == 0x000008, "Member 'GameplayStatics_PushSoundMixModifier::InSoundMixModifier' has a wrong offset!");

// Function Engine.GameplayStatics.RebaseLocalOriginOntoZero
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_RebaseLocalOriginOntoZero final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_RebaseLocalOriginOntoZero) == 0x000008, "Wrong alignment on GameplayStatics_RebaseLocalOriginOntoZero");
static_assert(sizeof(GameplayStatics_RebaseLocalOriginOntoZero) == 0x000020, "Wrong size on GameplayStatics_RebaseLocalOriginOntoZero");
static_assert(offsetof(GameplayStatics_RebaseLocalOriginOntoZero, WorldContextObject) == 0x000000, "Member 'GameplayStatics_RebaseLocalOriginOntoZero::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_RebaseLocalOriginOntoZero, WorldLocation) == 0x000008, "Member 'GameplayStatics_RebaseLocalOriginOntoZero::WorldLocation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_RebaseLocalOriginOntoZero, ReturnValue) == 0x000014, "Member 'GameplayStatics_RebaseLocalOriginOntoZero::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.RebaseZeroOriginOntoLocal
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_RebaseZeroOriginOntoLocal final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                WorldLocation;                                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_RebaseZeroOriginOntoLocal) == 0x000008, "Wrong alignment on GameplayStatics_RebaseZeroOriginOntoLocal");
static_assert(sizeof(GameplayStatics_RebaseZeroOriginOntoLocal) == 0x000020, "Wrong size on GameplayStatics_RebaseZeroOriginOntoLocal");
static_assert(offsetof(GameplayStatics_RebaseZeroOriginOntoLocal, WorldContextObject) == 0x000000, "Member 'GameplayStatics_RebaseZeroOriginOntoLocal::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_RebaseZeroOriginOntoLocal, WorldLocation) == 0x000008, "Member 'GameplayStatics_RebaseZeroOriginOntoLocal::WorldLocation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_RebaseZeroOriginOntoLocal, ReturnValue) == 0x000014, "Member 'GameplayStatics_RebaseZeroOriginOntoLocal::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.RemovePlayer
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_RemovePlayer final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDestroyPawn;                                      // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_RemovePlayer) == 0x000008, "Wrong alignment on GameplayStatics_RemovePlayer");
static_assert(sizeof(GameplayStatics_RemovePlayer) == 0x000010, "Wrong size on GameplayStatics_RemovePlayer");
static_assert(offsetof(GameplayStatics_RemovePlayer, Player) == 0x000000, "Member 'GameplayStatics_RemovePlayer::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_RemovePlayer, bDestroyPawn) == 0x000008, "Member 'GameplayStatics_RemovePlayer::bDestroyPawn' has a wrong offset!");

// Function Engine.GameplayStatics.SaveGameToSlot
// 0x0020 (0x0020 - 0x0000)
struct GameplayStatics_SaveGameToSlot final
{
public:
	class USaveGame*                              SaveGameObject;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SlotName;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UserIndex;                                         // 0x0018(0x0004)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SaveGameToSlot) == 0x000008, "Wrong alignment on GameplayStatics_SaveGameToSlot");
static_assert(sizeof(GameplayStatics_SaveGameToSlot) == 0x000020, "Wrong size on GameplayStatics_SaveGameToSlot");
static_assert(offsetof(GameplayStatics_SaveGameToSlot, SaveGameObject) == 0x000000, "Member 'GameplayStatics_SaveGameToSlot::SaveGameObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SaveGameToSlot, SlotName) == 0x000008, "Member 'GameplayStatics_SaveGameToSlot::SlotName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SaveGameToSlot, UserIndex) == 0x000018, "Member 'GameplayStatics_SaveGameToSlot::UserIndex' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SaveGameToSlot, ReturnValue) == 0x00001C, "Member 'GameplayStatics_SaveGameToSlot::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SetBaseSoundMix
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_SetBaseSoundMix final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              InSoundMix;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SetBaseSoundMix) == 0x000008, "Wrong alignment on GameplayStatics_SetBaseSoundMix");
static_assert(sizeof(GameplayStatics_SetBaseSoundMix) == 0x000010, "Wrong size on GameplayStatics_SetBaseSoundMix");
static_assert(offsetof(GameplayStatics_SetBaseSoundMix, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetBaseSoundMix::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetBaseSoundMix, InSoundMix) == 0x000008, "Member 'GameplayStatics_SetBaseSoundMix::InSoundMix' has a wrong offset!");

// Function Engine.GameplayStatics.SetGamePaused
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_SetGamePaused final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPaused;                                           // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SetGamePaused) == 0x000008, "Wrong alignment on GameplayStatics_SetGamePaused");
static_assert(sizeof(GameplayStatics_SetGamePaused) == 0x000010, "Wrong size on GameplayStatics_SetGamePaused");
static_assert(offsetof(GameplayStatics_SetGamePaused, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetGamePaused::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGamePaused, bPaused) == 0x000008, "Member 'GameplayStatics_SetGamePaused::bPaused' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGamePaused, ReturnValue) == 0x000009, "Member 'GameplayStatics_SetGamePaused::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SetGlobalListenerFocusParameters
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_SetGlobalListenerFocusParameters final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusAzimuthScale;                                 // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusAzimuthScale;                              // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusDistanceScale;                                // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusDistanceScale;                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusVolumeScale;                                  // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusVolumeScale;                               // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusPriorityScale;                                // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         NonFocusPriorityScale;                             // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SetGlobalListenerFocusParameters) == 0x000008, "Wrong alignment on GameplayStatics_SetGlobalListenerFocusParameters");
static_assert(sizeof(GameplayStatics_SetGlobalListenerFocusParameters) == 0x000028, "Wrong size on GameplayStatics_SetGlobalListenerFocusParameters");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, FocusAzimuthScale) == 0x000008, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::FocusAzimuthScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, NonFocusAzimuthScale) == 0x00000C, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::NonFocusAzimuthScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, FocusDistanceScale) == 0x000010, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::FocusDistanceScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, NonFocusDistanceScale) == 0x000014, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::NonFocusDistanceScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, FocusVolumeScale) == 0x000018, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::FocusVolumeScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, NonFocusVolumeScale) == 0x00001C, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::NonFocusVolumeScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, FocusPriorityScale) == 0x000020, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::FocusPriorityScale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalListenerFocusParameters, NonFocusPriorityScale) == 0x000024, "Member 'GameplayStatics_SetGlobalListenerFocusParameters::NonFocusPriorityScale' has a wrong offset!");

// Function Engine.GameplayStatics.SetGlobalPitchModulation
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_SetGlobalPitchModulation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchModulation;                                   // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeSec;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SetGlobalPitchModulation) == 0x000008, "Wrong alignment on GameplayStatics_SetGlobalPitchModulation");
static_assert(sizeof(GameplayStatics_SetGlobalPitchModulation) == 0x000010, "Wrong size on GameplayStatics_SetGlobalPitchModulation");
static_assert(offsetof(GameplayStatics_SetGlobalPitchModulation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetGlobalPitchModulation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalPitchModulation, PitchModulation) == 0x000008, "Member 'GameplayStatics_SetGlobalPitchModulation::PitchModulation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalPitchModulation, TimeSec) == 0x00000C, "Member 'GameplayStatics_SetGlobalPitchModulation::TimeSec' has a wrong offset!");

// Function Engine.GameplayStatics.SetGlobalTimeDilation
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_SetGlobalTimeDilation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TimeDilation;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SetGlobalTimeDilation) == 0x000008, "Wrong alignment on GameplayStatics_SetGlobalTimeDilation");
static_assert(sizeof(GameplayStatics_SetGlobalTimeDilation) == 0x000010, "Wrong size on GameplayStatics_SetGlobalTimeDilation");
static_assert(offsetof(GameplayStatics_SetGlobalTimeDilation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetGlobalTimeDilation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetGlobalTimeDilation, TimeDilation) == 0x000008, "Member 'GameplayStatics_SetGlobalTimeDilation::TimeDilation' has a wrong offset!");

// Function Engine.GameplayStatics.SetPlayerControllerID
// 0x0010 (0x0010 - 0x0000)
struct GameplayStatics_SetPlayerControllerID final
{
public:
	class APlayerController*                      Player;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ControllerId;                                      // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SetPlayerControllerID) == 0x000008, "Wrong alignment on GameplayStatics_SetPlayerControllerID");
static_assert(sizeof(GameplayStatics_SetPlayerControllerID) == 0x000010, "Wrong size on GameplayStatics_SetPlayerControllerID");
static_assert(offsetof(GameplayStatics_SetPlayerControllerID, Player) == 0x000000, "Member 'GameplayStatics_SetPlayerControllerID::Player' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetPlayerControllerID, ControllerId) == 0x000008, "Member 'GameplayStatics_SetPlayerControllerID::ControllerId' has a wrong offset!");

// Function Engine.GameplayStatics.SetSoundMixClassOverride
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_SetSoundMixClassOverride final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundMix*                              InSoundMixModifier;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundClass*                            InSoundClass;                                      // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Volume;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Pitch;                                             // 0x001C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeInTime;                                        // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bApplyToChildren;                                  // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SetSoundMixClassOverride) == 0x000008, "Wrong alignment on GameplayStatics_SetSoundMixClassOverride");
static_assert(sizeof(GameplayStatics_SetSoundMixClassOverride) == 0x000028, "Wrong size on GameplayStatics_SetSoundMixClassOverride");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetSoundMixClassOverride::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, InSoundMixModifier) == 0x000008, "Member 'GameplayStatics_SetSoundMixClassOverride::InSoundMixModifier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, InSoundClass) == 0x000010, "Member 'GameplayStatics_SetSoundMixClassOverride::InSoundClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, Volume) == 0x000018, "Member 'GameplayStatics_SetSoundMixClassOverride::Volume' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, Pitch) == 0x00001C, "Member 'GameplayStatics_SetSoundMixClassOverride::Pitch' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, FadeInTime) == 0x000020, "Member 'GameplayStatics_SetSoundMixClassOverride::FadeInTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetSoundMixClassOverride, bApplyToChildren) == 0x000024, "Member 'GameplayStatics_SetSoundMixClassOverride::bApplyToChildren' has a wrong offset!");

// Function Engine.GameplayStatics.SetSubtitlesEnabled
// 0x0001 (0x0001 - 0x0000)
struct GameplayStatics_SetSubtitlesEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SetSubtitlesEnabled) == 0x000001, "Wrong alignment on GameplayStatics_SetSubtitlesEnabled");
static_assert(sizeof(GameplayStatics_SetSubtitlesEnabled) == 0x000001, "Wrong size on GameplayStatics_SetSubtitlesEnabled");
static_assert(offsetof(GameplayStatics_SetSubtitlesEnabled, bEnabled) == 0x000000, "Member 'GameplayStatics_SetSubtitlesEnabled::bEnabled' has a wrong offset!");

// Function Engine.GameplayStatics.SetWorldOriginLocation
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_SetWorldOriginLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             NewLocation;                                       // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SetWorldOriginLocation) == 0x000008, "Wrong alignment on GameplayStatics_SetWorldOriginLocation");
static_assert(sizeof(GameplayStatics_SetWorldOriginLocation) == 0x000018, "Wrong size on GameplayStatics_SetWorldOriginLocation");
static_assert(offsetof(GameplayStatics_SetWorldOriginLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SetWorldOriginLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SetWorldOriginLocation, NewLocation) == 0x000008, "Member 'GameplayStatics_SetWorldOriginLocation::NewLocation' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnDecalAtLocation
// 0x0040 (0x0040 - 0x0000)
struct GameplayStatics_SpawnDecalAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         LifeSpan;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnDecalAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_SpawnDecalAtLocation");
static_assert(sizeof(GameplayStatics_SpawnDecalAtLocation) == 0x000040, "Wrong size on GameplayStatics_SpawnDecalAtLocation");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnDecalAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, DecalMaterial) == 0x000008, "Member 'GameplayStatics_SpawnDecalAtLocation::DecalMaterial' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, DecalSize) == 0x000010, "Member 'GameplayStatics_SpawnDecalAtLocation::DecalSize' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, Location) == 0x00001C, "Member 'GameplayStatics_SpawnDecalAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, Rotation) == 0x000028, "Member 'GameplayStatics_SpawnDecalAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, LifeSpan) == 0x000034, "Member 'GameplayStatics_SpawnDecalAtLocation::LifeSpan' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAtLocation, ReturnValue) == 0x000038, "Member 'GameplayStatics_SpawnDecalAtLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnDecalAttached
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_SpawnDecalAttached final
{
public:
	class UMaterialInterface*                     DecalMaterial;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DecalSize;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        AttachToComponent;                                 // 0x0018(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x3];                                       // 0x0041(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         LifeSpan;                                          // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDecalComponent*                        ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnDecalAttached) == 0x000008, "Wrong alignment on GameplayStatics_SpawnDecalAttached");
static_assert(sizeof(GameplayStatics_SpawnDecalAttached) == 0x000050, "Wrong size on GameplayStatics_SpawnDecalAttached");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, DecalMaterial) == 0x000000, "Member 'GameplayStatics_SpawnDecalAttached::DecalMaterial' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, DecalSize) == 0x000008, "Member 'GameplayStatics_SpawnDecalAttached::DecalSize' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, AttachToComponent) == 0x000018, "Member 'GameplayStatics_SpawnDecalAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, AttachPointName) == 0x000020, "Member 'GameplayStatics_SpawnDecalAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, Location) == 0x000028, "Member 'GameplayStatics_SpawnDecalAttached::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, Rotation) == 0x000034, "Member 'GameplayStatics_SpawnDecalAttached::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, LocationType) == 0x000040, "Member 'GameplayStatics_SpawnDecalAttached::LocationType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, LifeSpan) == 0x000044, "Member 'GameplayStatics_SpawnDecalAttached::LifeSpan' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDecalAttached, ReturnValue) == 0x000048, "Member 'GameplayStatics_SpawnDecalAttached::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnDialogue2D
// 0x0040 (0x0040 - 0x0000)
struct GameplayStatics_SpawnDialogue2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueWave*                          Dialogue;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnDialogue2D) == 0x000008, "Wrong alignment on GameplayStatics_SpawnDialogue2D");
static_assert(sizeof(GameplayStatics_SpawnDialogue2D) == 0x000040, "Wrong size on GameplayStatics_SpawnDialogue2D");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnDialogue2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, Dialogue) == 0x000008, "Member 'GameplayStatics_SpawnDialogue2D::Dialogue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, Context) == 0x000010, "Member 'GameplayStatics_SpawnDialogue2D::Context' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, VolumeMultiplier) == 0x000028, "Member 'GameplayStatics_SpawnDialogue2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, PitchMultiplier) == 0x00002C, "Member 'GameplayStatics_SpawnDialogue2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, StartTime) == 0x000030, "Member 'GameplayStatics_SpawnDialogue2D::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, bAutoDestroy) == 0x000034, "Member 'GameplayStatics_SpawnDialogue2D::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogue2D, ReturnValue) == 0x000038, "Member 'GameplayStatics_SpawnDialogue2D::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnDialogueAtLocation
// 0x0068 (0x0068 - 0x0000)
struct GameplayStatics_SpawnDialogueAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDialogueWave*                          Dialogue;                                          // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0048(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0060(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnDialogueAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_SpawnDialogueAtLocation");
static_assert(sizeof(GameplayStatics_SpawnDialogueAtLocation) == 0x000068, "Wrong size on GameplayStatics_SpawnDialogueAtLocation");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnDialogueAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, Dialogue) == 0x000008, "Member 'GameplayStatics_SpawnDialogueAtLocation::Dialogue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, Context) == 0x000010, "Member 'GameplayStatics_SpawnDialogueAtLocation::Context' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, Location) == 0x000028, "Member 'GameplayStatics_SpawnDialogueAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, Rotation) == 0x000034, "Member 'GameplayStatics_SpawnDialogueAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, VolumeMultiplier) == 0x000040, "Member 'GameplayStatics_SpawnDialogueAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, PitchMultiplier) == 0x000044, "Member 'GameplayStatics_SpawnDialogueAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, StartTime) == 0x000048, "Member 'GameplayStatics_SpawnDialogueAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, AttenuationSettings) == 0x000050, "Member 'GameplayStatics_SpawnDialogueAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, bAutoDestroy) == 0x000058, "Member 'GameplayStatics_SpawnDialogueAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAtLocation, ReturnValue) == 0x000060, "Member 'GameplayStatics_SpawnDialogueAtLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnDialogueAttached
// 0x0070 (0x0070 - 0x0000)
struct GameplayStatics_SpawnDialogueAttached final
{
public:
	class UDialogueWave*                          Dialogue;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDialogueContext                       Context;                                           // 0x0008(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0020(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x003C(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0049(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4A[0x2];                                       // 0x004A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0058(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0068(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnDialogueAttached) == 0x000008, "Wrong alignment on GameplayStatics_SpawnDialogueAttached");
static_assert(sizeof(GameplayStatics_SpawnDialogueAttached) == 0x000070, "Wrong size on GameplayStatics_SpawnDialogueAttached");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, Dialogue) == 0x000000, "Member 'GameplayStatics_SpawnDialogueAttached::Dialogue' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, Context) == 0x000008, "Member 'GameplayStatics_SpawnDialogueAttached::Context' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, AttachToComponent) == 0x000020, "Member 'GameplayStatics_SpawnDialogueAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, AttachPointName) == 0x000028, "Member 'GameplayStatics_SpawnDialogueAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, Location) == 0x000030, "Member 'GameplayStatics_SpawnDialogueAttached::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, Rotation) == 0x00003C, "Member 'GameplayStatics_SpawnDialogueAttached::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, LocationType) == 0x000048, "Member 'GameplayStatics_SpawnDialogueAttached::LocationType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, bStopWhenAttachedToDestroyed) == 0x000049, "Member 'GameplayStatics_SpawnDialogueAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, VolumeMultiplier) == 0x00004C, "Member 'GameplayStatics_SpawnDialogueAttached::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, PitchMultiplier) == 0x000050, "Member 'GameplayStatics_SpawnDialogueAttached::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, StartTime) == 0x000054, "Member 'GameplayStatics_SpawnDialogueAttached::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, AttenuationSettings) == 0x000058, "Member 'GameplayStatics_SpawnDialogueAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, bAutoDestroy) == 0x000060, "Member 'GameplayStatics_SpawnDialogueAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnDialogueAttached, ReturnValue) == 0x000068, "Member 'GameplayStatics_SpawnDialogueAttached::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnEmitterAtLocation
// 0x0040 (0x0040 - 0x0000)
struct GameplayStatics_SpawnEmitterAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0034(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ReturnValue;                                       // 0x0038(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnEmitterAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_SpawnEmitterAtLocation");
static_assert(sizeof(GameplayStatics_SpawnEmitterAtLocation) == 0x000040, "Wrong size on GameplayStatics_SpawnEmitterAtLocation");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnEmitterAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, EmitterTemplate) == 0x000008, "Member 'GameplayStatics_SpawnEmitterAtLocation::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, Location) == 0x000010, "Member 'GameplayStatics_SpawnEmitterAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, Rotation) == 0x00001C, "Member 'GameplayStatics_SpawnEmitterAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, Scale) == 0x000028, "Member 'GameplayStatics_SpawnEmitterAtLocation::Scale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, bAutoDestroy) == 0x000034, "Member 'GameplayStatics_SpawnEmitterAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAtLocation, ReturnValue) == 0x000038, "Member 'GameplayStatics_SpawnEmitterAtLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnEmitterAttached
// 0x0048 (0x0048 - 0x0000)
struct GameplayStatics_SpawnEmitterAttached final
{
public:
	class UParticleSystem*                        EmitterTemplate;                                   // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Scale;                                             // 0x0030(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x003C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x003D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class UParticleSystemComponent*               ReturnValue;                                       // 0x0040(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnEmitterAttached) == 0x000008, "Wrong alignment on GameplayStatics_SpawnEmitterAttached");
static_assert(sizeof(GameplayStatics_SpawnEmitterAttached) == 0x000048, "Wrong size on GameplayStatics_SpawnEmitterAttached");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, EmitterTemplate) == 0x000000, "Member 'GameplayStatics_SpawnEmitterAttached::EmitterTemplate' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, AttachToComponent) == 0x000008, "Member 'GameplayStatics_SpawnEmitterAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, AttachPointName) == 0x000010, "Member 'GameplayStatics_SpawnEmitterAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, Location) == 0x000018, "Member 'GameplayStatics_SpawnEmitterAttached::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, Rotation) == 0x000024, "Member 'GameplayStatics_SpawnEmitterAttached::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, Scale) == 0x000030, "Member 'GameplayStatics_SpawnEmitterAttached::Scale' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, LocationType) == 0x00003C, "Member 'GameplayStatics_SpawnEmitterAttached::LocationType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, bAutoDestroy) == 0x00003D, "Member 'GameplayStatics_SpawnEmitterAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnEmitterAttached, ReturnValue) == 0x000040, "Member 'GameplayStatics_SpawnEmitterAttached::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnForceFeedbackAtLocation
// 0x0050 (0x0050 - 0x0000)
struct GameplayStatics_SpawnForceFeedbackAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x3];                                       // 0x0029(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              AttenuationSettings;                               // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackComponent*                ReturnValue;                                       // 0x0048(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnForceFeedbackAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_SpawnForceFeedbackAtLocation");
static_assert(sizeof(GameplayStatics_SpawnForceFeedbackAtLocation) == 0x000050, "Wrong size on GameplayStatics_SpawnForceFeedbackAtLocation");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, ForceFeedbackEffect) == 0x000008, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, Location) == 0x000010, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, Rotation) == 0x00001C, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, bLooping) == 0x000028, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::bLooping' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, IntensityMultiplier) == 0x00002C, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::IntensityMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, StartTime) == 0x000030, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, AttenuationSettings) == 0x000038, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, bAutoDestroy) == 0x000040, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAtLocation, ReturnValue) == 0x000048, "Member 'GameplayStatics_SpawnForceFeedbackAtLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnForceFeedbackAttached
// 0x0058 (0x0058 - 0x0000)
struct GameplayStatics_SpawnForceFeedbackAttached final
{
public:
	class UForceFeedbackEffect*                   ForceFeedbackEffect;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0032(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33[0x1];                                       // 0x0033(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         IntensityMultiplier;                               // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackAttenuation*              AttenuationSettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UForceFeedbackComponent*                ReturnValue;                                       // 0x0050(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnForceFeedbackAttached) == 0x000008, "Wrong alignment on GameplayStatics_SpawnForceFeedbackAttached");
static_assert(sizeof(GameplayStatics_SpawnForceFeedbackAttached) == 0x000058, "Wrong size on GameplayStatics_SpawnForceFeedbackAttached");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, ForceFeedbackEffect) == 0x000000, "Member 'GameplayStatics_SpawnForceFeedbackAttached::ForceFeedbackEffect' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, AttachToComponent) == 0x000008, "Member 'GameplayStatics_SpawnForceFeedbackAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, AttachPointName) == 0x000010, "Member 'GameplayStatics_SpawnForceFeedbackAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, Location) == 0x000018, "Member 'GameplayStatics_SpawnForceFeedbackAttached::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, Rotation) == 0x000024, "Member 'GameplayStatics_SpawnForceFeedbackAttached::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, LocationType) == 0x000030, "Member 'GameplayStatics_SpawnForceFeedbackAttached::LocationType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, bStopWhenAttachedToDestroyed) == 0x000031, "Member 'GameplayStatics_SpawnForceFeedbackAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, bLooping) == 0x000032, "Member 'GameplayStatics_SpawnForceFeedbackAttached::bLooping' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, IntensityMultiplier) == 0x000034, "Member 'GameplayStatics_SpawnForceFeedbackAttached::IntensityMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, StartTime) == 0x000038, "Member 'GameplayStatics_SpawnForceFeedbackAttached::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, AttenuationSettings) == 0x000040, "Member 'GameplayStatics_SpawnForceFeedbackAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, bAutoDestroy) == 0x000048, "Member 'GameplayStatics_SpawnForceFeedbackAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnForceFeedbackAttached, ReturnValue) == 0x000050, "Member 'GameplayStatics_SpawnForceFeedbackAttached::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnObject
// 0x0018 (0x0018 - 0x0000)
struct GameplayStatics_SpawnObject final
{
public:
	TSubclassOf<class UObject>                    ObjectClass;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Outer_0;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnObject) == 0x000008, "Wrong alignment on GameplayStatics_SpawnObject");
static_assert(sizeof(GameplayStatics_SpawnObject) == 0x000018, "Wrong size on GameplayStatics_SpawnObject");
static_assert(offsetof(GameplayStatics_SpawnObject, ObjectClass) == 0x000000, "Member 'GameplayStatics_SpawnObject::ObjectClass' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnObject, Outer_0) == 0x000008, "Member 'GameplayStatics_SpawnObject::Outer_0' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnObject, ReturnValue) == 0x000010, "Member 'GameplayStatics_SpawnObject::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnSound2D
// 0x0038 (0x0038 - 0x0000)
struct GameplayStatics_SpawnSound2D final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPersistAcrossLevelTransition;                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0030(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnSound2D) == 0x000008, "Wrong alignment on GameplayStatics_SpawnSound2D");
static_assert(sizeof(GameplayStatics_SpawnSound2D) == 0x000038, "Wrong size on GameplayStatics_SpawnSound2D");
static_assert(offsetof(GameplayStatics_SpawnSound2D, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnSound2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, Sound) == 0x000008, "Member 'GameplayStatics_SpawnSound2D::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, VolumeMultiplier) == 0x000010, "Member 'GameplayStatics_SpawnSound2D::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, PitchMultiplier) == 0x000014, "Member 'GameplayStatics_SpawnSound2D::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, StartTime) == 0x000018, "Member 'GameplayStatics_SpawnSound2D::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, ConcurrencySettings) == 0x000020, "Member 'GameplayStatics_SpawnSound2D::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, bPersistAcrossLevelTransition) == 0x000028, "Member 'GameplayStatics_SpawnSound2D::bPersistAcrossLevelTransition' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, bAutoDestroy) == 0x000029, "Member 'GameplayStatics_SpawnSound2D::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSound2D, ReturnValue) == 0x000030, "Member 'GameplayStatics_SpawnSound2D::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnSoundAtLocation
// 0x0058 (0x0058 - 0x0000)
struct GameplayStatics_SpawnSoundAtLocation final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundBase*                             Sound;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0010(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	float                                         VolumeMultiplier;                                  // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0050(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnSoundAtLocation) == 0x000008, "Wrong alignment on GameplayStatics_SpawnSoundAtLocation");
static_assert(sizeof(GameplayStatics_SpawnSoundAtLocation) == 0x000058, "Wrong size on GameplayStatics_SpawnSoundAtLocation");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SpawnSoundAtLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, Sound) == 0x000008, "Member 'GameplayStatics_SpawnSoundAtLocation::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, Location) == 0x000010, "Member 'GameplayStatics_SpawnSoundAtLocation::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, Rotation) == 0x00001C, "Member 'GameplayStatics_SpawnSoundAtLocation::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, VolumeMultiplier) == 0x000028, "Member 'GameplayStatics_SpawnSoundAtLocation::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, PitchMultiplier) == 0x00002C, "Member 'GameplayStatics_SpawnSoundAtLocation::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, StartTime) == 0x000030, "Member 'GameplayStatics_SpawnSoundAtLocation::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, AttenuationSettings) == 0x000038, "Member 'GameplayStatics_SpawnSoundAtLocation::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, ConcurrencySettings) == 0x000040, "Member 'GameplayStatics_SpawnSoundAtLocation::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, bAutoDestroy) == 0x000048, "Member 'GameplayStatics_SpawnSoundAtLocation::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAtLocation, ReturnValue) == 0x000050, "Member 'GameplayStatics_SpawnSoundAtLocation::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SpawnSoundAttached
// 0x0060 (0x0060 - 0x0000)
struct GameplayStatics_SpawnSoundAttached final
{
public:
	class USoundBase*                             Sound;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USceneComponent*                        AttachToComponent;                                 // 0x0008(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   AttachPointName;                                   // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, NativeAccessSpecifierPublic)
	EAttachLocation                               LocationType;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStopWhenAttachedToDestroyed;                      // 0x0031(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x2];                                       // 0x0032(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         VolumeMultiplier;                                  // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PitchMultiplier;                                   // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StartTime;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundAttenuation*                      AttenuationSettings;                               // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USoundConcurrency*                      ConcurrencySettings;                               // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAutoDestroy;                                      // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAudioComponent*                        ReturnValue;                                       // 0x0058(0x0008)(ExportObject, Parm, OutParm, ZeroConstructor, ReturnParm, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_SpawnSoundAttached) == 0x000008, "Wrong alignment on GameplayStatics_SpawnSoundAttached");
static_assert(sizeof(GameplayStatics_SpawnSoundAttached) == 0x000060, "Wrong size on GameplayStatics_SpawnSoundAttached");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, Sound) == 0x000000, "Member 'GameplayStatics_SpawnSoundAttached::Sound' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, AttachToComponent) == 0x000008, "Member 'GameplayStatics_SpawnSoundAttached::AttachToComponent' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, AttachPointName) == 0x000010, "Member 'GameplayStatics_SpawnSoundAttached::AttachPointName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, Location) == 0x000018, "Member 'GameplayStatics_SpawnSoundAttached::Location' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, Rotation) == 0x000024, "Member 'GameplayStatics_SpawnSoundAttached::Rotation' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, LocationType) == 0x000030, "Member 'GameplayStatics_SpawnSoundAttached::LocationType' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, bStopWhenAttachedToDestroyed) == 0x000031, "Member 'GameplayStatics_SpawnSoundAttached::bStopWhenAttachedToDestroyed' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, VolumeMultiplier) == 0x000034, "Member 'GameplayStatics_SpawnSoundAttached::VolumeMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, PitchMultiplier) == 0x000038, "Member 'GameplayStatics_SpawnSoundAttached::PitchMultiplier' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, StartTime) == 0x00003C, "Member 'GameplayStatics_SpawnSoundAttached::StartTime' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, AttenuationSettings) == 0x000040, "Member 'GameplayStatics_SpawnSoundAttached::AttenuationSettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, ConcurrencySettings) == 0x000048, "Member 'GameplayStatics_SpawnSoundAttached::ConcurrencySettings' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, bAutoDestroy) == 0x000050, "Member 'GameplayStatics_SpawnSoundAttached::bAutoDestroy' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SpawnSoundAttached, ReturnValue) == 0x000058, "Member 'GameplayStatics_SpawnSoundAttached::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.SuggestProjectileVelocity_CustomArc
// 0x0038 (0x0038 - 0x0000)
struct GameplayStatics_SuggestProjectileVelocity_CustomArc final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutLaunchVelocity;                                 // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartPos;                                          // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OverrideGravityZ;                                  // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArcParam;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(GameplayStatics_SuggestProjectileVelocity_CustomArc) == 0x000008, "Wrong alignment on GameplayStatics_SuggestProjectileVelocity_CustomArc");
static_assert(sizeof(GameplayStatics_SuggestProjectileVelocity_CustomArc) == 0x000038, "Wrong size on GameplayStatics_SuggestProjectileVelocity_CustomArc");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, WorldContextObject) == 0x000000, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, OutLaunchVelocity) == 0x000008, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::OutLaunchVelocity' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, StartPos) == 0x000014, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::StartPos' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, EndPos) == 0x000020, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::EndPos' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, OverrideGravityZ) == 0x00002C, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::OverrideGravityZ' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, ArcParam) == 0x000030, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::ArcParam' has a wrong offset!");
static_assert(offsetof(GameplayStatics_SuggestProjectileVelocity_CustomArc, ReturnValue) == 0x000034, "Member 'GameplayStatics_SuggestProjectileVelocity_CustomArc::ReturnValue' has a wrong offset!");

// Function Engine.GameplayStatics.UnloadStreamLevel
// 0x0028 (0x0028 - 0x0000)
struct GameplayStatics_UnloadStreamLevel final
{
public:
	const class UObject*                          WorldContextObject;                                // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LevelName;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(GameplayStatics_UnloadStreamLevel) == 0x000008, "Wrong alignment on GameplayStatics_UnloadStreamLevel");
static_assert(sizeof(GameplayStatics_UnloadStreamLevel) == 0x000028, "Wrong size on GameplayStatics_UnloadStreamLevel");
static_assert(offsetof(GameplayStatics_UnloadStreamLevel, WorldContextObject) == 0x000000, "Member 'GameplayStatics_UnloadStreamLevel::WorldContextObject' has a wrong offset!");
static_assert(offsetof(GameplayStatics_UnloadStreamLevel, LevelName) == 0x000008, "Member 'GameplayStatics_UnloadStreamLevel::LevelName' has a wrong offset!");
static_assert(offsetof(GameplayStatics_UnloadStreamLevel, LatentInfo) == 0x000010, "Member 'GameplayStatics_UnloadStreamLevel::LatentInfo' has a wrong offset!");

// Function Engine.SpotLight.SetInnerConeAngle
// 0x0004 (0x0004 - 0x0000)
struct SpotLight_SetInnerConeAngle final
{
public:
	float                                         NewInnerConeAngle;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpotLight_SetInnerConeAngle) == 0x000004, "Wrong alignment on SpotLight_SetInnerConeAngle");
static_assert(sizeof(SpotLight_SetInnerConeAngle) == 0x000004, "Wrong size on SpotLight_SetInnerConeAngle");
static_assert(offsetof(SpotLight_SetInnerConeAngle, NewInnerConeAngle) == 0x000000, "Member 'SpotLight_SetInnerConeAngle::NewInnerConeAngle' has a wrong offset!");

// Function Engine.SpotLight.SetOuterConeAngle
// 0x0004 (0x0004 - 0x0000)
struct SpotLight_SetOuterConeAngle final
{
public:
	float                                         NewOuterConeAngle;                                 // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SpotLight_SetOuterConeAngle) == 0x000004, "Wrong alignment on SpotLight_SetOuterConeAngle");
static_assert(sizeof(SpotLight_SetOuterConeAngle) == 0x000004, "Wrong size on SpotLight_SetOuterConeAngle");
static_assert(offsetof(SpotLight_SetOuterConeAngle, NewOuterConeAngle) == 0x000000, "Member 'SpotLight_SetOuterConeAngle::NewOuterConeAngle' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.BreakImportanceTexture
// 0x0060 (0x0060 - 0x0000)
struct ImportanceSamplingLibrary_BreakImportanceTexture final
{
public:
	struct FImportanceTexture                     ImportanceTexture;                                 // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0050(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EImportanceWeight                             WeightingFunc;                                     // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ImportanceSamplingLibrary_BreakImportanceTexture) == 0x000008, "Wrong alignment on ImportanceSamplingLibrary_BreakImportanceTexture");
static_assert(sizeof(ImportanceSamplingLibrary_BreakImportanceTexture) == 0x000060, "Wrong size on ImportanceSamplingLibrary_BreakImportanceTexture");
static_assert(offsetof(ImportanceSamplingLibrary_BreakImportanceTexture, ImportanceTexture) == 0x000000, "Member 'ImportanceSamplingLibrary_BreakImportanceTexture::ImportanceTexture' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_BreakImportanceTexture, Texture) == 0x000050, "Member 'ImportanceSamplingLibrary_BreakImportanceTexture::Texture' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_BreakImportanceTexture, WeightingFunc) == 0x000058, "Member 'ImportanceSamplingLibrary_BreakImportanceTexture::WeightingFunc' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.ImportanceSample
// 0x0080 (0x0080 - 0x0000)
struct ImportanceSamplingLibrary_ImportanceSample final
{
public:
	struct FImportanceTexture                     Texture;                                           // 0x0000(0x0050)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              Rand;                                              // 0x0050(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Samples;                                           // 0x0058(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Intensity;                                         // 0x005C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              SamplePosition;                                    // 0x0060(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SampleColor;                                       // 0x0068(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleIntensity;                                   // 0x0078(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SampleSize;                                        // 0x007C(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_ImportanceSample) == 0x000008, "Wrong alignment on ImportanceSamplingLibrary_ImportanceSample");
static_assert(sizeof(ImportanceSamplingLibrary_ImportanceSample) == 0x000080, "Wrong size on ImportanceSamplingLibrary_ImportanceSample");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, Texture) == 0x000000, "Member 'ImportanceSamplingLibrary_ImportanceSample::Texture' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, Rand) == 0x000050, "Member 'ImportanceSamplingLibrary_ImportanceSample::Rand' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, Samples) == 0x000058, "Member 'ImportanceSamplingLibrary_ImportanceSample::Samples' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, Intensity) == 0x00005C, "Member 'ImportanceSamplingLibrary_ImportanceSample::Intensity' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, SamplePosition) == 0x000060, "Member 'ImportanceSamplingLibrary_ImportanceSample::SamplePosition' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, SampleColor) == 0x000068, "Member 'ImportanceSamplingLibrary_ImportanceSample::SampleColor' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, SampleIntensity) == 0x000078, "Member 'ImportanceSamplingLibrary_ImportanceSample::SampleIntensity' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_ImportanceSample, SampleSize) == 0x00007C, "Member 'ImportanceSamplingLibrary_ImportanceSample::SampleSize' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.MakeImportanceTexture
// 0x0060 (0x0060 - 0x0000)
struct ImportanceSamplingLibrary_MakeImportanceTexture final
{
public:
	class UTexture2D*                             Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EImportanceWeight                             WeightingFunc;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FImportanceTexture                     ReturnValue;                                       // 0x0010(0x0050)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_MakeImportanceTexture) == 0x000008, "Wrong alignment on ImportanceSamplingLibrary_MakeImportanceTexture");
static_assert(sizeof(ImportanceSamplingLibrary_MakeImportanceTexture) == 0x000060, "Wrong size on ImportanceSamplingLibrary_MakeImportanceTexture");
static_assert(offsetof(ImportanceSamplingLibrary_MakeImportanceTexture, Texture) == 0x000000, "Member 'ImportanceSamplingLibrary_MakeImportanceTexture::Texture' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_MakeImportanceTexture, WeightingFunc) == 0x000008, "Member 'ImportanceSamplingLibrary_MakeImportanceTexture::WeightingFunc' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_MakeImportanceTexture, ReturnValue) == 0x000010, "Member 'ImportanceSamplingLibrary_MakeImportanceTexture::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.NextSobolCell2D
// 0x0018 (0x0018 - 0x0000)
struct ImportanceSamplingLibrary_NextSobolCell2D final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCells;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              PreviousValue;                                     // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_NextSobolCell2D) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_NextSobolCell2D");
static_assert(sizeof(ImportanceSamplingLibrary_NextSobolCell2D) == 0x000018, "Wrong size on ImportanceSamplingLibrary_NextSobolCell2D");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell2D, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_NextSobolCell2D::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell2D, NumCells) == 0x000004, "Member 'ImportanceSamplingLibrary_NextSobolCell2D::NumCells' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell2D, PreviousValue) == 0x000008, "Member 'ImportanceSamplingLibrary_NextSobolCell2D::PreviousValue' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell2D, ReturnValue) == 0x000010, "Member 'ImportanceSamplingLibrary_NextSobolCell2D::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.NextSobolCell3D
// 0x0020 (0x0020 - 0x0000)
struct ImportanceSamplingLibrary_NextSobolCell3D final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCells;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PreviousValue;                                     // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0014(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_NextSobolCell3D) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_NextSobolCell3D");
static_assert(sizeof(ImportanceSamplingLibrary_NextSobolCell3D) == 0x000020, "Wrong size on ImportanceSamplingLibrary_NextSobolCell3D");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell3D, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_NextSobolCell3D::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell3D, NumCells) == 0x000004, "Member 'ImportanceSamplingLibrary_NextSobolCell3D::NumCells' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell3D, PreviousValue) == 0x000008, "Member 'ImportanceSamplingLibrary_NextSobolCell3D::PreviousValue' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolCell3D, ReturnValue) == 0x000014, "Member 'ImportanceSamplingLibrary_NextSobolCell3D::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.NextSobolFloat
// 0x0010 (0x0010 - 0x0000)
struct ImportanceSamplingLibrary_NextSobolFloat final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dimension;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PreviousValue;                                     // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_NextSobolFloat) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_NextSobolFloat");
static_assert(sizeof(ImportanceSamplingLibrary_NextSobolFloat) == 0x000010, "Wrong size on ImportanceSamplingLibrary_NextSobolFloat");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolFloat, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_NextSobolFloat::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolFloat, Dimension) == 0x000004, "Member 'ImportanceSamplingLibrary_NextSobolFloat::Dimension' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolFloat, PreviousValue) == 0x000008, "Member 'ImportanceSamplingLibrary_NextSobolFloat::PreviousValue' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_NextSobolFloat, ReturnValue) == 0x00000C, "Member 'ImportanceSamplingLibrary_NextSobolFloat::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.RandomSobolCell2D
// 0x0020 (0x0020 - 0x0000)
struct ImportanceSamplingLibrary_RandomSobolCell2D final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCells;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Cell;                                              // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Seed;                                              // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_RandomSobolCell2D) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_RandomSobolCell2D");
static_assert(sizeof(ImportanceSamplingLibrary_RandomSobolCell2D) == 0x000020, "Wrong size on ImportanceSamplingLibrary_RandomSobolCell2D");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell2D, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_RandomSobolCell2D::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell2D, NumCells) == 0x000004, "Member 'ImportanceSamplingLibrary_RandomSobolCell2D::NumCells' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell2D, Cell) == 0x000008, "Member 'ImportanceSamplingLibrary_RandomSobolCell2D::Cell' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell2D, Seed) == 0x000010, "Member 'ImportanceSamplingLibrary_RandomSobolCell2D::Seed' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell2D, ReturnValue) == 0x000018, "Member 'ImportanceSamplingLibrary_RandomSobolCell2D::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.RandomSobolCell3D
// 0x002C (0x002C - 0x0000)
struct ImportanceSamplingLibrary_RandomSobolCell3D final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumCells;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Cell;                                              // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Seed;                                              // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0020(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_RandomSobolCell3D) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_RandomSobolCell3D");
static_assert(sizeof(ImportanceSamplingLibrary_RandomSobolCell3D) == 0x00002C, "Wrong size on ImportanceSamplingLibrary_RandomSobolCell3D");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell3D, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_RandomSobolCell3D::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell3D, NumCells) == 0x000004, "Member 'ImportanceSamplingLibrary_RandomSobolCell3D::NumCells' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell3D, Cell) == 0x000008, "Member 'ImportanceSamplingLibrary_RandomSobolCell3D::Cell' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell3D, Seed) == 0x000014, "Member 'ImportanceSamplingLibrary_RandomSobolCell3D::Seed' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolCell3D, ReturnValue) == 0x000020, "Member 'ImportanceSamplingLibrary_RandomSobolCell3D::ReturnValue' has a wrong offset!");

// Function Engine.ImportanceSamplingLibrary.RandomSobolFloat
// 0x0010 (0x0010 - 0x0000)
struct ImportanceSamplingLibrary_RandomSobolFloat final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Dimension;                                         // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Seed;                                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(ImportanceSamplingLibrary_RandomSobolFloat) == 0x000004, "Wrong alignment on ImportanceSamplingLibrary_RandomSobolFloat");
static_assert(sizeof(ImportanceSamplingLibrary_RandomSobolFloat) == 0x000010, "Wrong size on ImportanceSamplingLibrary_RandomSobolFloat");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolFloat, Index_0) == 0x000000, "Member 'ImportanceSamplingLibrary_RandomSobolFloat::Index_0' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolFloat, Dimension) == 0x000004, "Member 'ImportanceSamplingLibrary_RandomSobolFloat::Dimension' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolFloat, Seed) == 0x000008, "Member 'ImportanceSamplingLibrary_RandomSobolFloat::Seed' has a wrong offset!");
static_assert(offsetof(ImportanceSamplingLibrary_RandomSobolFloat, ReturnValue) == 0x00000C, "Member 'ImportanceSamplingLibrary_RandomSobolFloat::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.GetControllerAnalogKeyState
// 0x0020 (0x0020 - 0x0000)
struct InputComponent_GetControllerAnalogKeyState final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_GetControllerAnalogKeyState) == 0x000008, "Wrong alignment on InputComponent_GetControllerAnalogKeyState");
static_assert(sizeof(InputComponent_GetControllerAnalogKeyState) == 0x000020, "Wrong size on InputComponent_GetControllerAnalogKeyState");
static_assert(offsetof(InputComponent_GetControllerAnalogKeyState, Key) == 0x000000, "Member 'InputComponent_GetControllerAnalogKeyState::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerAnalogKeyState, ReturnValue) == 0x000018, "Member 'InputComponent_GetControllerAnalogKeyState::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.GetControllerAnalogStickState
// 0x000C (0x000C - 0x0000)
struct InputComponent_GetControllerAnalogStickState final
{
public:
	EControllerAnalogStick                        WhichStick;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StickX;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StickY;                                            // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputComponent_GetControllerAnalogStickState) == 0x000004, "Wrong alignment on InputComponent_GetControllerAnalogStickState");
static_assert(sizeof(InputComponent_GetControllerAnalogStickState) == 0x00000C, "Wrong size on InputComponent_GetControllerAnalogStickState");
static_assert(offsetof(InputComponent_GetControllerAnalogStickState, WhichStick) == 0x000000, "Member 'InputComponent_GetControllerAnalogStickState::WhichStick' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerAnalogStickState, StickX) == 0x000004, "Member 'InputComponent_GetControllerAnalogStickState::StickX' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerAnalogStickState, StickY) == 0x000008, "Member 'InputComponent_GetControllerAnalogStickState::StickY' has a wrong offset!");

// Function Engine.InputComponent.GetControllerKeyTimeDown
// 0x0020 (0x0020 - 0x0000)
struct InputComponent_GetControllerKeyTimeDown final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_GetControllerKeyTimeDown) == 0x000008, "Wrong alignment on InputComponent_GetControllerKeyTimeDown");
static_assert(sizeof(InputComponent_GetControllerKeyTimeDown) == 0x000020, "Wrong size on InputComponent_GetControllerKeyTimeDown");
static_assert(offsetof(InputComponent_GetControllerKeyTimeDown, Key) == 0x000000, "Member 'InputComponent_GetControllerKeyTimeDown::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerKeyTimeDown, ReturnValue) == 0x000018, "Member 'InputComponent_GetControllerKeyTimeDown::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.GetControllerMouseDelta
// 0x0008 (0x0008 - 0x0000)
struct InputComponent_GetControllerMouseDelta final
{
public:
	float                                         DeltaX;                                            // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaY;                                            // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputComponent_GetControllerMouseDelta) == 0x000004, "Wrong alignment on InputComponent_GetControllerMouseDelta");
static_assert(sizeof(InputComponent_GetControllerMouseDelta) == 0x000008, "Wrong size on InputComponent_GetControllerMouseDelta");
static_assert(offsetof(InputComponent_GetControllerMouseDelta, DeltaX) == 0x000000, "Member 'InputComponent_GetControllerMouseDelta::DeltaX' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerMouseDelta, DeltaY) == 0x000004, "Member 'InputComponent_GetControllerMouseDelta::DeltaY' has a wrong offset!");

// Function Engine.InputComponent.GetControllerVectorKeyState
// 0x0028 (0x0028 - 0x0000)
struct InputComponent_GetControllerVectorKeyState final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0018(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_GetControllerVectorKeyState) == 0x000008, "Wrong alignment on InputComponent_GetControllerVectorKeyState");
static_assert(sizeof(InputComponent_GetControllerVectorKeyState) == 0x000028, "Wrong size on InputComponent_GetControllerVectorKeyState");
static_assert(offsetof(InputComponent_GetControllerVectorKeyState, Key) == 0x000000, "Member 'InputComponent_GetControllerVectorKeyState::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_GetControllerVectorKeyState, ReturnValue) == 0x000018, "Member 'InputComponent_GetControllerVectorKeyState::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.GetTouchState
// 0x0010 (0x0010 - 0x0000)
struct InputComponent_GetTouchState final
{
public:
	int32                                         FingerIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationX;                                         // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LocationY;                                         // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCurrentlyPressed;                               // 0x000C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_GetTouchState) == 0x000004, "Wrong alignment on InputComponent_GetTouchState");
static_assert(sizeof(InputComponent_GetTouchState) == 0x000010, "Wrong size on InputComponent_GetTouchState");
static_assert(offsetof(InputComponent_GetTouchState, FingerIndex) == 0x000000, "Member 'InputComponent_GetTouchState::FingerIndex' has a wrong offset!");
static_assert(offsetof(InputComponent_GetTouchState, LocationX) == 0x000004, "Member 'InputComponent_GetTouchState::LocationX' has a wrong offset!");
static_assert(offsetof(InputComponent_GetTouchState, LocationY) == 0x000008, "Member 'InputComponent_GetTouchState::LocationY' has a wrong offset!");
static_assert(offsetof(InputComponent_GetTouchState, bIsCurrentlyPressed) == 0x00000C, "Member 'InputComponent_GetTouchState::bIsCurrentlyPressed' has a wrong offset!");

// Function Engine.InputComponent.IsControllerKeyDown
// 0x0020 (0x0020 - 0x0000)
struct InputComponent_IsControllerKeyDown final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_IsControllerKeyDown) == 0x000008, "Wrong alignment on InputComponent_IsControllerKeyDown");
static_assert(sizeof(InputComponent_IsControllerKeyDown) == 0x000020, "Wrong size on InputComponent_IsControllerKeyDown");
static_assert(offsetof(InputComponent_IsControllerKeyDown, Key) == 0x000000, "Member 'InputComponent_IsControllerKeyDown::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_IsControllerKeyDown, ReturnValue) == 0x000018, "Member 'InputComponent_IsControllerKeyDown::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.WasControllerKeyJustPressed
// 0x0020 (0x0020 - 0x0000)
struct InputComponent_WasControllerKeyJustPressed final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_WasControllerKeyJustPressed) == 0x000008, "Wrong alignment on InputComponent_WasControllerKeyJustPressed");
static_assert(sizeof(InputComponent_WasControllerKeyJustPressed) == 0x000020, "Wrong size on InputComponent_WasControllerKeyJustPressed");
static_assert(offsetof(InputComponent_WasControllerKeyJustPressed, Key) == 0x000000, "Member 'InputComponent_WasControllerKeyJustPressed::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_WasControllerKeyJustPressed, ReturnValue) == 0x000018, "Member 'InputComponent_WasControllerKeyJustPressed::ReturnValue' has a wrong offset!");

// Function Engine.InputComponent.WasControllerKeyJustReleased
// 0x0020 (0x0020 - 0x0000)
struct InputComponent_WasControllerKeyJustReleased final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputComponent_WasControllerKeyJustReleased) == 0x000008, "Wrong alignment on InputComponent_WasControllerKeyJustReleased");
static_assert(sizeof(InputComponent_WasControllerKeyJustReleased) == 0x000020, "Wrong size on InputComponent_WasControllerKeyJustReleased");
static_assert(offsetof(InputComponent_WasControllerKeyJustReleased, Key) == 0x000000, "Member 'InputComponent_WasControllerKeyJustReleased::Key' has a wrong offset!");
static_assert(offsetof(InputComponent_WasControllerKeyJustReleased, ReturnValue) == 0x000018, "Member 'InputComponent_WasControllerKeyJustReleased::ReturnValue' has a wrong offset!");

// Function Engine.InputSettings.GetInputSettings
// 0x0008 (0x0008 - 0x0000)
struct InputSettings_GetInputSettings final
{
public:
	class UInputSettings*                         ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettings_GetInputSettings) == 0x000008, "Wrong alignment on InputSettings_GetInputSettings");
static_assert(sizeof(InputSettings_GetInputSettings) == 0x000008, "Wrong size on InputSettings_GetInputSettings");
static_assert(offsetof(InputSettings_GetInputSettings, ReturnValue) == 0x000000, "Member 'InputSettings_GetInputSettings::ReturnValue' has a wrong offset!");

// Function Engine.InputSettings.AddActionMapping
// 0x0030 (0x0030 - 0x0000)
struct InputSettings_AddActionMapping final
{
public:
	struct FInputActionKeyMapping                 KeyMapping;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceRebuildKeymaps;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettings_AddActionMapping) == 0x000008, "Wrong alignment on InputSettings_AddActionMapping");
static_assert(sizeof(InputSettings_AddActionMapping) == 0x000030, "Wrong size on InputSettings_AddActionMapping");
static_assert(offsetof(InputSettings_AddActionMapping, KeyMapping) == 0x000000, "Member 'InputSettings_AddActionMapping::KeyMapping' has a wrong offset!");
static_assert(offsetof(InputSettings_AddActionMapping, bForceRebuildKeymaps) == 0x000028, "Member 'InputSettings_AddActionMapping::bForceRebuildKeymaps' has a wrong offset!");

// Function Engine.InputSettings.AddAxisMapping
// 0x0030 (0x0030 - 0x0000)
struct InputSettings_AddAxisMapping final
{
public:
	struct FInputAxisKeyMapping                   KeyMapping;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceRebuildKeymaps;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettings_AddAxisMapping) == 0x000008, "Wrong alignment on InputSettings_AddAxisMapping");
static_assert(sizeof(InputSettings_AddAxisMapping) == 0x000030, "Wrong size on InputSettings_AddAxisMapping");
static_assert(offsetof(InputSettings_AddAxisMapping, KeyMapping) == 0x000000, "Member 'InputSettings_AddAxisMapping::KeyMapping' has a wrong offset!");
static_assert(offsetof(InputSettings_AddAxisMapping, bForceRebuildKeymaps) == 0x000028, "Member 'InputSettings_AddAxisMapping::bForceRebuildKeymaps' has a wrong offset!");

// Function Engine.InputSettings.RemoveActionMapping
// 0x0030 (0x0030 - 0x0000)
struct InputSettings_RemoveActionMapping final
{
public:
	struct FInputActionKeyMapping                 KeyMapping;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceRebuildKeymaps;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettings_RemoveActionMapping) == 0x000008, "Wrong alignment on InputSettings_RemoveActionMapping");
static_assert(sizeof(InputSettings_RemoveActionMapping) == 0x000030, "Wrong size on InputSettings_RemoveActionMapping");
static_assert(offsetof(InputSettings_RemoveActionMapping, KeyMapping) == 0x000000, "Member 'InputSettings_RemoveActionMapping::KeyMapping' has a wrong offset!");
static_assert(offsetof(InputSettings_RemoveActionMapping, bForceRebuildKeymaps) == 0x000028, "Member 'InputSettings_RemoveActionMapping::bForceRebuildKeymaps' has a wrong offset!");

// Function Engine.InputSettings.RemoveAxisMapping
// 0x0030 (0x0030 - 0x0000)
struct InputSettings_RemoveAxisMapping final
{
public:
	struct FInputAxisKeyMapping                   KeyMapping;                                        // 0x0000(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceRebuildKeymaps;                              // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InputSettings_RemoveAxisMapping) == 0x000008, "Wrong alignment on InputSettings_RemoveAxisMapping");
static_assert(sizeof(InputSettings_RemoveAxisMapping) == 0x000030, "Wrong size on InputSettings_RemoveAxisMapping");
static_assert(offsetof(InputSettings_RemoveAxisMapping, KeyMapping) == 0x000000, "Member 'InputSettings_RemoveAxisMapping::KeyMapping' has a wrong offset!");
static_assert(offsetof(InputSettings_RemoveAxisMapping, bForceRebuildKeymaps) == 0x000028, "Member 'InputSettings_RemoveAxisMapping::bForceRebuildKeymaps' has a wrong offset!");

// Function Engine.InputSettings.GetActionMappingByName
// 0x0018 (0x0018 - 0x0000)
struct InputSettings_GetActionMappingByName final
{
public:
	class FName                                   InActionName;                                      // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputActionKeyMapping>         OutMappings;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettings_GetActionMappingByName) == 0x000008, "Wrong alignment on InputSettings_GetActionMappingByName");
static_assert(sizeof(InputSettings_GetActionMappingByName) == 0x000018, "Wrong size on InputSettings_GetActionMappingByName");
static_assert(offsetof(InputSettings_GetActionMappingByName, InActionName) == 0x000000, "Member 'InputSettings_GetActionMappingByName::InActionName' has a wrong offset!");
static_assert(offsetof(InputSettings_GetActionMappingByName, OutMappings) == 0x000008, "Member 'InputSettings_GetActionMappingByName::OutMappings' has a wrong offset!");

// Function Engine.InputSettings.GetActionNames
// 0x0010 (0x0010 - 0x0000)
struct InputSettings_GetActionNames final
{
public:
	TArray<class FName>                           ActionNames;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettings_GetActionNames) == 0x000008, "Wrong alignment on InputSettings_GetActionNames");
static_assert(sizeof(InputSettings_GetActionNames) == 0x000010, "Wrong size on InputSettings_GetActionNames");
static_assert(offsetof(InputSettings_GetActionNames, ActionNames) == 0x000000, "Member 'InputSettings_GetActionNames::ActionNames' has a wrong offset!");

// Function Engine.InputSettings.GetAxisMappingByName
// 0x0018 (0x0018 - 0x0000)
struct InputSettings_GetAxisMappingByName final
{
public:
	class FName                                   InAxisName;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FInputAxisKeyMapping>           OutMappings;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettings_GetAxisMappingByName) == 0x000008, "Wrong alignment on InputSettings_GetAxisMappingByName");
static_assert(sizeof(InputSettings_GetAxisMappingByName) == 0x000018, "Wrong size on InputSettings_GetAxisMappingByName");
static_assert(offsetof(InputSettings_GetAxisMappingByName, InAxisName) == 0x000000, "Member 'InputSettings_GetAxisMappingByName::InAxisName' has a wrong offset!");
static_assert(offsetof(InputSettings_GetAxisMappingByName, OutMappings) == 0x000008, "Member 'InputSettings_GetAxisMappingByName::OutMappings' has a wrong offset!");

// Function Engine.InputSettings.GetAxisNames
// 0x0010 (0x0010 - 0x0000)
struct InputSettings_GetAxisNames final
{
public:
	TArray<class FName>                           AxisNames;                                         // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(InputSettings_GetAxisNames) == 0x000008, "Wrong alignment on InputSettings_GetAxisNames");
static_assert(sizeof(InputSettings_GetAxisNames) == 0x000010, "Wrong size on InputSettings_GetAxisNames");
static_assert(offsetof(InputSettings_GetAxisNames, AxisNames) == 0x000000, "Member 'InputSettings_GetAxisNames::AxisNames' has a wrong offset!");

// DelegateFunction Engine.InterpToMovementComponent.OnInterpToResetDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature) == 0x000008, "Wrong alignment on InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature");
static_assert(sizeof(InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature) == 0x000090, "Wrong size on InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature");
static_assert(offsetof(InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature, Time) == 0x000088, "Member 'InterpToMovementComponent_OnInterpToResetDelegate__DelegateSignature::Time' has a wrong offset!");

// DelegateFunction Engine.InterpToMovementComponent.OnInterpToReverseDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature) == 0x000008, "Wrong alignment on InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature");
static_assert(sizeof(InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature) == 0x000090, "Wrong size on InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature");
static_assert(offsetof(InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature, Time) == 0x000088, "Member 'InterpToMovementComponent_OnInterpToReverseDelegate__DelegateSignature::Time' has a wrong offset!");

// DelegateFunction Engine.InterpToMovementComponent.OnInterpToStopDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature) == 0x000008, "Wrong alignment on InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature");
static_assert(sizeof(InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature) == 0x000090, "Wrong size on InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature");
static_assert(offsetof(InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature, Time) == 0x000088, "Member 'InterpToMovementComponent_OnInterpToStopDelegate__DelegateSignature::Time' has a wrong offset!");

// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitBeginDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature) == 0x000008, "Wrong alignment on InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature");
static_assert(sizeof(InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature) == 0x000090, "Wrong size on InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature");
static_assert(offsetof(InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature, Time) == 0x000088, "Member 'InterpToMovementComponent_OnInterpToWaitBeginDelegate__DelegateSignature::Time' has a wrong offset!");

// DelegateFunction Engine.InterpToMovementComponent.OnInterpToWaitEndDelegate__DelegateSignature
// 0x0090 (0x0090 - 0x0000)
struct InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature final
{
public:
	struct FHitResult                             ImpactResult;                                      // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0088(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature) == 0x000008, "Wrong alignment on InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature");
static_assert(sizeof(InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature) == 0x000090, "Wrong size on InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature");
static_assert(offsetof(InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature, ImpactResult) == 0x000000, "Member 'InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature::ImpactResult' has a wrong offset!");
static_assert(offsetof(InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature, Time) == 0x000088, "Member 'InterpToMovementComponent_OnInterpToWaitEndDelegate__DelegateSignature::Time' has a wrong offset!");

// Function Engine.InterpToMovementComponent.RestartMovement
// 0x0004 (0x0004 - 0x0000)
struct InterpToMovementComponent_RestartMovement final
{
public:
	float                                         InitialDirection;                                  // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpToMovementComponent_RestartMovement) == 0x000004, "Wrong alignment on InterpToMovementComponent_RestartMovement");
static_assert(sizeof(InterpToMovementComponent_RestartMovement) == 0x000004, "Wrong size on InterpToMovementComponent_RestartMovement");
static_assert(offsetof(InterpToMovementComponent_RestartMovement, InitialDirection) == 0x000000, "Member 'InterpToMovementComponent_RestartMovement::InitialDirection' has a wrong offset!");

// Function Engine.InterpToMovementComponent.StopSimulating
// 0x0088 (0x0088 - 0x0000)
struct InterpToMovementComponent_StopSimulating final
{
public:
	struct FHitResult                             HitResult;                                         // 0x0000(0x0088)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
};
static_assert(alignof(InterpToMovementComponent_StopSimulating) == 0x000008, "Wrong alignment on InterpToMovementComponent_StopSimulating");
static_assert(sizeof(InterpToMovementComponent_StopSimulating) == 0x000088, "Wrong size on InterpToMovementComponent_StopSimulating");
static_assert(offsetof(InterpToMovementComponent_StopSimulating, HitResult) == 0x000000, "Member 'InterpToMovementComponent_StopSimulating::HitResult' has a wrong offset!");

// Function Engine.KismetGuidLibrary.Conv_GuidToString
// 0x0020 (0x0020 - 0x0000)
struct KismetGuidLibrary_Conv_GuidToString final
{
public:
	struct FGuid                                  InGuid;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetGuidLibrary_Conv_GuidToString) == 0x000008, "Wrong alignment on KismetGuidLibrary_Conv_GuidToString");
static_assert(sizeof(KismetGuidLibrary_Conv_GuidToString) == 0x000020, "Wrong size on KismetGuidLibrary_Conv_GuidToString");
static_assert(offsetof(KismetGuidLibrary_Conv_GuidToString, InGuid) == 0x000000, "Member 'KismetGuidLibrary_Conv_GuidToString::InGuid' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_Conv_GuidToString, ReturnValue) == 0x000010, "Member 'KismetGuidLibrary_Conv_GuidToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetGuidLibrary.EqualEqual_GuidGuid
// 0x0024 (0x0024 - 0x0000)
struct KismetGuidLibrary_EqualEqual_GuidGuid final
{
public:
	struct FGuid                                  A;                                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  B;                                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetGuidLibrary_EqualEqual_GuidGuid) == 0x000004, "Wrong alignment on KismetGuidLibrary_EqualEqual_GuidGuid");
static_assert(sizeof(KismetGuidLibrary_EqualEqual_GuidGuid) == 0x000024, "Wrong size on KismetGuidLibrary_EqualEqual_GuidGuid");
static_assert(offsetof(KismetGuidLibrary_EqualEqual_GuidGuid, A) == 0x000000, "Member 'KismetGuidLibrary_EqualEqual_GuidGuid::A' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_EqualEqual_GuidGuid, B) == 0x000010, "Member 'KismetGuidLibrary_EqualEqual_GuidGuid::B' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_EqualEqual_GuidGuid, ReturnValue) == 0x000020, "Member 'KismetGuidLibrary_EqualEqual_GuidGuid::ReturnValue' has a wrong offset!");

// Function Engine.KismetGuidLibrary.Invalidate_Guid
// 0x0010 (0x0010 - 0x0000)
struct KismetGuidLibrary_Invalidate_Guid final
{
public:
	struct FGuid                                  InGuid;                                            // 0x0000(0x0010)(Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetGuidLibrary_Invalidate_Guid) == 0x000004, "Wrong alignment on KismetGuidLibrary_Invalidate_Guid");
static_assert(sizeof(KismetGuidLibrary_Invalidate_Guid) == 0x000010, "Wrong size on KismetGuidLibrary_Invalidate_Guid");
static_assert(offsetof(KismetGuidLibrary_Invalidate_Guid, InGuid) == 0x000000, "Member 'KismetGuidLibrary_Invalidate_Guid::InGuid' has a wrong offset!");

// Function Engine.KismetGuidLibrary.IsValid_Guid
// 0x0014 (0x0014 - 0x0000)
struct KismetGuidLibrary_IsValid_Guid final
{
public:
	struct FGuid                                  InGuid;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetGuidLibrary_IsValid_Guid) == 0x000004, "Wrong alignment on KismetGuidLibrary_IsValid_Guid");
static_assert(sizeof(KismetGuidLibrary_IsValid_Guid) == 0x000014, "Wrong size on KismetGuidLibrary_IsValid_Guid");
static_assert(offsetof(KismetGuidLibrary_IsValid_Guid, InGuid) == 0x000000, "Member 'KismetGuidLibrary_IsValid_Guid::InGuid' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_IsValid_Guid, ReturnValue) == 0x000010, "Member 'KismetGuidLibrary_IsValid_Guid::ReturnValue' has a wrong offset!");

// Function Engine.KismetGuidLibrary.NewGuid
// 0x0010 (0x0010 - 0x0000)
struct KismetGuidLibrary_NewGuid final
{
public:
	struct FGuid                                  ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetGuidLibrary_NewGuid) == 0x000004, "Wrong alignment on KismetGuidLibrary_NewGuid");
static_assert(sizeof(KismetGuidLibrary_NewGuid) == 0x000010, "Wrong size on KismetGuidLibrary_NewGuid");
static_assert(offsetof(KismetGuidLibrary_NewGuid, ReturnValue) == 0x000000, "Member 'KismetGuidLibrary_NewGuid::ReturnValue' has a wrong offset!");

// Function Engine.KismetGuidLibrary.NotEqual_GuidGuid
// 0x0024 (0x0024 - 0x0000)
struct KismetGuidLibrary_NotEqual_GuidGuid final
{
public:
	struct FGuid                                  A;                                                 // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  B;                                                 // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetGuidLibrary_NotEqual_GuidGuid) == 0x000004, "Wrong alignment on KismetGuidLibrary_NotEqual_GuidGuid");
static_assert(sizeof(KismetGuidLibrary_NotEqual_GuidGuid) == 0x000024, "Wrong size on KismetGuidLibrary_NotEqual_GuidGuid");
static_assert(offsetof(KismetGuidLibrary_NotEqual_GuidGuid, A) == 0x000000, "Member 'KismetGuidLibrary_NotEqual_GuidGuid::A' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_NotEqual_GuidGuid, B) == 0x000010, "Member 'KismetGuidLibrary_NotEqual_GuidGuid::B' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_NotEqual_GuidGuid, ReturnValue) == 0x000020, "Member 'KismetGuidLibrary_NotEqual_GuidGuid::ReturnValue' has a wrong offset!");

// Function Engine.KismetGuidLibrary.Parse_StringToGuid
// 0x0028 (0x0028 - 0x0000)
struct KismetGuidLibrary_Parse_StringToGuid final
{
public:
	class FString                                 GuidString;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGuid                                  OutGuid;                                           // 0x0010(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Success;                                           // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetGuidLibrary_Parse_StringToGuid) == 0x000008, "Wrong alignment on KismetGuidLibrary_Parse_StringToGuid");
static_assert(sizeof(KismetGuidLibrary_Parse_StringToGuid) == 0x000028, "Wrong size on KismetGuidLibrary_Parse_StringToGuid");
static_assert(offsetof(KismetGuidLibrary_Parse_StringToGuid, GuidString) == 0x000000, "Member 'KismetGuidLibrary_Parse_StringToGuid::GuidString' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_Parse_StringToGuid, OutGuid) == 0x000010, "Member 'KismetGuidLibrary_Parse_StringToGuid::OutGuid' has a wrong offset!");
static_assert(offsetof(KismetGuidLibrary_Parse_StringToGuid, Success) == 0x000020, "Member 'KismetGuidLibrary_Parse_StringToGuid::Success' has a wrong offset!");

// Function Engine.KismetInputLibrary.EqualEqual_InputChordInputChord
// 0x0048 (0x0048 - 0x0000)
struct KismetInputLibrary_EqualEqual_InputChordInputChord final
{
public:
	struct FInputChord                            A;                                                 // 0x0000(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FInputChord                            B;                                                 // 0x0020(0x0020)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_EqualEqual_InputChordInputChord) == 0x000008, "Wrong alignment on KismetInputLibrary_EqualEqual_InputChordInputChord");
static_assert(sizeof(KismetInputLibrary_EqualEqual_InputChordInputChord) == 0x000048, "Wrong size on KismetInputLibrary_EqualEqual_InputChordInputChord");
static_assert(offsetof(KismetInputLibrary_EqualEqual_InputChordInputChord, A) == 0x000000, "Member 'KismetInputLibrary_EqualEqual_InputChordInputChord::A' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_EqualEqual_InputChordInputChord, B) == 0x000020, "Member 'KismetInputLibrary_EqualEqual_InputChordInputChord::B' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_EqualEqual_InputChordInputChord, ReturnValue) == 0x000040, "Member 'KismetInputLibrary_EqualEqual_InputChordInputChord::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.EqualEqual_KeyKey
// 0x0038 (0x0038 - 0x0000)
struct KismetInputLibrary_EqualEqual_KeyKey final
{
public:
	struct FKey                                   A;                                                 // 0x0000(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FKey                                   B;                                                 // 0x0018(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_EqualEqual_KeyKey) == 0x000008, "Wrong alignment on KismetInputLibrary_EqualEqual_KeyKey");
static_assert(sizeof(KismetInputLibrary_EqualEqual_KeyKey) == 0x000038, "Wrong size on KismetInputLibrary_EqualEqual_KeyKey");
static_assert(offsetof(KismetInputLibrary_EqualEqual_KeyKey, A) == 0x000000, "Member 'KismetInputLibrary_EqualEqual_KeyKey::A' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_EqualEqual_KeyKey, B) == 0x000018, "Member 'KismetInputLibrary_EqualEqual_KeyKey::B' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_EqualEqual_KeyKey, ReturnValue) == 0x000030, "Member 'KismetInputLibrary_EqualEqual_KeyKey::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.GetAnalogValue
// 0x0050 (0x0050 - 0x0000)
struct KismetInputLibrary_GetAnalogValue final
{
public:
	struct FAnalogInputEvent                      Input;                                             // 0x0000(0x0048)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0048(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4C[0x4];                                       // 0x004C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_GetAnalogValue) == 0x000008, "Wrong alignment on KismetInputLibrary_GetAnalogValue");
static_assert(sizeof(KismetInputLibrary_GetAnalogValue) == 0x000050, "Wrong size on KismetInputLibrary_GetAnalogValue");
static_assert(offsetof(KismetInputLibrary_GetAnalogValue, Input) == 0x000000, "Member 'KismetInputLibrary_GetAnalogValue::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_GetAnalogValue, ReturnValue) == 0x000048, "Member 'KismetInputLibrary_GetAnalogValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.GetKey
// 0x0058 (0x0058 - 0x0000)
struct KismetInputLibrary_GetKey final
{
public:
	struct FKeyEvent                              Input;                                             // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0040(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_GetKey) == 0x000008, "Wrong alignment on KismetInputLibrary_GetKey");
static_assert(sizeof(KismetInputLibrary_GetKey) == 0x000058, "Wrong size on KismetInputLibrary_GetKey");
static_assert(offsetof(KismetInputLibrary_GetKey, Input) == 0x000000, "Member 'KismetInputLibrary_GetKey::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_GetKey, ReturnValue) == 0x000040, "Member 'KismetInputLibrary_GetKey::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.GetUserIndex
// 0x0048 (0x0048 - 0x0000)
struct KismetInputLibrary_GetUserIndex final
{
public:
	struct FKeyEvent                              Input;                                             // 0x0000(0x0040)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_GetUserIndex) == 0x000008, "Wrong alignment on KismetInputLibrary_GetUserIndex");
static_assert(sizeof(KismetInputLibrary_GetUserIndex) == 0x000048, "Wrong size on KismetInputLibrary_GetUserIndex");
static_assert(offsetof(KismetInputLibrary_GetUserIndex, Input) == 0x000000, "Member 'KismetInputLibrary_GetUserIndex::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_GetUserIndex, ReturnValue) == 0x000040, "Member 'KismetInputLibrary_GetUserIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsAltDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsAltDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsAltDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsAltDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsAltDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsAltDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsAltDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsAltDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsAltDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsAltDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsCommandDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsCommandDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsCommandDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsCommandDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsCommandDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsCommandDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsCommandDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsCommandDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsCommandDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsCommandDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsControlDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsControlDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsControlDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsControlDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsControlDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsControlDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsControlDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsControlDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsControlDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsControlDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsLeftAltDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsLeftAltDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsLeftAltDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsLeftAltDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsLeftAltDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsLeftAltDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftAltDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsLeftAltDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftAltDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsLeftAltDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsLeftCommandDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsLeftCommandDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsLeftCommandDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsLeftCommandDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsLeftCommandDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsLeftCommandDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftCommandDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsLeftCommandDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftCommandDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsLeftCommandDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsLeftControlDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsLeftControlDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsLeftControlDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsLeftControlDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsLeftControlDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsLeftControlDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftControlDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsLeftControlDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftControlDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsLeftControlDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsLeftShiftDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsLeftShiftDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsLeftShiftDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsLeftShiftDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsLeftShiftDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsLeftShiftDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftShiftDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsLeftShiftDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsLeftShiftDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsLeftShiftDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsRepeat
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsRepeat final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsRepeat) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsRepeat");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsRepeat) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsRepeat");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRepeat, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsRepeat::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRepeat, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsRepeat::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsRightAltDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsRightAltDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsRightAltDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsRightAltDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsRightAltDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsRightAltDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightAltDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsRightAltDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightAltDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsRightAltDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsRightCommandDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsRightCommandDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsRightCommandDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsRightCommandDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsRightCommandDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsRightCommandDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightCommandDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsRightCommandDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightCommandDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsRightCommandDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsRightControlDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsRightControlDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsRightControlDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsRightControlDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsRightControlDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsRightControlDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightControlDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsRightControlDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightControlDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsRightControlDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsRightShiftDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsRightShiftDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsRightShiftDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsRightShiftDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsRightShiftDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsRightShiftDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightShiftDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsRightShiftDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsRightShiftDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsRightShiftDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.InputEvent_IsShiftDown
// 0x0028 (0x0028 - 0x0000)
struct KismetInputLibrary_InputEvent_IsShiftDown final
{
public:
	struct FInputEvent                            Input;                                             // 0x0000(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_InputEvent_IsShiftDown) == 0x000008, "Wrong alignment on KismetInputLibrary_InputEvent_IsShiftDown");
static_assert(sizeof(KismetInputLibrary_InputEvent_IsShiftDown) == 0x000028, "Wrong size on KismetInputLibrary_InputEvent_IsShiftDown");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsShiftDown, Input) == 0x000000, "Member 'KismetInputLibrary_InputEvent_IsShiftDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_InputEvent_IsShiftDown, ReturnValue) == 0x000020, "Member 'KismetInputLibrary_InputEvent_IsShiftDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_GetDisplayName
// 0x0030 (0x0030 - 0x0000)
struct KismetInputLibrary_Key_GetDisplayName final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_Key_GetDisplayName) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_GetDisplayName");
static_assert(sizeof(KismetInputLibrary_Key_GetDisplayName) == 0x000030, "Wrong size on KismetInputLibrary_Key_GetDisplayName");
static_assert(offsetof(KismetInputLibrary_Key_GetDisplayName, Key) == 0x000000, "Member 'KismetInputLibrary_Key_GetDisplayName::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_GetDisplayName, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_GetDisplayName::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsFloatAxis
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsFloatAxis final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsFloatAxis) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsFloatAxis");
static_assert(sizeof(KismetInputLibrary_Key_IsFloatAxis) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsFloatAxis");
static_assert(offsetof(KismetInputLibrary_Key_IsFloatAxis, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsFloatAxis::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsFloatAxis, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsFloatAxis::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsGamepadKey
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsGamepadKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsGamepadKey) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsGamepadKey");
static_assert(sizeof(KismetInputLibrary_Key_IsGamepadKey) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsGamepadKey");
static_assert(offsetof(KismetInputLibrary_Key_IsGamepadKey, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsGamepadKey::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsGamepadKey, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsGamepadKey::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsKeyboardKey
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsKeyboardKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsKeyboardKey) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsKeyboardKey");
static_assert(sizeof(KismetInputLibrary_Key_IsKeyboardKey) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsKeyboardKey");
static_assert(offsetof(KismetInputLibrary_Key_IsKeyboardKey, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsKeyboardKey::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsKeyboardKey, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsKeyboardKey::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsModifierKey
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsModifierKey final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsModifierKey) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsModifierKey");
static_assert(sizeof(KismetInputLibrary_Key_IsModifierKey) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsModifierKey");
static_assert(offsetof(KismetInputLibrary_Key_IsModifierKey, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsModifierKey::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsModifierKey, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsModifierKey::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsMouseButton
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsMouseButton final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsMouseButton) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsMouseButton");
static_assert(sizeof(KismetInputLibrary_Key_IsMouseButton) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsMouseButton");
static_assert(offsetof(KismetInputLibrary_Key_IsMouseButton, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsMouseButton::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsMouseButton, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsMouseButton::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.Key_IsVectorAxis
// 0x0020 (0x0020 - 0x0000)
struct KismetInputLibrary_Key_IsVectorAxis final
{
public:
	struct FKey                                   Key;                                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_Key_IsVectorAxis) == 0x000008, "Wrong alignment on KismetInputLibrary_Key_IsVectorAxis");
static_assert(sizeof(KismetInputLibrary_Key_IsVectorAxis) == 0x000020, "Wrong size on KismetInputLibrary_Key_IsVectorAxis");
static_assert(offsetof(KismetInputLibrary_Key_IsVectorAxis, Key) == 0x000000, "Member 'KismetInputLibrary_Key_IsVectorAxis::Key' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_Key_IsVectorAxis, ReturnValue) == 0x000018, "Member 'KismetInputLibrary_Key_IsVectorAxis::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetCursorDelta
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetCursorDelta final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetCursorDelta) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetCursorDelta");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetCursorDelta) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetCursorDelta");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetCursorDelta, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetCursorDelta::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetCursorDelta, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetCursorDelta::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetEffectingButton
// 0x0088 (0x0088 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetEffectingButton final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKey                                   ReturnValue;                                       // 0x0070(0x0018)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetEffectingButton) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetEffectingButton");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetEffectingButton) == 0x000088, "Wrong size on KismetInputLibrary_PointerEvent_GetEffectingButton");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetEffectingButton, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetEffectingButton::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetEffectingButton, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetEffectingButton::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetGestureDelta
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetGestureDelta final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetGestureDelta) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetGestureDelta");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetGestureDelta) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetGestureDelta");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetGestureDelta, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetGestureDelta::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetGestureDelta, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetGestureDelta::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetGestureType
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetGestureType final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	ESlateGesture                                 ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetGestureType) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetGestureType");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetGestureType) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetGestureType");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetGestureType, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetGestureType::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetGestureType, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetGestureType::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetLastScreenSpacePosition
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetLastScreenSpacePosition::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetPointerIndex
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetPointerIndex final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetPointerIndex) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetPointerIndex");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetPointerIndex) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetPointerIndex");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetPointerIndex, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetPointerIndex::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetPointerIndex, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetPointerIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetScreenSpacePosition
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetScreenSpacePosition final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector2D                              ReturnValue;                                       // 0x0070(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetScreenSpacePosition) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetScreenSpacePosition");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetScreenSpacePosition) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetScreenSpacePosition");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetScreenSpacePosition, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetScreenSpacePosition::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetScreenSpacePosition, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetScreenSpacePosition::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetTouchpadIndex
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetTouchpadIndex final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetTouchpadIndex) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetTouchpadIndex");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetTouchpadIndex) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetTouchpadIndex");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetTouchpadIndex, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetTouchpadIndex::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetTouchpadIndex, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetTouchpadIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetUserIndex
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetUserIndex final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetUserIndex) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetUserIndex");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetUserIndex) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetUserIndex");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetUserIndex, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetUserIndex::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetUserIndex, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetUserIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_GetWheelDelta
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_GetWheelDelta final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0070(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_74[0x4];                                       // 0x0074(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_GetWheelDelta) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_GetWheelDelta");
static_assert(sizeof(KismetInputLibrary_PointerEvent_GetWheelDelta) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_GetWheelDelta");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetWheelDelta, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_GetWheelDelta::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_GetWheelDelta, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_GetWheelDelta::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_IsMouseButtonDown
// 0x0090 (0x0090 - 0x0000)
struct KismetInputLibrary_PointerEvent_IsMouseButtonDown final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FKey                                   MouseButton;                                       // 0x0070(0x0018)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_IsMouseButtonDown) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_IsMouseButtonDown");
static_assert(sizeof(KismetInputLibrary_PointerEvent_IsMouseButtonDown) == 0x000090, "Wrong size on KismetInputLibrary_PointerEvent_IsMouseButtonDown");
static_assert(offsetof(KismetInputLibrary_PointerEvent_IsMouseButtonDown, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_IsMouseButtonDown::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_IsMouseButtonDown, MouseButton) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_IsMouseButtonDown::MouseButton' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_IsMouseButtonDown, ReturnValue) == 0x000088, "Member 'KismetInputLibrary_PointerEvent_IsMouseButtonDown::ReturnValue' has a wrong offset!");

// Function Engine.KismetInputLibrary.PointerEvent_IsTouchEvent
// 0x0078 (0x0078 - 0x0000)
struct KismetInputLibrary_PointerEvent_IsTouchEvent final
{
public:
	struct FPointerEvent                          Input;                                             // 0x0000(0x0070)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0070(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x7];                                       // 0x0071(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInputLibrary_PointerEvent_IsTouchEvent) == 0x000008, "Wrong alignment on KismetInputLibrary_PointerEvent_IsTouchEvent");
static_assert(sizeof(KismetInputLibrary_PointerEvent_IsTouchEvent) == 0x000078, "Wrong size on KismetInputLibrary_PointerEvent_IsTouchEvent");
static_assert(offsetof(KismetInputLibrary_PointerEvent_IsTouchEvent, Input) == 0x000000, "Member 'KismetInputLibrary_PointerEvent_IsTouchEvent::Input' has a wrong offset!");
static_assert(offsetof(KismetInputLibrary_PointerEvent_IsTouchEvent, ReturnValue) == 0x000070, "Member 'KismetInputLibrary_PointerEvent_IsTouchEvent::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.ClearCurrentAssetGroupCulture
// 0x0010 (0x0010 - 0x0000)
struct KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture final
{
public:
	class FName                                   AssetGroup;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0008(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture) == 0x000004, "Wrong alignment on KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture");
static_assert(sizeof(KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture) == 0x000010, "Wrong size on KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture");
static_assert(offsetof(KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture, AssetGroup) == 0x000000, "Member 'KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture::AssetGroup' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture, SaveToConfig) == 0x000008, "Member 'KismetInternationalizationLibrary_ClearCurrentAssetGroupCulture::SaveToConfig' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.GetCurrentAssetGroupCulture
// 0x0018 (0x0018 - 0x0000)
struct KismetInternationalizationLibrary_GetCurrentAssetGroupCulture final
{
public:
	class FName                                   AssetGroup;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInternationalizationLibrary_GetCurrentAssetGroupCulture) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_GetCurrentAssetGroupCulture");
static_assert(sizeof(KismetInternationalizationLibrary_GetCurrentAssetGroupCulture) == 0x000018, "Wrong size on KismetInternationalizationLibrary_GetCurrentAssetGroupCulture");
static_assert(offsetof(KismetInternationalizationLibrary_GetCurrentAssetGroupCulture, AssetGroup) == 0x000000, "Member 'KismetInternationalizationLibrary_GetCurrentAssetGroupCulture::AssetGroup' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_GetCurrentAssetGroupCulture, ReturnValue) == 0x000008, "Member 'KismetInternationalizationLibrary_GetCurrentAssetGroupCulture::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.GetCurrentCulture
// 0x0010 (0x0010 - 0x0000)
struct KismetInternationalizationLibrary_GetCurrentCulture final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInternationalizationLibrary_GetCurrentCulture) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_GetCurrentCulture");
static_assert(sizeof(KismetInternationalizationLibrary_GetCurrentCulture) == 0x000010, "Wrong size on KismetInternationalizationLibrary_GetCurrentCulture");
static_assert(offsetof(KismetInternationalizationLibrary_GetCurrentCulture, ReturnValue) == 0x000000, "Member 'KismetInternationalizationLibrary_GetCurrentCulture::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.GetCurrentLanguage
// 0x0010 (0x0010 - 0x0000)
struct KismetInternationalizationLibrary_GetCurrentLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInternationalizationLibrary_GetCurrentLanguage) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_GetCurrentLanguage");
static_assert(sizeof(KismetInternationalizationLibrary_GetCurrentLanguage) == 0x000010, "Wrong size on KismetInternationalizationLibrary_GetCurrentLanguage");
static_assert(offsetof(KismetInternationalizationLibrary_GetCurrentLanguage, ReturnValue) == 0x000000, "Member 'KismetInternationalizationLibrary_GetCurrentLanguage::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.GetCurrentLocale
// 0x0010 (0x0010 - 0x0000)
struct KismetInternationalizationLibrary_GetCurrentLocale final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetInternationalizationLibrary_GetCurrentLocale) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_GetCurrentLocale");
static_assert(sizeof(KismetInternationalizationLibrary_GetCurrentLocale) == 0x000010, "Wrong size on KismetInternationalizationLibrary_GetCurrentLocale");
static_assert(offsetof(KismetInternationalizationLibrary_GetCurrentLocale, ReturnValue) == 0x000000, "Member 'KismetInternationalizationLibrary_GetCurrentLocale::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.SetCurrentAssetGroupCulture
// 0x0020 (0x0020 - 0x0000)
struct KismetInternationalizationLibrary_SetCurrentAssetGroupCulture final
{
public:
	class FName                                   AssetGroup;                                        // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Culture;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0018(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0019(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_SetCurrentAssetGroupCulture");
static_assert(sizeof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture) == 0x000020, "Wrong size on KismetInternationalizationLibrary_SetCurrentAssetGroupCulture");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture, AssetGroup) == 0x000000, "Member 'KismetInternationalizationLibrary_SetCurrentAssetGroupCulture::AssetGroup' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture, Culture) == 0x000008, "Member 'KismetInternationalizationLibrary_SetCurrentAssetGroupCulture::Culture' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture, SaveToConfig) == 0x000018, "Member 'KismetInternationalizationLibrary_SetCurrentAssetGroupCulture::SaveToConfig' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentAssetGroupCulture, ReturnValue) == 0x000019, "Member 'KismetInternationalizationLibrary_SetCurrentAssetGroupCulture::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.SetCurrentCulture
// 0x0018 (0x0018 - 0x0000)
struct KismetInternationalizationLibrary_SetCurrentCulture final
{
public:
	class FString                                 Culture;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_SetCurrentCulture) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_SetCurrentCulture");
static_assert(sizeof(KismetInternationalizationLibrary_SetCurrentCulture) == 0x000018, "Wrong size on KismetInternationalizationLibrary_SetCurrentCulture");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentCulture, Culture) == 0x000000, "Member 'KismetInternationalizationLibrary_SetCurrentCulture::Culture' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentCulture, SaveToConfig) == 0x000010, "Member 'KismetInternationalizationLibrary_SetCurrentCulture::SaveToConfig' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentCulture, ReturnValue) == 0x000011, "Member 'KismetInternationalizationLibrary_SetCurrentCulture::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguage
// 0x0018 (0x0018 - 0x0000)
struct KismetInternationalizationLibrary_SetCurrentLanguage final
{
public:
	class FString                                 Culture;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_SetCurrentLanguage) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_SetCurrentLanguage");
static_assert(sizeof(KismetInternationalizationLibrary_SetCurrentLanguage) == 0x000018, "Wrong size on KismetInternationalizationLibrary_SetCurrentLanguage");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguage, Culture) == 0x000000, "Member 'KismetInternationalizationLibrary_SetCurrentLanguage::Culture' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguage, SaveToConfig) == 0x000010, "Member 'KismetInternationalizationLibrary_SetCurrentLanguage::SaveToConfig' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguage, ReturnValue) == 0x000011, "Member 'KismetInternationalizationLibrary_SetCurrentLanguage::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.SetCurrentLanguageAndLocale
// 0x0018 (0x0018 - 0x0000)
struct KismetInternationalizationLibrary_SetCurrentLanguageAndLocale final
{
public:
	class FString                                 Culture;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_SetCurrentLanguageAndLocale) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_SetCurrentLanguageAndLocale");
static_assert(sizeof(KismetInternationalizationLibrary_SetCurrentLanguageAndLocale) == 0x000018, "Wrong size on KismetInternationalizationLibrary_SetCurrentLanguageAndLocale");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguageAndLocale, Culture) == 0x000000, "Member 'KismetInternationalizationLibrary_SetCurrentLanguageAndLocale::Culture' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguageAndLocale, SaveToConfig) == 0x000010, "Member 'KismetInternationalizationLibrary_SetCurrentLanguageAndLocale::SaveToConfig' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLanguageAndLocale, ReturnValue) == 0x000011, "Member 'KismetInternationalizationLibrary_SetCurrentLanguageAndLocale::ReturnValue' has a wrong offset!");

// Function Engine.KismetInternationalizationLibrary.SetCurrentLocale
// 0x0018 (0x0018 - 0x0000)
struct KismetInternationalizationLibrary_SetCurrentLocale final
{
public:
	class FString                                 Culture;                                           // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          SaveToConfig;                                      // 0x0010(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0011(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetInternationalizationLibrary_SetCurrentLocale) == 0x000008, "Wrong alignment on KismetInternationalizationLibrary_SetCurrentLocale");
static_assert(sizeof(KismetInternationalizationLibrary_SetCurrentLocale) == 0x000018, "Wrong size on KismetInternationalizationLibrary_SetCurrentLocale");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLocale, Culture) == 0x000000, "Member 'KismetInternationalizationLibrary_SetCurrentLocale::Culture' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLocale, SaveToConfig) == 0x000010, "Member 'KismetInternationalizationLibrary_SetCurrentLocale::SaveToConfig' has a wrong offset!");
static_assert(offsetof(KismetInternationalizationLibrary_SetCurrentLocale, ReturnValue) == 0x000011, "Member 'KismetInternationalizationLibrary_SetCurrentLocale::ReturnValue' has a wrong offset!");

// Function Engine.KismetMaterialLibrary.CreateDynamicMaterialInstance
// 0x0018 (0x0018 - 0x0000)
struct KismetMaterialLibrary_CreateDynamicMaterialInstance final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Parent;                                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstanceDynamic*               ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMaterialLibrary_CreateDynamicMaterialInstance) == 0x000008, "Wrong alignment on KismetMaterialLibrary_CreateDynamicMaterialInstance");
static_assert(sizeof(KismetMaterialLibrary_CreateDynamicMaterialInstance) == 0x000018, "Wrong size on KismetMaterialLibrary_CreateDynamicMaterialInstance");
static_assert(offsetof(KismetMaterialLibrary_CreateDynamicMaterialInstance, WorldContextObject) == 0x000000, "Member 'KismetMaterialLibrary_CreateDynamicMaterialInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_CreateDynamicMaterialInstance, Parent) == 0x000008, "Member 'KismetMaterialLibrary_CreateDynamicMaterialInstance::Parent' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_CreateDynamicMaterialInstance, ReturnValue) == 0x000010, "Member 'KismetMaterialLibrary_CreateDynamicMaterialInstance::ReturnValue' has a wrong offset!");

// Function Engine.KismetMaterialLibrary.GetScalarParameterValue
// 0x0020 (0x0020 - 0x0000)
struct KismetMaterialLibrary_GetScalarParameterValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMaterialLibrary_GetScalarParameterValue) == 0x000008, "Wrong alignment on KismetMaterialLibrary_GetScalarParameterValue");
static_assert(sizeof(KismetMaterialLibrary_GetScalarParameterValue) == 0x000020, "Wrong size on KismetMaterialLibrary_GetScalarParameterValue");
static_assert(offsetof(KismetMaterialLibrary_GetScalarParameterValue, WorldContextObject) == 0x000000, "Member 'KismetMaterialLibrary_GetScalarParameterValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetScalarParameterValue, Collection) == 0x000008, "Member 'KismetMaterialLibrary_GetScalarParameterValue::Collection' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetScalarParameterValue, ParameterName) == 0x000010, "Member 'KismetMaterialLibrary_GetScalarParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetScalarParameterValue, ReturnValue) == 0x000018, "Member 'KismetMaterialLibrary_GetScalarParameterValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMaterialLibrary.GetVectorParameterValue
// 0x0028 (0x0028 - 0x0000)
struct KismetMaterialLibrary_GetVectorParameterValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMaterialLibrary_GetVectorParameterValue) == 0x000008, "Wrong alignment on KismetMaterialLibrary_GetVectorParameterValue");
static_assert(sizeof(KismetMaterialLibrary_GetVectorParameterValue) == 0x000028, "Wrong size on KismetMaterialLibrary_GetVectorParameterValue");
static_assert(offsetof(KismetMaterialLibrary_GetVectorParameterValue, WorldContextObject) == 0x000000, "Member 'KismetMaterialLibrary_GetVectorParameterValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetVectorParameterValue, Collection) == 0x000008, "Member 'KismetMaterialLibrary_GetVectorParameterValue::Collection' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetVectorParameterValue, ParameterName) == 0x000010, "Member 'KismetMaterialLibrary_GetVectorParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_GetVectorParameterValue, ReturnValue) == 0x000018, "Member 'KismetMaterialLibrary_GetVectorParameterValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetMaterialLibrary.SetScalarParameterValue
// 0x0020 (0x0020 - 0x0000)
struct KismetMaterialLibrary_SetScalarParameterValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ParameterValue;                                    // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetMaterialLibrary_SetScalarParameterValue) == 0x000008, "Wrong alignment on KismetMaterialLibrary_SetScalarParameterValue");
static_assert(sizeof(KismetMaterialLibrary_SetScalarParameterValue) == 0x000020, "Wrong size on KismetMaterialLibrary_SetScalarParameterValue");
static_assert(offsetof(KismetMaterialLibrary_SetScalarParameterValue, WorldContextObject) == 0x000000, "Member 'KismetMaterialLibrary_SetScalarParameterValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetScalarParameterValue, Collection) == 0x000008, "Member 'KismetMaterialLibrary_SetScalarParameterValue::Collection' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetScalarParameterValue, ParameterName) == 0x000010, "Member 'KismetMaterialLibrary_SetScalarParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetScalarParameterValue, ParameterValue) == 0x000018, "Member 'KismetMaterialLibrary_SetScalarParameterValue::ParameterValue' has a wrong offset!");

// Function Engine.KismetMaterialLibrary.SetVectorParameterValue
// 0x0028 (0x0028 - 0x0000)
struct KismetMaterialLibrary_SetVectorParameterValue final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialParameterCollection*           Collection;                                        // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ParameterName;                                     // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ParameterValue;                                    // 0x0018(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetMaterialLibrary_SetVectorParameterValue) == 0x000008, "Wrong alignment on KismetMaterialLibrary_SetVectorParameterValue");
static_assert(sizeof(KismetMaterialLibrary_SetVectorParameterValue) == 0x000028, "Wrong size on KismetMaterialLibrary_SetVectorParameterValue");
static_assert(offsetof(KismetMaterialLibrary_SetVectorParameterValue, WorldContextObject) == 0x000000, "Member 'KismetMaterialLibrary_SetVectorParameterValue::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetVectorParameterValue, Collection) == 0x000008, "Member 'KismetMaterialLibrary_SetVectorParameterValue::Collection' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetVectorParameterValue, ParameterName) == 0x000010, "Member 'KismetMaterialLibrary_SetVectorParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(KismetMaterialLibrary_SetVectorParameterValue, ParameterValue) == 0x000018, "Member 'KismetMaterialLibrary_SetVectorParameterValue::ParameterValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.BitIsMarked
// 0x000C (0x000C - 0x0000)
struct KismetNodeHelperLibrary_BitIsMarked final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetNodeHelperLibrary_BitIsMarked) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_BitIsMarked");
static_assert(sizeof(KismetNodeHelperLibrary_BitIsMarked) == 0x00000C, "Wrong size on KismetNodeHelperLibrary_BitIsMarked");
static_assert(offsetof(KismetNodeHelperLibrary_BitIsMarked, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_BitIsMarked::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_BitIsMarked, Index_0) == 0x000004, "Member 'KismetNodeHelperLibrary_BitIsMarked::Index_0' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_BitIsMarked, ReturnValue) == 0x000008, "Member 'KismetNodeHelperLibrary_BitIsMarked::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.ClearAllBits
// 0x0004 (0x0004 - 0x0000)
struct KismetNodeHelperLibrary_ClearAllBits final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_ClearAllBits) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_ClearAllBits");
static_assert(sizeof(KismetNodeHelperLibrary_ClearAllBits) == 0x000004, "Wrong size on KismetNodeHelperLibrary_ClearAllBits");
static_assert(offsetof(KismetNodeHelperLibrary_ClearAllBits, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_ClearAllBits::Data' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.ClearBit
// 0x0008 (0x0008 - 0x0000)
struct KismetNodeHelperLibrary_ClearBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_ClearBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_ClearBit");
static_assert(sizeof(KismetNodeHelperLibrary_ClearBit) == 0x000008, "Wrong size on KismetNodeHelperLibrary_ClearBit");
static_assert(offsetof(KismetNodeHelperLibrary_ClearBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_ClearBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_ClearBit, Index_0) == 0x000004, "Member 'KismetNodeHelperLibrary_ClearBit::Index_0' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetEnumeratorName
// 0x0018 (0x0018 - 0x0000)
struct KismetNodeHelperLibrary_GetEnumeratorName final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnumeratorValue;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_GetEnumeratorName) == 0x000008, "Wrong alignment on KismetNodeHelperLibrary_GetEnumeratorName");
static_assert(sizeof(KismetNodeHelperLibrary_GetEnumeratorName) == 0x000018, "Wrong size on KismetNodeHelperLibrary_GetEnumeratorName");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorName, Enum) == 0x000000, "Member 'KismetNodeHelperLibrary_GetEnumeratorName::Enum' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorName, EnumeratorValue) == 0x000008, "Member 'KismetNodeHelperLibrary_GetEnumeratorName::EnumeratorValue' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorName, ReturnValue) == 0x000010, "Member 'KismetNodeHelperLibrary_GetEnumeratorName::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetEnumeratorUserFriendlyName
// 0x0020 (0x0020 - 0x0000)
struct KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnumeratorValue;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName) == 0x000008, "Wrong alignment on KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName");
static_assert(sizeof(KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName) == 0x000020, "Wrong size on KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName, Enum) == 0x000000, "Member 'KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName::Enum' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName, EnumeratorValue) == 0x000008, "Member 'KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName::EnumeratorValue' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName, ReturnValue) == 0x000010, "Member 'KismetNodeHelperLibrary_GetEnumeratorUserFriendlyName::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetEnumeratorValueFromIndex
// 0x0010 (0x0010 - 0x0000)
struct KismetNodeHelperLibrary_GetEnumeratorValueFromIndex final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnumeratorIndex;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetNodeHelperLibrary_GetEnumeratorValueFromIndex) == 0x000008, "Wrong alignment on KismetNodeHelperLibrary_GetEnumeratorValueFromIndex");
static_assert(sizeof(KismetNodeHelperLibrary_GetEnumeratorValueFromIndex) == 0x000010, "Wrong size on KismetNodeHelperLibrary_GetEnumeratorValueFromIndex");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorValueFromIndex, Enum) == 0x000000, "Member 'KismetNodeHelperLibrary_GetEnumeratorValueFromIndex::Enum' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorValueFromIndex, EnumeratorIndex) == 0x000008, "Member 'KismetNodeHelperLibrary_GetEnumeratorValueFromIndex::EnumeratorIndex' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetEnumeratorValueFromIndex, ReturnValue) == 0x000009, "Member 'KismetNodeHelperLibrary_GetEnumeratorValueFromIndex::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetFirstUnmarkedBit
// 0x0010 (0x0010 - 0x0000)
struct KismetNodeHelperLibrary_GetFirstUnmarkedBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIdx;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBits;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_GetFirstUnmarkedBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_GetFirstUnmarkedBit");
static_assert(sizeof(KismetNodeHelperLibrary_GetFirstUnmarkedBit) == 0x000010, "Wrong size on KismetNodeHelperLibrary_GetFirstUnmarkedBit");
static_assert(offsetof(KismetNodeHelperLibrary_GetFirstUnmarkedBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_GetFirstUnmarkedBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetFirstUnmarkedBit, StartIdx) == 0x000004, "Member 'KismetNodeHelperLibrary_GetFirstUnmarkedBit::StartIdx' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetFirstUnmarkedBit, NumBits) == 0x000008, "Member 'KismetNodeHelperLibrary_GetFirstUnmarkedBit::NumBits' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetFirstUnmarkedBit, ReturnValue) == 0x00000C, "Member 'KismetNodeHelperLibrary_GetFirstUnmarkedBit::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetRandomUnmarkedBit
// 0x0010 (0x0010 - 0x0000)
struct KismetNodeHelperLibrary_GetRandomUnmarkedBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIdx;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBits;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_GetRandomUnmarkedBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_GetRandomUnmarkedBit");
static_assert(sizeof(KismetNodeHelperLibrary_GetRandomUnmarkedBit) == 0x000010, "Wrong size on KismetNodeHelperLibrary_GetRandomUnmarkedBit");
static_assert(offsetof(KismetNodeHelperLibrary_GetRandomUnmarkedBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_GetRandomUnmarkedBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetRandomUnmarkedBit, StartIdx) == 0x000004, "Member 'KismetNodeHelperLibrary_GetRandomUnmarkedBit::StartIdx' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetRandomUnmarkedBit, NumBits) == 0x000008, "Member 'KismetNodeHelperLibrary_GetRandomUnmarkedBit::NumBits' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetRandomUnmarkedBit, ReturnValue) == 0x00000C, "Member 'KismetNodeHelperLibrary_GetRandomUnmarkedBit::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetUnmarkedBit
// 0x0014 (0x0014 - 0x0000)
struct KismetNodeHelperLibrary_GetUnmarkedBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIdx;                                          // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBits;                                           // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bRandom;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_GetUnmarkedBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_GetUnmarkedBit");
static_assert(sizeof(KismetNodeHelperLibrary_GetUnmarkedBit) == 0x000014, "Wrong size on KismetNodeHelperLibrary_GetUnmarkedBit");
static_assert(offsetof(KismetNodeHelperLibrary_GetUnmarkedBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_GetUnmarkedBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetUnmarkedBit, StartIdx) == 0x000004, "Member 'KismetNodeHelperLibrary_GetUnmarkedBit::StartIdx' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetUnmarkedBit, NumBits) == 0x000008, "Member 'KismetNodeHelperLibrary_GetUnmarkedBit::NumBits' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetUnmarkedBit, bRandom) == 0x00000C, "Member 'KismetNodeHelperLibrary_GetUnmarkedBit::bRandom' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetUnmarkedBit, ReturnValue) == 0x000010, "Member 'KismetNodeHelperLibrary_GetUnmarkedBit::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.GetValidValue
// 0x0010 (0x0010 - 0x0000)
struct KismetNodeHelperLibrary_GetValidValue final
{
public:
	const class UEnum*                            Enum;                                              // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         EnumeratorValue;                                   // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0009(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x6];                                        // 0x000A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetNodeHelperLibrary_GetValidValue) == 0x000008, "Wrong alignment on KismetNodeHelperLibrary_GetValidValue");
static_assert(sizeof(KismetNodeHelperLibrary_GetValidValue) == 0x000010, "Wrong size on KismetNodeHelperLibrary_GetValidValue");
static_assert(offsetof(KismetNodeHelperLibrary_GetValidValue, Enum) == 0x000000, "Member 'KismetNodeHelperLibrary_GetValidValue::Enum' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetValidValue, EnumeratorValue) == 0x000008, "Member 'KismetNodeHelperLibrary_GetValidValue::EnumeratorValue' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_GetValidValue, ReturnValue) == 0x000009, "Member 'KismetNodeHelperLibrary_GetValidValue::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.HasMarkedBit
// 0x000C (0x000C - 0x0000)
struct KismetNodeHelperLibrary_HasMarkedBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBits;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetNodeHelperLibrary_HasMarkedBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_HasMarkedBit");
static_assert(sizeof(KismetNodeHelperLibrary_HasMarkedBit) == 0x00000C, "Wrong size on KismetNodeHelperLibrary_HasMarkedBit");
static_assert(offsetof(KismetNodeHelperLibrary_HasMarkedBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_HasMarkedBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_HasMarkedBit, NumBits) == 0x000004, "Member 'KismetNodeHelperLibrary_HasMarkedBit::NumBits' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_HasMarkedBit, ReturnValue) == 0x000008, "Member 'KismetNodeHelperLibrary_HasMarkedBit::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.HasUnmarkedBit
// 0x000C (0x000C - 0x0000)
struct KismetNodeHelperLibrary_HasUnmarkedBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumBits;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetNodeHelperLibrary_HasUnmarkedBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_HasUnmarkedBit");
static_assert(sizeof(KismetNodeHelperLibrary_HasUnmarkedBit) == 0x00000C, "Wrong size on KismetNodeHelperLibrary_HasUnmarkedBit");
static_assert(offsetof(KismetNodeHelperLibrary_HasUnmarkedBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_HasUnmarkedBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_HasUnmarkedBit, NumBits) == 0x000004, "Member 'KismetNodeHelperLibrary_HasUnmarkedBit::NumBits' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_HasUnmarkedBit, ReturnValue) == 0x000008, "Member 'KismetNodeHelperLibrary_HasUnmarkedBit::ReturnValue' has a wrong offset!");

// Function Engine.KismetNodeHelperLibrary.MarkBit
// 0x0008 (0x0008 - 0x0000)
struct KismetNodeHelperLibrary_MarkBit final
{
public:
	int32                                         Data;                                              // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetNodeHelperLibrary_MarkBit) == 0x000004, "Wrong alignment on KismetNodeHelperLibrary_MarkBit");
static_assert(sizeof(KismetNodeHelperLibrary_MarkBit) == 0x000008, "Wrong size on KismetNodeHelperLibrary_MarkBit");
static_assert(offsetof(KismetNodeHelperLibrary_MarkBit, Data) == 0x000000, "Member 'KismetNodeHelperLibrary_MarkBit::Data' has a wrong offset!");
static_assert(offsetof(KismetNodeHelperLibrary_MarkBit, Index_0) == 0x000004, "Member 'KismetNodeHelperLibrary_MarkBit::Index_0' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.BeginDrawCanvasToRenderTarget
// 0x0030 (0x0030 - 0x0000)
struct KismetRenderingLibrary_BeginDrawCanvasToRenderTarget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCanvas*                                Canvas;                                            // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Size;                                              // 0x0018(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDrawToRenderTargetContext             Context;                                           // 0x0020(0x0010)(Parm, OutParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget) == 0x000008, "Wrong alignment on KismetRenderingLibrary_BeginDrawCanvasToRenderTarget");
static_assert(sizeof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget) == 0x000030, "Wrong size on KismetRenderingLibrary_BeginDrawCanvasToRenderTarget");
static_assert(offsetof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_BeginDrawCanvasToRenderTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget, TextureRenderTarget) == 0x000008, "Member 'KismetRenderingLibrary_BeginDrawCanvasToRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget, Canvas) == 0x000010, "Member 'KismetRenderingLibrary_BeginDrawCanvasToRenderTarget::Canvas' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget, Size) == 0x000018, "Member 'KismetRenderingLibrary_BeginDrawCanvasToRenderTarget::Size' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BeginDrawCanvasToRenderTarget, Context) == 0x000020, "Member 'KismetRenderingLibrary_BeginDrawCanvasToRenderTarget::Context' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.BreakSkinWeightInfo
// 0x0048 (0x0048 - 0x0000)
struct KismetRenderingLibrary_BreakSkinWeightInfo final
{
public:
	struct FSkelMeshSkinWeightInfo                InWeight;                                          // 0x0000(0x0028)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         Bone0;                                             // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight0;                                           // 0x002C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2D[0x3];                                       // 0x002D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone1;                                             // 0x0030(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight1;                                           // 0x0034(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone2;                                             // 0x0038(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight2;                                           // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone3;                                             // 0x0040(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight3;                                           // 0x0044(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetRenderingLibrary_BreakSkinWeightInfo) == 0x000004, "Wrong alignment on KismetRenderingLibrary_BreakSkinWeightInfo");
static_assert(sizeof(KismetRenderingLibrary_BreakSkinWeightInfo) == 0x000048, "Wrong size on KismetRenderingLibrary_BreakSkinWeightInfo");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, InWeight) == 0x000000, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::InWeight' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Bone0) == 0x000028, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Bone0' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Weight0) == 0x00002C, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Weight0' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Bone1) == 0x000030, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Bone1' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Weight1) == 0x000034, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Weight1' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Bone2) == 0x000038, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Bone2' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Weight2) == 0x00003C, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Weight2' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Bone3) == 0x000040, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Bone3' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_BreakSkinWeightInfo, Weight3) == 0x000044, "Member 'KismetRenderingLibrary_BreakSkinWeightInfo::Weight3' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.ClearRenderTarget2D
// 0x0020 (0x0020 - 0x0000)
struct KismetRenderingLibrary_ClearRenderTarget2D final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ClearColor;                                        // 0x0010(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_ClearRenderTarget2D) == 0x000008, "Wrong alignment on KismetRenderingLibrary_ClearRenderTarget2D");
static_assert(sizeof(KismetRenderingLibrary_ClearRenderTarget2D) == 0x000020, "Wrong size on KismetRenderingLibrary_ClearRenderTarget2D");
static_assert(offsetof(KismetRenderingLibrary_ClearRenderTarget2D, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_ClearRenderTarget2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ClearRenderTarget2D, TextureRenderTarget) == 0x000008, "Member 'KismetRenderingLibrary_ClearRenderTarget2D::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ClearRenderTarget2D, ClearColor) == 0x000010, "Member 'KismetRenderingLibrary_ClearRenderTarget2D::ClearColor' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.ConvertRenderTargetToTexture2DEditorOnly
// 0x0018 (0x0018 - 0x0000)
struct KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly) == 0x000008, "Wrong alignment on KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly");
static_assert(sizeof(KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly) == 0x000018, "Wrong size on KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly");
static_assert(offsetof(KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly, RenderTarget) == 0x000008, "Member 'KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly::RenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly, Texture) == 0x000010, "Member 'KismetRenderingLibrary_ConvertRenderTargetToTexture2DEditorOnly::Texture' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.CreateRenderTarget2D
// 0x0020 (0x0020 - 0x0000)
struct KismetRenderingLibrary_CreateRenderTarget2D final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Width;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureRenderTargetFormat                    Format;                                            // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UTextureRenderTarget2D*                 ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_CreateRenderTarget2D) == 0x000008, "Wrong alignment on KismetRenderingLibrary_CreateRenderTarget2D");
static_assert(sizeof(KismetRenderingLibrary_CreateRenderTarget2D) == 0x000020, "Wrong size on KismetRenderingLibrary_CreateRenderTarget2D");
static_assert(offsetof(KismetRenderingLibrary_CreateRenderTarget2D, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_CreateRenderTarget2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_CreateRenderTarget2D, Width) == 0x000008, "Member 'KismetRenderingLibrary_CreateRenderTarget2D::Width' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_CreateRenderTarget2D, Height) == 0x00000C, "Member 'KismetRenderingLibrary_CreateRenderTarget2D::Height' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_CreateRenderTarget2D, Format) == 0x000010, "Member 'KismetRenderingLibrary_CreateRenderTarget2D::Format' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_CreateRenderTarget2D, ReturnValue) == 0x000018, "Member 'KismetRenderingLibrary_CreateRenderTarget2D::ReturnValue' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.DrawMaterialToRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct KismetRenderingLibrary_DrawMaterialToRenderTarget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInterface*                     Material;                                          // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_DrawMaterialToRenderTarget) == 0x000008, "Wrong alignment on KismetRenderingLibrary_DrawMaterialToRenderTarget");
static_assert(sizeof(KismetRenderingLibrary_DrawMaterialToRenderTarget) == 0x000018, "Wrong size on KismetRenderingLibrary_DrawMaterialToRenderTarget");
static_assert(offsetof(KismetRenderingLibrary_DrawMaterialToRenderTarget, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_DrawMaterialToRenderTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_DrawMaterialToRenderTarget, TextureRenderTarget) == 0x000008, "Member 'KismetRenderingLibrary_DrawMaterialToRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_DrawMaterialToRenderTarget, Material) == 0x000010, "Member 'KismetRenderingLibrary_DrawMaterialToRenderTarget::Material' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.EndDrawCanvasToRenderTarget
// 0x0018 (0x0018 - 0x0000)
struct KismetRenderingLibrary_EndDrawCanvasToRenderTarget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDrawToRenderTargetContext             Context;                                           // 0x0008(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_EndDrawCanvasToRenderTarget) == 0x000008, "Wrong alignment on KismetRenderingLibrary_EndDrawCanvasToRenderTarget");
static_assert(sizeof(KismetRenderingLibrary_EndDrawCanvasToRenderTarget) == 0x000018, "Wrong size on KismetRenderingLibrary_EndDrawCanvasToRenderTarget");
static_assert(offsetof(KismetRenderingLibrary_EndDrawCanvasToRenderTarget, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_EndDrawCanvasToRenderTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_EndDrawCanvasToRenderTarget, Context) == 0x000008, "Member 'KismetRenderingLibrary_EndDrawCanvasToRenderTarget::Context' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.ExportRenderTarget
// 0x0030 (0x0030 - 0x0000)
struct KismetRenderingLibrary_ExportRenderTarget final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_ExportRenderTarget) == 0x000008, "Wrong alignment on KismetRenderingLibrary_ExportRenderTarget");
static_assert(sizeof(KismetRenderingLibrary_ExportRenderTarget) == 0x000030, "Wrong size on KismetRenderingLibrary_ExportRenderTarget");
static_assert(offsetof(KismetRenderingLibrary_ExportRenderTarget, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_ExportRenderTarget::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportRenderTarget, TextureRenderTarget) == 0x000008, "Member 'KismetRenderingLibrary_ExportRenderTarget::TextureRenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportRenderTarget, FilePath) == 0x000010, "Member 'KismetRenderingLibrary_ExportRenderTarget::FilePath' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportRenderTarget, Filename) == 0x000020, "Member 'KismetRenderingLibrary_ExportRenderTarget::Filename' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.ExportTexture2D
// 0x0030 (0x0030 - 0x0000)
struct KismetRenderingLibrary_ExportTexture2D final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture2D*                             Texture;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FilePath;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_ExportTexture2D) == 0x000008, "Wrong alignment on KismetRenderingLibrary_ExportTexture2D");
static_assert(sizeof(KismetRenderingLibrary_ExportTexture2D) == 0x000030, "Wrong size on KismetRenderingLibrary_ExportTexture2D");
static_assert(offsetof(KismetRenderingLibrary_ExportTexture2D, WorldContextObject) == 0x000000, "Member 'KismetRenderingLibrary_ExportTexture2D::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportTexture2D, Texture) == 0x000008, "Member 'KismetRenderingLibrary_ExportTexture2D::Texture' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportTexture2D, FilePath) == 0x000010, "Member 'KismetRenderingLibrary_ExportTexture2D::FilePath' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_ExportTexture2D, Filename) == 0x000020, "Member 'KismetRenderingLibrary_ExportTexture2D::Filename' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.MakeSkinWeightInfo
// 0x0048 (0x0048 - 0x0000)
struct KismetRenderingLibrary_MakeSkinWeightInfo final
{
public:
	int32                                         Bone0;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight0;                                           // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone1;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight1;                                           // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone2;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight2;                                           // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Bone3;                                             // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Weight3;                                           // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSkelMeshSkinWeightInfo                ReturnValue;                                       // 0x0020(0x0028)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_MakeSkinWeightInfo) == 0x000004, "Wrong alignment on KismetRenderingLibrary_MakeSkinWeightInfo");
static_assert(sizeof(KismetRenderingLibrary_MakeSkinWeightInfo) == 0x000048, "Wrong size on KismetRenderingLibrary_MakeSkinWeightInfo");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Bone0) == 0x000000, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Bone0' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Weight0) == 0x000004, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Weight0' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Bone1) == 0x000008, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Bone1' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Weight1) == 0x00000C, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Weight1' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Bone2) == 0x000010, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Bone2' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Weight2) == 0x000014, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Weight2' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Bone3) == 0x000018, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Bone3' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, Weight3) == 0x00001C, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::Weight3' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_MakeSkinWeightInfo, ReturnValue) == 0x000020, "Member 'KismetRenderingLibrary_MakeSkinWeightInfo::ReturnValue' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.ReleaseRenderTarget2D
// 0x0008 (0x0008 - 0x0000)
struct KismetRenderingLibrary_ReleaseRenderTarget2D final
{
public:
	class UTextureRenderTarget2D*                 TextureRenderTarget;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_ReleaseRenderTarget2D) == 0x000008, "Wrong alignment on KismetRenderingLibrary_ReleaseRenderTarget2D");
static_assert(sizeof(KismetRenderingLibrary_ReleaseRenderTarget2D) == 0x000008, "Wrong size on KismetRenderingLibrary_ReleaseRenderTarget2D");
static_assert(offsetof(KismetRenderingLibrary_ReleaseRenderTarget2D, TextureRenderTarget) == 0x000000, "Member 'KismetRenderingLibrary_ReleaseRenderTarget2D::TextureRenderTarget' has a wrong offset!");

// Function Engine.KismetRenderingLibrary.RenderTargetCreateStaticTexture2DEditorOnly
// 0x0028 (0x0028 - 0x0000)
struct KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly final
{
public:
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name_0;                                            // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureCompressionSettings                   CompressionSettings;                               // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETextureMipGenSettings                        MipSettings;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UTexture2D*                             ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly) == 0x000008, "Wrong alignment on KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly");
static_assert(sizeof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly) == 0x000028, "Wrong size on KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly");
static_assert(offsetof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly, RenderTarget) == 0x000000, "Member 'KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly::RenderTarget' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly, Name_0) == 0x000008, "Member 'KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly::Name_0' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly, CompressionSettings) == 0x000018, "Member 'KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly::CompressionSettings' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly, MipSettings) == 0x000019, "Member 'KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly::MipSettings' has a wrong offset!");
static_assert(offsetof(KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly, ReturnValue) == 0x000020, "Member 'KismetRenderingLibrary_RenderTargetCreateStaticTexture2DEditorOnly::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Bool
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Bool final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          InBool;                                            // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Bool) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Bool");
static_assert(sizeof(KismetStringLibrary_BuildString_Bool) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Bool");
static_assert(offsetof(KismetStringLibrary_BuildString_Bool, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Bool::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Bool, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Bool::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Bool, InBool) == 0x000020, "Member 'KismetStringLibrary_BuildString_Bool::InBool' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Bool, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Bool::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Bool, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Bool::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Color
// 0x0050 (0x0050 - 0x0000)
struct KismetStringLibrary_BuildString_Color final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           InColor;                                           // 0x0020(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Suffix;                                            // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Color) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Color");
static_assert(sizeof(KismetStringLibrary_BuildString_Color) == 0x000050, "Wrong size on KismetStringLibrary_BuildString_Color");
static_assert(offsetof(KismetStringLibrary_BuildString_Color, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Color::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Color, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Color::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Color, InColor) == 0x000020, "Member 'KismetStringLibrary_BuildString_Color::InColor' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Color, Suffix) == 0x000030, "Member 'KismetStringLibrary_BuildString_Color::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Color, ReturnValue) == 0x000040, "Member 'KismetStringLibrary_BuildString_Color::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Float
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Float final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InFloat;                                           // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Float) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Float");
static_assert(sizeof(KismetStringLibrary_BuildString_Float) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Float");
static_assert(offsetof(KismetStringLibrary_BuildString_Float, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Float::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Float, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Float::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Float, InFloat) == 0x000020, "Member 'KismetStringLibrary_BuildString_Float::InFloat' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Float, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Float::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Float, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Float::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Int
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Int final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         InInt;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Int) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Int");
static_assert(sizeof(KismetStringLibrary_BuildString_Int) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Int");
static_assert(offsetof(KismetStringLibrary_BuildString_Int, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Int::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Int, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Int::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Int, InInt) == 0x000020, "Member 'KismetStringLibrary_BuildString_Int::InInt' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Int, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Int::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Int, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Int::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_IntVector
// 0x0050 (0x0050 - 0x0000)
struct KismetStringLibrary_BuildString_IntVector final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             InIntVector;                                       // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_IntVector) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_IntVector");
static_assert(sizeof(KismetStringLibrary_BuildString_IntVector) == 0x000050, "Wrong size on KismetStringLibrary_BuildString_IntVector");
static_assert(offsetof(KismetStringLibrary_BuildString_IntVector, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_IntVector::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_IntVector, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_IntVector::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_IntVector, InIntVector) == 0x000020, "Member 'KismetStringLibrary_BuildString_IntVector::InIntVector' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_IntVector, Suffix) == 0x000030, "Member 'KismetStringLibrary_BuildString_IntVector::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_IntVector, ReturnValue) == 0x000040, "Member 'KismetStringLibrary_BuildString_IntVector::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Name
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Name final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   InName;                                            // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Name) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Name");
static_assert(sizeof(KismetStringLibrary_BuildString_Name) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Name");
static_assert(offsetof(KismetStringLibrary_BuildString_Name, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Name::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Name, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Name::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Name, InName) == 0x000020, "Member 'KismetStringLibrary_BuildString_Name::InName' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Name, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Name::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Name, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Name::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Object
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Object final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                InObj;                                             // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Object) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Object");
static_assert(sizeof(KismetStringLibrary_BuildString_Object) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Object");
static_assert(offsetof(KismetStringLibrary_BuildString_Object, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Object::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Object, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Object::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Object, InObj) == 0x000020, "Member 'KismetStringLibrary_BuildString_Object::InObj' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Object, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Object::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Object, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Object::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Rotator
// 0x0050 (0x0050 - 0x0000)
struct KismetStringLibrary_BuildString_Rotator final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRot;                                             // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Rotator) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Rotator");
static_assert(sizeof(KismetStringLibrary_BuildString_Rotator) == 0x000050, "Wrong size on KismetStringLibrary_BuildString_Rotator");
static_assert(offsetof(KismetStringLibrary_BuildString_Rotator, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Rotator::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Rotator, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Rotator::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Rotator, InRot) == 0x000020, "Member 'KismetStringLibrary_BuildString_Rotator::InRot' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Rotator, Suffix) == 0x000030, "Member 'KismetStringLibrary_BuildString_Rotator::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Rotator, ReturnValue) == 0x000040, "Member 'KismetStringLibrary_BuildString_Rotator::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Vector
// 0x0050 (0x0050 - 0x0000)
struct KismetStringLibrary_BuildString_Vector final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InVector;                                          // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Suffix;                                            // 0x0030(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Vector) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Vector");
static_assert(sizeof(KismetStringLibrary_BuildString_Vector) == 0x000050, "Wrong size on KismetStringLibrary_BuildString_Vector");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Vector::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Vector::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector, InVector) == 0x000020, "Member 'KismetStringLibrary_BuildString_Vector::InVector' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector, Suffix) == 0x000030, "Member 'KismetStringLibrary_BuildString_Vector::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector, ReturnValue) == 0x000040, "Member 'KismetStringLibrary_BuildString_Vector::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.BuildString_Vector2d
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_BuildString_Vector2d final
{
public:
	class FString                                 AppendTo;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Prefix;                                            // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              InVector2D;                                        // 0x0020(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Suffix;                                            // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_BuildString_Vector2d) == 0x000008, "Wrong alignment on KismetStringLibrary_BuildString_Vector2d");
static_assert(sizeof(KismetStringLibrary_BuildString_Vector2d) == 0x000048, "Wrong size on KismetStringLibrary_BuildString_Vector2d");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector2d, AppendTo) == 0x000000, "Member 'KismetStringLibrary_BuildString_Vector2d::AppendTo' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector2d, Prefix) == 0x000010, "Member 'KismetStringLibrary_BuildString_Vector2d::Prefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector2d, InVector2D) == 0x000020, "Member 'KismetStringLibrary_BuildString_Vector2d::InVector2D' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector2d, Suffix) == 0x000028, "Member 'KismetStringLibrary_BuildString_Vector2d::Suffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_BuildString_Vector2d, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_BuildString_Vector2d::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Concat_StrStr
// 0x0030 (0x0030 - 0x0000)
struct KismetStringLibrary_Concat_StrStr final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Concat_StrStr) == 0x000008, "Wrong alignment on KismetStringLibrary_Concat_StrStr");
static_assert(sizeof(KismetStringLibrary_Concat_StrStr) == 0x000030, "Wrong size on KismetStringLibrary_Concat_StrStr");
static_assert(offsetof(KismetStringLibrary_Concat_StrStr, A) == 0x000000, "Member 'KismetStringLibrary_Concat_StrStr::A' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Concat_StrStr, B) == 0x000010, "Member 'KismetStringLibrary_Concat_StrStr::B' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Concat_StrStr, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_Concat_StrStr::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Contains
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_Contains final
{
public:
	class FString                                 SearchIn;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Substring;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCase;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSearchFromEnd;                                    // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0022(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_23[0x5];                                       // 0x0023(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Contains) == 0x000008, "Wrong alignment on KismetStringLibrary_Contains");
static_assert(sizeof(KismetStringLibrary_Contains) == 0x000028, "Wrong size on KismetStringLibrary_Contains");
static_assert(offsetof(KismetStringLibrary_Contains, SearchIn) == 0x000000, "Member 'KismetStringLibrary_Contains::SearchIn' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Contains, Substring) == 0x000010, "Member 'KismetStringLibrary_Contains::Substring' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Contains, bUseCase) == 0x000020, "Member 'KismetStringLibrary_Contains::bUseCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Contains, bSearchFromEnd) == 0x000021, "Member 'KismetStringLibrary_Contains::bSearchFromEnd' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Contains, ReturnValue) == 0x000022, "Member 'KismetStringLibrary_Contains::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_BoolToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_BoolToString final
{
public:
	bool                                          InBool;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_BoolToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_BoolToString");
static_assert(sizeof(KismetStringLibrary_Conv_BoolToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_BoolToString");
static_assert(offsetof(KismetStringLibrary_Conv_BoolToString, InBool) == 0x000000, "Member 'KismetStringLibrary_Conv_BoolToString::InBool' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_BoolToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_BoolToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_ByteToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_ByteToString final
{
public:
	uint8                                         InByte;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_ByteToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_ByteToString");
static_assert(sizeof(KismetStringLibrary_Conv_ByteToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_ByteToString");
static_assert(offsetof(KismetStringLibrary_Conv_ByteToString, InByte) == 0x000000, "Member 'KismetStringLibrary_Conv_ByteToString::InByte' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_ByteToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_ByteToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_ColorToString
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_ColorToString final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_ColorToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_ColorToString");
static_assert(sizeof(KismetStringLibrary_Conv_ColorToString) == 0x000020, "Wrong size on KismetStringLibrary_Conv_ColorToString");
static_assert(offsetof(KismetStringLibrary_Conv_ColorToString, InColor) == 0x000000, "Member 'KismetStringLibrary_Conv_ColorToString::InColor' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_ColorToString, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_ColorToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_FloatToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_FloatToString final
{
public:
	float                                         InFloat;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_FloatToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_FloatToString");
static_assert(sizeof(KismetStringLibrary_Conv_FloatToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_FloatToString");
static_assert(offsetof(KismetStringLibrary_Conv_FloatToString, InFloat) == 0x000000, "Member 'KismetStringLibrary_Conv_FloatToString::InFloat' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_FloatToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_FloatToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_IntToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_IntToString final
{
public:
	int32                                         InInt;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_IntToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_IntToString");
static_assert(sizeof(KismetStringLibrary_Conv_IntToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_IntToString");
static_assert(offsetof(KismetStringLibrary_Conv_IntToString, InInt) == 0x000000, "Member 'KismetStringLibrary_Conv_IntToString::InInt' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_IntToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_IntToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_IntVectorToString
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_IntVectorToString final
{
public:
	struct FIntVector                             InIntVec;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_IntVectorToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_IntVectorToString");
static_assert(sizeof(KismetStringLibrary_Conv_IntVectorToString) == 0x000020, "Wrong size on KismetStringLibrary_Conv_IntVectorToString");
static_assert(offsetof(KismetStringLibrary_Conv_IntVectorToString, InIntVec) == 0x000000, "Member 'KismetStringLibrary_Conv_IntVectorToString::InIntVec' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_IntVectorToString, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_IntVectorToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_NameToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_NameToString final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_NameToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_NameToString");
static_assert(sizeof(KismetStringLibrary_Conv_NameToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_NameToString");
static_assert(offsetof(KismetStringLibrary_Conv_NameToString, InName) == 0x000000, "Member 'KismetStringLibrary_Conv_NameToString::InName' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_NameToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_NameToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_ObjectToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_ObjectToString final
{
public:
	class UObject*                                InObj;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_ObjectToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_ObjectToString");
static_assert(sizeof(KismetStringLibrary_Conv_ObjectToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_ObjectToString");
static_assert(offsetof(KismetStringLibrary_Conv_ObjectToString, InObj) == 0x000000, "Member 'KismetStringLibrary_Conv_ObjectToString::InObj' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_ObjectToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_ObjectToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_RotatorToString
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_RotatorToString final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_RotatorToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_RotatorToString");
static_assert(sizeof(KismetStringLibrary_Conv_RotatorToString) == 0x000020, "Wrong size on KismetStringLibrary_Conv_RotatorToString");
static_assert(offsetof(KismetStringLibrary_Conv_RotatorToString, InRot) == 0x000000, "Member 'KismetStringLibrary_Conv_RotatorToString::InRot' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_RotatorToString, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_RotatorToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToColor
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_Conv_StringToColor final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           OutConvertedColor;                                 // 0x0010(0x0010)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutIsValid;                                        // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToColor) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToColor");
static_assert(sizeof(KismetStringLibrary_Conv_StringToColor) == 0x000028, "Wrong size on KismetStringLibrary_Conv_StringToColor");
static_assert(offsetof(KismetStringLibrary_Conv_StringToColor, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToColor::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToColor, OutConvertedColor) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToColor::OutConvertedColor' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToColor, OutIsValid) == 0x000020, "Member 'KismetStringLibrary_Conv_StringToColor::OutIsValid' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToFloat
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_StringToFloat final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToFloat) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToFloat");
static_assert(sizeof(KismetStringLibrary_Conv_StringToFloat) == 0x000018, "Wrong size on KismetStringLibrary_Conv_StringToFloat");
static_assert(offsetof(KismetStringLibrary_Conv_StringToFloat, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToFloat::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToFloat, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToInt
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_StringToInt final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToInt) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToInt");
static_assert(sizeof(KismetStringLibrary_Conv_StringToInt) == 0x000018, "Wrong size on KismetStringLibrary_Conv_StringToInt");
static_assert(offsetof(KismetStringLibrary_Conv_StringToInt, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToInt::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToInt, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToName
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_StringToName final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_StringToName) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToName");
static_assert(sizeof(KismetStringLibrary_Conv_StringToName) == 0x000018, "Wrong size on KismetStringLibrary_Conv_StringToName");
static_assert(offsetof(KismetStringLibrary_Conv_StringToName, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToName::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToName, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToName::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToRotator
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_StringToRotator final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               OutConvertedRotator;                               // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          OutIsValid;                                        // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToRotator) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToRotator");
static_assert(sizeof(KismetStringLibrary_Conv_StringToRotator) == 0x000020, "Wrong size on KismetStringLibrary_Conv_StringToRotator");
static_assert(offsetof(KismetStringLibrary_Conv_StringToRotator, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToRotator::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToRotator, OutConvertedRotator) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToRotator::OutConvertedRotator' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToRotator, OutIsValid) == 0x00001C, "Member 'KismetStringLibrary_Conv_StringToRotator::OutIsValid' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToVector
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_StringToVector final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                OutConvertedVector;                                // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutIsValid;                                        // 0x001C(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToVector) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToVector");
static_assert(sizeof(KismetStringLibrary_Conv_StringToVector) == 0x000020, "Wrong size on KismetStringLibrary_Conv_StringToVector");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToVector::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector, OutConvertedVector) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToVector::OutConvertedVector' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector, OutIsValid) == 0x00001C, "Member 'KismetStringLibrary_Conv_StringToVector::OutIsValid' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_StringToVector2D
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_StringToVector2D final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              OutConvertedVector2D;                              // 0x0010(0x0008)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          OutIsValid;                                        // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Conv_StringToVector2D) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_StringToVector2D");
static_assert(sizeof(KismetStringLibrary_Conv_StringToVector2D) == 0x000020, "Wrong size on KismetStringLibrary_Conv_StringToVector2D");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector2D, InString) == 0x000000, "Member 'KismetStringLibrary_Conv_StringToVector2D::InString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector2D, OutConvertedVector2D) == 0x000010, "Member 'KismetStringLibrary_Conv_StringToVector2D::OutConvertedVector2D' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_StringToVector2D, OutIsValid) == 0x000018, "Member 'KismetStringLibrary_Conv_StringToVector2D::OutIsValid' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_TransformToString
// 0x0040 (0x0040 - 0x0000)
struct KismetStringLibrary_Conv_TransformToString final
{
public:
	struct FTransform                             InTrans;                                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_TransformToString) == 0x000010, "Wrong alignment on KismetStringLibrary_Conv_TransformToString");
static_assert(sizeof(KismetStringLibrary_Conv_TransformToString) == 0x000040, "Wrong size on KismetStringLibrary_Conv_TransformToString");
static_assert(offsetof(KismetStringLibrary_Conv_TransformToString, InTrans) == 0x000000, "Member 'KismetStringLibrary_Conv_TransformToString::InTrans' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_TransformToString, ReturnValue) == 0x000030, "Member 'KismetStringLibrary_Conv_TransformToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_Vector2dToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Conv_Vector2dToString final
{
public:
	struct FVector2D                              InVec;                                             // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_Vector2dToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_Vector2dToString");
static_assert(sizeof(KismetStringLibrary_Conv_Vector2dToString) == 0x000018, "Wrong size on KismetStringLibrary_Conv_Vector2dToString");
static_assert(offsetof(KismetStringLibrary_Conv_Vector2dToString, InVec) == 0x000000, "Member 'KismetStringLibrary_Conv_Vector2dToString::InVec' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_Vector2dToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_Conv_Vector2dToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Conv_VectorToString
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Conv_VectorToString final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Conv_VectorToString) == 0x000008, "Wrong alignment on KismetStringLibrary_Conv_VectorToString");
static_assert(sizeof(KismetStringLibrary_Conv_VectorToString) == 0x000020, "Wrong size on KismetStringLibrary_Conv_VectorToString");
static_assert(offsetof(KismetStringLibrary_Conv_VectorToString, InVec) == 0x000000, "Member 'KismetStringLibrary_Conv_VectorToString::InVec' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Conv_VectorToString, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Conv_VectorToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.CullArray
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_CullArray final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         InArray;                                           // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_CullArray) == 0x000008, "Wrong alignment on KismetStringLibrary_CullArray");
static_assert(sizeof(KismetStringLibrary_CullArray) == 0x000028, "Wrong size on KismetStringLibrary_CullArray");
static_assert(offsetof(KismetStringLibrary_CullArray, SourceString) == 0x000000, "Member 'KismetStringLibrary_CullArray::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_CullArray, InArray) == 0x000010, "Member 'KismetStringLibrary_CullArray::InArray' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_CullArray, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_CullArray::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.EndsWith
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_EndsWith final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InSuffix;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_EndsWith) == 0x000008, "Wrong alignment on KismetStringLibrary_EndsWith");
static_assert(sizeof(KismetStringLibrary_EndsWith) == 0x000028, "Wrong size on KismetStringLibrary_EndsWith");
static_assert(offsetof(KismetStringLibrary_EndsWith, SourceString) == 0x000000, "Member 'KismetStringLibrary_EndsWith::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EndsWith, InSuffix) == 0x000010, "Member 'KismetStringLibrary_EndsWith::InSuffix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EndsWith, SearchCase) == 0x000020, "Member 'KismetStringLibrary_EndsWith::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EndsWith, ReturnValue) == 0x000021, "Member 'KismetStringLibrary_EndsWith::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.EqualEqual_StriStri
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_EqualEqual_StriStri final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_EqualEqual_StriStri) == 0x000008, "Wrong alignment on KismetStringLibrary_EqualEqual_StriStri");
static_assert(sizeof(KismetStringLibrary_EqualEqual_StriStri) == 0x000028, "Wrong size on KismetStringLibrary_EqualEqual_StriStri");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StriStri, A) == 0x000000, "Member 'KismetStringLibrary_EqualEqual_StriStri::A' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StriStri, B) == 0x000010, "Member 'KismetStringLibrary_EqualEqual_StriStri::B' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StriStri, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_EqualEqual_StriStri::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.EqualEqual_StrStr
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_EqualEqual_StrStr final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_EqualEqual_StrStr) == 0x000008, "Wrong alignment on KismetStringLibrary_EqualEqual_StrStr");
static_assert(sizeof(KismetStringLibrary_EqualEqual_StrStr) == 0x000028, "Wrong size on KismetStringLibrary_EqualEqual_StrStr");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StrStr, A) == 0x000000, "Member 'KismetStringLibrary_EqualEqual_StrStr::A' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StrStr, B) == 0x000010, "Member 'KismetStringLibrary_EqualEqual_StrStr::B' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_EqualEqual_StrStr, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_EqualEqual_StrStr::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.FindSubstring
// 0x0030 (0x0030 - 0x0000)
struct KismetStringLibrary_FindSubstring final
{
public:
	class FString                                 SearchIn;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Substring;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseCase;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSearchFromEnd;                                    // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         StartPosition;                                     // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0028(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_FindSubstring) == 0x000008, "Wrong alignment on KismetStringLibrary_FindSubstring");
static_assert(sizeof(KismetStringLibrary_FindSubstring) == 0x000030, "Wrong size on KismetStringLibrary_FindSubstring");
static_assert(offsetof(KismetStringLibrary_FindSubstring, SearchIn) == 0x000000, "Member 'KismetStringLibrary_FindSubstring::SearchIn' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_FindSubstring, Substring) == 0x000010, "Member 'KismetStringLibrary_FindSubstring::Substring' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_FindSubstring, bUseCase) == 0x000020, "Member 'KismetStringLibrary_FindSubstring::bUseCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_FindSubstring, bSearchFromEnd) == 0x000021, "Member 'KismetStringLibrary_FindSubstring::bSearchFromEnd' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_FindSubstring, StartPosition) == 0x000024, "Member 'KismetStringLibrary_FindSubstring::StartPosition' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_FindSubstring, ReturnValue) == 0x000028, "Member 'KismetStringLibrary_FindSubstring::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.GetCharacterArrayFromString
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_GetCharacterArrayFromString final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_GetCharacterArrayFromString) == 0x000008, "Wrong alignment on KismetStringLibrary_GetCharacterArrayFromString");
static_assert(sizeof(KismetStringLibrary_GetCharacterArrayFromString) == 0x000020, "Wrong size on KismetStringLibrary_GetCharacterArrayFromString");
static_assert(offsetof(KismetStringLibrary_GetCharacterArrayFromString, SourceString) == 0x000000, "Member 'KismetStringLibrary_GetCharacterArrayFromString::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetCharacterArrayFromString, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_GetCharacterArrayFromString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.GetCharacterAsNumber
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_GetCharacterAsNumber final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0014(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_GetCharacterAsNumber) == 0x000008, "Wrong alignment on KismetStringLibrary_GetCharacterAsNumber");
static_assert(sizeof(KismetStringLibrary_GetCharacterAsNumber) == 0x000018, "Wrong size on KismetStringLibrary_GetCharacterAsNumber");
static_assert(offsetof(KismetStringLibrary_GetCharacterAsNumber, SourceString) == 0x000000, "Member 'KismetStringLibrary_GetCharacterAsNumber::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetCharacterAsNumber, Index_0) == 0x000010, "Member 'KismetStringLibrary_GetCharacterAsNumber::Index_0' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetCharacterAsNumber, ReturnValue) == 0x000014, "Member 'KismetStringLibrary_GetCharacterAsNumber::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.GetSubstring
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_GetSubstring final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StartIndex;                                        // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Length;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_GetSubstring) == 0x000008, "Wrong alignment on KismetStringLibrary_GetSubstring");
static_assert(sizeof(KismetStringLibrary_GetSubstring) == 0x000028, "Wrong size on KismetStringLibrary_GetSubstring");
static_assert(offsetof(KismetStringLibrary_GetSubstring, SourceString) == 0x000000, "Member 'KismetStringLibrary_GetSubstring::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetSubstring, StartIndex) == 0x000010, "Member 'KismetStringLibrary_GetSubstring::StartIndex' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetSubstring, Length) == 0x000014, "Member 'KismetStringLibrary_GetSubstring::Length' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_GetSubstring, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_GetSubstring::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.IsNumeric
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_IsNumeric final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_IsNumeric) == 0x000008, "Wrong alignment on KismetStringLibrary_IsNumeric");
static_assert(sizeof(KismetStringLibrary_IsNumeric) == 0x000018, "Wrong size on KismetStringLibrary_IsNumeric");
static_assert(offsetof(KismetStringLibrary_IsNumeric, SourceString) == 0x000000, "Member 'KismetStringLibrary_IsNumeric::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_IsNumeric, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_IsNumeric::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.JoinStringArray
// 0x0030 (0x0030 - 0x0000)
struct KismetStringLibrary_JoinStringArray final
{
public:
	TArray<class FString>                         SourceArray;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 Separator;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_JoinStringArray) == 0x000008, "Wrong alignment on KismetStringLibrary_JoinStringArray");
static_assert(sizeof(KismetStringLibrary_JoinStringArray) == 0x000030, "Wrong size on KismetStringLibrary_JoinStringArray");
static_assert(offsetof(KismetStringLibrary_JoinStringArray, SourceArray) == 0x000000, "Member 'KismetStringLibrary_JoinStringArray::SourceArray' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_JoinStringArray, Separator) == 0x000010, "Member 'KismetStringLibrary_JoinStringArray::Separator' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_JoinStringArray, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_JoinStringArray::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Left
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_Left final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Left) == 0x000008, "Wrong alignment on KismetStringLibrary_Left");
static_assert(sizeof(KismetStringLibrary_Left) == 0x000028, "Wrong size on KismetStringLibrary_Left");
static_assert(offsetof(KismetStringLibrary_Left, SourceString) == 0x000000, "Member 'KismetStringLibrary_Left::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Left, Count) == 0x000010, "Member 'KismetStringLibrary_Left::Count' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Left, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_Left::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.LeftChop
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_LeftChop final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_LeftChop) == 0x000008, "Wrong alignment on KismetStringLibrary_LeftChop");
static_assert(sizeof(KismetStringLibrary_LeftChop) == 0x000028, "Wrong size on KismetStringLibrary_LeftChop");
static_assert(offsetof(KismetStringLibrary_LeftChop, SourceString) == 0x000000, "Member 'KismetStringLibrary_LeftChop::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_LeftChop, Count) == 0x000010, "Member 'KismetStringLibrary_LeftChop::Count' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_LeftChop, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_LeftChop::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.LeftPad
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_LeftPad final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChCount;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_LeftPad) == 0x000008, "Wrong alignment on KismetStringLibrary_LeftPad");
static_assert(sizeof(KismetStringLibrary_LeftPad) == 0x000028, "Wrong size on KismetStringLibrary_LeftPad");
static_assert(offsetof(KismetStringLibrary_LeftPad, SourceString) == 0x000000, "Member 'KismetStringLibrary_LeftPad::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_LeftPad, ChCount) == 0x000010, "Member 'KismetStringLibrary_LeftPad::ChCount' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_LeftPad, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_LeftPad::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Len
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_Len final
{
public:
	class FString                                 S;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Len) == 0x000008, "Wrong alignment on KismetStringLibrary_Len");
static_assert(sizeof(KismetStringLibrary_Len) == 0x000018, "Wrong size on KismetStringLibrary_Len");
static_assert(offsetof(KismetStringLibrary_Len, S) == 0x000000, "Member 'KismetStringLibrary_Len::S' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Len, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Len::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.MatchesWildcard
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_MatchesWildcard final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Wildcard;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_MatchesWildcard) == 0x000008, "Wrong alignment on KismetStringLibrary_MatchesWildcard");
static_assert(sizeof(KismetStringLibrary_MatchesWildcard) == 0x000028, "Wrong size on KismetStringLibrary_MatchesWildcard");
static_assert(offsetof(KismetStringLibrary_MatchesWildcard, SourceString) == 0x000000, "Member 'KismetStringLibrary_MatchesWildcard::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_MatchesWildcard, Wildcard) == 0x000010, "Member 'KismetStringLibrary_MatchesWildcard::Wildcard' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_MatchesWildcard, SearchCase) == 0x000020, "Member 'KismetStringLibrary_MatchesWildcard::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_MatchesWildcard, ReturnValue) == 0x000021, "Member 'KismetStringLibrary_MatchesWildcard::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Mid
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_Mid final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Start;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Mid) == 0x000008, "Wrong alignment on KismetStringLibrary_Mid");
static_assert(sizeof(KismetStringLibrary_Mid) == 0x000028, "Wrong size on KismetStringLibrary_Mid");
static_assert(offsetof(KismetStringLibrary_Mid, SourceString) == 0x000000, "Member 'KismetStringLibrary_Mid::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Mid, Start) == 0x000010, "Member 'KismetStringLibrary_Mid::Start' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Mid, Count) == 0x000014, "Member 'KismetStringLibrary_Mid::Count' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Mid, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_Mid::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.NotEqual_StriStri
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_NotEqual_StriStri final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_NotEqual_StriStri) == 0x000008, "Wrong alignment on KismetStringLibrary_NotEqual_StriStri");
static_assert(sizeof(KismetStringLibrary_NotEqual_StriStri) == 0x000028, "Wrong size on KismetStringLibrary_NotEqual_StriStri");
static_assert(offsetof(KismetStringLibrary_NotEqual_StriStri, A) == 0x000000, "Member 'KismetStringLibrary_NotEqual_StriStri::A' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_NotEqual_StriStri, B) == 0x000010, "Member 'KismetStringLibrary_NotEqual_StriStri::B' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_NotEqual_StriStri, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_NotEqual_StriStri::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.NotEqual_StrStr
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_NotEqual_StrStr final
{
public:
	class FString                                 A;                                                 // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 B;                                                 // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_NotEqual_StrStr) == 0x000008, "Wrong alignment on KismetStringLibrary_NotEqual_StrStr");
static_assert(sizeof(KismetStringLibrary_NotEqual_StrStr) == 0x000028, "Wrong size on KismetStringLibrary_NotEqual_StrStr");
static_assert(offsetof(KismetStringLibrary_NotEqual_StrStr, A) == 0x000000, "Member 'KismetStringLibrary_NotEqual_StrStr::A' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_NotEqual_StrStr, B) == 0x000010, "Member 'KismetStringLibrary_NotEqual_StrStr::B' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_NotEqual_StrStr, ReturnValue) == 0x000020, "Member 'KismetStringLibrary_NotEqual_StrStr::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.ParseIntoArray
// 0x0038 (0x0038 - 0x0000)
struct KismetStringLibrary_ParseIntoArray final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Delimiter;                                         // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          CullEmptyStrings;                                  // 0x0020(0x0001)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         ReturnValue;                                       // 0x0028(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_ParseIntoArray) == 0x000008, "Wrong alignment on KismetStringLibrary_ParseIntoArray");
static_assert(sizeof(KismetStringLibrary_ParseIntoArray) == 0x000038, "Wrong size on KismetStringLibrary_ParseIntoArray");
static_assert(offsetof(KismetStringLibrary_ParseIntoArray, SourceString) == 0x000000, "Member 'KismetStringLibrary_ParseIntoArray::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ParseIntoArray, Delimiter) == 0x000010, "Member 'KismetStringLibrary_ParseIntoArray::Delimiter' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ParseIntoArray, CullEmptyStrings) == 0x000020, "Member 'KismetStringLibrary_ParseIntoArray::CullEmptyStrings' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ParseIntoArray, ReturnValue) == 0x000028, "Member 'KismetStringLibrary_ParseIntoArray::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Replace
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_Replace final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 From;                                              // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 To;                                                // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Replace) == 0x000008, "Wrong alignment on KismetStringLibrary_Replace");
static_assert(sizeof(KismetStringLibrary_Replace) == 0x000048, "Wrong size on KismetStringLibrary_Replace");
static_assert(offsetof(KismetStringLibrary_Replace, SourceString) == 0x000000, "Member 'KismetStringLibrary_Replace::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Replace, From) == 0x000010, "Member 'KismetStringLibrary_Replace::From' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Replace, To) == 0x000020, "Member 'KismetStringLibrary_Replace::To' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Replace, SearchCase) == 0x000030, "Member 'KismetStringLibrary_Replace::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Replace, ReturnValue) == 0x000038, "Member 'KismetStringLibrary_Replace::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.ReplaceInline
// 0x0038 (0x0038 - 0x0000)
struct KismetStringLibrary_ReplaceInline final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReferenceParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SearchText;                                        // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReplacementText;                                   // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ReturnValue;                                       // 0x0034(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_ReplaceInline) == 0x000008, "Wrong alignment on KismetStringLibrary_ReplaceInline");
static_assert(sizeof(KismetStringLibrary_ReplaceInline) == 0x000038, "Wrong size on KismetStringLibrary_ReplaceInline");
static_assert(offsetof(KismetStringLibrary_ReplaceInline, SourceString) == 0x000000, "Member 'KismetStringLibrary_ReplaceInline::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ReplaceInline, SearchText) == 0x000010, "Member 'KismetStringLibrary_ReplaceInline::SearchText' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ReplaceInline, ReplacementText) == 0x000020, "Member 'KismetStringLibrary_ReplaceInline::ReplacementText' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ReplaceInline, SearchCase) == 0x000030, "Member 'KismetStringLibrary_ReplaceInline::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ReplaceInline, ReturnValue) == 0x000034, "Member 'KismetStringLibrary_ReplaceInline::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Reverse
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Reverse final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Reverse) == 0x000008, "Wrong alignment on KismetStringLibrary_Reverse");
static_assert(sizeof(KismetStringLibrary_Reverse) == 0x000020, "Wrong size on KismetStringLibrary_Reverse");
static_assert(offsetof(KismetStringLibrary_Reverse, SourceString) == 0x000000, "Member 'KismetStringLibrary_Reverse::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Reverse, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Reverse::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Right
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_Right final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Right) == 0x000008, "Wrong alignment on KismetStringLibrary_Right");
static_assert(sizeof(KismetStringLibrary_Right) == 0x000028, "Wrong size on KismetStringLibrary_Right");
static_assert(offsetof(KismetStringLibrary_Right, SourceString) == 0x000000, "Member 'KismetStringLibrary_Right::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Right, Count) == 0x000010, "Member 'KismetStringLibrary_Right::Count' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Right, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_Right::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.RightChop
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_RightChop final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Count;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_RightChop) == 0x000008, "Wrong alignment on KismetStringLibrary_RightChop");
static_assert(sizeof(KismetStringLibrary_RightChop) == 0x000028, "Wrong size on KismetStringLibrary_RightChop");
static_assert(offsetof(KismetStringLibrary_RightChop, SourceString) == 0x000000, "Member 'KismetStringLibrary_RightChop::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_RightChop, Count) == 0x000010, "Member 'KismetStringLibrary_RightChop::Count' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_RightChop, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_RightChop::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.RightPad
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_RightPad final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChCount;                                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_RightPad) == 0x000008, "Wrong alignment on KismetStringLibrary_RightPad");
static_assert(sizeof(KismetStringLibrary_RightPad) == 0x000028, "Wrong size on KismetStringLibrary_RightPad");
static_assert(offsetof(KismetStringLibrary_RightPad, SourceString) == 0x000000, "Member 'KismetStringLibrary_RightPad::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_RightPad, ChCount) == 0x000010, "Member 'KismetStringLibrary_RightPad::ChCount' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_RightPad, ReturnValue) == 0x000018, "Member 'KismetStringLibrary_RightPad::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Split
// 0x0048 (0x0048 - 0x0000)
struct KismetStringLibrary_Split final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InStr;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LeftS;                                             // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RightS;                                            // 0x0030(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchDir                                    SearchDir;                                         // 0x0041(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0042(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_43[0x5];                                       // 0x0043(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_Split) == 0x000008, "Wrong alignment on KismetStringLibrary_Split");
static_assert(sizeof(KismetStringLibrary_Split) == 0x000048, "Wrong size on KismetStringLibrary_Split");
static_assert(offsetof(KismetStringLibrary_Split, SourceString) == 0x000000, "Member 'KismetStringLibrary_Split::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, InStr) == 0x000010, "Member 'KismetStringLibrary_Split::InStr' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, LeftS) == 0x000020, "Member 'KismetStringLibrary_Split::LeftS' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, RightS) == 0x000030, "Member 'KismetStringLibrary_Split::RightS' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, SearchCase) == 0x000040, "Member 'KismetStringLibrary_Split::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, SearchDir) == 0x000041, "Member 'KismetStringLibrary_Split::SearchDir' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Split, ReturnValue) == 0x000042, "Member 'KismetStringLibrary_Split::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.StartsWith
// 0x0028 (0x0028 - 0x0000)
struct KismetStringLibrary_StartsWith final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InPrefix;                                          // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESearchCase                                   SearchCase;                                        // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0021(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringLibrary_StartsWith) == 0x000008, "Wrong alignment on KismetStringLibrary_StartsWith");
static_assert(sizeof(KismetStringLibrary_StartsWith) == 0x000028, "Wrong size on KismetStringLibrary_StartsWith");
static_assert(offsetof(KismetStringLibrary_StartsWith, SourceString) == 0x000000, "Member 'KismetStringLibrary_StartsWith::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_StartsWith, InPrefix) == 0x000010, "Member 'KismetStringLibrary_StartsWith::InPrefix' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_StartsWith, SearchCase) == 0x000020, "Member 'KismetStringLibrary_StartsWith::SearchCase' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_StartsWith, ReturnValue) == 0x000021, "Member 'KismetStringLibrary_StartsWith::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.TimeSecondsToString
// 0x0018 (0x0018 - 0x0000)
struct KismetStringLibrary_TimeSecondsToString final
{
public:
	float                                         InSeconds;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_TimeSecondsToString) == 0x000008, "Wrong alignment on KismetStringLibrary_TimeSecondsToString");
static_assert(sizeof(KismetStringLibrary_TimeSecondsToString) == 0x000018, "Wrong size on KismetStringLibrary_TimeSecondsToString");
static_assert(offsetof(KismetStringLibrary_TimeSecondsToString, InSeconds) == 0x000000, "Member 'KismetStringLibrary_TimeSecondsToString::InSeconds' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_TimeSecondsToString, ReturnValue) == 0x000008, "Member 'KismetStringLibrary_TimeSecondsToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.ToLower
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_ToLower final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_ToLower) == 0x000008, "Wrong alignment on KismetStringLibrary_ToLower");
static_assert(sizeof(KismetStringLibrary_ToLower) == 0x000020, "Wrong size on KismetStringLibrary_ToLower");
static_assert(offsetof(KismetStringLibrary_ToLower, SourceString) == 0x000000, "Member 'KismetStringLibrary_ToLower::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ToLower, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_ToLower::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.ToUpper
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_ToUpper final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_ToUpper) == 0x000008, "Wrong alignment on KismetStringLibrary_ToUpper");
static_assert(sizeof(KismetStringLibrary_ToUpper) == 0x000020, "Wrong size on KismetStringLibrary_ToUpper");
static_assert(offsetof(KismetStringLibrary_ToUpper, SourceString) == 0x000000, "Member 'KismetStringLibrary_ToUpper::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_ToUpper, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_ToUpper::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.Trim
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_Trim final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_Trim) == 0x000008, "Wrong alignment on KismetStringLibrary_Trim");
static_assert(sizeof(KismetStringLibrary_Trim) == 0x000020, "Wrong size on KismetStringLibrary_Trim");
static_assert(offsetof(KismetStringLibrary_Trim, SourceString) == 0x000000, "Member 'KismetStringLibrary_Trim::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_Trim, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_Trim::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringLibrary.TrimTrailing
// 0x0020 (0x0020 - 0x0000)
struct KismetStringLibrary_TrimTrailing final
{
public:
	class FString                                 SourceString;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringLibrary_TrimTrailing) == 0x000008, "Wrong alignment on KismetStringLibrary_TrimTrailing");
static_assert(sizeof(KismetStringLibrary_TrimTrailing) == 0x000020, "Wrong size on KismetStringLibrary_TrimTrailing");
static_assert(offsetof(KismetStringLibrary_TrimTrailing, SourceString) == 0x000000, "Member 'KismetStringLibrary_TrimTrailing::SourceString' has a wrong offset!");
static_assert(offsetof(KismetStringLibrary_TrimTrailing, ReturnValue) == 0x000010, "Member 'KismetStringLibrary_TrimTrailing::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetKeysFromStringTable
// 0x0018 (0x0018 - 0x0000)
struct KismetStringTableLibrary_GetKeysFromStringTable final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetKeysFromStringTable) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetKeysFromStringTable");
static_assert(sizeof(KismetStringTableLibrary_GetKeysFromStringTable) == 0x000018, "Wrong size on KismetStringTableLibrary_GetKeysFromStringTable");
static_assert(offsetof(KismetStringTableLibrary_GetKeysFromStringTable, TableId) == 0x000000, "Member 'KismetStringTableLibrary_GetKeysFromStringTable::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetKeysFromStringTable, ReturnValue) == 0x000008, "Member 'KismetStringTableLibrary_GetKeysFromStringTable::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetMetaDataIdsFromStringTableEntry
// 0x0028 (0x0028 - 0x0000)
struct KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FName>                           ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry");
static_assert(sizeof(KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry) == 0x000028, "Wrong size on KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry");
static_assert(offsetof(KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry, TableId) == 0x000000, "Member 'KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry, Key) == 0x000008, "Member 'KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry::Key' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry, ReturnValue) == 0x000018, "Member 'KismetStringTableLibrary_GetMetaDataIdsFromStringTableEntry::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetRegisteredStringTables
// 0x0010 (0x0010 - 0x0000)
struct KismetStringTableLibrary_GetRegisteredStringTables final
{
public:
	TArray<class FName>                           ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetRegisteredStringTables) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetRegisteredStringTables");
static_assert(sizeof(KismetStringTableLibrary_GetRegisteredStringTables) == 0x000010, "Wrong size on KismetStringTableLibrary_GetRegisteredStringTables");
static_assert(offsetof(KismetStringTableLibrary_GetRegisteredStringTables, ReturnValue) == 0x000000, "Member 'KismetStringTableLibrary_GetRegisteredStringTables::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetTableEntryMetaData
// 0x0030 (0x0030 - 0x0000)
struct KismetStringTableLibrary_GetTableEntryMetaData final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MetaDataId;                                        // 0x0018(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetTableEntryMetaData) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetTableEntryMetaData");
static_assert(sizeof(KismetStringTableLibrary_GetTableEntryMetaData) == 0x000030, "Wrong size on KismetStringTableLibrary_GetTableEntryMetaData");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntryMetaData, TableId) == 0x000000, "Member 'KismetStringTableLibrary_GetTableEntryMetaData::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntryMetaData, Key) == 0x000008, "Member 'KismetStringTableLibrary_GetTableEntryMetaData::Key' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntryMetaData, MetaDataId) == 0x000018, "Member 'KismetStringTableLibrary_GetTableEntryMetaData::MetaDataId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntryMetaData, ReturnValue) == 0x000020, "Member 'KismetStringTableLibrary_GetTableEntryMetaData::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetTableEntrySourceString
// 0x0028 (0x0028 - 0x0000)
struct KismetStringTableLibrary_GetTableEntrySourceString final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetTableEntrySourceString) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetTableEntrySourceString");
static_assert(sizeof(KismetStringTableLibrary_GetTableEntrySourceString) == 0x000028, "Wrong size on KismetStringTableLibrary_GetTableEntrySourceString");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntrySourceString, TableId) == 0x000000, "Member 'KismetStringTableLibrary_GetTableEntrySourceString::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntrySourceString, Key) == 0x000008, "Member 'KismetStringTableLibrary_GetTableEntrySourceString::Key' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableEntrySourceString, ReturnValue) == 0x000018, "Member 'KismetStringTableLibrary_GetTableEntrySourceString::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.GetTableNamespace
// 0x0018 (0x0018 - 0x0000)
struct KismetStringTableLibrary_GetTableNamespace final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetStringTableLibrary_GetTableNamespace) == 0x000008, "Wrong alignment on KismetStringTableLibrary_GetTableNamespace");
static_assert(sizeof(KismetStringTableLibrary_GetTableNamespace) == 0x000018, "Wrong size on KismetStringTableLibrary_GetTableNamespace");
static_assert(offsetof(KismetStringTableLibrary_GetTableNamespace, TableId) == 0x000000, "Member 'KismetStringTableLibrary_GetTableNamespace::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_GetTableNamespace, ReturnValue) == 0x000008, "Member 'KismetStringTableLibrary_GetTableNamespace::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.IsRegisteredTableEntry
// 0x0020 (0x0020 - 0x0000)
struct KismetStringTableLibrary_IsRegisteredTableEntry final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringTableLibrary_IsRegisteredTableEntry) == 0x000008, "Wrong alignment on KismetStringTableLibrary_IsRegisteredTableEntry");
static_assert(sizeof(KismetStringTableLibrary_IsRegisteredTableEntry) == 0x000020, "Wrong size on KismetStringTableLibrary_IsRegisteredTableEntry");
static_assert(offsetof(KismetStringTableLibrary_IsRegisteredTableEntry, TableId) == 0x000000, "Member 'KismetStringTableLibrary_IsRegisteredTableEntry::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_IsRegisteredTableEntry, Key) == 0x000008, "Member 'KismetStringTableLibrary_IsRegisteredTableEntry::Key' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_IsRegisteredTableEntry, ReturnValue) == 0x000018, "Member 'KismetStringTableLibrary_IsRegisteredTableEntry::ReturnValue' has a wrong offset!");

// Function Engine.KismetStringTableLibrary.IsRegisteredTableId
// 0x0010 (0x0010 - 0x0000)
struct KismetStringTableLibrary_IsRegisteredTableId final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetStringTableLibrary_IsRegisteredTableId) == 0x000004, "Wrong alignment on KismetStringTableLibrary_IsRegisteredTableId");
static_assert(sizeof(KismetStringTableLibrary_IsRegisteredTableId) == 0x000010, "Wrong size on KismetStringTableLibrary_IsRegisteredTableId");
static_assert(offsetof(KismetStringTableLibrary_IsRegisteredTableId, TableId) == 0x000000, "Member 'KismetStringTableLibrary_IsRegisteredTableId::TableId' has a wrong offset!");
static_assert(offsetof(KismetStringTableLibrary_IsRegisteredTableId, ReturnValue) == 0x000008, "Member 'KismetStringTableLibrary_IsRegisteredTableId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.AddFloatHistorySample
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_AddFloatHistorySample final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDebugFloatHistory                     FloatHistory;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FDebugFloatHistory                     ReturnValue;                                       // 0x0028(0x0020)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_AddFloatHistorySample) == 0x000008, "Wrong alignment on KismetSystemLibrary_AddFloatHistorySample");
static_assert(sizeof(KismetSystemLibrary_AddFloatHistorySample) == 0x000048, "Wrong size on KismetSystemLibrary_AddFloatHistorySample");
static_assert(offsetof(KismetSystemLibrary_AddFloatHistorySample, Value) == 0x000000, "Member 'KismetSystemLibrary_AddFloatHistorySample::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_AddFloatHistorySample, FloatHistory) == 0x000008, "Member 'KismetSystemLibrary_AddFloatHistorySample::FloatHistory' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_AddFloatHistorySample, ReturnValue) == 0x000028, "Member 'KismetSystemLibrary_AddFloatHistorySample::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxOverlapActors
// 0x0060 (0x0060 - 0x0000)
struct KismetSystemLibrary_BoxOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxPos;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxOverlapActors) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxOverlapActors");
static_assert(sizeof(KismetSystemLibrary_BoxOverlapActors) == 0x000060, "Wrong size on KismetSystemLibrary_BoxOverlapActors");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, BoxPos) == 0x000008, "Member 'KismetSystemLibrary_BoxOverlapActors::BoxPos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, BoxExtent) == 0x000014, "Member 'KismetSystemLibrary_BoxOverlapActors::BoxExtent' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_BoxOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, ActorClassFilter) == 0x000030, "Member 'KismetSystemLibrary_BoxOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_BoxOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, OutActors) == 0x000048, "Member 'KismetSystemLibrary_BoxOverlapActors::OutActors' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapActors, ReturnValue) == 0x000058, "Member 'KismetSystemLibrary_BoxOverlapActors::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxOverlapComponents
// 0x0060 (0x0060 - 0x0000)
struct KismetSystemLibrary_BoxOverlapComponents final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxPos;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ComponentClassFilter;                              // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxOverlapComponents) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxOverlapComponents");
static_assert(sizeof(KismetSystemLibrary_BoxOverlapComponents) == 0x000060, "Wrong size on KismetSystemLibrary_BoxOverlapComponents");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxOverlapComponents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, BoxPos) == 0x000008, "Member 'KismetSystemLibrary_BoxOverlapComponents::BoxPos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, Extent) == 0x000014, "Member 'KismetSystemLibrary_BoxOverlapComponents::Extent' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_BoxOverlapComponents::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, ComponentClassFilter) == 0x000030, "Member 'KismetSystemLibrary_BoxOverlapComponents::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_BoxOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, OutComponents) == 0x000048, "Member 'KismetSystemLibrary_BoxOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxOverlapComponents, ReturnValue) == 0x000058, "Member 'KismetSystemLibrary_BoxOverlapComponents::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceMulti
// 0x0098 (0x0098 - 0x0000)
struct KismetSystemLibrary_BoxTraceMulti final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x006C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x007C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceMulti) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceMulti");
static_assert(sizeof(KismetSystemLibrary_BoxTraceMulti) == 0x000098, "Wrong size on KismetSystemLibrary_BoxTraceMulti");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceMulti::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceMulti::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceMulti::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceMulti::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceMulti::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, TraceChannel) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceMulti::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, bTraceComplex) == 0x000039, "Member 'KismetSystemLibrary_BoxTraceMulti::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_BoxTraceMulti::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_BoxTraceMulti::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, OutHits) == 0x000058, "Member 'KismetSystemLibrary_BoxTraceMulti::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, bIgnoreSelf) == 0x000068, "Member 'KismetSystemLibrary_BoxTraceMulti::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, TraceColor) == 0x00006C, "Member 'KismetSystemLibrary_BoxTraceMulti::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, TraceHitColor) == 0x00007C, "Member 'KismetSystemLibrary_BoxTraceMulti::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, DrawTime) == 0x00008C, "Member 'KismetSystemLibrary_BoxTraceMulti::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMulti, ReturnValue) == 0x000090, "Member 'KismetSystemLibrary_BoxTraceMulti::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceMultiByProfile
// 0x00A0 (0x00A0 - 0x0000)
struct KismetSystemLibrary_BoxTraceMultiByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0060(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0070(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71[0x3];                                       // 0x0071(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0074(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0084(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0094(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0098(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x7];                                       // 0x0099(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceMultiByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceMultiByProfile");
static_assert(sizeof(KismetSystemLibrary_BoxTraceMultiByProfile) == 0x0000A0, "Wrong size on KismetSystemLibrary_BoxTraceMultiByProfile");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, ProfileName) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, bTraceComplex) == 0x000040, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, ActorsToIgnore) == 0x000048, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, DrawDebugType) == 0x000058, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, OutHits) == 0x000060, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, bIgnoreSelf) == 0x000070, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, TraceColor) == 0x000074, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, TraceHitColor) == 0x000084, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, DrawTime) == 0x000094, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiByProfile, ReturnValue) == 0x000098, "Member 'KismetSystemLibrary_BoxTraceMultiByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceMultiForObjects
// 0x00A8 (0x00A8 - 0x0000)
struct KismetSystemLibrary_BoxTraceMultiForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0078(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x3];                                       // 0x0079(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x007C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x008C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x009C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00A0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceMultiForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceMultiForObjects");
static_assert(sizeof(KismetSystemLibrary_BoxTraceMultiForObjects) == 0x0000A8, "Wrong size on KismetSystemLibrary_BoxTraceMultiForObjects");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, ObjectTypes) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, bTraceComplex) == 0x000048, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, ActorsToIgnore) == 0x000050, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, DrawDebugType) == 0x000060, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, OutHits) == 0x000068, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, bIgnoreSelf) == 0x000078, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, TraceColor) == 0x00007C, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, TraceHitColor) == 0x00008C, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, DrawTime) == 0x00009C, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceMultiForObjects, ReturnValue) == 0x0000A0, "Member 'KismetSystemLibrary_BoxTraceMultiForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceSingle
// 0x0110 (0x0110 - 0x0000)
struct KismetSystemLibrary_BoxTraceSingle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0039(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A[0x6];                                       // 0x003A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0058(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00E0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00E4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00F4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0104(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0108(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceSingle) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceSingle");
static_assert(sizeof(KismetSystemLibrary_BoxTraceSingle) == 0x000110, "Wrong size on KismetSystemLibrary_BoxTraceSingle");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceSingle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceSingle::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceSingle::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceSingle::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceSingle::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, TraceChannel) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceSingle::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, bTraceComplex) == 0x000039, "Member 'KismetSystemLibrary_BoxTraceSingle::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_BoxTraceSingle::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_BoxTraceSingle::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, OutHit) == 0x000058, "Member 'KismetSystemLibrary_BoxTraceSingle::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, bIgnoreSelf) == 0x0000E0, "Member 'KismetSystemLibrary_BoxTraceSingle::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, TraceColor) == 0x0000E4, "Member 'KismetSystemLibrary_BoxTraceSingle::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, TraceHitColor) == 0x0000F4, "Member 'KismetSystemLibrary_BoxTraceSingle::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, DrawTime) == 0x000104, "Member 'KismetSystemLibrary_BoxTraceSingle::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingle, ReturnValue) == 0x000108, "Member 'KismetSystemLibrary_BoxTraceSingle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceSingleByProfile
// 0x0118 (0x0118 - 0x0000)
struct KismetSystemLibrary_BoxTraceSingleByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0048(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0060(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00E8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E9[0x3];                                       // 0x00E9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00EC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00FC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x010C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0110(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_111[0x7];                                      // 0x0111(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceSingleByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceSingleByProfile");
static_assert(sizeof(KismetSystemLibrary_BoxTraceSingleByProfile) == 0x000118, "Wrong size on KismetSystemLibrary_BoxTraceSingleByProfile");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, ProfileName) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, bTraceComplex) == 0x000040, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, ActorsToIgnore) == 0x000048, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, DrawDebugType) == 0x000058, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, OutHit) == 0x000060, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, bIgnoreSelf) == 0x0000E8, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, TraceColor) == 0x0000EC, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, TraceHitColor) == 0x0000FC, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, DrawTime) == 0x00010C, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleByProfile, ReturnValue) == 0x000110, "Member 'KismetSystemLibrary_BoxTraceSingleByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BoxTraceSingleForObjects
// 0x0120 (0x0120 - 0x0000)
struct KismetSystemLibrary_BoxTraceSingleForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HalfSize;                                          // 0x0020(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Orientation;                                       // 0x002C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0050(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0068(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00F0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x3];                                       // 0x00F1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00F4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0104(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0114(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0118(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_119[0x7];                                      // 0x0119(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_BoxTraceSingleForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_BoxTraceSingleForObjects");
static_assert(sizeof(KismetSystemLibrary_BoxTraceSingleForObjects) == 0x000120, "Wrong size on KismetSystemLibrary_BoxTraceSingleForObjects");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, HalfSize) == 0x000020, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::HalfSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, Orientation) == 0x00002C, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::Orientation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, ObjectTypes) == 0x000038, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, bTraceComplex) == 0x000048, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, ActorsToIgnore) == 0x000050, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, DrawDebugType) == 0x000060, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, OutHit) == 0x000068, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, bIgnoreSelf) == 0x0000F0, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, TraceColor) == 0x0000F4, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, TraceHitColor) == 0x000104, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, DrawTime) == 0x000114, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BoxTraceSingleForObjects, ReturnValue) == 0x000118, "Member 'KismetSystemLibrary_BoxTraceSingleForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.BreakSoftObjectPath
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_BreakSoftObjectPath final
{
public:
	struct FSoftObjectPath                        InSoftObjectPath;                                  // 0x0000(0x0008)(Parm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PathString;                                        // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_BreakSoftObjectPath) == 0x000008, "Wrong alignment on KismetSystemLibrary_BreakSoftObjectPath");
static_assert(sizeof(KismetSystemLibrary_BreakSoftObjectPath) == 0x000018, "Wrong size on KismetSystemLibrary_BreakSoftObjectPath");
static_assert(offsetof(KismetSystemLibrary_BreakSoftObjectPath, InSoftObjectPath) == 0x000000, "Member 'KismetSystemLibrary_BreakSoftObjectPath::InSoftObjectPath' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_BreakSoftObjectPath, PathString) == 0x000008, "Member 'KismetSystemLibrary_BreakSoftObjectPath::PathString' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CanLaunchURL
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_CanLaunchURL final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CanLaunchURL) == 0x000008, "Wrong alignment on KismetSystemLibrary_CanLaunchURL");
static_assert(sizeof(KismetSystemLibrary_CanLaunchURL) == 0x000018, "Wrong size on KismetSystemLibrary_CanLaunchURL");
static_assert(offsetof(KismetSystemLibrary_CanLaunchURL, URL) == 0x000000, "Member 'KismetSystemLibrary_CanLaunchURL::URL' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CanLaunchURL, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_CanLaunchURL::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleOverlapActors
// 0x0060 (0x0060 - 0x0000)
struct KismetSystemLibrary_CapsuleOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsulePos;                                        // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleOverlapActors) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleOverlapActors");
static_assert(sizeof(KismetSystemLibrary_CapsuleOverlapActors) == 0x000060, "Wrong size on KismetSystemLibrary_CapsuleOverlapActors");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, CapsulePos) == 0x000008, "Member 'KismetSystemLibrary_CapsuleOverlapActors::CapsulePos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, Radius) == 0x000014, "Member 'KismetSystemLibrary_CapsuleOverlapActors::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, HalfHeight) == 0x000018, "Member 'KismetSystemLibrary_CapsuleOverlapActors::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_CapsuleOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, ActorClassFilter) == 0x000030, "Member 'KismetSystemLibrary_CapsuleOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_CapsuleOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, OutActors) == 0x000048, "Member 'KismetSystemLibrary_CapsuleOverlapActors::OutActors' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapActors, ReturnValue) == 0x000058, "Member 'KismetSystemLibrary_CapsuleOverlapActors::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleOverlapComponents
// 0x0060 (0x0060 - 0x0000)
struct KismetSystemLibrary_CapsuleOverlapComponents final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CapsulePos;                                        // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ComponentClassFilter;                              // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0058(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleOverlapComponents) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleOverlapComponents");
static_assert(sizeof(KismetSystemLibrary_CapsuleOverlapComponents) == 0x000060, "Wrong size on KismetSystemLibrary_CapsuleOverlapComponents");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, CapsulePos) == 0x000008, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::CapsulePos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, Radius) == 0x000014, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, HalfHeight) == 0x000018, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, ComponentClassFilter) == 0x000030, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, OutComponents) == 0x000048, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleOverlapComponents, ReturnValue) == 0x000058, "Member 'KismetSystemLibrary_CapsuleOverlapComponents::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceMulti
// 0x0088 (0x0088 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceMulti final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x005C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x006C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceMulti) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceMulti");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceMulti) == 0x000088, "Wrong size on KismetSystemLibrary_CapsuleTraceMulti");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceMulti::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceMulti::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceMulti::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceMulti::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceMulti::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, TraceChannel) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceMulti::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, bTraceComplex) == 0x000029, "Member 'KismetSystemLibrary_CapsuleTraceMulti::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_CapsuleTraceMulti::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, DrawDebugType) == 0x000040, "Member 'KismetSystemLibrary_CapsuleTraceMulti::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, OutHits) == 0x000048, "Member 'KismetSystemLibrary_CapsuleTraceMulti::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, bIgnoreSelf) == 0x000058, "Member 'KismetSystemLibrary_CapsuleTraceMulti::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, TraceColor) == 0x00005C, "Member 'KismetSystemLibrary_CapsuleTraceMulti::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, TraceHitColor) == 0x00006C, "Member 'KismetSystemLibrary_CapsuleTraceMulti::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, DrawTime) == 0x00007C, "Member 'KismetSystemLibrary_CapsuleTraceMulti::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMulti, ReturnValue) == 0x000080, "Member 'KismetSystemLibrary_CapsuleTraceMulti::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceMultiByProfile
// 0x0090 (0x0090 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceMultiByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0064(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0074(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceMultiByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceMultiByProfile");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceMultiByProfile) == 0x000090, "Wrong size on KismetSystemLibrary_CapsuleTraceMultiByProfile");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, ProfileName) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, OutHits) == 0x000050, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, bIgnoreSelf) == 0x000060, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, TraceColor) == 0x000064, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, TraceHitColor) == 0x000074, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, DrawTime) == 0x000084, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiByProfile, ReturnValue) == 0x000088, "Member 'KismetSystemLibrary_CapsuleTraceMultiByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceMultiForObjects
// 0x0098 (0x0098 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceMultiForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x006C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x007C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceMultiForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceMultiForObjects");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceMultiForObjects) == 0x000098, "Wrong size on KismetSystemLibrary_CapsuleTraceMultiForObjects");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, ObjectTypes) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, bTraceComplex) == 0x000038, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, OutHits) == 0x000058, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, bIgnoreSelf) == 0x000068, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, TraceColor) == 0x00006C, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, TraceHitColor) == 0x00007C, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, DrawTime) == 0x00008C, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceMultiForObjects, ReturnValue) == 0x000090, "Member 'KismetSystemLibrary_CapsuleTraceMultiForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceSingle
// 0x0100 (0x0100 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceSingle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0048(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00D4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00E4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00F4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceSingle) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceSingle");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceSingle) == 0x000100, "Wrong size on KismetSystemLibrary_CapsuleTraceSingle");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceSingle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceSingle::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceSingle::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceSingle::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceSingle::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, TraceChannel) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceSingle::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, bTraceComplex) == 0x000029, "Member 'KismetSystemLibrary_CapsuleTraceSingle::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_CapsuleTraceSingle::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, DrawDebugType) == 0x000040, "Member 'KismetSystemLibrary_CapsuleTraceSingle::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, OutHit) == 0x000048, "Member 'KismetSystemLibrary_CapsuleTraceSingle::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, bIgnoreSelf) == 0x0000D0, "Member 'KismetSystemLibrary_CapsuleTraceSingle::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, TraceColor) == 0x0000D4, "Member 'KismetSystemLibrary_CapsuleTraceSingle::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, TraceHitColor) == 0x0000E4, "Member 'KismetSystemLibrary_CapsuleTraceSingle::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, DrawTime) == 0x0000F4, "Member 'KismetSystemLibrary_CapsuleTraceSingle::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingle, ReturnValue) == 0x0000F8, "Member 'KismetSystemLibrary_CapsuleTraceSingle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceSingleByProfile
// 0x0108 (0x0108 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceSingleByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0050(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00D8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00DC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00EC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00FC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceSingleByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceSingleByProfile");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceSingleByProfile) == 0x000108, "Wrong size on KismetSystemLibrary_CapsuleTraceSingleByProfile");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, ProfileName) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, OutHit) == 0x000050, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, bIgnoreSelf) == 0x0000D8, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, TraceColor) == 0x0000DC, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, TraceHitColor) == 0x0000EC, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, DrawTime) == 0x0000FC, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleByProfile, ReturnValue) == 0x000100, "Member 'KismetSystemLibrary_CapsuleTraceSingleByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CapsuleTraceSingleForObjects
// 0x0110 (0x0110 - 0x0000)
struct KismetSystemLibrary_CapsuleTraceSingleForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0058(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00E0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00E4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00F4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0104(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0108(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_CapsuleTraceSingleForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_CapsuleTraceSingleForObjects");
static_assert(sizeof(KismetSystemLibrary_CapsuleTraceSingleForObjects) == 0x000110, "Wrong size on KismetSystemLibrary_CapsuleTraceSingleForObjects");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, Radius) == 0x000020, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, HalfHeight) == 0x000024, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, ObjectTypes) == 0x000028, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, bTraceComplex) == 0x000038, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, OutHit) == 0x000058, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, bIgnoreSelf) == 0x0000E0, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, TraceColor) == 0x0000E4, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, TraceHitColor) == 0x0000F4, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, DrawTime) == 0x000104, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_CapsuleTraceSingleForObjects, ReturnValue) == 0x000108, "Member 'KismetSystemLibrary_CapsuleTraceSingleForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ComponentOverlapActors
// 0x0080 (0x0080 - 0x0000)
struct KismetSystemLibrary_ComponentOverlapActors final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ComponentTransform;                                // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0058(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_ComponentOverlapActors) == 0x000010, "Wrong alignment on KismetSystemLibrary_ComponentOverlapActors");
static_assert(sizeof(KismetSystemLibrary_ComponentOverlapActors) == 0x000080, "Wrong size on KismetSystemLibrary_ComponentOverlapActors");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, Component) == 0x000000, "Member 'KismetSystemLibrary_ComponentOverlapActors::Component' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, ComponentTransform) == 0x000010, "Member 'KismetSystemLibrary_ComponentOverlapActors::ComponentTransform' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, ObjectTypes) == 0x000040, "Member 'KismetSystemLibrary_ComponentOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, ActorClassFilter) == 0x000050, "Member 'KismetSystemLibrary_ComponentOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, ActorsToIgnore) == 0x000058, "Member 'KismetSystemLibrary_ComponentOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, OutActors) == 0x000068, "Member 'KismetSystemLibrary_ComponentOverlapActors::OutActors' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapActors, ReturnValue) == 0x000078, "Member 'KismetSystemLibrary_ComponentOverlapActors::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ComponentOverlapComponents
// 0x0080 (0x0080 - 0x0000)
struct KismetSystemLibrary_ComponentOverlapComponents final
{
public:
	class UPrimitiveComponent*                    Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ComponentTransform;                                // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ComponentClassFilter;                              // 0x0050(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0058(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0068(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_ComponentOverlapComponents) == 0x000010, "Wrong alignment on KismetSystemLibrary_ComponentOverlapComponents");
static_assert(sizeof(KismetSystemLibrary_ComponentOverlapComponents) == 0x000080, "Wrong size on KismetSystemLibrary_ComponentOverlapComponents");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, Component) == 0x000000, "Member 'KismetSystemLibrary_ComponentOverlapComponents::Component' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, ComponentTransform) == 0x000010, "Member 'KismetSystemLibrary_ComponentOverlapComponents::ComponentTransform' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, ObjectTypes) == 0x000040, "Member 'KismetSystemLibrary_ComponentOverlapComponents::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, ComponentClassFilter) == 0x000050, "Member 'KismetSystemLibrary_ComponentOverlapComponents::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, ActorsToIgnore) == 0x000058, "Member 'KismetSystemLibrary_ComponentOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, OutComponents) == 0x000068, "Member 'KismetSystemLibrary_ComponentOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ComponentOverlapComponents, ReturnValue) == 0x000078, "Member 'KismetSystemLibrary_ComponentOverlapComponents::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ControlScreensaver
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_ControlScreensaver final
{
public:
	bool                                          bAllowScreenSaver;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_ControlScreensaver) == 0x000001, "Wrong alignment on KismetSystemLibrary_ControlScreensaver");
static_assert(sizeof(KismetSystemLibrary_ControlScreensaver) == 0x000001, "Wrong size on KismetSystemLibrary_ControlScreensaver");
static_assert(offsetof(KismetSystemLibrary_ControlScreensaver, bAllowScreenSaver) == 0x000000, "Member 'KismetSystemLibrary_ControlScreensaver::bAllowScreenSaver' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_ClassToSoftClassReference
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_Conv_ClassToSoftClassReference final
{
public:
	TSubclassOf<class UObject>                    Class_0;                                           // 0x0000(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_ClassToSoftClassReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_ClassToSoftClassReference");
static_assert(sizeof(KismetSystemLibrary_Conv_ClassToSoftClassReference) == 0x000020, "Wrong size on KismetSystemLibrary_Conv_ClassToSoftClassReference");
static_assert(offsetof(KismetSystemLibrary_Conv_ClassToSoftClassReference, Class_0) == 0x000000, "Member 'KismetSystemLibrary_Conv_ClassToSoftClassReference::Class_0' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_ClassToSoftClassReference, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_Conv_ClassToSoftClassReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_InterfaceToObject
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_Conv_InterfaceToObject final
{
public:
	TScriptInterface<class IInterface>            Interface;                                         // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_InterfaceToObject) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_InterfaceToObject");
static_assert(sizeof(KismetSystemLibrary_Conv_InterfaceToObject) == 0x000018, "Wrong size on KismetSystemLibrary_Conv_InterfaceToObject");
static_assert(offsetof(KismetSystemLibrary_Conv_InterfaceToObject, Interface) == 0x000000, "Member 'KismetSystemLibrary_Conv_InterfaceToObject::Interface' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_InterfaceToObject, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_Conv_InterfaceToObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_ObjectToSoftObjectReference
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_Conv_ObjectToSoftObjectReference final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_ObjectToSoftObjectReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_ObjectToSoftObjectReference");
static_assert(sizeof(KismetSystemLibrary_Conv_ObjectToSoftObjectReference) == 0x000020, "Wrong size on KismetSystemLibrary_Conv_ObjectToSoftObjectReference");
static_assert(offsetof(KismetSystemLibrary_Conv_ObjectToSoftObjectReference, Object) == 0x000000, "Member 'KismetSystemLibrary_Conv_ObjectToSoftObjectReference::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_ObjectToSoftObjectReference, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_Conv_ObjectToSoftObjectReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetIdToString
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_Conv_PrimaryAssetIdToString final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_PrimaryAssetIdToString) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_PrimaryAssetIdToString");
static_assert(sizeof(KismetSystemLibrary_Conv_PrimaryAssetIdToString) == 0x000020, "Wrong size on KismetSystemLibrary_Conv_PrimaryAssetIdToString");
static_assert(offsetof(KismetSystemLibrary_Conv_PrimaryAssetIdToString, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_Conv_PrimaryAssetIdToString::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_PrimaryAssetIdToString, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_Conv_PrimaryAssetIdToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_PrimaryAssetTypeToString
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_Conv_PrimaryAssetTypeToString final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_PrimaryAssetTypeToString) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_PrimaryAssetTypeToString");
static_assert(sizeof(KismetSystemLibrary_Conv_PrimaryAssetTypeToString) == 0x000018, "Wrong size on KismetSystemLibrary_Conv_PrimaryAssetTypeToString");
static_assert(offsetof(KismetSystemLibrary_Conv_PrimaryAssetTypeToString, PrimaryAssetType) == 0x000000, "Member 'KismetSystemLibrary_Conv_PrimaryAssetTypeToString::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_PrimaryAssetTypeToString, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_Conv_PrimaryAssetTypeToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToClass
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_Conv_SoftClassReferenceToClass final
{
public:
	TSoftClassPtr<class UClass>                   SoftClass;                                         // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_SoftClassReferenceToClass) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_SoftClassReferenceToClass");
static_assert(sizeof(KismetSystemLibrary_Conv_SoftClassReferenceToClass) == 0x000020, "Wrong size on KismetSystemLibrary_Conv_SoftClassReferenceToClass");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftClassReferenceToClass, SoftClass) == 0x000000, "Member 'KismetSystemLibrary_Conv_SoftClassReferenceToClass::SoftClass' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftClassReferenceToClass, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_Conv_SoftClassReferenceToClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_SoftClassReferenceToString
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_Conv_SoftClassReferenceToString final
{
public:
	TSoftClassPtr<class UClass>                   SoftClassReference;                                // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_SoftClassReferenceToString) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_SoftClassReferenceToString");
static_assert(sizeof(KismetSystemLibrary_Conv_SoftClassReferenceToString) == 0x000028, "Wrong size on KismetSystemLibrary_Conv_SoftClassReferenceToString");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftClassReferenceToString, SoftClassReference) == 0x000000, "Member 'KismetSystemLibrary_Conv_SoftClassReferenceToString::SoftClassReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftClassReferenceToString, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_Conv_SoftClassReferenceToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToObject
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_Conv_SoftObjectReferenceToObject final
{
public:
	TSoftObjectPtr<class UObject>                 SoftObject;                                        // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_SoftObjectReferenceToObject) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_SoftObjectReferenceToObject");
static_assert(sizeof(KismetSystemLibrary_Conv_SoftObjectReferenceToObject) == 0x000020, "Wrong size on KismetSystemLibrary_Conv_SoftObjectReferenceToObject");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftObjectReferenceToObject, SoftObject) == 0x000000, "Member 'KismetSystemLibrary_Conv_SoftObjectReferenceToObject::SoftObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftObjectReferenceToObject, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_Conv_SoftObjectReferenceToObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Conv_SoftObjectReferenceToString
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_Conv_SoftObjectReferenceToString final
{
public:
	TSoftObjectPtr<class UObject>                 SoftObjectReference;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Conv_SoftObjectReferenceToString) == 0x000008, "Wrong alignment on KismetSystemLibrary_Conv_SoftObjectReferenceToString");
static_assert(sizeof(KismetSystemLibrary_Conv_SoftObjectReferenceToString) == 0x000028, "Wrong size on KismetSystemLibrary_Conv_SoftObjectReferenceToString");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftObjectReferenceToString, SoftObjectReference) == 0x000000, "Member 'KismetSystemLibrary_Conv_SoftObjectReferenceToString::SoftObjectReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Conv_SoftObjectReferenceToString, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_Conv_SoftObjectReferenceToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.CreateCopyForUndoBuffer
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_CreateCopyForUndoBuffer final
{
public:
	class UObject*                                ObjectToModify;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_CreateCopyForUndoBuffer) == 0x000008, "Wrong alignment on KismetSystemLibrary_CreateCopyForUndoBuffer");
static_assert(sizeof(KismetSystemLibrary_CreateCopyForUndoBuffer) == 0x000008, "Wrong size on KismetSystemLibrary_CreateCopyForUndoBuffer");
static_assert(offsetof(KismetSystemLibrary_CreateCopyForUndoBuffer, ObjectToModify) == 0x000000, "Member 'KismetSystemLibrary_CreateCopyForUndoBuffer::ObjectToModify' has a wrong offset!");

// Function Engine.KismetSystemLibrary.Delay
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_Delay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_Delay) == 0x000008, "Wrong alignment on KismetSystemLibrary_Delay");
static_assert(sizeof(KismetSystemLibrary_Delay) == 0x000028, "Wrong size on KismetSystemLibrary_Delay");
static_assert(offsetof(KismetSystemLibrary_Delay, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_Delay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Delay, Duration) == 0x000008, "Member 'KismetSystemLibrary_Delay::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_Delay, LatentInfo) == 0x000010, "Member 'KismetSystemLibrary_Delay::LatentInfo' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DoesImplementInterface
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_DoesImplementInterface final
{
public:
	class UObject*                                TestObject;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class IInterface>                 Interface;                                         // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DoesImplementInterface) == 0x000008, "Wrong alignment on KismetSystemLibrary_DoesImplementInterface");
static_assert(sizeof(KismetSystemLibrary_DoesImplementInterface) == 0x000018, "Wrong size on KismetSystemLibrary_DoesImplementInterface");
static_assert(offsetof(KismetSystemLibrary_DoesImplementInterface, TestObject) == 0x000000, "Member 'KismetSystemLibrary_DoesImplementInterface::TestObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DoesImplementInterface, Interface) == 0x000008, "Member 'KismetSystemLibrary_DoesImplementInterface::Interface' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DoesImplementInterface, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_DoesImplementInterface::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugArrow
// 0x0040 (0x0040 - 0x0000)
struct KismetSystemLibrary_DrawDebugArrow final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ArrowSize;                                         // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0024(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugArrow) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugArrow");
static_assert(sizeof(KismetSystemLibrary_DrawDebugArrow) == 0x000040, "Wrong size on KismetSystemLibrary_DrawDebugArrow");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugArrow::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, LineStart) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugArrow::LineStart' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, LineEnd) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugArrow::LineEnd' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, ArrowSize) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugArrow::ArrowSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, LineColor) == 0x000024, "Member 'KismetSystemLibrary_DrawDebugArrow::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, Duration) == 0x000034, "Member 'KismetSystemLibrary_DrawDebugArrow::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugArrow, Thickness) == 0x000038, "Member 'KismetSystemLibrary_DrawDebugArrow::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugBox
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_DrawDebugBox final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Extent;                                            // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0020(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0030(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugBox) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugBox");
static_assert(sizeof(KismetSystemLibrary_DrawDebugBox) == 0x000048, "Wrong size on KismetSystemLibrary_DrawDebugBox");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugBox::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, Center) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugBox::Center' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, Extent) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugBox::Extent' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, LineColor) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugBox::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, Rotation) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugBox::Rotation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, Duration) == 0x00003C, "Member 'KismetSystemLibrary_DrawDebugBox::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugBox, Thickness) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugBox::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCamera
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_DrawDebugCamera final
{
public:
	const class ACameraActor*                     CameraActor;                                       // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           CameraColor;                                       // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCamera) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCamera");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCamera) == 0x000020, "Wrong size on KismetSystemLibrary_DrawDebugCamera");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCamera, CameraActor) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCamera::CameraActor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCamera, CameraColor) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCamera::CameraColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCamera, Duration) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugCamera::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCapsule
// 0x0040 (0x0040 - 0x0000)
struct KismetSystemLibrary_DrawDebugCapsule final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HalfHeight;                                        // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x001C(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0028(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCapsule) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCapsule");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCapsule) == 0x000040, "Wrong size on KismetSystemLibrary_DrawDebugCapsule");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCapsule::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, Center) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCapsule::Center' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, HalfHeight) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugCapsule::HalfHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, Radius) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugCapsule::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, Rotation) == 0x00001C, "Member 'KismetSystemLibrary_DrawDebugCapsule::Rotation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, LineColor) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugCapsule::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, Duration) == 0x000038, "Member 'KismetSystemLibrary_DrawDebugCapsule::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCapsule, Thickness) == 0x00003C, "Member 'KismetSystemLibrary_DrawDebugCapsule::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCircle
// 0x0050 (0x0050 - 0x0000)
struct KismetSystemLibrary_DrawDebugCircle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSegments;                                       // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x001C(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                YAxis;                                             // 0x0034(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ZAxis;                                             // 0x0040(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDrawAxis;                                         // 0x004C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4D[0x3];                                       // 0x004D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCircle) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCircle");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCircle) == 0x000050, "Wrong size on KismetSystemLibrary_DrawDebugCircle");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCircle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, Center) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCircle::Center' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, Radius) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugCircle::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, NumSegments) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugCircle::NumSegments' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, LineColor) == 0x00001C, "Member 'KismetSystemLibrary_DrawDebugCircle::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, Duration) == 0x00002C, "Member 'KismetSystemLibrary_DrawDebugCircle::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, Thickness) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugCircle::Thickness' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, YAxis) == 0x000034, "Member 'KismetSystemLibrary_DrawDebugCircle::YAxis' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, ZAxis) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugCircle::ZAxis' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCircle, bDrawAxis) == 0x00004C, "Member 'KismetSystemLibrary_DrawDebugCircle::bDrawAxis' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCone
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_DrawDebugCone final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0030(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCone) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCone");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCone) == 0x000048, "Wrong size on KismetSystemLibrary_DrawDebugCone");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCone::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, Origin) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCone::Origin' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, Direction) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugCone::Direction' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, Length) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugCone::Length' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, AngleWidth) == 0x000024, "Member 'KismetSystemLibrary_DrawDebugCone::AngleWidth' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, AngleHeight) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugCone::AngleHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, NumSides) == 0x00002C, "Member 'KismetSystemLibrary_DrawDebugCone::NumSides' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, LineColor) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugCone::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, Duration) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugCone::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCone, Thickness) == 0x000044, "Member 'KismetSystemLibrary_DrawDebugCone::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugConeInDegrees
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_DrawDebugConeInDegrees final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Direction;                                         // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Length;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleWidth;                                        // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AngleHeight;                                       // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         NumSides;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0030(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0044(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugConeInDegrees) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugConeInDegrees");
static_assert(sizeof(KismetSystemLibrary_DrawDebugConeInDegrees) == 0x000048, "Wrong size on KismetSystemLibrary_DrawDebugConeInDegrees");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, Origin) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::Origin' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, Direction) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::Direction' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, Length) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::Length' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, AngleWidth) == 0x000024, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::AngleWidth' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, AngleHeight) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::AngleHeight' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, NumSides) == 0x00002C, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::NumSides' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, LineColor) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, Duration) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugConeInDegrees, Thickness) == 0x000044, "Member 'KismetSystemLibrary_DrawDebugConeInDegrees::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCoordinateSystem
// 0x0030 (0x0030 - 0x0000)
struct KismetSystemLibrary_DrawDebugCoordinateSystem final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                AxisLoc;                                           // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               AxisRot;                                           // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Scale;                                             // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCoordinateSystem) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCoordinateSystem");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCoordinateSystem) == 0x000030, "Wrong size on KismetSystemLibrary_DrawDebugCoordinateSystem");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, AxisLoc) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::AxisLoc' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, AxisRot) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::AxisRot' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, Scale) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::Scale' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, Duration) == 0x000024, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCoordinateSystem, Thickness) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugCoordinateSystem::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugCylinder
// 0x0040 (0x0040 - 0x0000)
struct KismetSystemLibrary_DrawDebugCylinder final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0028(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x003C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugCylinder) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugCylinder");
static_assert(sizeof(KismetSystemLibrary_DrawDebugCylinder) == 0x000040, "Wrong size on KismetSystemLibrary_DrawDebugCylinder");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugCylinder::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, Start) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugCylinder::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, End) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugCylinder::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, Radius) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugCylinder::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, Segments) == 0x000024, "Member 'KismetSystemLibrary_DrawDebugCylinder::Segments' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, LineColor) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugCylinder::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, Duration) == 0x000038, "Member 'KismetSystemLibrary_DrawDebugCylinder::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugCylinder, Thickness) == 0x00003C, "Member 'KismetSystemLibrary_DrawDebugCylinder::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryLocation
// 0x0050 (0x0050 - 0x0000)
struct KismetSystemLibrary_DrawDebugFloatHistoryLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDebugFloatHistory                     FloatHistory;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	struct FVector                                DrawLocation;                                      // 0x0028(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawSize;                                          // 0x0034(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DrawColor;                                         // 0x003C(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x004C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugFloatHistoryLocation) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugFloatHistoryLocation");
static_assert(sizeof(KismetSystemLibrary_DrawDebugFloatHistoryLocation) == 0x000050, "Wrong size on KismetSystemLibrary_DrawDebugFloatHistoryLocation");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, FloatHistory) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::FloatHistory' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, DrawLocation) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::DrawLocation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, DrawSize) == 0x000034, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::DrawSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, DrawColor) == 0x00003C, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::DrawColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryLocation, Duration) == 0x00004C, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryLocation::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugFloatHistoryTransform
// 0x0080 (0x0080 - 0x0000)
struct KismetSystemLibrary_DrawDebugFloatHistoryTransform final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDebugFloatHistory                     FloatHistory;                                      // 0x0008(0x0020)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             DrawTransform;                                     // 0x0030(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector2D                              DrawSize;                                          // 0x0060(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           DrawColor;                                         // 0x0068(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0078(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7C[0x4];                                       // 0x007C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugFloatHistoryTransform) == 0x000010, "Wrong alignment on KismetSystemLibrary_DrawDebugFloatHistoryTransform");
static_assert(sizeof(KismetSystemLibrary_DrawDebugFloatHistoryTransform) == 0x000080, "Wrong size on KismetSystemLibrary_DrawDebugFloatHistoryTransform");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, FloatHistory) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::FloatHistory' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, DrawTransform) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::DrawTransform' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, DrawSize) == 0x000060, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::DrawSize' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, DrawColor) == 0x000068, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::DrawColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFloatHistoryTransform, Duration) == 0x000078, "Member 'KismetSystemLibrary_DrawDebugFloatHistoryTransform::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugFrustum
// 0x0060 (0x0060 - 0x0000)
struct KismetSystemLibrary_DrawDebugFrustum final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             FrustumTransform;                                  // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FLinearColor                           FrustumColor;                                      // 0x0040(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0050(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0054(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_58[0x8];                                       // 0x0058(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugFrustum) == 0x000010, "Wrong alignment on KismetSystemLibrary_DrawDebugFrustum");
static_assert(sizeof(KismetSystemLibrary_DrawDebugFrustum) == 0x000060, "Wrong size on KismetSystemLibrary_DrawDebugFrustum");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFrustum, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugFrustum::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFrustum, FrustumTransform) == 0x000010, "Member 'KismetSystemLibrary_DrawDebugFrustum::FrustumTransform' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFrustum, FrustumColor) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugFrustum::FrustumColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFrustum, Duration) == 0x000050, "Member 'KismetSystemLibrary_DrawDebugFrustum::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugFrustum, Thickness) == 0x000054, "Member 'KismetSystemLibrary_DrawDebugFrustum::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugLine
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_DrawDebugLine final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineStart;                                         // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LineEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x0020(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_DrawDebugLine) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugLine");
static_assert(sizeof(KismetSystemLibrary_DrawDebugLine) == 0x000038, "Wrong size on KismetSystemLibrary_DrawDebugLine");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugLine::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, LineStart) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugLine::LineStart' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, LineEnd) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugLine::LineEnd' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, LineColor) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugLine::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, Duration) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugLine::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugLine, Thickness) == 0x000034, "Member 'KismetSystemLibrary_DrawDebugLine::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugPlane
// 0x0050 (0x0050 - 0x0000)
struct KismetSystemLibrary_DrawDebugPlane final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FPlane                                 PlaneCoordinates;                                  // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0020(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PlaneColor;                                        // 0x0030(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0xC];                                       // 0x0044(0x000C)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugPlane) == 0x000010, "Wrong alignment on KismetSystemLibrary_DrawDebugPlane");
static_assert(sizeof(KismetSystemLibrary_DrawDebugPlane) == 0x000050, "Wrong size on KismetSystemLibrary_DrawDebugPlane");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugPlane::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, PlaneCoordinates) == 0x000010, "Member 'KismetSystemLibrary_DrawDebugPlane::PlaneCoordinates' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, Location) == 0x000020, "Member 'KismetSystemLibrary_DrawDebugPlane::Location' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, Size) == 0x00002C, "Member 'KismetSystemLibrary_DrawDebugPlane::Size' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, PlaneColor) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugPlane::PlaneColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPlane, Duration) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugPlane::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugPoint
// 0x0030 (0x0030 - 0x0000)
struct KismetSystemLibrary_DrawDebugPoint final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Position;                                          // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Size;                                              // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           PointColor;                                        // 0x0018(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0028(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugPoint) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugPoint");
static_assert(sizeof(KismetSystemLibrary_DrawDebugPoint) == 0x000030, "Wrong size on KismetSystemLibrary_DrawDebugPoint");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPoint, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugPoint::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPoint, Position) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugPoint::Position' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPoint, Size) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugPoint::Size' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPoint, PointColor) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugPoint::PointColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugPoint, Duration) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugPoint::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugSphere
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_DrawDebugSphere final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Center;                                            // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Segments;                                          // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           LineColor;                                         // 0x001C(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Thickness;                                         // 0x0030(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugSphere) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugSphere");
static_assert(sizeof(KismetSystemLibrary_DrawDebugSphere) == 0x000038, "Wrong size on KismetSystemLibrary_DrawDebugSphere");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugSphere::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, Center) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugSphere::Center' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, Radius) == 0x000014, "Member 'KismetSystemLibrary_DrawDebugSphere::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, Segments) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugSphere::Segments' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, LineColor) == 0x00001C, "Member 'KismetSystemLibrary_DrawDebugSphere::LineColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, Duration) == 0x00002C, "Member 'KismetSystemLibrary_DrawDebugSphere::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugSphere, Thickness) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugSphere::Thickness' has a wrong offset!");

// Function Engine.KismetSystemLibrary.DrawDebugString
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_DrawDebugString final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TextLocation;                                      // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 TestBaseActor;                                     // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TextColor;                                         // 0x0030(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0040(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_DrawDebugString) == 0x000008, "Wrong alignment on KismetSystemLibrary_DrawDebugString");
static_assert(sizeof(KismetSystemLibrary_DrawDebugString) == 0x000048, "Wrong size on KismetSystemLibrary_DrawDebugString");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_DrawDebugString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, TextLocation) == 0x000008, "Member 'KismetSystemLibrary_DrawDebugString::TextLocation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, Text) == 0x000018, "Member 'KismetSystemLibrary_DrawDebugString::Text' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, TestBaseActor) == 0x000028, "Member 'KismetSystemLibrary_DrawDebugString::TestBaseActor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, TextColor) == 0x000030, "Member 'KismetSystemLibrary_DrawDebugString::TextColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_DrawDebugString, Duration) == 0x000040, "Member 'KismetSystemLibrary_DrawDebugString::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_EqualEqual_PrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        A;                                                 // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        B;                                                 // 0x0010(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_EqualEqual_PrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_EqualEqual_PrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_EqualEqual_PrimaryAssetId) == 0x000028, "Wrong size on KismetSystemLibrary_EqualEqual_PrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetId, A) == 0x000000, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetId::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetId, B) == 0x000010, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetId::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetId, ReturnValue) == 0x000020, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.EqualEqual_PrimaryAssetType
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_EqualEqual_PrimaryAssetType final
{
public:
	struct FPrimaryAssetType                      A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetType                      B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_EqualEqual_PrimaryAssetType) == 0x000008, "Wrong alignment on KismetSystemLibrary_EqualEqual_PrimaryAssetType");
static_assert(sizeof(KismetSystemLibrary_EqualEqual_PrimaryAssetType) == 0x000018, "Wrong size on KismetSystemLibrary_EqualEqual_PrimaryAssetType");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetType, A) == 0x000000, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetType::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetType, B) == 0x000008, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetType::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_PrimaryAssetType, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_EqualEqual_PrimaryAssetType::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.EqualEqual_SoftClassReference
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_EqualEqual_SoftClassReference final
{
public:
	TSoftClassPtr<class UClass>                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_EqualEqual_SoftClassReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_EqualEqual_SoftClassReference");
static_assert(sizeof(KismetSystemLibrary_EqualEqual_SoftClassReference) == 0x000038, "Wrong size on KismetSystemLibrary_EqualEqual_SoftClassReference");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftClassReference, A) == 0x000000, "Member 'KismetSystemLibrary_EqualEqual_SoftClassReference::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftClassReference, B) == 0x000018, "Member 'KismetSystemLibrary_EqualEqual_SoftClassReference::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftClassReference, ReturnValue) == 0x000030, "Member 'KismetSystemLibrary_EqualEqual_SoftClassReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.EqualEqual_SoftObjectReference
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_EqualEqual_SoftObjectReference final
{
public:
	TSoftObjectPtr<class UObject>                 A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_EqualEqual_SoftObjectReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_EqualEqual_SoftObjectReference");
static_assert(sizeof(KismetSystemLibrary_EqualEqual_SoftObjectReference) == 0x000038, "Wrong size on KismetSystemLibrary_EqualEqual_SoftObjectReference");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftObjectReference, A) == 0x000000, "Member 'KismetSystemLibrary_EqualEqual_SoftObjectReference::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftObjectReference, B) == 0x000018, "Member 'KismetSystemLibrary_EqualEqual_SoftObjectReference::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_EqualEqual_SoftObjectReference, ReturnValue) == 0x000030, "Member 'KismetSystemLibrary_EqualEqual_SoftObjectReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ExecuteConsoleCommand
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_ExecuteConsoleCommand final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Command;                                           // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      SpecificPlayer;                                    // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_ExecuteConsoleCommand) == 0x000008, "Wrong alignment on KismetSystemLibrary_ExecuteConsoleCommand");
static_assert(sizeof(KismetSystemLibrary_ExecuteConsoleCommand) == 0x000020, "Wrong size on KismetSystemLibrary_ExecuteConsoleCommand");
static_assert(offsetof(KismetSystemLibrary_ExecuteConsoleCommand, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_ExecuteConsoleCommand::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ExecuteConsoleCommand, Command) == 0x000008, "Member 'KismetSystemLibrary_ExecuteConsoleCommand::Command' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ExecuteConsoleCommand, SpecificPlayer) == 0x000018, "Member 'KismetSystemLibrary_ExecuteConsoleCommand::SpecificPlayer' has a wrong offset!");

// Function Engine.KismetSystemLibrary.FlushDebugStrings
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_FlushDebugStrings final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_FlushDebugStrings) == 0x000008, "Wrong alignment on KismetSystemLibrary_FlushDebugStrings");
static_assert(sizeof(KismetSystemLibrary_FlushDebugStrings) == 0x000008, "Wrong size on KismetSystemLibrary_FlushDebugStrings");
static_assert(offsetof(KismetSystemLibrary_FlushDebugStrings, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_FlushDebugStrings::WorldContextObject' has a wrong offset!");

// Function Engine.KismetSystemLibrary.FlushPersistentDebugLines
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_FlushPersistentDebugLines final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_FlushPersistentDebugLines) == 0x000008, "Wrong alignment on KismetSystemLibrary_FlushPersistentDebugLines");
static_assert(sizeof(KismetSystemLibrary_FlushPersistentDebugLines) == 0x000008, "Wrong size on KismetSystemLibrary_FlushPersistentDebugLines");
static_assert(offsetof(KismetSystemLibrary_FlushPersistentDebugLines, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_FlushPersistentDebugLines::WorldContextObject' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetActorBounds
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_GetActorBounds final
{
public:
	const class AActor*                           Actor;                                             // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetActorBounds) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetActorBounds");
static_assert(sizeof(KismetSystemLibrary_GetActorBounds) == 0x000020, "Wrong size on KismetSystemLibrary_GetActorBounds");
static_assert(offsetof(KismetSystemLibrary_GetActorBounds, Actor) == 0x000000, "Member 'KismetSystemLibrary_GetActorBounds::Actor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetActorBounds, Origin) == 0x000008, "Member 'KismetSystemLibrary_GetActorBounds::Origin' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetActorBounds, BoxExtent) == 0x000014, "Member 'KismetSystemLibrary_GetActorBounds::BoxExtent' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetActorListFromComponentList
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetActorListFromComponentList final
{
public:
	TArray<class UPrimitiveComponent*>            ComponentList;                                     // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, ContainsInstancedReference, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActorList;                                      // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetActorListFromComponentList) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetActorListFromComponentList");
static_assert(sizeof(KismetSystemLibrary_GetActorListFromComponentList) == 0x000028, "Wrong size on KismetSystemLibrary_GetActorListFromComponentList");
static_assert(offsetof(KismetSystemLibrary_GetActorListFromComponentList, ComponentList) == 0x000000, "Member 'KismetSystemLibrary_GetActorListFromComponentList::ComponentList' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetActorListFromComponentList, ActorClassFilter) == 0x000010, "Member 'KismetSystemLibrary_GetActorListFromComponentList::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetActorListFromComponentList, OutActorList) == 0x000018, "Member 'KismetSystemLibrary_GetActorListFromComponentList::OutActorList' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetAdIDCount
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_GetAdIDCount final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetAdIDCount) == 0x000004, "Wrong alignment on KismetSystemLibrary_GetAdIDCount");
static_assert(sizeof(KismetSystemLibrary_GetAdIDCount) == 0x000004, "Wrong size on KismetSystemLibrary_GetAdIDCount");
static_assert(offsetof(KismetSystemLibrary_GetAdIDCount, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetAdIDCount::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetClassDisplayName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetClassDisplayName final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetClassDisplayName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetClassDisplayName");
static_assert(sizeof(KismetSystemLibrary_GetClassDisplayName) == 0x000018, "Wrong size on KismetSystemLibrary_GetClassDisplayName");
static_assert(offsetof(KismetSystemLibrary_GetClassDisplayName, Class_0) == 0x000000, "Member 'KismetSystemLibrary_GetClassDisplayName::Class_0' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetClassDisplayName, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetClassDisplayName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetClassFromPrimaryAssetId
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetClassFromPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetClassFromPrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetClassFromPrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_GetClassFromPrimaryAssetId) == 0x000018, "Wrong size on KismetSystemLibrary_GetClassFromPrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_GetClassFromPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_GetClassFromPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetClassFromPrimaryAssetId, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetClassFromPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetCommandLine
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetCommandLine final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetCommandLine) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetCommandLine");
static_assert(sizeof(KismetSystemLibrary_GetCommandLine) == 0x000010, "Wrong size on KismetSystemLibrary_GetCommandLine");
static_assert(offsetof(KismetSystemLibrary_GetCommandLine, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetCommandLine::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetComponentBounds
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetComponentBounds final
{
public:
	const class USceneComponent*                  Component;                                         // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                BoxExtent;                                         // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_GetComponentBounds) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetComponentBounds");
static_assert(sizeof(KismetSystemLibrary_GetComponentBounds) == 0x000028, "Wrong size on KismetSystemLibrary_GetComponentBounds");
static_assert(offsetof(KismetSystemLibrary_GetComponentBounds, Component) == 0x000000, "Member 'KismetSystemLibrary_GetComponentBounds::Component' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetComponentBounds, Origin) == 0x000008, "Member 'KismetSystemLibrary_GetComponentBounds::Origin' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetComponentBounds, BoxExtent) == 0x000014, "Member 'KismetSystemLibrary_GetComponentBounds::BoxExtent' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetComponentBounds, SphereRadius) == 0x000020, "Member 'KismetSystemLibrary_GetComponentBounds::SphereRadius' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetConvenientWindowedResolutions
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetConvenientWindowedResolutions final
{
public:
	TArray<struct FIntPoint>                      Resolutions;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_GetConvenientWindowedResolutions) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetConvenientWindowedResolutions");
static_assert(sizeof(KismetSystemLibrary_GetConvenientWindowedResolutions) == 0x000018, "Wrong size on KismetSystemLibrary_GetConvenientWindowedResolutions");
static_assert(offsetof(KismetSystemLibrary_GetConvenientWindowedResolutions, Resolutions) == 0x000000, "Member 'KismetSystemLibrary_GetConvenientWindowedResolutions::Resolutions' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetConvenientWindowedResolutions, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetConvenientWindowedResolutions::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetCurrentBundleState
// 0x0030 (0x0030 - 0x0000)
struct KismetSystemLibrary_GetCurrentBundleState final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceCurrentState;                                // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FName>                           OutBundles;                                        // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_GetCurrentBundleState) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetCurrentBundleState");
static_assert(sizeof(KismetSystemLibrary_GetCurrentBundleState) == 0x000030, "Wrong size on KismetSystemLibrary_GetCurrentBundleState");
static_assert(offsetof(KismetSystemLibrary_GetCurrentBundleState, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_GetCurrentBundleState::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetCurrentBundleState, bForceCurrentState) == 0x000010, "Member 'KismetSystemLibrary_GetCurrentBundleState::bForceCurrentState' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetCurrentBundleState, OutBundles) == 0x000018, "Member 'KismetSystemLibrary_GetCurrentBundleState::OutBundles' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetCurrentBundleState, ReturnValue) == 0x000028, "Member 'KismetSystemLibrary_GetCurrentBundleState::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetDefaultLanguage
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetDefaultLanguage final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetDefaultLanguage) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetDefaultLanguage");
static_assert(sizeof(KismetSystemLibrary_GetDefaultLanguage) == 0x000010, "Wrong size on KismetSystemLibrary_GetDefaultLanguage");
static_assert(offsetof(KismetSystemLibrary_GetDefaultLanguage, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetDefaultLanguage::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetDefaultLocale
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetDefaultLocale final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetDefaultLocale) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetDefaultLocale");
static_assert(sizeof(KismetSystemLibrary_GetDefaultLocale) == 0x000010, "Wrong size on KismetSystemLibrary_GetDefaultLocale");
static_assert(offsetof(KismetSystemLibrary_GetDefaultLocale, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetDefaultLocale::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetDeviceId
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetDeviceId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetDeviceId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetDeviceId");
static_assert(sizeof(KismetSystemLibrary_GetDeviceId) == 0x000010, "Wrong size on KismetSystemLibrary_GetDeviceId");
static_assert(offsetof(KismetSystemLibrary_GetDeviceId, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetDeviceId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetDisplayName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetDisplayName final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetDisplayName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetDisplayName");
static_assert(sizeof(KismetSystemLibrary_GetDisplayName) == 0x000018, "Wrong size on KismetSystemLibrary_GetDisplayName");
static_assert(offsetof(KismetSystemLibrary_GetDisplayName, Object) == 0x000000, "Member 'KismetSystemLibrary_GetDisplayName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetDisplayName, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetDisplayName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetEngineVersion
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetEngineVersion final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetEngineVersion) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetEngineVersion");
static_assert(sizeof(KismetSystemLibrary_GetEngineVersion) == 0x000010, "Wrong size on KismetSystemLibrary_GetEngineVersion");
static_assert(offsetof(KismetSystemLibrary_GetEngineVersion, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetEngineVersion::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetGameBundleId
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetGameBundleId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetGameBundleId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetGameBundleId");
static_assert(sizeof(KismetSystemLibrary_GetGameBundleId) == 0x000010, "Wrong size on KismetSystemLibrary_GetGameBundleId");
static_assert(offsetof(KismetSystemLibrary_GetGameBundleId, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetGameBundleId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetGameName
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetGameName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetGameName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetGameName");
static_assert(sizeof(KismetSystemLibrary_GetGameName) == 0x000010, "Wrong size on KismetSystemLibrary_GetGameName");
static_assert(offsetof(KismetSystemLibrary_GetGameName, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetGameName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetGameTimeInSeconds
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetGameTimeInSeconds final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_GetGameTimeInSeconds) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetGameTimeInSeconds");
static_assert(sizeof(KismetSystemLibrary_GetGameTimeInSeconds) == 0x000010, "Wrong size on KismetSystemLibrary_GetGameTimeInSeconds");
static_assert(offsetof(KismetSystemLibrary_GetGameTimeInSeconds, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_GetGameTimeInSeconds::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetGameTimeInSeconds, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetGameTimeInSeconds::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetLocalCurrencyCode
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetLocalCurrencyCode final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetLocalCurrencyCode) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetLocalCurrencyCode");
static_assert(sizeof(KismetSystemLibrary_GetLocalCurrencyCode) == 0x000010, "Wrong size on KismetSystemLibrary_GetLocalCurrencyCode");
static_assert(offsetof(KismetSystemLibrary_GetLocalCurrencyCode, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetLocalCurrencyCode::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetLocalCurrencySymbol
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetLocalCurrencySymbol final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetLocalCurrencySymbol) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetLocalCurrencySymbol");
static_assert(sizeof(KismetSystemLibrary_GetLocalCurrencySymbol) == 0x000010, "Wrong size on KismetSystemLibrary_GetLocalCurrencySymbol");
static_assert(offsetof(KismetSystemLibrary_GetLocalCurrencySymbol, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetLocalCurrencySymbol::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetLongPackageFName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_GetLongPackageFName final
{
public:
	TSoftObjectPtr<class UObject>                 Asset;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetLongPackageFName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetLongPackageFName");
static_assert(sizeof(KismetSystemLibrary_GetLongPackageFName) == 0x000020, "Wrong size on KismetSystemLibrary_GetLongPackageFName");
static_assert(offsetof(KismetSystemLibrary_GetLongPackageFName, Asset) == 0x000000, "Member 'KismetSystemLibrary_GetLongPackageFName::Asset' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetLongPackageFName, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_GetLongPackageFName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetLongPackageName
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetLongPackageName final
{
public:
	TSoftObjectPtr<class UObject>                 Asset;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetLongPackageName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetLongPackageName");
static_assert(sizeof(KismetSystemLibrary_GetLongPackageName) == 0x000028, "Wrong size on KismetSystemLibrary_GetLongPackageName");
static_assert(offsetof(KismetSystemLibrary_GetLongPackageName, Asset) == 0x000000, "Member 'KismetSystemLibrary_GetLongPackageName::Asset' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetLongPackageName, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_GetLongPackageName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetMinYResolutionFor3DView
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_GetMinYResolutionFor3DView final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetMinYResolutionFor3DView) == 0x000004, "Wrong alignment on KismetSystemLibrary_GetMinYResolutionFor3DView");
static_assert(sizeof(KismetSystemLibrary_GetMinYResolutionFor3DView) == 0x000004, "Wrong size on KismetSystemLibrary_GetMinYResolutionFor3DView");
static_assert(offsetof(KismetSystemLibrary_GetMinYResolutionFor3DView, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetMinYResolutionFor3DView::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetMinYResolutionForUI
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_GetMinYResolutionForUI final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetMinYResolutionForUI) == 0x000004, "Wrong alignment on KismetSystemLibrary_GetMinYResolutionForUI");
static_assert(sizeof(KismetSystemLibrary_GetMinYResolutionForUI) == 0x000004, "Wrong size on KismetSystemLibrary_GetMinYResolutionForUI");
static_assert(offsetof(KismetSystemLibrary_GetMinYResolutionForUI, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetMinYResolutionForUI::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetObjectFromPrimaryAssetId
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetObjectFromPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetObjectFromPrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetObjectFromPrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_GetObjectFromPrimaryAssetId) == 0x000018, "Wrong size on KismetSystemLibrary_GetObjectFromPrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_GetObjectFromPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_GetObjectFromPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetObjectFromPrimaryAssetId, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetObjectFromPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetObjectName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetObjectName final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetObjectName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetObjectName");
static_assert(sizeof(KismetSystemLibrary_GetObjectName) == 0x000018, "Wrong size on KismetSystemLibrary_GetObjectName");
static_assert(offsetof(KismetSystemLibrary_GetObjectName, Object) == 0x000000, "Member 'KismetSystemLibrary_GetObjectName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetObjectName, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetObjectName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPathName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetPathName final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPathName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPathName");
static_assert(sizeof(KismetSystemLibrary_GetPathName) == 0x000018, "Wrong size on KismetSystemLibrary_GetPathName");
static_assert(offsetof(KismetSystemLibrary_GetPathName, Object) == 0x000000, "Member 'KismetSystemLibrary_GetPathName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPathName, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetPathName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPlatformUserName
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetPlatformUserName final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPlatformUserName) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPlatformUserName");
static_assert(sizeof(KismetSystemLibrary_GetPlatformUserName) == 0x000010, "Wrong size on KismetSystemLibrary_GetPlatformUserName");
static_assert(offsetof(KismetSystemLibrary_GetPlatformUserName, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetPlatformUserName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPreferredLanguages
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetPreferredLanguages final
{
public:
	TArray<class FString>                         ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPreferredLanguages) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPreferredLanguages");
static_assert(sizeof(KismetSystemLibrary_GetPreferredLanguages) == 0x000010, "Wrong size on KismetSystemLibrary_GetPreferredLanguages");
static_assert(offsetof(KismetSystemLibrary_GetPreferredLanguages, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetPreferredLanguages::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromClass
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetIdFromClass final
{
public:
	TSubclassOf<class UObject>                    Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetIdFromClass) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetIdFromClass");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetIdFromClass) == 0x000018, "Wrong size on KismetSystemLibrary_GetPrimaryAssetIdFromClass");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromClass, Class_0) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromClass::Class_0' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromClass, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromObject
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetIdFromObject final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetIdFromObject) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetIdFromObject");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetIdFromObject) == 0x000018, "Wrong size on KismetSystemLibrary_GetPrimaryAssetIdFromObject");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromObject, Object) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromObject::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromObject, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromObject::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftClassReference
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference final
{
public:
	TSoftClassPtr<class UClass>                   SoftClassReference;                                // 0x0000(0x0018)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference) == 0x000028, "Wrong size on KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference, SoftClassReference) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference::SoftClassReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromSoftClassReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdFromSoftObjectReference
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference final
{
public:
	TSoftObjectPtr<class UObject>                 SoftObjectReference;                               // 0x0000(0x0018)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ReturnParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference) == 0x000028, "Wrong size on KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference, SoftObjectReference) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference::SoftObjectReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_GetPrimaryAssetIdFromSoftObjectReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetIdList
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetIdList final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                OutPrimaryAssetIdList;                             // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetIdList) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetIdList");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetIdList) == 0x000018, "Wrong size on KismetSystemLibrary_GetPrimaryAssetIdList");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdList, PrimaryAssetType) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetIdList::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetIdList, OutPrimaryAssetIdList) == 0x000008, "Member 'KismetSystemLibrary_GetPrimaryAssetIdList::OutPrimaryAssetIdList' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetPrimaryAssetsWithBundleState
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_GetPrimaryAssetsWithBundleState final
{
public:
	TArray<class FName>                           RequiredBundles;                                   // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class FName>                           ExcludedBundles;                                   // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetType>              ValidTypes;                                        // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bForceCurrentState;                                // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FPrimaryAssetId>                OutPrimaryAssetIdList;                             // 0x0038(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetPrimaryAssetsWithBundleState");
static_assert(sizeof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState) == 0x000048, "Wrong size on KismetSystemLibrary_GetPrimaryAssetsWithBundleState");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState, RequiredBundles) == 0x000000, "Member 'KismetSystemLibrary_GetPrimaryAssetsWithBundleState::RequiredBundles' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState, ExcludedBundles) == 0x000010, "Member 'KismetSystemLibrary_GetPrimaryAssetsWithBundleState::ExcludedBundles' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState, ValidTypes) == 0x000020, "Member 'KismetSystemLibrary_GetPrimaryAssetsWithBundleState::ValidTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState, bForceCurrentState) == 0x000030, "Member 'KismetSystemLibrary_GetPrimaryAssetsWithBundleState::bForceCurrentState' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetPrimaryAssetsWithBundleState, OutPrimaryAssetIdList) == 0x000038, "Member 'KismetSystemLibrary_GetPrimaryAssetsWithBundleState::OutPrimaryAssetIdList' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetRenderingDetailMode
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_GetRenderingDetailMode final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetRenderingDetailMode) == 0x000004, "Wrong alignment on KismetSystemLibrary_GetRenderingDetailMode");
static_assert(sizeof(KismetSystemLibrary_GetRenderingDetailMode) == 0x000004, "Wrong size on KismetSystemLibrary_GetRenderingDetailMode");
static_assert(offsetof(KismetSystemLibrary_GetRenderingDetailMode, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetRenderingDetailMode::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetRenderingMaterialQualityLevel
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_GetRenderingMaterialQualityLevel final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetRenderingMaterialQualityLevel) == 0x000004, "Wrong alignment on KismetSystemLibrary_GetRenderingMaterialQualityLevel");
static_assert(sizeof(KismetSystemLibrary_GetRenderingMaterialQualityLevel) == 0x000004, "Wrong size on KismetSystemLibrary_GetRenderingMaterialQualityLevel");
static_assert(offsetof(KismetSystemLibrary_GetRenderingMaterialQualityLevel, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetRenderingMaterialQualityLevel::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetSoftClassReferenceFromPrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId) == 0x000028, "Wrong size on KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetSoftClassReferenceFromPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetSoftObjectReferenceFromPrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId) == 0x000028, "Wrong size on KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetSoftObjectReferenceFromPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetSupportedFullscreenResolutions
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_GetSupportedFullscreenResolutions final
{
public:
	TArray<struct FIntPoint>                      Resolutions;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_GetSupportedFullscreenResolutions) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetSupportedFullscreenResolutions");
static_assert(sizeof(KismetSystemLibrary_GetSupportedFullscreenResolutions) == 0x000018, "Wrong size on KismetSystemLibrary_GetSupportedFullscreenResolutions");
static_assert(offsetof(KismetSystemLibrary_GetSupportedFullscreenResolutions, Resolutions) == 0x000000, "Member 'KismetSystemLibrary_GetSupportedFullscreenResolutions::Resolutions' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_GetSupportedFullscreenResolutions, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_GetSupportedFullscreenResolutions::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetUniqueDeviceId
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_GetUniqueDeviceId final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetUniqueDeviceId) == 0x000008, "Wrong alignment on KismetSystemLibrary_GetUniqueDeviceId");
static_assert(sizeof(KismetSystemLibrary_GetUniqueDeviceId) == 0x000010, "Wrong size on KismetSystemLibrary_GetUniqueDeviceId");
static_assert(offsetof(KismetSystemLibrary_GetUniqueDeviceId, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetUniqueDeviceId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.GetVolumeButtonsHandledBySystem
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_GetVolumeButtonsHandledBySystem final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_GetVolumeButtonsHandledBySystem) == 0x000001, "Wrong alignment on KismetSystemLibrary_GetVolumeButtonsHandledBySystem");
static_assert(sizeof(KismetSystemLibrary_GetVolumeButtonsHandledBySystem) == 0x000001, "Wrong size on KismetSystemLibrary_GetVolumeButtonsHandledBySystem");
static_assert(offsetof(KismetSystemLibrary_GetVolumeButtonsHandledBySystem, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_GetVolumeButtonsHandledBySystem::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsControllerAssignedToGamepad
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_IsControllerAssignedToGamepad final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsControllerAssignedToGamepad) == 0x000004, "Wrong alignment on KismetSystemLibrary_IsControllerAssignedToGamepad");
static_assert(sizeof(KismetSystemLibrary_IsControllerAssignedToGamepad) == 0x000008, "Wrong size on KismetSystemLibrary_IsControllerAssignedToGamepad");
static_assert(offsetof(KismetSystemLibrary_IsControllerAssignedToGamepad, ControllerId) == 0x000000, "Member 'KismetSystemLibrary_IsControllerAssignedToGamepad::ControllerId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsControllerAssignedToGamepad, ReturnValue) == 0x000004, "Member 'KismetSystemLibrary_IsControllerAssignedToGamepad::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsDedicatedServer
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsDedicatedServer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsDedicatedServer) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsDedicatedServer");
static_assert(sizeof(KismetSystemLibrary_IsDedicatedServer) == 0x000010, "Wrong size on KismetSystemLibrary_IsDedicatedServer");
static_assert(offsetof(KismetSystemLibrary_IsDedicatedServer, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_IsDedicatedServer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsDedicatedServer, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsDedicatedServer::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsInterstitialAdAvailable
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_IsInterstitialAdAvailable final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_IsInterstitialAdAvailable) == 0x000001, "Wrong alignment on KismetSystemLibrary_IsInterstitialAdAvailable");
static_assert(sizeof(KismetSystemLibrary_IsInterstitialAdAvailable) == 0x000001, "Wrong size on KismetSystemLibrary_IsInterstitialAdAvailable");
static_assert(offsetof(KismetSystemLibrary_IsInterstitialAdAvailable, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_IsInterstitialAdAvailable::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsInterstitialAdRequested
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_IsInterstitialAdRequested final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_IsInterstitialAdRequested) == 0x000001, "Wrong alignment on KismetSystemLibrary_IsInterstitialAdRequested");
static_assert(sizeof(KismetSystemLibrary_IsInterstitialAdRequested) == 0x000001, "Wrong size on KismetSystemLibrary_IsInterstitialAdRequested");
static_assert(offsetof(KismetSystemLibrary_IsInterstitialAdRequested, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_IsInterstitialAdRequested::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsLoggedIn
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsLoggedIn final
{
public:
	class APlayerController*                      SpecificPlayer;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsLoggedIn) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsLoggedIn");
static_assert(sizeof(KismetSystemLibrary_IsLoggedIn) == 0x000010, "Wrong size on KismetSystemLibrary_IsLoggedIn");
static_assert(offsetof(KismetSystemLibrary_IsLoggedIn, SpecificPlayer) == 0x000000, "Member 'KismetSystemLibrary_IsLoggedIn::SpecificPlayer' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsLoggedIn, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsLoggedIn::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsPackagedForDistribution
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_IsPackagedForDistribution final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_IsPackagedForDistribution) == 0x000001, "Wrong alignment on KismetSystemLibrary_IsPackagedForDistribution");
static_assert(sizeof(KismetSystemLibrary_IsPackagedForDistribution) == 0x000001, "Wrong size on KismetSystemLibrary_IsPackagedForDistribution");
static_assert(offsetof(KismetSystemLibrary_IsPackagedForDistribution, ReturnValue) == 0x000000, "Member 'KismetSystemLibrary_IsPackagedForDistribution::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsServer
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsServer final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsServer) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsServer");
static_assert(sizeof(KismetSystemLibrary_IsServer) == 0x000010, "Wrong size on KismetSystemLibrary_IsServer");
static_assert(offsetof(KismetSystemLibrary_IsServer, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_IsServer::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsServer, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsServer::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsStandalone
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsStandalone final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsStandalone) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsStandalone");
static_assert(sizeof(KismetSystemLibrary_IsStandalone) == 0x000010, "Wrong size on KismetSystemLibrary_IsStandalone");
static_assert(offsetof(KismetSystemLibrary_IsStandalone, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_IsStandalone::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsStandalone, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsStandalone::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValid
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsValid final
{
public:
	const class UObject*                          Object;                                            // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValid) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValid");
static_assert(sizeof(KismetSystemLibrary_IsValid) == 0x000010, "Wrong size on KismetSystemLibrary_IsValid");
static_assert(offsetof(KismetSystemLibrary_IsValid, Object) == 0x000000, "Member 'KismetSystemLibrary_IsValid::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValid, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsValid::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValidClass
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsValidClass final
{
public:
	class UClass*                                 Class_0;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValidClass) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValidClass");
static_assert(sizeof(KismetSystemLibrary_IsValidClass) == 0x000010, "Wrong size on KismetSystemLibrary_IsValidClass");
static_assert(offsetof(KismetSystemLibrary_IsValidClass, Class_0) == 0x000000, "Member 'KismetSystemLibrary_IsValidClass::Class_0' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValidClass, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsValidClass::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetId
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_IsValidPrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValidPrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValidPrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_IsValidPrimaryAssetId) == 0x000018, "Wrong size on KismetSystemLibrary_IsValidPrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_IsValidPrimaryAssetId, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_IsValidPrimaryAssetId::PrimaryAssetId' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValidPrimaryAssetId, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_IsValidPrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValidPrimaryAssetType
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_IsValidPrimaryAssetType final
{
public:
	struct FPrimaryAssetType                      PrimaryAssetType;                                  // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValidPrimaryAssetType) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValidPrimaryAssetType");
static_assert(sizeof(KismetSystemLibrary_IsValidPrimaryAssetType) == 0x000010, "Wrong size on KismetSystemLibrary_IsValidPrimaryAssetType");
static_assert(offsetof(KismetSystemLibrary_IsValidPrimaryAssetType, PrimaryAssetType) == 0x000000, "Member 'KismetSystemLibrary_IsValidPrimaryAssetType::PrimaryAssetType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValidPrimaryAssetType, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_IsValidPrimaryAssetType::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValidSoftClassReference
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_IsValidSoftClassReference final
{
public:
	TSoftClassPtr<class UClass>                   SoftClassReference;                                // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValidSoftClassReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValidSoftClassReference");
static_assert(sizeof(KismetSystemLibrary_IsValidSoftClassReference) == 0x000020, "Wrong size on KismetSystemLibrary_IsValidSoftClassReference");
static_assert(offsetof(KismetSystemLibrary_IsValidSoftClassReference, SoftClassReference) == 0x000000, "Member 'KismetSystemLibrary_IsValidSoftClassReference::SoftClassReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValidSoftClassReference, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_IsValidSoftClassReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.IsValidSoftObjectReference
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_IsValidSoftObjectReference final
{
public:
	TSoftObjectPtr<class UObject>                 SoftObjectReference;                               // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_IsValidSoftObjectReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_IsValidSoftObjectReference");
static_assert(sizeof(KismetSystemLibrary_IsValidSoftObjectReference) == 0x000020, "Wrong size on KismetSystemLibrary_IsValidSoftObjectReference");
static_assert(offsetof(KismetSystemLibrary_IsValidSoftObjectReference, SoftObjectReference) == 0x000000, "Member 'KismetSystemLibrary_IsValidSoftObjectReference::SoftObjectReference' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_IsValidSoftObjectReference, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_IsValidSoftObjectReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_ClearAndInvalidateTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_ClearAndInvalidateTimerHandle::Handle' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_ClearTimer
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_ClearTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_ClearTimer) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_ClearTimer");
static_assert(sizeof(KismetSystemLibrary_K2_ClearTimer) == 0x000018, "Wrong size on KismetSystemLibrary_K2_ClearTimer");
static_assert(offsetof(KismetSystemLibrary_K2_ClearTimer, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_ClearTimer::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_ClearTimer, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_ClearTimer::FunctionName' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_ClearTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_ClearTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_ClearTimerDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_ClearTimerDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_ClearTimerDelegate) == 0x000010, "Wrong size on KismetSystemLibrary_K2_ClearTimerDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_ClearTimerDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_ClearTimerDelegate::Delegate' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_ClearTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_ClearTimerHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_ClearTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_ClearTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_ClearTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_ClearTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_ClearTimerHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_ClearTimerHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_ClearTimerHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_ClearTimerHandle::Handle' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTime
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerElapsedTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerElapsedTime) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_GetTimerElapsedTime");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerElapsedTime) == 0x000020, "Wrong size on KismetSystemLibrary_K2_GetTimerElapsedTime");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTime, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTime::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTime, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTime::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTime, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeDelegate
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate) == 0x000018, "Wrong size on KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTimeDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerElapsedTimeHandle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerElapsedTimeHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerElapsedTimeHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_GetTimerElapsedTimeHandle");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerElapsedTimeHandle) == 0x000018, "Wrong size on KismetSystemLibrary_K2_GetTimerElapsedTimeHandle");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTimeHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTimeHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTimeHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerElapsedTimeHandle, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_GetTimerElapsedTimeHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTime
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerRemainingTime final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0018(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerRemainingTime) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_GetTimerRemainingTime");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerRemainingTime) == 0x000020, "Wrong size on KismetSystemLibrary_K2_GetTimerRemainingTime");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTime, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTime::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTime, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTime::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTime, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeDelegate
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate) == 0x000018, "Wrong size on KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTimeDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_GetTimerRemainingTimeHandle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_GetTimerRemainingTimeHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_GetTimerRemainingTimeHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_GetTimerRemainingTimeHandle");
static_assert(sizeof(KismetSystemLibrary_K2_GetTimerRemainingTimeHandle) == 0x000018, "Wrong size on KismetSystemLibrary_K2_GetTimerRemainingTimeHandle");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTimeHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTimeHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTimeHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTimeHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_GetTimerRemainingTimeHandle, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_GetTimerRemainingTimeHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_InvalidateTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_InvalidateTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	struct FTimerHandle                           ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_InvalidateTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_InvalidateTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_InvalidateTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_InvalidateTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_InvalidateTimerHandle, Handle) == 0x000000, "Member 'KismetSystemLibrary_K2_InvalidateTimerHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_InvalidateTimerHandle, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_K2_InvalidateTimerHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerActive
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerActive final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerActive) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_IsTimerActive");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerActive) == 0x000020, "Wrong size on KismetSystemLibrary_K2_IsTimerActive");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActive, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerActive::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActive, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_IsTimerActive::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActive, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_IsTimerActive::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerActiveDelegate
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerActiveDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerActiveDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_IsTimerActiveDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerActiveDelegate) == 0x000018, "Wrong size on KismetSystemLibrary_K2_IsTimerActiveDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActiveDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerActiveDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActiveDelegate, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_IsTimerActiveDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerActiveHandle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerActiveHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerActiveHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_IsTimerActiveHandle");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerActiveHandle) == 0x000018, "Wrong size on KismetSystemLibrary_K2_IsTimerActiveHandle");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActiveHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerActiveHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActiveHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_IsTimerActiveHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerActiveHandle, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_IsTimerActiveHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerPaused
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerPaused final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerPaused) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_IsTimerPaused");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerPaused) == 0x000020, "Wrong size on KismetSystemLibrary_K2_IsTimerPaused");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPaused, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerPaused::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPaused, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_IsTimerPaused::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPaused, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_IsTimerPaused::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerPausedDelegate
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerPausedDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerPausedDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_IsTimerPausedDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerPausedDelegate) == 0x000018, "Wrong size on KismetSystemLibrary_K2_IsTimerPausedDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPausedDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerPausedDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPausedDelegate, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_IsTimerPausedDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsTimerPausedHandle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_IsTimerPausedHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsTimerPausedHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_IsTimerPausedHandle");
static_assert(sizeof(KismetSystemLibrary_K2_IsTimerPausedHandle) == 0x000018, "Wrong size on KismetSystemLibrary_K2_IsTimerPausedHandle");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPausedHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_IsTimerPausedHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPausedHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_IsTimerPausedHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsTimerPausedHandle, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_IsTimerPausedHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_IsValidTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_IsValidTimerHandle final
{
public:
	struct FTimerHandle                           Handle;                                            // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_IsValidTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_IsValidTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_IsValidTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_IsValidTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_IsValidTimerHandle, Handle) == 0x000000, "Member 'KismetSystemLibrary_K2_IsValidTimerHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_IsValidTimerHandle, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_K2_IsValidTimerHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_PauseTimer
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_PauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_PauseTimer) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_PauseTimer");
static_assert(sizeof(KismetSystemLibrary_K2_PauseTimer) == 0x000018, "Wrong size on KismetSystemLibrary_K2_PauseTimer");
static_assert(offsetof(KismetSystemLibrary_K2_PauseTimer, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_PauseTimer::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_PauseTimer, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_PauseTimer::FunctionName' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_PauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_PauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_PauseTimerDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_PauseTimerDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_PauseTimerDelegate) == 0x000010, "Wrong size on KismetSystemLibrary_K2_PauseTimerDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_PauseTimerDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_PauseTimerDelegate::Delegate' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_PauseTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_PauseTimerHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_PauseTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_PauseTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_PauseTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_PauseTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_PauseTimerHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_PauseTimerHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_PauseTimerHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_PauseTimerHandle::Handle' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_SetTimer
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_K2_SetTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ReturnValue;                                       // 0x0020(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_SetTimer) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_SetTimer");
static_assert(sizeof(KismetSystemLibrary_K2_SetTimer) == 0x000028, "Wrong size on KismetSystemLibrary_K2_SetTimer");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimer, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_SetTimer::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimer, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_SetTimer::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimer, Time) == 0x000018, "Member 'KismetSystemLibrary_K2_SetTimer::Time' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimer, bLooping) == 0x00001C, "Member 'KismetSystemLibrary_K2_SetTimer::bLooping' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimer, ReturnValue) == 0x000020, "Member 'KismetSystemLibrary_K2_SetTimer::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_SetTimerDelegate
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_SetTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	float                                         Time;                                              // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLooping;                                          // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           ReturnValue;                                       // 0x0018(0x0008)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_SetTimerDelegate) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_SetTimerDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_SetTimerDelegate) == 0x000020, "Wrong size on KismetSystemLibrary_K2_SetTimerDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimerDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_SetTimerDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimerDelegate, Time) == 0x000010, "Member 'KismetSystemLibrary_K2_SetTimerDelegate::Time' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimerDelegate, bLooping) == 0x000014, "Member 'KismetSystemLibrary_K2_SetTimerDelegate::bLooping' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_SetTimerDelegate, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_SetTimerDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_TimerExists
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_K2_TimerExists final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_TimerExists) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_TimerExists");
static_assert(sizeof(KismetSystemLibrary_K2_TimerExists) == 0x000020, "Wrong size on KismetSystemLibrary_K2_TimerExists");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExists, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_TimerExists::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExists, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_TimerExists::FunctionName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExists, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_K2_TimerExists::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_TimerExistsDelegate
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_TimerExistsDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_TimerExistsDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_TimerExistsDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_TimerExistsDelegate) == 0x000018, "Wrong size on KismetSystemLibrary_K2_TimerExistsDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExistsDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_TimerExistsDelegate::Delegate' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExistsDelegate, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_TimerExistsDelegate::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_TimerExistsHandle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_TimerExistsHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_K2_TimerExistsHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_TimerExistsHandle");
static_assert(sizeof(KismetSystemLibrary_K2_TimerExistsHandle) == 0x000018, "Wrong size on KismetSystemLibrary_K2_TimerExistsHandle");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExistsHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_TimerExistsHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExistsHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_TimerExistsHandle::Handle' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_TimerExistsHandle, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_K2_TimerExistsHandle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_UnPauseTimer
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_K2_UnPauseTimer final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 FunctionName;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_UnPauseTimer) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_UnPauseTimer");
static_assert(sizeof(KismetSystemLibrary_K2_UnPauseTimer) == 0x000018, "Wrong size on KismetSystemLibrary_K2_UnPauseTimer");
static_assert(offsetof(KismetSystemLibrary_K2_UnPauseTimer, Object) == 0x000000, "Member 'KismetSystemLibrary_K2_UnPauseTimer::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_UnPauseTimer, FunctionName) == 0x000008, "Member 'KismetSystemLibrary_K2_UnPauseTimer::FunctionName' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_UnPauseTimerDelegate
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_UnPauseTimerDelegate final
{
public:
	TDelegate<void()>                             Delegate;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_UnPauseTimerDelegate) == 0x000004, "Wrong alignment on KismetSystemLibrary_K2_UnPauseTimerDelegate");
static_assert(sizeof(KismetSystemLibrary_K2_UnPauseTimerDelegate) == 0x000010, "Wrong size on KismetSystemLibrary_K2_UnPauseTimerDelegate");
static_assert(offsetof(KismetSystemLibrary_K2_UnPauseTimerDelegate, Delegate) == 0x000000, "Member 'KismetSystemLibrary_K2_UnPauseTimerDelegate::Delegate' has a wrong offset!");

// Function Engine.KismetSystemLibrary.K2_UnPauseTimerHandle
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_K2_UnPauseTimerHandle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimerHandle                           Handle;                                            // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_K2_UnPauseTimerHandle) == 0x000008, "Wrong alignment on KismetSystemLibrary_K2_UnPauseTimerHandle");
static_assert(sizeof(KismetSystemLibrary_K2_UnPauseTimerHandle) == 0x000010, "Wrong size on KismetSystemLibrary_K2_UnPauseTimerHandle");
static_assert(offsetof(KismetSystemLibrary_K2_UnPauseTimerHandle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_K2_UnPauseTimerHandle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_K2_UnPauseTimerHandle, Handle) == 0x000008, "Member 'KismetSystemLibrary_K2_UnPauseTimerHandle::Handle' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LaunchURL
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_LaunchURL final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_LaunchURL) == 0x000008, "Wrong alignment on KismetSystemLibrary_LaunchURL");
static_assert(sizeof(KismetSystemLibrary_LaunchURL) == 0x000010, "Wrong size on KismetSystemLibrary_LaunchURL");
static_assert(offsetof(KismetSystemLibrary_LaunchURL, URL) == 0x000000, "Member 'KismetSystemLibrary_LaunchURL::URL' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceMulti
// 0x0080 (0x0080 - 0x0000)
struct KismetSystemLibrary_LineTraceMulti final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0054(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0064(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceMulti) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceMulti");
static_assert(sizeof(KismetSystemLibrary_LineTraceMulti) == 0x000080, "Wrong size on KismetSystemLibrary_LineTraceMulti");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceMulti::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceMulti::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceMulti::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, TraceChannel) == 0x000020, "Member 'KismetSystemLibrary_LineTraceMulti::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, bTraceComplex) == 0x000021, "Member 'KismetSystemLibrary_LineTraceMulti::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, ActorsToIgnore) == 0x000028, "Member 'KismetSystemLibrary_LineTraceMulti::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, DrawDebugType) == 0x000038, "Member 'KismetSystemLibrary_LineTraceMulti::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, OutHits) == 0x000040, "Member 'KismetSystemLibrary_LineTraceMulti::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, bIgnoreSelf) == 0x000050, "Member 'KismetSystemLibrary_LineTraceMulti::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, TraceColor) == 0x000054, "Member 'KismetSystemLibrary_LineTraceMulti::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, TraceHitColor) == 0x000064, "Member 'KismetSystemLibrary_LineTraceMulti::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, DrawTime) == 0x000074, "Member 'KismetSystemLibrary_LineTraceMulti::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMulti, ReturnValue) == 0x000078, "Member 'KismetSystemLibrary_LineTraceMulti::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceMultiByProfile
// 0x0088 (0x0088 - 0x0000)
struct KismetSystemLibrary_LineTraceMultiByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0048(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0058(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x005C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x006C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x007C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0080(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_81[0x7];                                       // 0x0081(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceMultiByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceMultiByProfile");
static_assert(sizeof(KismetSystemLibrary_LineTraceMultiByProfile) == 0x000088, "Wrong size on KismetSystemLibrary_LineTraceMultiByProfile");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, ProfileName) == 0x000020, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, bTraceComplex) == 0x000028, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, DrawDebugType) == 0x000040, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, OutHits) == 0x000048, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, bIgnoreSelf) == 0x000058, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, TraceColor) == 0x00005C, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, TraceHitColor) == 0x00006C, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, DrawTime) == 0x00007C, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiByProfile, ReturnValue) == 0x000080, "Member 'KismetSystemLibrary_LineTraceMultiByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceMultiForObjects
// 0x0090 (0x0090 - 0x0000)
struct KismetSystemLibrary_LineTraceMultiForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0064(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0074(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceMultiForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceMultiForObjects");
static_assert(sizeof(KismetSystemLibrary_LineTraceMultiForObjects) == 0x000090, "Wrong size on KismetSystemLibrary_LineTraceMultiForObjects");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, OutHits) == 0x000050, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, bIgnoreSelf) == 0x000060, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, TraceColor) == 0x000064, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, TraceHitColor) == 0x000074, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, DrawTime) == 0x000084, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceMultiForObjects, ReturnValue) == 0x000088, "Member 'KismetSystemLibrary_LineTraceMultiForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceSingle
// 0x00F8 (0x00F8 - 0x0000)
struct KismetSystemLibrary_LineTraceSingle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x6];                                       // 0x0022(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0040(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00C8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00CC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00DC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00EC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceSingle) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceSingle");
static_assert(sizeof(KismetSystemLibrary_LineTraceSingle) == 0x0000F8, "Wrong size on KismetSystemLibrary_LineTraceSingle");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceSingle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceSingle::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceSingle::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, TraceChannel) == 0x000020, "Member 'KismetSystemLibrary_LineTraceSingle::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, bTraceComplex) == 0x000021, "Member 'KismetSystemLibrary_LineTraceSingle::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, ActorsToIgnore) == 0x000028, "Member 'KismetSystemLibrary_LineTraceSingle::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, DrawDebugType) == 0x000038, "Member 'KismetSystemLibrary_LineTraceSingle::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, OutHit) == 0x000040, "Member 'KismetSystemLibrary_LineTraceSingle::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, bIgnoreSelf) == 0x0000C8, "Member 'KismetSystemLibrary_LineTraceSingle::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, TraceColor) == 0x0000CC, "Member 'KismetSystemLibrary_LineTraceSingle::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, TraceHitColor) == 0x0000DC, "Member 'KismetSystemLibrary_LineTraceSingle::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, DrawTime) == 0x0000EC, "Member 'KismetSystemLibrary_LineTraceSingle::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingle, ReturnValue) == 0x0000F0, "Member 'KismetSystemLibrary_LineTraceSingle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceSingleByProfile
// 0x0100 (0x0100 - 0x0000)
struct KismetSystemLibrary_LineTraceSingleByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0048(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00D0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D1[0x3];                                       // 0x00D1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00D4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00E4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00F4(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F8(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F9[0x7];                                       // 0x00F9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceSingleByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceSingleByProfile");
static_assert(sizeof(KismetSystemLibrary_LineTraceSingleByProfile) == 0x000100, "Wrong size on KismetSystemLibrary_LineTraceSingleByProfile");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, ProfileName) == 0x000020, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, bTraceComplex) == 0x000028, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, DrawDebugType) == 0x000040, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, OutHit) == 0x000048, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, bIgnoreSelf) == 0x0000D0, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, TraceColor) == 0x0000D4, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, TraceHitColor) == 0x0000E4, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, DrawTime) == 0x0000F4, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleByProfile, ReturnValue) == 0x0000F8, "Member 'KismetSystemLibrary_LineTraceSingleByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LineTraceSingleForObjects
// 0x0108 (0x0108 - 0x0000)
struct KismetSystemLibrary_LineTraceSingleForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0020(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0050(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00D8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00DC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00EC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00FC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_LineTraceSingleForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_LineTraceSingleForObjects");
static_assert(sizeof(KismetSystemLibrary_LineTraceSingleForObjects) == 0x000108, "Wrong size on KismetSystemLibrary_LineTraceSingleForObjects");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, ObjectTypes) == 0x000020, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, OutHit) == 0x000050, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, bIgnoreSelf) == 0x0000D8, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, TraceColor) == 0x0000DC, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, TraceHitColor) == 0x0000EC, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, DrawTime) == 0x0000FC, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LineTraceSingleForObjects, ReturnValue) == 0x000100, "Member 'KismetSystemLibrary_LineTraceSingleForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LoadAsset
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_LoadAsset final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Asset;                                             // 0x0008(0x0018)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(class UObject* Loaded)>        OnLoaded;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0030(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_LoadAsset) == 0x000008, "Wrong alignment on KismetSystemLibrary_LoadAsset");
static_assert(sizeof(KismetSystemLibrary_LoadAsset) == 0x000048, "Wrong size on KismetSystemLibrary_LoadAsset");
static_assert(offsetof(KismetSystemLibrary_LoadAsset, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LoadAsset::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAsset, Asset) == 0x000008, "Member 'KismetSystemLibrary_LoadAsset::Asset' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAsset, OnLoaded) == 0x000020, "Member 'KismetSystemLibrary_LoadAsset::OnLoaded' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAsset, LatentInfo) == 0x000030, "Member 'KismetSystemLibrary_LoadAsset::LatentInfo' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LoadAssetClass
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_LoadAssetClass final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AssetClass;                                        // 0x0008(0x0018)(Parm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TDelegate<void(TSubclassOf<class UObject> Loaded)> OnLoaded;                                          // 0x0020(0x0010)(Parm, ZeroConstructor, NoDestructor, NativeAccessSpecifierPublic)
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0030(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_LoadAssetClass) == 0x000008, "Wrong alignment on KismetSystemLibrary_LoadAssetClass");
static_assert(sizeof(KismetSystemLibrary_LoadAssetClass) == 0x000048, "Wrong size on KismetSystemLibrary_LoadAssetClass");
static_assert(offsetof(KismetSystemLibrary_LoadAssetClass, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_LoadAssetClass::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAssetClass, AssetClass) == 0x000008, "Member 'KismetSystemLibrary_LoadAssetClass::AssetClass' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAssetClass, OnLoaded) == 0x000020, "Member 'KismetSystemLibrary_LoadAssetClass::OnLoaded' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_LoadAssetClass, LatentInfo) == 0x000030, "Member 'KismetSystemLibrary_LoadAssetClass::LatentInfo' has a wrong offset!");

// Function Engine.KismetSystemLibrary.LoadInterstitialAd
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_LoadInterstitialAd final
{
public:
	int32                                         AdIdIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_LoadInterstitialAd) == 0x000004, "Wrong alignment on KismetSystemLibrary_LoadInterstitialAd");
static_assert(sizeof(KismetSystemLibrary_LoadInterstitialAd) == 0x000004, "Wrong size on KismetSystemLibrary_LoadInterstitialAd");
static_assert(offsetof(KismetSystemLibrary_LoadInterstitialAd, AdIdIndex) == 0x000000, "Member 'KismetSystemLibrary_LoadInterstitialAd::AdIdIndex' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralBool
// 0x0002 (0x0002 - 0x0000)
struct KismetSystemLibrary_MakeLiteralBool final
{
public:
	bool                                          Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralBool) == 0x000001, "Wrong alignment on KismetSystemLibrary_MakeLiteralBool");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralBool) == 0x000002, "Wrong size on KismetSystemLibrary_MakeLiteralBool");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralBool, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralBool::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralBool, ReturnValue) == 0x000001, "Member 'KismetSystemLibrary_MakeLiteralBool::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralByte
// 0x0002 (0x0002 - 0x0000)
struct KismetSystemLibrary_MakeLiteralByte final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         ReturnValue;                                       // 0x0001(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralByte) == 0x000001, "Wrong alignment on KismetSystemLibrary_MakeLiteralByte");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralByte) == 0x000002, "Wrong size on KismetSystemLibrary_MakeLiteralByte");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralByte, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralByte::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralByte, ReturnValue) == 0x000001, "Member 'KismetSystemLibrary_MakeLiteralByte::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralFloat
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_MakeLiteralFloat final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralFloat) == 0x000004, "Wrong alignment on KismetSystemLibrary_MakeLiteralFloat");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralFloat) == 0x000008, "Wrong size on KismetSystemLibrary_MakeLiteralFloat");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralFloat, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralFloat::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralFloat, ReturnValue) == 0x000004, "Member 'KismetSystemLibrary_MakeLiteralFloat::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralInt
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_MakeLiteralInt final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralInt) == 0x000004, "Wrong alignment on KismetSystemLibrary_MakeLiteralInt");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralInt) == 0x000008, "Wrong size on KismetSystemLibrary_MakeLiteralInt");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralInt, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralInt::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralInt, ReturnValue) == 0x000004, "Member 'KismetSystemLibrary_MakeLiteralInt::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralName
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_MakeLiteralName final
{
public:
	class FName                                   Value;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralName) == 0x000004, "Wrong alignment on KismetSystemLibrary_MakeLiteralName");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralName) == 0x000010, "Wrong size on KismetSystemLibrary_MakeLiteralName");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralName, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralName::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralName, ReturnValue) == 0x000008, "Member 'KismetSystemLibrary_MakeLiteralName::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralString
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_MakeLiteralString final
{
public:
	class FString                                 Value;                                             // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralString) == 0x000008, "Wrong alignment on KismetSystemLibrary_MakeLiteralString");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralString) == 0x000020, "Wrong size on KismetSystemLibrary_MakeLiteralString");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralString, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralString::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralString, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_MakeLiteralString::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeLiteralText
// 0x0030 (0x0030 - 0x0000)
struct KismetSystemLibrary_MakeLiteralText final
{
public:
	class FText                                   Value;                                             // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeLiteralText) == 0x000008, "Wrong alignment on KismetSystemLibrary_MakeLiteralText");
static_assert(sizeof(KismetSystemLibrary_MakeLiteralText) == 0x000030, "Wrong size on KismetSystemLibrary_MakeLiteralText");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralText, Value) == 0x000000, "Member 'KismetSystemLibrary_MakeLiteralText::Value' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeLiteralText, ReturnValue) == 0x000018, "Member 'KismetSystemLibrary_MakeLiteralText::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MakeSoftObjectPath
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_MakeSoftObjectPath final
{
public:
	class FString                                 PathString;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSoftObjectPath                        ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MakeSoftObjectPath) == 0x000008, "Wrong alignment on KismetSystemLibrary_MakeSoftObjectPath");
static_assert(sizeof(KismetSystemLibrary_MakeSoftObjectPath) == 0x000018, "Wrong size on KismetSystemLibrary_MakeSoftObjectPath");
static_assert(offsetof(KismetSystemLibrary_MakeSoftObjectPath, PathString) == 0x000000, "Member 'KismetSystemLibrary_MakeSoftObjectPath::PathString' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MakeSoftObjectPath, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_MakeSoftObjectPath::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MarkModify
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_MarkModify final
{
public:
	class UObject*                                ObjectToModify;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MarkModify) == 0x000008, "Wrong alignment on KismetSystemLibrary_MarkModify");
static_assert(sizeof(KismetSystemLibrary_MarkModify) == 0x000008, "Wrong size on KismetSystemLibrary_MarkModify");
static_assert(offsetof(KismetSystemLibrary_MarkModify, ObjectToModify) == 0x000000, "Member 'KismetSystemLibrary_MarkModify::ObjectToModify' has a wrong offset!");

// Function Engine.KismetSystemLibrary.MoveComponentTo
// 0x0048 (0x0048 - 0x0000)
struct KismetSystemLibrary_MoveComponentTo final
{
public:
	class USceneComponent*                        Component;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                TargetRelativeLocation;                            // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               TargetRelativeRotation;                            // 0x0014(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bEaseOut;                                          // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEaseIn;                                           // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         OverTime;                                          // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceShortestRotationPath;                        // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EMoveComponentAction                          MoveAction;                                        // 0x0029(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A[0x6];                                       // 0x002A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0030(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_MoveComponentTo) == 0x000008, "Wrong alignment on KismetSystemLibrary_MoveComponentTo");
static_assert(sizeof(KismetSystemLibrary_MoveComponentTo) == 0x000048, "Wrong size on KismetSystemLibrary_MoveComponentTo");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, Component) == 0x000000, "Member 'KismetSystemLibrary_MoveComponentTo::Component' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, TargetRelativeLocation) == 0x000008, "Member 'KismetSystemLibrary_MoveComponentTo::TargetRelativeLocation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, TargetRelativeRotation) == 0x000014, "Member 'KismetSystemLibrary_MoveComponentTo::TargetRelativeRotation' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, bEaseOut) == 0x000020, "Member 'KismetSystemLibrary_MoveComponentTo::bEaseOut' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, bEaseIn) == 0x000021, "Member 'KismetSystemLibrary_MoveComponentTo::bEaseIn' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, OverTime) == 0x000024, "Member 'KismetSystemLibrary_MoveComponentTo::OverTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, bForceShortestRotationPath) == 0x000028, "Member 'KismetSystemLibrary_MoveComponentTo::bForceShortestRotationPath' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, MoveAction) == 0x000029, "Member 'KismetSystemLibrary_MoveComponentTo::MoveAction' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_MoveComponentTo, LatentInfo) == 0x000030, "Member 'KismetSystemLibrary_MoveComponentTo::LatentInfo' has a wrong offset!");

// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetId
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_NotEqual_PrimaryAssetId final
{
public:
	struct FPrimaryAssetId                        A;                                                 // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPrimaryAssetId                        B;                                                 // 0x0010(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0020(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_NotEqual_PrimaryAssetId) == 0x000008, "Wrong alignment on KismetSystemLibrary_NotEqual_PrimaryAssetId");
static_assert(sizeof(KismetSystemLibrary_NotEqual_PrimaryAssetId) == 0x000028, "Wrong size on KismetSystemLibrary_NotEqual_PrimaryAssetId");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetId, A) == 0x000000, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetId::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetId, B) == 0x000010, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetId::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetId, ReturnValue) == 0x000020, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetId::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.NotEqual_PrimaryAssetType
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_NotEqual_PrimaryAssetType final
{
public:
	struct FPrimaryAssetType                      A;                                                 // 0x0000(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	struct FPrimaryAssetType                      B;                                                 // 0x0008(0x0008)(Parm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0010(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_NotEqual_PrimaryAssetType) == 0x000008, "Wrong alignment on KismetSystemLibrary_NotEqual_PrimaryAssetType");
static_assert(sizeof(KismetSystemLibrary_NotEqual_PrimaryAssetType) == 0x000018, "Wrong size on KismetSystemLibrary_NotEqual_PrimaryAssetType");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetType, A) == 0x000000, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetType::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetType, B) == 0x000008, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetType::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_PrimaryAssetType, ReturnValue) == 0x000010, "Member 'KismetSystemLibrary_NotEqual_PrimaryAssetType::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.NotEqual_SoftClassReference
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_NotEqual_SoftClassReference final
{
public:
	TSoftClassPtr<class UClass>                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_NotEqual_SoftClassReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_NotEqual_SoftClassReference");
static_assert(sizeof(KismetSystemLibrary_NotEqual_SoftClassReference) == 0x000038, "Wrong size on KismetSystemLibrary_NotEqual_SoftClassReference");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftClassReference, A) == 0x000000, "Member 'KismetSystemLibrary_NotEqual_SoftClassReference::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftClassReference, B) == 0x000018, "Member 'KismetSystemLibrary_NotEqual_SoftClassReference::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftClassReference, ReturnValue) == 0x000030, "Member 'KismetSystemLibrary_NotEqual_SoftClassReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.NotEqual_SoftObjectReference
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_NotEqual_SoftObjectReference final
{
public:
	TSoftObjectPtr<class UObject>                 A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_NotEqual_SoftObjectReference) == 0x000008, "Wrong alignment on KismetSystemLibrary_NotEqual_SoftObjectReference");
static_assert(sizeof(KismetSystemLibrary_NotEqual_SoftObjectReference) == 0x000038, "Wrong size on KismetSystemLibrary_NotEqual_SoftObjectReference");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftObjectReference, A) == 0x000000, "Member 'KismetSystemLibrary_NotEqual_SoftObjectReference::A' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftObjectReference, B) == 0x000018, "Member 'KismetSystemLibrary_NotEqual_SoftObjectReference::B' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_NotEqual_SoftObjectReference, ReturnValue) == 0x000030, "Member 'KismetSystemLibrary_NotEqual_SoftObjectReference::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.PrintString
// 0x0030 (0x0030 - 0x0000)
struct KismetSystemLibrary_PrintString final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InString;                                          // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintToScreen;                                    // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintToLog;                                       // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x2];                                       // 0x001A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TextColor;                                         // 0x001C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x002C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_PrintString) == 0x000008, "Wrong alignment on KismetSystemLibrary_PrintString");
static_assert(sizeof(KismetSystemLibrary_PrintString) == 0x000030, "Wrong size on KismetSystemLibrary_PrintString");
static_assert(offsetof(KismetSystemLibrary_PrintString, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_PrintString::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintString, InString) == 0x000008, "Member 'KismetSystemLibrary_PrintString::InString' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintString, bPrintToScreen) == 0x000018, "Member 'KismetSystemLibrary_PrintString::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintString, bPrintToLog) == 0x000019, "Member 'KismetSystemLibrary_PrintString::bPrintToLog' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintString, TextColor) == 0x00001C, "Member 'KismetSystemLibrary_PrintString::TextColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintString, Duration) == 0x00002C, "Member 'KismetSystemLibrary_PrintString::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.PrintText
// 0x0038 (0x0038 - 0x0000)
struct KismetSystemLibrary_PrintText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   InText;                                            // 0x0008(0x0018)(ConstParm, Parm, NativeAccessSpecifierPublic)
	bool                                          bPrintToScreen;                                    // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bPrintToLog;                                       // 0x0021(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_22[0x2];                                       // 0x0022(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TextColor;                                         // 0x0024(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0034(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_PrintText) == 0x000008, "Wrong alignment on KismetSystemLibrary_PrintText");
static_assert(sizeof(KismetSystemLibrary_PrintText) == 0x000038, "Wrong size on KismetSystemLibrary_PrintText");
static_assert(offsetof(KismetSystemLibrary_PrintText, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_PrintText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintText, InText) == 0x000008, "Member 'KismetSystemLibrary_PrintText::InText' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintText, bPrintToScreen) == 0x000020, "Member 'KismetSystemLibrary_PrintText::bPrintToScreen' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintText, bPrintToLog) == 0x000021, "Member 'KismetSystemLibrary_PrintText::bPrintToLog' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintText, TextColor) == 0x000024, "Member 'KismetSystemLibrary_PrintText::TextColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_PrintText, Duration) == 0x000034, "Member 'KismetSystemLibrary_PrintText::Duration' has a wrong offset!");

// Function Engine.KismetSystemLibrary.PrintWarning
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_PrintWarning final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_PrintWarning) == 0x000008, "Wrong alignment on KismetSystemLibrary_PrintWarning");
static_assert(sizeof(KismetSystemLibrary_PrintWarning) == 0x000010, "Wrong size on KismetSystemLibrary_PrintWarning");
static_assert(offsetof(KismetSystemLibrary_PrintWarning, InString) == 0x000000, "Member 'KismetSystemLibrary_PrintWarning::InString' has a wrong offset!");

// Function Engine.KismetSystemLibrary.QuitGame
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_QuitGame final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class APlayerController*                      SpecificPlayer;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EQuitPreference                               QuitPreference;                                    // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_QuitGame) == 0x000008, "Wrong alignment on KismetSystemLibrary_QuitGame");
static_assert(sizeof(KismetSystemLibrary_QuitGame) == 0x000018, "Wrong size on KismetSystemLibrary_QuitGame");
static_assert(offsetof(KismetSystemLibrary_QuitGame, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_QuitGame::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_QuitGame, SpecificPlayer) == 0x000008, "Member 'KismetSystemLibrary_QuitGame::SpecificPlayer' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_QuitGame, QuitPreference) == 0x000010, "Member 'KismetSystemLibrary_QuitGame::QuitPreference' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ResetGamepadAssignmentToController
// 0x0004 (0x0004 - 0x0000)
struct KismetSystemLibrary_ResetGamepadAssignmentToController final
{
public:
	int32                                         ControllerId;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_ResetGamepadAssignmentToController) == 0x000004, "Wrong alignment on KismetSystemLibrary_ResetGamepadAssignmentToController");
static_assert(sizeof(KismetSystemLibrary_ResetGamepadAssignmentToController) == 0x000004, "Wrong size on KismetSystemLibrary_ResetGamepadAssignmentToController");
static_assert(offsetof(KismetSystemLibrary_ResetGamepadAssignmentToController, ControllerId) == 0x000000, "Member 'KismetSystemLibrary_ResetGamepadAssignmentToController::ControllerId' has a wrong offset!");

// Function Engine.KismetSystemLibrary.RetriggerableDelay
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_RetriggerableDelay final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Duration;                                          // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLatentActionInfo                      LatentInfo;                                        // 0x0010(0x0018)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_RetriggerableDelay) == 0x000008, "Wrong alignment on KismetSystemLibrary_RetriggerableDelay");
static_assert(sizeof(KismetSystemLibrary_RetriggerableDelay) == 0x000028, "Wrong size on KismetSystemLibrary_RetriggerableDelay");
static_assert(offsetof(KismetSystemLibrary_RetriggerableDelay, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_RetriggerableDelay::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_RetriggerableDelay, Duration) == 0x000008, "Member 'KismetSystemLibrary_RetriggerableDelay::Duration' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_RetriggerableDelay, LatentInfo) == 0x000010, "Member 'KismetSystemLibrary_RetriggerableDelay::LatentInfo' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetBoolPropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetBoolPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Value;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetBoolPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetBoolPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetBoolPropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetBoolPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetBoolPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetBoolPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetBoolPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetBoolPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetBoolPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetBoolPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetBytePropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetBytePropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Value;                                             // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetBytePropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetBytePropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetBytePropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetBytePropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetBytePropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetBytePropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetBytePropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetBytePropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetBytePropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetBytePropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetClassPropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetClassPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UObject>                    Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetClassPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetClassPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetClassPropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetClassPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetClassPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetClassPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetClassPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetClassPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetClassPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetClassPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetCollisionProfileNameProperty
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetCollisionProfileNameProperty final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCollisionProfileName                  Value;                                             // 0x0010(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetCollisionProfileNameProperty) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetCollisionProfileNameProperty");
static_assert(sizeof(KismetSystemLibrary_SetCollisionProfileNameProperty) == 0x000018, "Wrong size on KismetSystemLibrary_SetCollisionProfileNameProperty");
static_assert(offsetof(KismetSystemLibrary_SetCollisionProfileNameProperty, Object) == 0x000000, "Member 'KismetSystemLibrary_SetCollisionProfileNameProperty::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetCollisionProfileNameProperty, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetCollisionProfileNameProperty::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetCollisionProfileNameProperty, Value) == 0x000010, "Member 'KismetSystemLibrary_SetCollisionProfileNameProperty::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetFloatPropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetFloatPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetFloatPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetFloatPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetFloatPropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetFloatPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetFloatPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetFloatPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetFloatPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetFloatPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetFloatPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetFloatPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetInterfacePropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_SetInterfacePropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TScriptInterface<class IInterface>            Value;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetInterfacePropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetInterfacePropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetInterfacePropertyByName) == 0x000020, "Wrong size on KismetSystemLibrary_SetInterfacePropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetInterfacePropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetInterfacePropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetInterfacePropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetInterfacePropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetInterfacePropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetInterfacePropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetIntPropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetIntPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Value;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetIntPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetIntPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetIntPropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetIntPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetIntPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetIntPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetIntPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetIntPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetIntPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetIntPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetLinearColorPropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_SetLinearColorPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0010(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetLinearColorPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetLinearColorPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetLinearColorPropertyByName) == 0x000020, "Wrong size on KismetSystemLibrary_SetLinearColorPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetLinearColorPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetLinearColorPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetLinearColorPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetLinearColorPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetLinearColorPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetLinearColorPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetNamePropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetNamePropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   Value;                                             // 0x0010(0x0008)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetNamePropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetNamePropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetNamePropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetNamePropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetNamePropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetNamePropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetNamePropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetNamePropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetNamePropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetNamePropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetObjectPropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetObjectPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UObject*                                Value;                                             // 0x0010(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetObjectPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetObjectPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetObjectPropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetObjectPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetObjectPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetObjectPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetObjectPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetObjectPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetObjectPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetObjectPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetRotatorPropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_SetRotatorPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Value;                                             // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetRotatorPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetRotatorPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetRotatorPropertyByName) == 0x000020, "Wrong size on KismetSystemLibrary_SetRotatorPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetRotatorPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetRotatorPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetRotatorPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetRotatorPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetRotatorPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetRotatorPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetSoftClassPropertyByName
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_SetSoftClassPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   Value;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetSoftClassPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetSoftClassPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetSoftClassPropertyByName) == 0x000028, "Wrong size on KismetSystemLibrary_SetSoftClassPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetSoftClassPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetSoftClassPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetSoftClassPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetSoftClassPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetSoftClassPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetSoftClassPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetSoftObjectPropertyByName
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_SetSoftObjectPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UObject>                 Value;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetSoftObjectPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetSoftObjectPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetSoftObjectPropertyByName) == 0x000028, "Wrong size on KismetSystemLibrary_SetSoftObjectPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetSoftObjectPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetSoftObjectPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetSoftObjectPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetSoftObjectPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetSoftObjectPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetSoftObjectPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetStringPropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_SetStringPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetStringPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetStringPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetStringPropertyByName) == 0x000020, "Wrong size on KismetSystemLibrary_SetStringPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetStringPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetStringPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetStringPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetStringPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetStringPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetStringPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetStructurePropertyByName
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetStructurePropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGenericStruct                         Value;                                             // 0x0010(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetStructurePropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetStructurePropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetStructurePropertyByName) == 0x000018, "Wrong size on KismetSystemLibrary_SetStructurePropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetStructurePropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetStructurePropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetStructurePropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetStructurePropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetStructurePropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetStructurePropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetSuppressViewportTransitionMessage
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_SetSuppressViewportTransitionMessage final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bState;                                            // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetSuppressViewportTransitionMessage) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetSuppressViewportTransitionMessage");
static_assert(sizeof(KismetSystemLibrary_SetSuppressViewportTransitionMessage) == 0x000010, "Wrong size on KismetSystemLibrary_SetSuppressViewportTransitionMessage");
static_assert(offsetof(KismetSystemLibrary_SetSuppressViewportTransitionMessage, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SetSuppressViewportTransitionMessage::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetSuppressViewportTransitionMessage, bState) == 0x000008, "Member 'KismetSystemLibrary_SetSuppressViewportTransitionMessage::bState' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetTextPropertyByName
// 0x0028 (0x0028 - 0x0000)
struct KismetSystemLibrary_SetTextPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Value;                                             // 0x0010(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetTextPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetTextPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetTextPropertyByName) == 0x000028, "Wrong size on KismetSystemLibrary_SetTextPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetTextPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetTextPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetTextPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetTextPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetTextPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetTextPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetTransformPropertyByName
// 0x0040 (0x0040 - 0x0000)
struct KismetSystemLibrary_SetTransformPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTransform                             Value;                                             // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetTransformPropertyByName) == 0x000010, "Wrong alignment on KismetSystemLibrary_SetTransformPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetTransformPropertyByName) == 0x000040, "Wrong size on KismetSystemLibrary_SetTransformPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetTransformPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetTransformPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetTransformPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetTransformPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetTransformPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetTransformPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetUserActivity
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetUserActivity final
{
public:
	struct FUserActivity                          UserActivity;                                      // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetUserActivity) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetUserActivity");
static_assert(sizeof(KismetSystemLibrary_SetUserActivity) == 0x000018, "Wrong size on KismetSystemLibrary_SetUserActivity");
static_assert(offsetof(KismetSystemLibrary_SetUserActivity, UserActivity) == 0x000000, "Member 'KismetSystemLibrary_SetUserActivity::UserActivity' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetVectorPropertyByName
// 0x0020 (0x0020 - 0x0000)
struct KismetSystemLibrary_SetVectorPropertyByName final
{
public:
	class UObject*                                Object;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   PropertyName;                                      // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Value;                                             // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SetVectorPropertyByName) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetVectorPropertyByName");
static_assert(sizeof(KismetSystemLibrary_SetVectorPropertyByName) == 0x000020, "Wrong size on KismetSystemLibrary_SetVectorPropertyByName");
static_assert(offsetof(KismetSystemLibrary_SetVectorPropertyByName, Object) == 0x000000, "Member 'KismetSystemLibrary_SetVectorPropertyByName::Object' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetVectorPropertyByName, PropertyName) == 0x000008, "Member 'KismetSystemLibrary_SetVectorPropertyByName::PropertyName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SetVectorPropertyByName, Value) == 0x000010, "Member 'KismetSystemLibrary_SetVectorPropertyByName::Value' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetVolumeButtonsHandledBySystem
// 0x0001 (0x0001 - 0x0000)
struct KismetSystemLibrary_SetVolumeButtonsHandledBySystem final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetVolumeButtonsHandledBySystem) == 0x000001, "Wrong alignment on KismetSystemLibrary_SetVolumeButtonsHandledBySystem");
static_assert(sizeof(KismetSystemLibrary_SetVolumeButtonsHandledBySystem) == 0x000001, "Wrong size on KismetSystemLibrary_SetVolumeButtonsHandledBySystem");
static_assert(offsetof(KismetSystemLibrary_SetVolumeButtonsHandledBySystem, bEnabled) == 0x000000, "Member 'KismetSystemLibrary_SetVolumeButtonsHandledBySystem::bEnabled' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SetWindowTitle
// 0x0018 (0x0018 - 0x0000)
struct KismetSystemLibrary_SetWindowTitle final
{
public:
	class FText                                   Title;                                             // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_SetWindowTitle) == 0x000008, "Wrong alignment on KismetSystemLibrary_SetWindowTitle");
static_assert(sizeof(KismetSystemLibrary_SetWindowTitle) == 0x000018, "Wrong size on KismetSystemLibrary_SetWindowTitle");
static_assert(offsetof(KismetSystemLibrary_SetWindowTitle, Title) == 0x000000, "Member 'KismetSystemLibrary_SetWindowTitle::Title' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ShowAdBanner
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_ShowAdBanner final
{
public:
	int32                                         AdIdIndex;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnBottomOfScreen;                             // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_ShowAdBanner) == 0x000004, "Wrong alignment on KismetSystemLibrary_ShowAdBanner");
static_assert(sizeof(KismetSystemLibrary_ShowAdBanner) == 0x000008, "Wrong size on KismetSystemLibrary_ShowAdBanner");
static_assert(offsetof(KismetSystemLibrary_ShowAdBanner, AdIdIndex) == 0x000000, "Member 'KismetSystemLibrary_ShowAdBanner::AdIdIndex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_ShowAdBanner, bShowOnBottomOfScreen) == 0x000004, "Member 'KismetSystemLibrary_ShowAdBanner::bShowOnBottomOfScreen' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ShowPlatformSpecificAchievementsScreen
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen final
{
public:
	class APlayerController*                      SpecificPlayer;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen) == 0x000008, "Wrong alignment on KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen");
static_assert(sizeof(KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen) == 0x000008, "Wrong size on KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen");
static_assert(offsetof(KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen, SpecificPlayer) == 0x000000, "Member 'KismetSystemLibrary_ShowPlatformSpecificAchievementsScreen::SpecificPlayer' has a wrong offset!");

// Function Engine.KismetSystemLibrary.ShowPlatformSpecificLeaderboardScreen
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen final
{
public:
	class FString                                 CategoryName;                                      // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen) == 0x000008, "Wrong alignment on KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen");
static_assert(sizeof(KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen) == 0x000010, "Wrong size on KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen");
static_assert(offsetof(KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen, CategoryName) == 0x000000, "Member 'KismetSystemLibrary_ShowPlatformSpecificLeaderboardScreen::CategoryName' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereOverlapActors
// 0x0058 (0x0058 - 0x0000)
struct KismetSystemLibrary_SphereOverlapActors final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpherePos;                                         // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ActorClassFilter;                                  // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         OutActors;                                         // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereOverlapActors) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereOverlapActors");
static_assert(sizeof(KismetSystemLibrary_SphereOverlapActors) == 0x000058, "Wrong size on KismetSystemLibrary_SphereOverlapActors");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereOverlapActors::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, SpherePos) == 0x000008, "Member 'KismetSystemLibrary_SphereOverlapActors::SpherePos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, SphereRadius) == 0x000014, "Member 'KismetSystemLibrary_SphereOverlapActors::SphereRadius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, ObjectTypes) == 0x000018, "Member 'KismetSystemLibrary_SphereOverlapActors::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, ActorClassFilter) == 0x000028, "Member 'KismetSystemLibrary_SphereOverlapActors::ActorClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_SphereOverlapActors::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, OutActors) == 0x000040, "Member 'KismetSystemLibrary_SphereOverlapActors::OutActors' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapActors, ReturnValue) == 0x000050, "Member 'KismetSystemLibrary_SphereOverlapActors::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereOverlapComponents
// 0x0058 (0x0058 - 0x0000)
struct KismetSystemLibrary_SphereOverlapComponents final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                SpherePos;                                         // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SphereRadius;                                      // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0018(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	class UClass*                                 ComponentClassFilter;                              // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0030(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	TArray<class UPrimitiveComponent*>            OutComponents;                                     // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0050(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereOverlapComponents) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereOverlapComponents");
static_assert(sizeof(KismetSystemLibrary_SphereOverlapComponents) == 0x000058, "Wrong size on KismetSystemLibrary_SphereOverlapComponents");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereOverlapComponents::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, SpherePos) == 0x000008, "Member 'KismetSystemLibrary_SphereOverlapComponents::SpherePos' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, SphereRadius) == 0x000014, "Member 'KismetSystemLibrary_SphereOverlapComponents::SphereRadius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, ObjectTypes) == 0x000018, "Member 'KismetSystemLibrary_SphereOverlapComponents::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, ComponentClassFilter) == 0x000028, "Member 'KismetSystemLibrary_SphereOverlapComponents::ComponentClassFilter' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, ActorsToIgnore) == 0x000030, "Member 'KismetSystemLibrary_SphereOverlapComponents::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, OutComponents) == 0x000040, "Member 'KismetSystemLibrary_SphereOverlapComponents::OutComponents' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereOverlapComponents, ReturnValue) == 0x000050, "Member 'KismetSystemLibrary_SphereOverlapComponents::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceMulti
// 0x0080 (0x0080 - 0x0000)
struct KismetSystemLibrary_SphereTraceMulti final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0040(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x3];                                       // 0x0051(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0054(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0064(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0074(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0078(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceMulti) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceMulti");
static_assert(sizeof(KismetSystemLibrary_SphereTraceMulti) == 0x000080, "Wrong size on KismetSystemLibrary_SphereTraceMulti");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceMulti::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceMulti::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceMulti::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceMulti::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, TraceChannel) == 0x000024, "Member 'KismetSystemLibrary_SphereTraceMulti::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, bTraceComplex) == 0x000025, "Member 'KismetSystemLibrary_SphereTraceMulti::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, ActorsToIgnore) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceMulti::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, DrawDebugType) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceMulti::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, OutHits) == 0x000040, "Member 'KismetSystemLibrary_SphereTraceMulti::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, bIgnoreSelf) == 0x000050, "Member 'KismetSystemLibrary_SphereTraceMulti::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, TraceColor) == 0x000054, "Member 'KismetSystemLibrary_SphereTraceMulti::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, TraceHitColor) == 0x000064, "Member 'KismetSystemLibrary_SphereTraceMulti::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, DrawTime) == 0x000074, "Member 'KismetSystemLibrary_SphereTraceMulti::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMulti, ReturnValue) == 0x000078, "Member 'KismetSystemLibrary_SphereTraceMulti::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceMultiByProfile
// 0x0090 (0x0090 - 0x0000)
struct KismetSystemLibrary_SphereTraceMultiByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProfileName;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0050(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0060(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_61[0x3];                                       // 0x0061(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x0064(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x0074(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0084(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0088(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x7];                                       // 0x0089(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceMultiByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceMultiByProfile");
static_assert(sizeof(KismetSystemLibrary_SphereTraceMultiByProfile) == 0x000090, "Wrong size on KismetSystemLibrary_SphereTraceMultiByProfile");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, ProfileName) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, OutHits) == 0x000050, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, bIgnoreSelf) == 0x000060, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, TraceColor) == 0x000064, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, TraceHitColor) == 0x000074, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, DrawTime) == 0x000084, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiByProfile, ReturnValue) == 0x000088, "Member 'KismetSystemLibrary_SphereTraceMultiByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceMultiForObjects
// 0x0098 (0x0098 - 0x0000)
struct KismetSystemLibrary_SphereTraceMultiForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FHitResult>                     OutHits;                                           // 0x0058(0x0010)(Parm, OutParm, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x0068(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_69[0x3];                                       // 0x0069(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x006C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x007C(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x008C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0090(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceMultiForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceMultiForObjects");
static_assert(sizeof(KismetSystemLibrary_SphereTraceMultiForObjects) == 0x000098, "Wrong size on KismetSystemLibrary_SphereTraceMultiForObjects");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, ObjectTypes) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, bTraceComplex) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, OutHits) == 0x000058, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::OutHits' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, bIgnoreSelf) == 0x000068, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, TraceColor) == 0x00006C, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, TraceHitColor) == 0x00007C, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, DrawTime) == 0x00008C, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceMultiForObjects, ReturnValue) == 0x000090, "Member 'KismetSystemLibrary_SphereTraceMultiForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceSingle
// 0x00F8 (0x00F8 - 0x0000)
struct KismetSystemLibrary_SphereTraceSingle final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ETraceTypeQuery                               TraceChannel;                                      // 0x0024(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0025(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_26[0x2];                                       // 0x0026(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0040(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00C8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C9[0x3];                                       // 0x00C9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00CC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00DC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00EC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x00F0(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F1[0x7];                                       // 0x00F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceSingle) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceSingle");
static_assert(sizeof(KismetSystemLibrary_SphereTraceSingle) == 0x0000F8, "Wrong size on KismetSystemLibrary_SphereTraceSingle");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceSingle::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceSingle::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceSingle::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceSingle::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, TraceChannel) == 0x000024, "Member 'KismetSystemLibrary_SphereTraceSingle::TraceChannel' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, bTraceComplex) == 0x000025, "Member 'KismetSystemLibrary_SphereTraceSingle::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, ActorsToIgnore) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceSingle::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, DrawDebugType) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceSingle::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, OutHit) == 0x000040, "Member 'KismetSystemLibrary_SphereTraceSingle::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, bIgnoreSelf) == 0x0000C8, "Member 'KismetSystemLibrary_SphereTraceSingle::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, TraceColor) == 0x0000CC, "Member 'KismetSystemLibrary_SphereTraceSingle::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, TraceHitColor) == 0x0000DC, "Member 'KismetSystemLibrary_SphereTraceSingle::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, DrawTime) == 0x0000EC, "Member 'KismetSystemLibrary_SphereTraceSingle::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingle, ReturnValue) == 0x0000F0, "Member 'KismetSystemLibrary_SphereTraceSingle::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceSingleByProfile
// 0x0108 (0x0108 - 0x0000)
struct KismetSystemLibrary_SphereTraceSingleByProfile final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   ProfileName;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0038(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0048(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0050(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00D8(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D9[0x3];                                       // 0x00D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00DC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00EC(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x00FC(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0100(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_101[0x7];                                      // 0x0101(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceSingleByProfile) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceSingleByProfile");
static_assert(sizeof(KismetSystemLibrary_SphereTraceSingleByProfile) == 0x000108, "Wrong size on KismetSystemLibrary_SphereTraceSingleByProfile");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, ProfileName) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::ProfileName' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, bTraceComplex) == 0x000030, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, ActorsToIgnore) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, DrawDebugType) == 0x000048, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, OutHit) == 0x000050, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, bIgnoreSelf) == 0x0000D8, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, TraceColor) == 0x0000DC, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, TraceHitColor) == 0x0000EC, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, DrawTime) == 0x0000FC, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleByProfile, ReturnValue) == 0x000100, "Member 'KismetSystemLibrary_SphereTraceSingleByProfile::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.SphereTraceSingleForObjects
// 0x0110 (0x0110 - 0x0000)
struct KismetSystemLibrary_SphereTraceSingleForObjects final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Start;                                             // 0x0008(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                End;                                               // 0x0014(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      ObjectTypes;                                       // 0x0028(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bTraceComplex;                                     // 0x0038(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         ActorsToIgnore;                                    // 0x0040(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	EDrawDebugTrace                               DrawDebugType;                                     // 0x0050(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_51[0x7];                                       // 0x0051(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FHitResult                             OutHit;                                            // 0x0058(0x0088)(Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	bool                                          bIgnoreSelf;                                       // 0x00E0(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E1[0x3];                                       // 0x00E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           TraceColor;                                        // 0x00E4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           TraceHitColor;                                     // 0x00F4(0x0010)(Parm, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DrawTime;                                          // 0x0104(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0108(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetSystemLibrary_SphereTraceSingleForObjects) == 0x000008, "Wrong alignment on KismetSystemLibrary_SphereTraceSingleForObjects");
static_assert(sizeof(KismetSystemLibrary_SphereTraceSingleForObjects) == 0x000110, "Wrong size on KismetSystemLibrary_SphereTraceSingleForObjects");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, WorldContextObject) == 0x000000, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::WorldContextObject' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, Start) == 0x000008, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::Start' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, End) == 0x000014, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::End' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, Radius) == 0x000020, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::Radius' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, ObjectTypes) == 0x000028, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::ObjectTypes' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, bTraceComplex) == 0x000038, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::bTraceComplex' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, ActorsToIgnore) == 0x000040, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::ActorsToIgnore' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, DrawDebugType) == 0x000050, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::DrawDebugType' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, OutHit) == 0x000058, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::OutHit' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, bIgnoreSelf) == 0x0000E0, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::bIgnoreSelf' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, TraceColor) == 0x0000E4, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::TraceColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, TraceHitColor) == 0x0000F4, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::TraceHitColor' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, DrawTime) == 0x000104, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::DrawTime' has a wrong offset!");
static_assert(offsetof(KismetSystemLibrary_SphereTraceSingleForObjects, ReturnValue) == 0x000108, "Member 'KismetSystemLibrary_SphereTraceSingleForObjects::ReturnValue' has a wrong offset!");

// Function Engine.KismetSystemLibrary.UnloadPrimaryAsset
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_UnloadPrimaryAsset final
{
public:
	struct FPrimaryAssetId                        PrimaryAssetId;                                    // 0x0000(0x0010)(Parm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_UnloadPrimaryAsset) == 0x000008, "Wrong alignment on KismetSystemLibrary_UnloadPrimaryAsset");
static_assert(sizeof(KismetSystemLibrary_UnloadPrimaryAsset) == 0x000010, "Wrong size on KismetSystemLibrary_UnloadPrimaryAsset");
static_assert(offsetof(KismetSystemLibrary_UnloadPrimaryAsset, PrimaryAssetId) == 0x000000, "Member 'KismetSystemLibrary_UnloadPrimaryAsset::PrimaryAssetId' has a wrong offset!");

// Function Engine.KismetSystemLibrary.UnloadPrimaryAssetList
// 0x0010 (0x0010 - 0x0000)
struct KismetSystemLibrary_UnloadPrimaryAssetList final
{
public:
	TArray<struct FPrimaryAssetId>                PrimaryAssetIdList;                                // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_UnloadPrimaryAssetList) == 0x000008, "Wrong alignment on KismetSystemLibrary_UnloadPrimaryAssetList");
static_assert(sizeof(KismetSystemLibrary_UnloadPrimaryAssetList) == 0x000010, "Wrong size on KismetSystemLibrary_UnloadPrimaryAssetList");
static_assert(offsetof(KismetSystemLibrary_UnloadPrimaryAssetList, PrimaryAssetIdList) == 0x000000, "Member 'KismetSystemLibrary_UnloadPrimaryAssetList::PrimaryAssetIdList' has a wrong offset!");

// DelegateFunction Engine.KismetSystemLibrary.OnAssetLoaded__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_OnAssetLoaded__DelegateSignature final
{
public:
	class UObject*                                Loaded;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_OnAssetLoaded__DelegateSignature) == 0x000008, "Wrong alignment on KismetSystemLibrary_OnAssetLoaded__DelegateSignature");
static_assert(sizeof(KismetSystemLibrary_OnAssetLoaded__DelegateSignature) == 0x000008, "Wrong size on KismetSystemLibrary_OnAssetLoaded__DelegateSignature");
static_assert(offsetof(KismetSystemLibrary_OnAssetLoaded__DelegateSignature, Loaded) == 0x000000, "Member 'KismetSystemLibrary_OnAssetLoaded__DelegateSignature::Loaded' has a wrong offset!");

// DelegateFunction Engine.KismetSystemLibrary.OnAssetClassLoaded__DelegateSignature
// 0x0008 (0x0008 - 0x0000)
struct KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature final
{
public:
	TSubclassOf<class UObject>                    Loaded;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature) == 0x000008, "Wrong alignment on KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature");
static_assert(sizeof(KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature) == 0x000008, "Wrong size on KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature");
static_assert(offsetof(KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature, Loaded) == 0x000000, "Member 'KismetSystemLibrary_OnAssetClassLoaded__DelegateSignature::Loaded' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsCurrency_Float
// 0x0040 (0x0040 - 0x0000)
struct KismetTextLibrary_AsCurrency_Float final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumFractionalDigits;                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyCode;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0028(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsCurrency_Float) == 0x000008, "Wrong alignment on KismetTextLibrary_AsCurrency_Float");
static_assert(sizeof(KismetTextLibrary_AsCurrency_Float) == 0x000040, "Wrong size on KismetTextLibrary_AsCurrency_Float");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, Value) == 0x000000, "Member 'KismetTextLibrary_AsCurrency_Float::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, RoundingMode) == 0x000004, "Member 'KismetTextLibrary_AsCurrency_Float::RoundingMode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, bUseGrouping) == 0x000005, "Member 'KismetTextLibrary_AsCurrency_Float::bUseGrouping' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, MinimumIntegralDigits) == 0x000008, "Member 'KismetTextLibrary_AsCurrency_Float::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, MaximumIntegralDigits) == 0x00000C, "Member 'KismetTextLibrary_AsCurrency_Float::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, MinimumFractionalDigits) == 0x000010, "Member 'KismetTextLibrary_AsCurrency_Float::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, MaximumFractionalDigits) == 0x000014, "Member 'KismetTextLibrary_AsCurrency_Float::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, CurrencyCode) == 0x000018, "Member 'KismetTextLibrary_AsCurrency_Float::CurrencyCode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Float, ReturnValue) == 0x000028, "Member 'KismetTextLibrary_AsCurrency_Float::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsCurrency_Integer
// 0x0040 (0x0040 - 0x0000)
struct KismetTextLibrary_AsCurrency_Integer final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumFractionalDigits;                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CurrencyCode;                                      // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0028(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsCurrency_Integer) == 0x000008, "Wrong alignment on KismetTextLibrary_AsCurrency_Integer");
static_assert(sizeof(KismetTextLibrary_AsCurrency_Integer) == 0x000040, "Wrong size on KismetTextLibrary_AsCurrency_Integer");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, Value) == 0x000000, "Member 'KismetTextLibrary_AsCurrency_Integer::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, RoundingMode) == 0x000004, "Member 'KismetTextLibrary_AsCurrency_Integer::RoundingMode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, bUseGrouping) == 0x000005, "Member 'KismetTextLibrary_AsCurrency_Integer::bUseGrouping' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, MinimumIntegralDigits) == 0x000008, "Member 'KismetTextLibrary_AsCurrency_Integer::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, MaximumIntegralDigits) == 0x00000C, "Member 'KismetTextLibrary_AsCurrency_Integer::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, MinimumFractionalDigits) == 0x000010, "Member 'KismetTextLibrary_AsCurrency_Integer::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, MaximumFractionalDigits) == 0x000014, "Member 'KismetTextLibrary_AsCurrency_Integer::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, CurrencyCode) == 0x000018, "Member 'KismetTextLibrary_AsCurrency_Integer::CurrencyCode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrency_Integer, ReturnValue) == 0x000028, "Member 'KismetTextLibrary_AsCurrency_Integer::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsCurrencyBase
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_AsCurrencyBase final
{
public:
	int32                                         BaseValue;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CurrencyCode;                                      // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsCurrencyBase) == 0x000008, "Wrong alignment on KismetTextLibrary_AsCurrencyBase");
static_assert(sizeof(KismetTextLibrary_AsCurrencyBase) == 0x000030, "Wrong size on KismetTextLibrary_AsCurrencyBase");
static_assert(offsetof(KismetTextLibrary_AsCurrencyBase, BaseValue) == 0x000000, "Member 'KismetTextLibrary_AsCurrencyBase::BaseValue' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrencyBase, CurrencyCode) == 0x000008, "Member 'KismetTextLibrary_AsCurrencyBase::CurrencyCode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsCurrencyBase, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_AsCurrencyBase::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsDate_DateTime
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_AsDate_DateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsDate_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsDate_DateTime");
static_assert(sizeof(KismetTextLibrary_AsDate_DateTime) == 0x000020, "Wrong size on KismetTextLibrary_AsDate_DateTime");
static_assert(offsetof(KismetTextLibrary_AsDate_DateTime, InDateTime) == 0x000000, "Member 'KismetTextLibrary_AsDate_DateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsDate_DateTime, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_AsDate_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsDateTime_DateTime
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_AsDateTime_DateTime final
{
public:
	struct FDateTime                              In;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsDateTime_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsDateTime_DateTime");
static_assert(sizeof(KismetTextLibrary_AsDateTime_DateTime) == 0x000020, "Wrong size on KismetTextLibrary_AsDateTime_DateTime");
static_assert(offsetof(KismetTextLibrary_AsDateTime_DateTime, In) == 0x000000, "Member 'KismetTextLibrary_AsDateTime_DateTime::In' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsDateTime_DateTime, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_AsDateTime_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsPercent_Float
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_AsPercent_Float final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumFractionalDigits;                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsPercent_Float) == 0x000008, "Wrong alignment on KismetTextLibrary_AsPercent_Float");
static_assert(sizeof(KismetTextLibrary_AsPercent_Float) == 0x000030, "Wrong size on KismetTextLibrary_AsPercent_Float");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, Value) == 0x000000, "Member 'KismetTextLibrary_AsPercent_Float::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, RoundingMode) == 0x000004, "Member 'KismetTextLibrary_AsPercent_Float::RoundingMode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, bUseGrouping) == 0x000005, "Member 'KismetTextLibrary_AsPercent_Float::bUseGrouping' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, MinimumIntegralDigits) == 0x000008, "Member 'KismetTextLibrary_AsPercent_Float::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, MaximumIntegralDigits) == 0x00000C, "Member 'KismetTextLibrary_AsPercent_Float::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, MinimumFractionalDigits) == 0x000010, "Member 'KismetTextLibrary_AsPercent_Float::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, MaximumFractionalDigits) == 0x000014, "Member 'KismetTextLibrary_AsPercent_Float::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsPercent_Float, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_AsPercent_Float::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsTime_DateTime
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_AsTime_DateTime final
{
public:
	struct FDateTime                              In;                                                // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsTime_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsTime_DateTime");
static_assert(sizeof(KismetTextLibrary_AsTime_DateTime) == 0x000020, "Wrong size on KismetTextLibrary_AsTime_DateTime");
static_assert(offsetof(KismetTextLibrary_AsTime_DateTime, In) == 0x000000, "Member 'KismetTextLibrary_AsTime_DateTime::In' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTime_DateTime, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_AsTime_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsTimespan_Timespan
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_AsTimespan_Timespan final
{
public:
	struct FTimespan                              InTimespan;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsTimespan_Timespan) == 0x000008, "Wrong alignment on KismetTextLibrary_AsTimespan_Timespan");
static_assert(sizeof(KismetTextLibrary_AsTimespan_Timespan) == 0x000020, "Wrong size on KismetTextLibrary_AsTimespan_Timespan");
static_assert(offsetof(KismetTextLibrary_AsTimespan_Timespan, InTimespan) == 0x000000, "Member 'KismetTextLibrary_AsTimespan_Timespan::InTimespan' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimespan_Timespan, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_AsTimespan_Timespan::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsTimeZoneDate_DateTime
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_AsTimeZoneDate_DateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTimeZone;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsTimeZoneDate_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsTimeZoneDate_DateTime");
static_assert(sizeof(KismetTextLibrary_AsTimeZoneDate_DateTime) == 0x000030, "Wrong size on KismetTextLibrary_AsTimeZoneDate_DateTime");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDate_DateTime, InDateTime) == 0x000000, "Member 'KismetTextLibrary_AsTimeZoneDate_DateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDate_DateTime, InTimeZone) == 0x000008, "Member 'KismetTextLibrary_AsTimeZoneDate_DateTime::InTimeZone' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDate_DateTime, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_AsTimeZoneDate_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsTimeZoneDateTime_DateTime
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_AsTimeZoneDateTime_DateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTimeZone;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsTimeZoneDateTime_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsTimeZoneDateTime_DateTime");
static_assert(sizeof(KismetTextLibrary_AsTimeZoneDateTime_DateTime) == 0x000030, "Wrong size on KismetTextLibrary_AsTimeZoneDateTime_DateTime");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDateTime_DateTime, InDateTime) == 0x000000, "Member 'KismetTextLibrary_AsTimeZoneDateTime_DateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDateTime_DateTime, InTimeZone) == 0x000008, "Member 'KismetTextLibrary_AsTimeZoneDateTime_DateTime::InTimeZone' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneDateTime_DateTime, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_AsTimeZoneDateTime_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.AsTimeZoneTime_DateTime
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_AsTimeZoneTime_DateTime final
{
public:
	struct FDateTime                              InDateTime;                                        // 0x0000(0x0008)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 InTimeZone;                                        // 0x0008(0x0010)(Parm, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_AsTimeZoneTime_DateTime) == 0x000008, "Wrong alignment on KismetTextLibrary_AsTimeZoneTime_DateTime");
static_assert(sizeof(KismetTextLibrary_AsTimeZoneTime_DateTime) == 0x000030, "Wrong size on KismetTextLibrary_AsTimeZoneTime_DateTime");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneTime_DateTime, InDateTime) == 0x000000, "Member 'KismetTextLibrary_AsTimeZoneTime_DateTime::InDateTime' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneTime_DateTime, InTimeZone) == 0x000008, "Member 'KismetTextLibrary_AsTimeZoneTime_DateTime::InTimeZone' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_AsTimeZoneTime_DateTime, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_AsTimeZoneTime_DateTime::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_BoolToText
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_Conv_BoolToText final
{
public:
	bool                                          InBool;                                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_BoolToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_BoolToText");
static_assert(sizeof(KismetTextLibrary_Conv_BoolToText) == 0x000020, "Wrong size on KismetTextLibrary_Conv_BoolToText");
static_assert(offsetof(KismetTextLibrary_Conv_BoolToText, InBool) == 0x000000, "Member 'KismetTextLibrary_Conv_BoolToText::InBool' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_BoolToText, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_Conv_BoolToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_ByteToText
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_Conv_ByteToText final
{
public:
	uint8                                         Value;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_ByteToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_ByteToText");
static_assert(sizeof(KismetTextLibrary_Conv_ByteToText) == 0x000020, "Wrong size on KismetTextLibrary_Conv_ByteToText");
static_assert(offsetof(KismetTextLibrary_Conv_ByteToText, Value) == 0x000000, "Member 'KismetTextLibrary_Conv_ByteToText::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_ByteToText, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_Conv_ByteToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_ColorToText
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_ColorToText final
{
public:
	struct FLinearColor                           InColor;                                           // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_ColorToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_ColorToText");
static_assert(sizeof(KismetTextLibrary_Conv_ColorToText) == 0x000028, "Wrong size on KismetTextLibrary_Conv_ColorToText");
static_assert(offsetof(KismetTextLibrary_Conv_ColorToText, InColor) == 0x000000, "Member 'KismetTextLibrary_Conv_ColorToText::InColor' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_ColorToText, ReturnValue) == 0x000010, "Member 'KismetTextLibrary_Conv_ColorToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_FloatToText
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_Conv_FloatToText final
{
public:
	float                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERoundingMode                                 RoundingMode;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinimumFractionalDigits;                           // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumFractionalDigits;                           // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_FloatToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_FloatToText");
static_assert(sizeof(KismetTextLibrary_Conv_FloatToText) == 0x000030, "Wrong size on KismetTextLibrary_Conv_FloatToText");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, Value) == 0x000000, "Member 'KismetTextLibrary_Conv_FloatToText::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, RoundingMode) == 0x000004, "Member 'KismetTextLibrary_Conv_FloatToText::RoundingMode' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, bUseGrouping) == 0x000005, "Member 'KismetTextLibrary_Conv_FloatToText::bUseGrouping' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, MinimumIntegralDigits) == 0x000008, "Member 'KismetTextLibrary_Conv_FloatToText::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, MaximumIntegralDigits) == 0x00000C, "Member 'KismetTextLibrary_Conv_FloatToText::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, MinimumFractionalDigits) == 0x000010, "Member 'KismetTextLibrary_Conv_FloatToText::MinimumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, MaximumFractionalDigits) == 0x000014, "Member 'KismetTextLibrary_Conv_FloatToText::MaximumFractionalDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_FloatToText, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_Conv_FloatToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_IntToText
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_IntToText final
{
public:
	int32                                         Value;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseGrouping;                                      // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MinimumIntegralDigits;                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaximumIntegralDigits;                             // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_IntToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_IntToText");
static_assert(sizeof(KismetTextLibrary_Conv_IntToText) == 0x000028, "Wrong size on KismetTextLibrary_Conv_IntToText");
static_assert(offsetof(KismetTextLibrary_Conv_IntToText, Value) == 0x000000, "Member 'KismetTextLibrary_Conv_IntToText::Value' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_IntToText, bUseGrouping) == 0x000004, "Member 'KismetTextLibrary_Conv_IntToText::bUseGrouping' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_IntToText, MinimumIntegralDigits) == 0x000008, "Member 'KismetTextLibrary_Conv_IntToText::MinimumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_IntToText, MaximumIntegralDigits) == 0x00000C, "Member 'KismetTextLibrary_Conv_IntToText::MaximumIntegralDigits' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_IntToText, ReturnValue) == 0x000010, "Member 'KismetTextLibrary_Conv_IntToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_NameToText
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_Conv_NameToText final
{
public:
	class FName                                   InName;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_NameToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_NameToText");
static_assert(sizeof(KismetTextLibrary_Conv_NameToText) == 0x000020, "Wrong size on KismetTextLibrary_Conv_NameToText");
static_assert(offsetof(KismetTextLibrary_Conv_NameToText, InName) == 0x000000, "Member 'KismetTextLibrary_Conv_NameToText::InName' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_NameToText, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_Conv_NameToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_ObjectToText
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_Conv_ObjectToText final
{
public:
	class UObject*                                InObj;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_ObjectToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_ObjectToText");
static_assert(sizeof(KismetTextLibrary_Conv_ObjectToText) == 0x000020, "Wrong size on KismetTextLibrary_Conv_ObjectToText");
static_assert(offsetof(KismetTextLibrary_Conv_ObjectToText, InObj) == 0x000000, "Member 'KismetTextLibrary_Conv_ObjectToText::InObj' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_ObjectToText, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_Conv_ObjectToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_RotatorToText
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_RotatorToText final
{
public:
	struct FRotator                               InRot;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_RotatorToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_RotatorToText");
static_assert(sizeof(KismetTextLibrary_Conv_RotatorToText) == 0x000028, "Wrong size on KismetTextLibrary_Conv_RotatorToText");
static_assert(offsetof(KismetTextLibrary_Conv_RotatorToText, InRot) == 0x000000, "Member 'KismetTextLibrary_Conv_RotatorToText::InRot' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_RotatorToText, ReturnValue) == 0x000010, "Member 'KismetTextLibrary_Conv_RotatorToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_StringToText
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_StringToText final
{
public:
	class FString                                 InString;                                          // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_StringToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_StringToText");
static_assert(sizeof(KismetTextLibrary_Conv_StringToText) == 0x000028, "Wrong size on KismetTextLibrary_Conv_StringToText");
static_assert(offsetof(KismetTextLibrary_Conv_StringToText, InString) == 0x000000, "Member 'KismetTextLibrary_Conv_StringToText::InString' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_StringToText, ReturnValue) == 0x000010, "Member 'KismetTextLibrary_Conv_StringToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_TextToString
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_TextToString final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_TextToString) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_TextToString");
static_assert(sizeof(KismetTextLibrary_Conv_TextToString) == 0x000028, "Wrong size on KismetTextLibrary_Conv_TextToString");
static_assert(offsetof(KismetTextLibrary_Conv_TextToString, InText) == 0x000000, "Member 'KismetTextLibrary_Conv_TextToString::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_TextToString, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_Conv_TextToString::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_TransformToText
// 0x0050 (0x0050 - 0x0000)
struct KismetTextLibrary_Conv_TransformToText final
{
public:
	struct FTransform                             InTrans;                                           // 0x0000(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0030(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
	uint8                                         Pad_48[0x8];                                       // 0x0048(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_Conv_TransformToText) == 0x000010, "Wrong alignment on KismetTextLibrary_Conv_TransformToText");
static_assert(sizeof(KismetTextLibrary_Conv_TransformToText) == 0x000050, "Wrong size on KismetTextLibrary_Conv_TransformToText");
static_assert(offsetof(KismetTextLibrary_Conv_TransformToText, InTrans) == 0x000000, "Member 'KismetTextLibrary_Conv_TransformToText::InTrans' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_TransformToText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_Conv_TransformToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_Vector2dToText
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_Conv_Vector2dToText final
{
public:
	struct FVector2D                              InVec;                                             // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0008(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_Vector2dToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_Vector2dToText");
static_assert(sizeof(KismetTextLibrary_Conv_Vector2dToText) == 0x000020, "Wrong size on KismetTextLibrary_Conv_Vector2dToText");
static_assert(offsetof(KismetTextLibrary_Conv_Vector2dToText, InVec) == 0x000000, "Member 'KismetTextLibrary_Conv_Vector2dToText::InVec' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_Vector2dToText, ReturnValue) == 0x000008, "Member 'KismetTextLibrary_Conv_Vector2dToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Conv_VectorToText
// 0x0028 (0x0028 - 0x0000)
struct KismetTextLibrary_Conv_VectorToText final
{
public:
	struct FVector                                InVec;                                             // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   ReturnValue;                                       // 0x0010(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Conv_VectorToText) == 0x000008, "Wrong alignment on KismetTextLibrary_Conv_VectorToText");
static_assert(sizeof(KismetTextLibrary_Conv_VectorToText) == 0x000028, "Wrong size on KismetTextLibrary_Conv_VectorToText");
static_assert(offsetof(KismetTextLibrary_Conv_VectorToText, InVec) == 0x000000, "Member 'KismetTextLibrary_Conv_VectorToText::InVec' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Conv_VectorToText, ReturnValue) == 0x000010, "Member 'KismetTextLibrary_Conv_VectorToText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.EqualEqual_IgnoreCase_TextText
// 0x0038 (0x0038 - 0x0000)
struct KismetTextLibrary_EqualEqual_IgnoreCase_TextText final
{
public:
	class FText                                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_EqualEqual_IgnoreCase_TextText) == 0x000008, "Wrong alignment on KismetTextLibrary_EqualEqual_IgnoreCase_TextText");
static_assert(sizeof(KismetTextLibrary_EqualEqual_IgnoreCase_TextText) == 0x000038, "Wrong size on KismetTextLibrary_EqualEqual_IgnoreCase_TextText");
static_assert(offsetof(KismetTextLibrary_EqualEqual_IgnoreCase_TextText, A) == 0x000000, "Member 'KismetTextLibrary_EqualEqual_IgnoreCase_TextText::A' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_EqualEqual_IgnoreCase_TextText, B) == 0x000018, "Member 'KismetTextLibrary_EqualEqual_IgnoreCase_TextText::B' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_EqualEqual_IgnoreCase_TextText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_EqualEqual_IgnoreCase_TextText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.EqualEqual_TextText
// 0x0038 (0x0038 - 0x0000)
struct KismetTextLibrary_EqualEqual_TextText final
{
public:
	class FText                                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_EqualEqual_TextText) == 0x000008, "Wrong alignment on KismetTextLibrary_EqualEqual_TextText");
static_assert(sizeof(KismetTextLibrary_EqualEqual_TextText) == 0x000038, "Wrong size on KismetTextLibrary_EqualEqual_TextText");
static_assert(offsetof(KismetTextLibrary_EqualEqual_TextText, A) == 0x000000, "Member 'KismetTextLibrary_EqualEqual_TextText::A' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_EqualEqual_TextText, B) == 0x000018, "Member 'KismetTextLibrary_EqualEqual_TextText::B' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_EqualEqual_TextText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_EqualEqual_TextText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.FindTextInLocalizationTable
// 0x0040 (0x0040 - 0x0000)
struct KismetTextLibrary_FindTextInLocalizationTable final
{
public:
	class FString                                 Namespace;                                         // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   OutText;                                           // 0x0020(0x0018)(Parm, OutParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_FindTextInLocalizationTable) == 0x000008, "Wrong alignment on KismetTextLibrary_FindTextInLocalizationTable");
static_assert(sizeof(KismetTextLibrary_FindTextInLocalizationTable) == 0x000040, "Wrong size on KismetTextLibrary_FindTextInLocalizationTable");
static_assert(offsetof(KismetTextLibrary_FindTextInLocalizationTable, Namespace) == 0x000000, "Member 'KismetTextLibrary_FindTextInLocalizationTable::Namespace' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_FindTextInLocalizationTable, Key) == 0x000010, "Member 'KismetTextLibrary_FindTextInLocalizationTable::Key' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_FindTextInLocalizationTable, OutText) == 0x000020, "Member 'KismetTextLibrary_FindTextInLocalizationTable::OutText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_FindTextInLocalizationTable, ReturnValue) == 0x000038, "Member 'KismetTextLibrary_FindTextInLocalizationTable::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.Format
// 0x0040 (0x0040 - 0x0000)
struct KismetTextLibrary_Format final
{
public:
	class FText                                   InPattern;                                         // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	TArray<struct FFormatArgumentData>            InArgs;                                            // 0x0018(0x0010)(Parm, ZeroConstructor, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0028(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_Format) == 0x000008, "Wrong alignment on KismetTextLibrary_Format");
static_assert(sizeof(KismetTextLibrary_Format) == 0x000040, "Wrong size on KismetTextLibrary_Format");
static_assert(offsetof(KismetTextLibrary_Format, InPattern) == 0x000000, "Member 'KismetTextLibrary_Format::InPattern' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Format, InArgs) == 0x000018, "Member 'KismetTextLibrary_Format::InArgs' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_Format, ReturnValue) == 0x000028, "Member 'KismetTextLibrary_Format::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.GetEmptyText
// 0x0018 (0x0018 - 0x0000)
struct KismetTextLibrary_GetEmptyText final
{
public:
	class FText                                   ReturnValue;                                       // 0x0000(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_GetEmptyText) == 0x000008, "Wrong alignment on KismetTextLibrary_GetEmptyText");
static_assert(sizeof(KismetTextLibrary_GetEmptyText) == 0x000018, "Wrong size on KismetTextLibrary_GetEmptyText");
static_assert(offsetof(KismetTextLibrary_GetEmptyText, ReturnValue) == 0x000000, "Member 'KismetTextLibrary_GetEmptyText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.NotEqual_IgnoreCase_TextText
// 0x0038 (0x0038 - 0x0000)
struct KismetTextLibrary_NotEqual_IgnoreCase_TextText final
{
public:
	class FText                                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_NotEqual_IgnoreCase_TextText) == 0x000008, "Wrong alignment on KismetTextLibrary_NotEqual_IgnoreCase_TextText");
static_assert(sizeof(KismetTextLibrary_NotEqual_IgnoreCase_TextText) == 0x000038, "Wrong size on KismetTextLibrary_NotEqual_IgnoreCase_TextText");
static_assert(offsetof(KismetTextLibrary_NotEqual_IgnoreCase_TextText, A) == 0x000000, "Member 'KismetTextLibrary_NotEqual_IgnoreCase_TextText::A' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_NotEqual_IgnoreCase_TextText, B) == 0x000018, "Member 'KismetTextLibrary_NotEqual_IgnoreCase_TextText::B' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_NotEqual_IgnoreCase_TextText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_NotEqual_IgnoreCase_TextText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.NotEqual_TextText
// 0x0038 (0x0038 - 0x0000)
struct KismetTextLibrary_NotEqual_TextText final
{
public:
	class FText                                   A;                                                 // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   B;                                                 // 0x0018(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_NotEqual_TextText) == 0x000008, "Wrong alignment on KismetTextLibrary_NotEqual_TextText");
static_assert(sizeof(KismetTextLibrary_NotEqual_TextText) == 0x000038, "Wrong size on KismetTextLibrary_NotEqual_TextText");
static_assert(offsetof(KismetTextLibrary_NotEqual_TextText, A) == 0x000000, "Member 'KismetTextLibrary_NotEqual_TextText::A' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_NotEqual_TextText, B) == 0x000018, "Member 'KismetTextLibrary_NotEqual_TextText::B' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_NotEqual_TextText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_NotEqual_TextText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.StringTableIdAndKeyFromText
// 0x0038 (0x0038 - 0x0000)
struct KismetTextLibrary_StringTableIdAndKeyFromText final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(Parm, NativeAccessSpecifierPublic)
	class FName                                   OutTableId;                                        // 0x0018(0x0008)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OutKey;                                            // 0x0020(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_StringTableIdAndKeyFromText) == 0x000008, "Wrong alignment on KismetTextLibrary_StringTableIdAndKeyFromText");
static_assert(sizeof(KismetTextLibrary_StringTableIdAndKeyFromText) == 0x000038, "Wrong size on KismetTextLibrary_StringTableIdAndKeyFromText");
static_assert(offsetof(KismetTextLibrary_StringTableIdAndKeyFromText, Text) == 0x000000, "Member 'KismetTextLibrary_StringTableIdAndKeyFromText::Text' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_StringTableIdAndKeyFromText, OutTableId) == 0x000018, "Member 'KismetTextLibrary_StringTableIdAndKeyFromText::OutTableId' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_StringTableIdAndKeyFromText, OutKey) == 0x000020, "Member 'KismetTextLibrary_StringTableIdAndKeyFromText::OutKey' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_StringTableIdAndKeyFromText, ReturnValue) == 0x000030, "Member 'KismetTextLibrary_StringTableIdAndKeyFromText::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextFromStringTable
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextFromStringTable final
{
public:
	class FName                                   TableId;                                           // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Key;                                               // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextFromStringTable) == 0x000008, "Wrong alignment on KismetTextLibrary_TextFromStringTable");
static_assert(sizeof(KismetTextLibrary_TextFromStringTable) == 0x000030, "Wrong size on KismetTextLibrary_TextFromStringTable");
static_assert(offsetof(KismetTextLibrary_TextFromStringTable, TableId) == 0x000000, "Member 'KismetTextLibrary_TextFromStringTable::TableId' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextFromStringTable, Key) == 0x000008, "Member 'KismetTextLibrary_TextFromStringTable::Key' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextFromStringTable, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextFromStringTable::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextIsCultureInvariant
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_TextIsCultureInvariant final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_TextIsCultureInvariant) == 0x000008, "Wrong alignment on KismetTextLibrary_TextIsCultureInvariant");
static_assert(sizeof(KismetTextLibrary_TextIsCultureInvariant) == 0x000020, "Wrong size on KismetTextLibrary_TextIsCultureInvariant");
static_assert(offsetof(KismetTextLibrary_TextIsCultureInvariant, InText) == 0x000000, "Member 'KismetTextLibrary_TextIsCultureInvariant::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextIsCultureInvariant, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextIsCultureInvariant::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextIsEmpty
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_TextIsEmpty final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_TextIsEmpty) == 0x000008, "Wrong alignment on KismetTextLibrary_TextIsEmpty");
static_assert(sizeof(KismetTextLibrary_TextIsEmpty) == 0x000020, "Wrong size on KismetTextLibrary_TextIsEmpty");
static_assert(offsetof(KismetTextLibrary_TextIsEmpty, InText) == 0x000000, "Member 'KismetTextLibrary_TextIsEmpty::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextIsEmpty, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextIsEmpty::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextIsFromStringTable
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_TextIsFromStringTable final
{
public:
	class FText                                   Text;                                              // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_TextIsFromStringTable) == 0x000008, "Wrong alignment on KismetTextLibrary_TextIsFromStringTable");
static_assert(sizeof(KismetTextLibrary_TextIsFromStringTable) == 0x000020, "Wrong size on KismetTextLibrary_TextIsFromStringTable");
static_assert(offsetof(KismetTextLibrary_TextIsFromStringTable, Text) == 0x000000, "Member 'KismetTextLibrary_TextIsFromStringTable::Text' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextIsFromStringTable, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextIsFromStringTable::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextIsTransient
// 0x0020 (0x0020 - 0x0000)
struct KismetTextLibrary_TextIsTransient final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0018(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(KismetTextLibrary_TextIsTransient) == 0x000008, "Wrong alignment on KismetTextLibrary_TextIsTransient");
static_assert(sizeof(KismetTextLibrary_TextIsTransient) == 0x000020, "Wrong size on KismetTextLibrary_TextIsTransient");
static_assert(offsetof(KismetTextLibrary_TextIsTransient, InText) == 0x000000, "Member 'KismetTextLibrary_TextIsTransient::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextIsTransient, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextIsTransient::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextToLower
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextToLower final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextToLower) == 0x000008, "Wrong alignment on KismetTextLibrary_TextToLower");
static_assert(sizeof(KismetTextLibrary_TextToLower) == 0x000030, "Wrong size on KismetTextLibrary_TextToLower");
static_assert(offsetof(KismetTextLibrary_TextToLower, InText) == 0x000000, "Member 'KismetTextLibrary_TextToLower::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextToLower, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextToLower::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextToUpper
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextToUpper final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextToUpper) == 0x000008, "Wrong alignment on KismetTextLibrary_TextToUpper");
static_assert(sizeof(KismetTextLibrary_TextToUpper) == 0x000030, "Wrong size on KismetTextLibrary_TextToUpper");
static_assert(offsetof(KismetTextLibrary_TextToUpper, InText) == 0x000000, "Member 'KismetTextLibrary_TextToUpper::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextToUpper, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextToUpper::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextTrimPreceding
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextTrimPreceding final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextTrimPreceding) == 0x000008, "Wrong alignment on KismetTextLibrary_TextTrimPreceding");
static_assert(sizeof(KismetTextLibrary_TextTrimPreceding) == 0x000030, "Wrong size on KismetTextLibrary_TextTrimPreceding");
static_assert(offsetof(KismetTextLibrary_TextTrimPreceding, InText) == 0x000000, "Member 'KismetTextLibrary_TextTrimPreceding::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextTrimPreceding, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextTrimPreceding::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextTrimPrecedingAndTrailing
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextTrimPrecedingAndTrailing final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextTrimPrecedingAndTrailing) == 0x000008, "Wrong alignment on KismetTextLibrary_TextTrimPrecedingAndTrailing");
static_assert(sizeof(KismetTextLibrary_TextTrimPrecedingAndTrailing) == 0x000030, "Wrong size on KismetTextLibrary_TextTrimPrecedingAndTrailing");
static_assert(offsetof(KismetTextLibrary_TextTrimPrecedingAndTrailing, InText) == 0x000000, "Member 'KismetTextLibrary_TextTrimPrecedingAndTrailing::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextTrimPrecedingAndTrailing, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextTrimPrecedingAndTrailing::ReturnValue' has a wrong offset!");

// Function Engine.KismetTextLibrary.TextTrimTrailing
// 0x0030 (0x0030 - 0x0000)
struct KismetTextLibrary_TextTrimTrailing final
{
public:
	class FText                                   InText;                                            // 0x0000(0x0018)(ConstParm, Parm, OutParm, ReferenceParm, NativeAccessSpecifierPublic)
	class FText                                   ReturnValue;                                       // 0x0018(0x0018)(Parm, OutParm, ReturnParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(KismetTextLibrary_TextTrimTrailing) == 0x000008, "Wrong alignment on KismetTextLibrary_TextTrimTrailing");
static_assert(sizeof(KismetTextLibrary_TextTrimTrailing) == 0x000030, "Wrong size on KismetTextLibrary_TextTrimTrailing");
static_assert(offsetof(KismetTextLibrary_TextTrimTrailing, InText) == 0x000000, "Member 'KismetTextLibrary_TextTrimTrailing::InText' has a wrong offset!");
static_assert(offsetof(KismetTextLibrary_TextTrimTrailing, ReturnValue) == 0x000018, "Member 'KismetTextLibrary_TextTrimTrailing::ReturnValue' has a wrong offset!");

// Function Engine.LevelScriptActor.RemoteEvent
// 0x0010 (0x0010 - 0x0000)
struct LevelScriptActor_RemoteEvent final
{
public:
	class FName                                   EventName;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(LevelScriptActor_RemoteEvent) == 0x000004, "Wrong alignment on LevelScriptActor_RemoteEvent");
static_assert(sizeof(LevelScriptActor_RemoteEvent) == 0x000010, "Wrong size on LevelScriptActor_RemoteEvent");
static_assert(offsetof(LevelScriptActor_RemoteEvent, EventName) == 0x000000, "Member 'LevelScriptActor_RemoteEvent::EventName' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_RemoteEvent, ReturnValue) == 0x000008, "Member 'LevelScriptActor_RemoteEvent::ReturnValue' has a wrong offset!");

// Function Engine.LevelScriptActor.SetCinematicMode
// 0x0005 (0x0005 - 0x0000)
struct LevelScriptActor_SetCinematicMode final
{
public:
	bool                                          bCinematicMode;                                    // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHidePlayer;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsHUD;                                       // 0x0002(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsMovement;                                  // 0x0003(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAffectsTurning;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelScriptActor_SetCinematicMode) == 0x000001, "Wrong alignment on LevelScriptActor_SetCinematicMode");
static_assert(sizeof(LevelScriptActor_SetCinematicMode) == 0x000005, "Wrong size on LevelScriptActor_SetCinematicMode");
static_assert(offsetof(LevelScriptActor_SetCinematicMode, bCinematicMode) == 0x000000, "Member 'LevelScriptActor_SetCinematicMode::bCinematicMode' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_SetCinematicMode, bHidePlayer) == 0x000001, "Member 'LevelScriptActor_SetCinematicMode::bHidePlayer' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_SetCinematicMode, bAffectsHUD) == 0x000002, "Member 'LevelScriptActor_SetCinematicMode::bAffectsHUD' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_SetCinematicMode, bAffectsMovement) == 0x000003, "Member 'LevelScriptActor_SetCinematicMode::bAffectsMovement' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_SetCinematicMode, bAffectsTurning) == 0x000004, "Member 'LevelScriptActor_SetCinematicMode::bAffectsTurning' has a wrong offset!");

// Function Engine.LevelScriptActor.WorldOriginLocationChanged
// 0x0018 (0x0018 - 0x0000)
struct LevelScriptActor_WorldOriginLocationChanged final
{
public:
	struct FIntVector                             OldOriginLocation;                                 // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FIntVector                             NewOriginLocation;                                 // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelScriptActor_WorldOriginLocationChanged) == 0x000004, "Wrong alignment on LevelScriptActor_WorldOriginLocationChanged");
static_assert(sizeof(LevelScriptActor_WorldOriginLocationChanged) == 0x000018, "Wrong size on LevelScriptActor_WorldOriginLocationChanged");
static_assert(offsetof(LevelScriptActor_WorldOriginLocationChanged, OldOriginLocation) == 0x000000, "Member 'LevelScriptActor_WorldOriginLocationChanged::OldOriginLocation' has a wrong offset!");
static_assert(offsetof(LevelScriptActor_WorldOriginLocationChanged, NewOriginLocation) == 0x00000C, "Member 'LevelScriptActor_WorldOriginLocationChanged::NewOriginLocation' has a wrong offset!");

// Function Engine.LevelStreamingKismet.LoadLevelInstance
// 0x0040 (0x0040 - 0x0000)
struct LevelStreamingKismet_LoadLevelInstance final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LevelName;                                         // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0018(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0024(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bOutSuccess;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ULevelStreamingKismet*                  ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(LevelStreamingKismet_LoadLevelInstance) == 0x000008, "Wrong alignment on LevelStreamingKismet_LoadLevelInstance");
static_assert(sizeof(LevelStreamingKismet_LoadLevelInstance) == 0x000040, "Wrong size on LevelStreamingKismet_LoadLevelInstance");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, WorldContextObject) == 0x000000, "Member 'LevelStreamingKismet_LoadLevelInstance::WorldContextObject' has a wrong offset!");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, LevelName) == 0x000008, "Member 'LevelStreamingKismet_LoadLevelInstance::LevelName' has a wrong offset!");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, Location) == 0x000018, "Member 'LevelStreamingKismet_LoadLevelInstance::Location' has a wrong offset!");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, Rotation) == 0x000024, "Member 'LevelStreamingKismet_LoadLevelInstance::Rotation' has a wrong offset!");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, bOutSuccess) == 0x000030, "Member 'LevelStreamingKismet_LoadLevelInstance::bOutSuccess' has a wrong offset!");
static_assert(offsetof(LevelStreamingKismet_LoadLevelInstance, ReturnValue) == 0x000038, "Member 'LevelStreamingKismet_LoadLevelInstance::ReturnValue' has a wrong offset!");

// Function Engine.Texture2D.Blueprint_GetSizeX
// 0x0004 (0x0004 - 0x0000)
struct Texture2D_Blueprint_GetSizeX final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Texture2D_Blueprint_GetSizeX) == 0x000004, "Wrong alignment on Texture2D_Blueprint_GetSizeX");
static_assert(sizeof(Texture2D_Blueprint_GetSizeX) == 0x000004, "Wrong size on Texture2D_Blueprint_GetSizeX");
static_assert(offsetof(Texture2D_Blueprint_GetSizeX, ReturnValue) == 0x000000, "Member 'Texture2D_Blueprint_GetSizeX::ReturnValue' has a wrong offset!");

// Function Engine.Texture2D.Blueprint_GetSizeY
// 0x0004 (0x0004 - 0x0000)
struct Texture2D_Blueprint_GetSizeY final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(Texture2D_Blueprint_GetSizeY) == 0x000004, "Wrong alignment on Texture2D_Blueprint_GetSizeY");
static_assert(sizeof(Texture2D_Blueprint_GetSizeY) == 0x000004, "Wrong size on Texture2D_Blueprint_GetSizeY");
static_assert(offsetof(Texture2D_Blueprint_GetSizeY, ReturnValue) == 0x000000, "Member 'Texture2D_Blueprint_GetSizeY::ReturnValue' has a wrong offset!");

// Function Engine.MaterialBillboardComponent.AddElement
// 0x0030 (0x0030 - 0x0000)
struct MaterialBillboardComponent_AddElement final
{
public:
	class UMaterialInterface*                     Material;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UCurveFloat*                            DistanceToOpacityCurve;                            // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSizeIsInScreenSpace;                              // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         BaseSizeX;                                         // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseSizeY;                                         // 0x0018(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UCurveFloat*                            DistanceToSizeCurve;                               // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFixedUpVector;                                    // 0x0028(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaterialBillboardComponent_AddElement) == 0x000008, "Wrong alignment on MaterialBillboardComponent_AddElement");
static_assert(sizeof(MaterialBillboardComponent_AddElement) == 0x000030, "Wrong size on MaterialBillboardComponent_AddElement");
static_assert(offsetof(MaterialBillboardComponent_AddElement, Material) == 0x000000, "Member 'MaterialBillboardComponent_AddElement::Material' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, DistanceToOpacityCurve) == 0x000008, "Member 'MaterialBillboardComponent_AddElement::DistanceToOpacityCurve' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, bSizeIsInScreenSpace) == 0x000010, "Member 'MaterialBillboardComponent_AddElement::bSizeIsInScreenSpace' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, BaseSizeX) == 0x000014, "Member 'MaterialBillboardComponent_AddElement::BaseSizeX' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, BaseSizeY) == 0x000018, "Member 'MaterialBillboardComponent_AddElement::BaseSizeY' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, DistanceToSizeCurve) == 0x000020, "Member 'MaterialBillboardComponent_AddElement::DistanceToSizeCurve' has a wrong offset!");
static_assert(offsetof(MaterialBillboardComponent_AddElement, bFixedUpVector) == 0x000028, "Member 'MaterialBillboardComponent_AddElement::bFixedUpVector' has a wrong offset!");

// Function Engine.MaterialBillboardComponent.SetElements
// 0x0010 (0x0010 - 0x0000)
struct MaterialBillboardComponent_SetElements final
{
public:
	TArray<struct FMaterialSpriteElement>         NewElements;                                       // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialBillboardComponent_SetElements) == 0x000008, "Wrong alignment on MaterialBillboardComponent_SetElements");
static_assert(sizeof(MaterialBillboardComponent_SetElements) == 0x000010, "Wrong size on MaterialBillboardComponent_SetElements");
static_assert(offsetof(MaterialBillboardComponent_SetElements, NewElements) == 0x000000, "Member 'MaterialBillboardComponent_SetElements::NewElements' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.CopyInterpParameters
// 0x0008 (0x0008 - 0x0000)
struct MaterialInstanceDynamic_CopyInterpParameters final
{
public:
	class UMaterialInstance*                      Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_CopyInterpParameters) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_CopyInterpParameters");
static_assert(sizeof(MaterialInstanceDynamic_CopyInterpParameters) == 0x000008, "Wrong size on MaterialInstanceDynamic_CopyInterpParameters");
static_assert(offsetof(MaterialInstanceDynamic_CopyInterpParameters, Source) == 0x000000, "Member 'MaterialInstanceDynamic_CopyInterpParameters::Source' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.CopyParameterOverrides
// 0x0008 (0x0008 - 0x0000)
struct MaterialInstanceDynamic_CopyParameterOverrides final
{
public:
	class UMaterialInstance*                      MaterialInstance;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_CopyParameterOverrides) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_CopyParameterOverrides");
static_assert(sizeof(MaterialInstanceDynamic_CopyParameterOverrides) == 0x000008, "Wrong size on MaterialInstanceDynamic_CopyParameterOverrides");
static_assert(offsetof(MaterialInstanceDynamic_CopyParameterOverrides, MaterialInstance) == 0x000000, "Member 'MaterialInstanceDynamic_CopyParameterOverrides::MaterialInstance' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.K2_CopyMaterialInstanceParameters
// 0x0008 (0x0008 - 0x0000)
struct MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters final
{
public:
	class UMaterialInterface*                     Source;                                            // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters");
static_assert(sizeof(MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters) == 0x000008, "Wrong size on MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters");
static_assert(offsetof(MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters, Source) == 0x000000, "Member 'MaterialInstanceDynamic_K2_CopyMaterialInstanceParameters::Source' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.K2_GetScalarParameterValue
// 0x0010 (0x0010 - 0x0000)
struct MaterialInstanceDynamic_K2_GetScalarParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaterialInstanceDynamic_K2_GetScalarParameterValue) == 0x000004, "Wrong alignment on MaterialInstanceDynamic_K2_GetScalarParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_K2_GetScalarParameterValue) == 0x000010, "Wrong size on MaterialInstanceDynamic_K2_GetScalarParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetScalarParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_K2_GetScalarParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetScalarParameterValue, ReturnValue) == 0x000008, "Member 'MaterialInstanceDynamic_K2_GetScalarParameterValue::ReturnValue' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.K2_GetTextureParameterValue
// 0x0010 (0x0010 - 0x0000)
struct MaterialInstanceDynamic_K2_GetTextureParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_K2_GetTextureParameterValue) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_K2_GetTextureParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_K2_GetTextureParameterValue) == 0x000010, "Wrong size on MaterialInstanceDynamic_K2_GetTextureParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetTextureParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_K2_GetTextureParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetTextureParameterValue, ReturnValue) == 0x000008, "Member 'MaterialInstanceDynamic_K2_GetTextureParameterValue::ReturnValue' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.K2_GetVectorParameterValue
// 0x0018 (0x0018 - 0x0000)
struct MaterialInstanceDynamic_K2_GetVectorParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_K2_GetVectorParameterValue) == 0x000004, "Wrong alignment on MaterialInstanceDynamic_K2_GetVectorParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_K2_GetVectorParameterValue) == 0x000018, "Wrong size on MaterialInstanceDynamic_K2_GetVectorParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetVectorParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_K2_GetVectorParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_K2_GetVectorParameterValue, ReturnValue) == 0x000008, "Member 'MaterialInstanceDynamic_K2_GetVectorParameterValue::ReturnValue' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.K2_InterpolateMaterialInstanceParams
// 0x0018 (0x0018 - 0x0000)
struct MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams final
{
public:
	class UMaterialInstance*                      SourceA;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UMaterialInstance*                      SourceB;                                           // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Alpha;                                             // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams");
static_assert(sizeof(MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams) == 0x000018, "Wrong size on MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams");
static_assert(offsetof(MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams, SourceA) == 0x000000, "Member 'MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams::SourceA' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams, SourceB) == 0x000008, "Member 'MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams::SourceB' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams, Alpha) == 0x000010, "Member 'MaterialInstanceDynamic_K2_InterpolateMaterialInstanceParams::Alpha' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.SetScalarParameterValue
// 0x0010 (0x0010 - 0x0000)
struct MaterialInstanceDynamic_SetScalarParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Value;                                             // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(MaterialInstanceDynamic_SetScalarParameterValue) == 0x000004, "Wrong alignment on MaterialInstanceDynamic_SetScalarParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_SetScalarParameterValue) == 0x000010, "Wrong size on MaterialInstanceDynamic_SetScalarParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_SetScalarParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_SetScalarParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_SetScalarParameterValue, Value) == 0x000008, "Member 'MaterialInstanceDynamic_SetScalarParameterValue::Value' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.SetTextureParameterValue
// 0x0010 (0x0010 - 0x0000)
struct MaterialInstanceDynamic_SetTextureParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               Value;                                             // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_SetTextureParameterValue) == 0x000008, "Wrong alignment on MaterialInstanceDynamic_SetTextureParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_SetTextureParameterValue) == 0x000010, "Wrong size on MaterialInstanceDynamic_SetTextureParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_SetTextureParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_SetTextureParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_SetTextureParameterValue, Value) == 0x000008, "Member 'MaterialInstanceDynamic_SetTextureParameterValue::Value' has a wrong offset!");

// Function Engine.MaterialInstanceDynamic.SetVectorParameterValue
// 0x0018 (0x0018 - 0x0000)
struct MaterialInstanceDynamic_SetVectorParameterValue final
{
public:
	class FName                                   ParameterName;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           Value;                                             // 0x0008(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(MaterialInstanceDynamic_SetVectorParameterValue) == 0x000004, "Wrong alignment on MaterialInstanceDynamic_SetVectorParameterValue");
static_assert(sizeof(MaterialInstanceDynamic_SetVectorParameterValue) == 0x000018, "Wrong size on MaterialInstanceDynamic_SetVectorParameterValue");
static_assert(offsetof(MaterialInstanceDynamic_SetVectorParameterValue, ParameterName) == 0x000000, "Member 'MaterialInstanceDynamic_SetVectorParameterValue::ParameterName' has a wrong offset!");
static_assert(offsetof(MaterialInstanceDynamic_SetVectorParameterValue, Value) == 0x000008, "Member 'MaterialInstanceDynamic_SetVectorParameterValue::Value' has a wrong offset!");

// Function Engine.NavigationPath.EnableDebugDrawing
// 0x0014 (0x0014 - 0x0000)
struct NavigationPath_EnableDebugDrawing final
{
public:
	bool                                          bShouldDrawDebugData;                              // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           PathColor;                                         // 0x0004(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_EnableDebugDrawing) == 0x000004, "Wrong alignment on NavigationPath_EnableDebugDrawing");
static_assert(sizeof(NavigationPath_EnableDebugDrawing) == 0x000014, "Wrong size on NavigationPath_EnableDebugDrawing");
static_assert(offsetof(NavigationPath_EnableDebugDrawing, bShouldDrawDebugData) == 0x000000, "Member 'NavigationPath_EnableDebugDrawing::bShouldDrawDebugData' has a wrong offset!");
static_assert(offsetof(NavigationPath_EnableDebugDrawing, PathColor) == 0x000004, "Member 'NavigationPath_EnableDebugDrawing::PathColor' has a wrong offset!");

// Function Engine.NavigationPath.EnableRecalculationOnInvalidation
// 0x0001 (0x0001 - 0x0000)
struct NavigationPath_EnableRecalculationOnInvalidation final
{
public:
	ENavigationOptionFlag                         DoRecalculation;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_EnableRecalculationOnInvalidation) == 0x000001, "Wrong alignment on NavigationPath_EnableRecalculationOnInvalidation");
static_assert(sizeof(NavigationPath_EnableRecalculationOnInvalidation) == 0x000001, "Wrong size on NavigationPath_EnableRecalculationOnInvalidation");
static_assert(offsetof(NavigationPath_EnableRecalculationOnInvalidation, DoRecalculation) == 0x000000, "Member 'NavigationPath_EnableRecalculationOnInvalidation::DoRecalculation' has a wrong offset!");

// Function Engine.NavigationPath.GetDebugString
// 0x0010 (0x0010 - 0x0000)
struct NavigationPath_GetDebugString final
{
public:
	class FString                                 ReturnValue;                                       // 0x0000(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_GetDebugString) == 0x000008, "Wrong alignment on NavigationPath_GetDebugString");
static_assert(sizeof(NavigationPath_GetDebugString) == 0x000010, "Wrong size on NavigationPath_GetDebugString");
static_assert(offsetof(NavigationPath_GetDebugString, ReturnValue) == 0x000000, "Member 'NavigationPath_GetDebugString::ReturnValue' has a wrong offset!");

// Function Engine.NavigationPath.GetPathCost
// 0x0004 (0x0004 - 0x0000)
struct NavigationPath_GetPathCost final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_GetPathCost) == 0x000004, "Wrong alignment on NavigationPath_GetPathCost");
static_assert(sizeof(NavigationPath_GetPathCost) == 0x000004, "Wrong size on NavigationPath_GetPathCost");
static_assert(offsetof(NavigationPath_GetPathCost, ReturnValue) == 0x000000, "Member 'NavigationPath_GetPathCost::ReturnValue' has a wrong offset!");

// Function Engine.NavigationPath.GetPathLength
// 0x0004 (0x0004 - 0x0000)
struct NavigationPath_GetPathLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_GetPathLength) == 0x000004, "Wrong alignment on NavigationPath_GetPathLength");
static_assert(sizeof(NavigationPath_GetPathLength) == 0x000004, "Wrong size on NavigationPath_GetPathLength");
static_assert(offsetof(NavigationPath_GetPathLength, ReturnValue) == 0x000000, "Member 'NavigationPath_GetPathLength::ReturnValue' has a wrong offset!");

// Function Engine.NavigationPath.IsPartial
// 0x0001 (0x0001 - 0x0000)
struct NavigationPath_IsPartial final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_IsPartial) == 0x000001, "Wrong alignment on NavigationPath_IsPartial");
static_assert(sizeof(NavigationPath_IsPartial) == 0x000001, "Wrong size on NavigationPath_IsPartial");
static_assert(offsetof(NavigationPath_IsPartial, ReturnValue) == 0x000000, "Member 'NavigationPath_IsPartial::ReturnValue' has a wrong offset!");

// Function Engine.NavigationPath.IsStringPulled
// 0x0001 (0x0001 - 0x0000)
struct NavigationPath_IsStringPulled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_IsStringPulled) == 0x000001, "Wrong alignment on NavigationPath_IsStringPulled");
static_assert(sizeof(NavigationPath_IsStringPulled) == 0x000001, "Wrong size on NavigationPath_IsStringPulled");
static_assert(offsetof(NavigationPath_IsStringPulled, ReturnValue) == 0x000000, "Member 'NavigationPath_IsStringPulled::ReturnValue' has a wrong offset!");

// Function Engine.NavigationPath.IsValid
// 0x0001 (0x0001 - 0x0000)
struct NavigationPath_IsValid final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationPath_IsValid) == 0x000001, "Wrong alignment on NavigationPath_IsValid");
static_assert(sizeof(NavigationPath_IsValid) == 0x000001, "Wrong size on NavigationPath_IsValid");
static_assert(offsetof(NavigationPath_IsValid, ReturnValue) == 0x000000, "Member 'NavigationPath_IsValid::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.FindPathToActorSynchronously
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_FindPathToActorSynchronously final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 GoalActor;                                         // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TetherDistance;                                    // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AActor*                                 PathfindingContext;                                // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationPath*                        ReturnValue;                                       // 0x0038(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_FindPathToActorSynchronously) == 0x000008, "Wrong alignment on NavigationSystem_FindPathToActorSynchronously");
static_assert(sizeof(NavigationSystem_FindPathToActorSynchronously) == 0x000040, "Wrong size on NavigationSystem_FindPathToActorSynchronously");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, WorldContextObject) == 0x000000, "Member 'NavigationSystem_FindPathToActorSynchronously::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, PathStart) == 0x000008, "Member 'NavigationSystem_FindPathToActorSynchronously::PathStart' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, GoalActor) == 0x000018, "Member 'NavigationSystem_FindPathToActorSynchronously::GoalActor' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, TetherDistance) == 0x000020, "Member 'NavigationSystem_FindPathToActorSynchronously::TetherDistance' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, PathfindingContext) == 0x000028, "Member 'NavigationSystem_FindPathToActorSynchronously::PathfindingContext' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, FilterClass) == 0x000030, "Member 'NavigationSystem_FindPathToActorSynchronously::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToActorSynchronously, ReturnValue) == 0x000038, "Member 'NavigationSystem_FindPathToActorSynchronously::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.FindPathToLocationSynchronously
// 0x0038 (0x0038 - 0x0000)
struct NavigationSystem_FindPathToLocationSynchronously final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 PathfindingContext;                                // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationPath*                        ReturnValue;                                       // 0x0030(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_FindPathToLocationSynchronously) == 0x000008, "Wrong alignment on NavigationSystem_FindPathToLocationSynchronously");
static_assert(sizeof(NavigationSystem_FindPathToLocationSynchronously) == 0x000038, "Wrong size on NavigationSystem_FindPathToLocationSynchronously");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, WorldContextObject) == 0x000000, "Member 'NavigationSystem_FindPathToLocationSynchronously::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, PathStart) == 0x000008, "Member 'NavigationSystem_FindPathToLocationSynchronously::PathStart' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, PathEnd) == 0x000014, "Member 'NavigationSystem_FindPathToLocationSynchronously::PathEnd' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, PathfindingContext) == 0x000020, "Member 'NavigationSystem_FindPathToLocationSynchronously::PathfindingContext' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, FilterClass) == 0x000028, "Member 'NavigationSystem_FindPathToLocationSynchronously::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_FindPathToLocationSynchronously, ReturnValue) == 0x000030, "Member 'NavigationSystem_FindPathToLocationSynchronously::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.GetNavigationSystem
// 0x0010 (0x0010 - 0x0000)
struct NavigationSystem_GetNavigationSystem final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNavigationSystem*                      ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_GetNavigationSystem) == 0x000008, "Wrong alignment on NavigationSystem_GetNavigationSystem");
static_assert(sizeof(NavigationSystem_GetNavigationSystem) == 0x000010, "Wrong size on NavigationSystem_GetNavigationSystem");
static_assert(offsetof(NavigationSystem_GetNavigationSystem, WorldContextObject) == 0x000000, "Member 'NavigationSystem_GetNavigationSystem::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetNavigationSystem, ReturnValue) == 0x000008, "Member 'NavigationSystem_GetNavigationSystem::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.GetPathCost
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_GetPathCost final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathCost;                                          // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavigationQueryResult                        ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_GetPathCost) == 0x000008, "Wrong alignment on NavigationSystem_GetPathCost");
static_assert(sizeof(NavigationSystem_GetPathCost) == 0x000040, "Wrong size on NavigationSystem_GetPathCost");
static_assert(offsetof(NavigationSystem_GetPathCost, WorldContextObject) == 0x000000, "Member 'NavigationSystem_GetPathCost::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, PathStart) == 0x000008, "Member 'NavigationSystem_GetPathCost::PathStart' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, PathEnd) == 0x000014, "Member 'NavigationSystem_GetPathCost::PathEnd' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, PathCost) == 0x000020, "Member 'NavigationSystem_GetPathCost::PathCost' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, NavData) == 0x000028, "Member 'NavigationSystem_GetPathCost::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, FilterClass) == 0x000030, "Member 'NavigationSystem_GetPathCost::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathCost, ReturnValue) == 0x000038, "Member 'NavigationSystem_GetPathCost::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.GetPathLength
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_GetPathLength final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathStart;                                         // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                PathEnd;                                           // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PathLength;                                        // 0x0020(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ENavigationQueryResult                        ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_GetPathLength) == 0x000008, "Wrong alignment on NavigationSystem_GetPathLength");
static_assert(sizeof(NavigationSystem_GetPathLength) == 0x000040, "Wrong size on NavigationSystem_GetPathLength");
static_assert(offsetof(NavigationSystem_GetPathLength, WorldContextObject) == 0x000000, "Member 'NavigationSystem_GetPathLength::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, PathStart) == 0x000008, "Member 'NavigationSystem_GetPathLength::PathStart' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, PathEnd) == 0x000014, "Member 'NavigationSystem_GetPathLength::PathEnd' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, PathLength) == 0x000020, "Member 'NavigationSystem_GetPathLength::PathLength' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, NavData) == 0x000028, "Member 'NavigationSystem_GetPathLength::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, FilterClass) == 0x000030, "Member 'NavigationSystem_GetPathLength::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetPathLength, ReturnValue) == 0x000038, "Member 'NavigationSystem_GetPathLength::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.GetRandomPointInNavigableRadius
// 0x0038 (0x0038 - 0x0000)
struct NavigationSystem_GetRandomPointInNavigableRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationData*                        NavData;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_GetRandomPointInNavigableRadius) == 0x000008, "Wrong alignment on NavigationSystem_GetRandomPointInNavigableRadius");
static_assert(sizeof(NavigationSystem_GetRandomPointInNavigableRadius) == 0x000038, "Wrong size on NavigationSystem_GetRandomPointInNavigableRadius");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, WorldContextObject) == 0x000000, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, Origin) == 0x000008, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::Origin' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, Radius) == 0x000014, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::Radius' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, NavData) == 0x000018, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, FilterClass) == 0x000020, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomPointInNavigableRadius, ReturnValue) == 0x000028, "Member 'NavigationSystem_GetRandomPointInNavigableRadius::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.GetRandomReachablePointInRadius
// 0x0038 (0x0038 - 0x0000)
struct NavigationSystem_GetRandomReachablePointInRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0014(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationData*                        NavData;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0028(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_GetRandomReachablePointInRadius) == 0x000008, "Wrong alignment on NavigationSystem_GetRandomReachablePointInRadius");
static_assert(sizeof(NavigationSystem_GetRandomReachablePointInRadius) == 0x000038, "Wrong size on NavigationSystem_GetRandomReachablePointInRadius");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, WorldContextObject) == 0x000000, "Member 'NavigationSystem_GetRandomReachablePointInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, Origin) == 0x000008, "Member 'NavigationSystem_GetRandomReachablePointInRadius::Origin' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, Radius) == 0x000014, "Member 'NavigationSystem_GetRandomReachablePointInRadius::Radius' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, NavData) == 0x000018, "Member 'NavigationSystem_GetRandomReachablePointInRadius::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, FilterClass) == 0x000020, "Member 'NavigationSystem_GetRandomReachablePointInRadius::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_GetRandomReachablePointInRadius, ReturnValue) == 0x000028, "Member 'NavigationSystem_GetRandomReachablePointInRadius::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.IsNavigationBeingBuilt
// 0x0010 (0x0010 - 0x0000)
struct NavigationSystem_IsNavigationBeingBuilt final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_IsNavigationBeingBuilt) == 0x000008, "Wrong alignment on NavigationSystem_IsNavigationBeingBuilt");
static_assert(sizeof(NavigationSystem_IsNavigationBeingBuilt) == 0x000010, "Wrong size on NavigationSystem_IsNavigationBeingBuilt");
static_assert(offsetof(NavigationSystem_IsNavigationBeingBuilt, WorldContextObject) == 0x000000, "Member 'NavigationSystem_IsNavigationBeingBuilt::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_IsNavigationBeingBuilt, ReturnValue) == 0x000008, "Member 'NavigationSystem_IsNavigationBeingBuilt::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.IsNavigationBeingBuiltOrLocked
// 0x0010 (0x0010 - 0x0000)
struct NavigationSystem_IsNavigationBeingBuiltOrLocked final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_IsNavigationBeingBuiltOrLocked) == 0x000008, "Wrong alignment on NavigationSystem_IsNavigationBeingBuiltOrLocked");
static_assert(sizeof(NavigationSystem_IsNavigationBeingBuiltOrLocked) == 0x000010, "Wrong size on NavigationSystem_IsNavigationBeingBuiltOrLocked");
static_assert(offsetof(NavigationSystem_IsNavigationBeingBuiltOrLocked, WorldContextObject) == 0x000000, "Member 'NavigationSystem_IsNavigationBeingBuiltOrLocked::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_IsNavigationBeingBuiltOrLocked, ReturnValue) == 0x000008, "Member 'NavigationSystem_IsNavigationBeingBuiltOrLocked::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.K2_GetRandomPointInNavigableRadius
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_K2_GetRandomPointInNavigableRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomLocation;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_K2_GetRandomPointInNavigableRadius) == 0x000008, "Wrong alignment on NavigationSystem_K2_GetRandomPointInNavigableRadius");
static_assert(sizeof(NavigationSystem_K2_GetRandomPointInNavigableRadius) == 0x000040, "Wrong size on NavigationSystem_K2_GetRandomPointInNavigableRadius");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, WorldContextObject) == 0x000000, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, Origin) == 0x000008, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::Origin' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, RandomLocation) == 0x000014, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::RandomLocation' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, Radius) == 0x000020, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::Radius' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, NavData) == 0x000028, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, FilterClass) == 0x000030, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomPointInNavigableRadius, ReturnValue) == 0x000038, "Member 'NavigationSystem_K2_GetRandomPointInNavigableRadius::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.K2_GetRandomReachablePointInRadius
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_K2_GetRandomReachablePointInRadius final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Origin;                                            // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RandomLocation;                                    // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0020(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0038(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_K2_GetRandomReachablePointInRadius) == 0x000008, "Wrong alignment on NavigationSystem_K2_GetRandomReachablePointInRadius");
static_assert(sizeof(NavigationSystem_K2_GetRandomReachablePointInRadius) == 0x000040, "Wrong size on NavigationSystem_K2_GetRandomReachablePointInRadius");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, WorldContextObject) == 0x000000, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, Origin) == 0x000008, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::Origin' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, RandomLocation) == 0x000014, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::RandomLocation' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, Radius) == 0x000020, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::Radius' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, NavData) == 0x000028, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, FilterClass) == 0x000030, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_GetRandomReachablePointInRadius, ReturnValue) == 0x000038, "Member 'NavigationSystem_K2_GetRandomReachablePointInRadius::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.K2_ProjectPointToNavigation
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_K2_ProjectPointToNavigation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ProjectedLocation;                                 // 0x0014(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class ANavigationData*                        NavData;                                           // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0028(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryExtent;                                       // 0x0030(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x003C(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D[0x3];                                       // 0x003D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_K2_ProjectPointToNavigation) == 0x000008, "Wrong alignment on NavigationSystem_K2_ProjectPointToNavigation");
static_assert(sizeof(NavigationSystem_K2_ProjectPointToNavigation) == 0x000040, "Wrong size on NavigationSystem_K2_ProjectPointToNavigation");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, WorldContextObject) == 0x000000, "Member 'NavigationSystem_K2_ProjectPointToNavigation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, Point) == 0x000008, "Member 'NavigationSystem_K2_ProjectPointToNavigation::Point' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, ProjectedLocation) == 0x000014, "Member 'NavigationSystem_K2_ProjectPointToNavigation::ProjectedLocation' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, NavData) == 0x000020, "Member 'NavigationSystem_K2_ProjectPointToNavigation::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, FilterClass) == 0x000028, "Member 'NavigationSystem_K2_ProjectPointToNavigation::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, QueryExtent) == 0x000030, "Member 'NavigationSystem_K2_ProjectPointToNavigation::QueryExtent' has a wrong offset!");
static_assert(offsetof(NavigationSystem_K2_ProjectPointToNavigation, ReturnValue) == 0x00003C, "Member 'NavigationSystem_K2_ProjectPointToNavigation::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.NavigationRaycast
// 0x0048 (0x0048 - 0x0000)
struct NavigationSystem_NavigationRaycast final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayStart;                                          // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                RayEnd;                                            // 0x0014(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0020(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0030(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AController*                            Querier;                                           // 0x0038(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0040(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_NavigationRaycast) == 0x000008, "Wrong alignment on NavigationSystem_NavigationRaycast");
static_assert(sizeof(NavigationSystem_NavigationRaycast) == 0x000048, "Wrong size on NavigationSystem_NavigationRaycast");
static_assert(offsetof(NavigationSystem_NavigationRaycast, WorldContextObject) == 0x000000, "Member 'NavigationSystem_NavigationRaycast::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, RayStart) == 0x000008, "Member 'NavigationSystem_NavigationRaycast::RayStart' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, RayEnd) == 0x000014, "Member 'NavigationSystem_NavigationRaycast::RayEnd' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, HitLocation) == 0x000020, "Member 'NavigationSystem_NavigationRaycast::HitLocation' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, FilterClass) == 0x000030, "Member 'NavigationSystem_NavigationRaycast::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, Querier) == 0x000038, "Member 'NavigationSystem_NavigationRaycast::Querier' has a wrong offset!");
static_assert(offsetof(NavigationSystem_NavigationRaycast, ReturnValue) == 0x000040, "Member 'NavigationSystem_NavigationRaycast::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.ProjectPointToNavigation
// 0x0040 (0x0040 - 0x0000)
struct NavigationSystem_ProjectPointToNavigation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Point;                                             // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ANavigationData*                        NavData;                                           // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class UNavigationQueryFilter>     FilterClass;                                       // 0x0020(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                QueryExtent;                                       // 0x0028(0x000C)(ConstParm, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0034(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_ProjectPointToNavigation) == 0x000008, "Wrong alignment on NavigationSystem_ProjectPointToNavigation");
static_assert(sizeof(NavigationSystem_ProjectPointToNavigation) == 0x000040, "Wrong size on NavigationSystem_ProjectPointToNavigation");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, WorldContextObject) == 0x000000, "Member 'NavigationSystem_ProjectPointToNavigation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, Point) == 0x000008, "Member 'NavigationSystem_ProjectPointToNavigation::Point' has a wrong offset!");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, NavData) == 0x000018, "Member 'NavigationSystem_ProjectPointToNavigation::NavData' has a wrong offset!");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, FilterClass) == 0x000020, "Member 'NavigationSystem_ProjectPointToNavigation::FilterClass' has a wrong offset!");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, QueryExtent) == 0x000028, "Member 'NavigationSystem_ProjectPointToNavigation::QueryExtent' has a wrong offset!");
static_assert(offsetof(NavigationSystem_ProjectPointToNavigation, ReturnValue) == 0x000034, "Member 'NavigationSystem_ProjectPointToNavigation::ReturnValue' has a wrong offset!");

// Function Engine.NavigationSystem.SimpleMoveToActor
// 0x0010 (0x0010 - 0x0000)
struct NavigationSystem_SimpleMoveToActor final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	const class AActor*                           Goal;                                              // 0x0008(0x0008)(ConstParm, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_SimpleMoveToActor) == 0x000008, "Wrong alignment on NavigationSystem_SimpleMoveToActor");
static_assert(sizeof(NavigationSystem_SimpleMoveToActor) == 0x000010, "Wrong size on NavigationSystem_SimpleMoveToActor");
static_assert(offsetof(NavigationSystem_SimpleMoveToActor, Controller) == 0x000000, "Member 'NavigationSystem_SimpleMoveToActor::Controller' has a wrong offset!");
static_assert(offsetof(NavigationSystem_SimpleMoveToActor, Goal) == 0x000008, "Member 'NavigationSystem_SimpleMoveToActor::Goal' has a wrong offset!");

// Function Engine.NavigationSystem.SimpleMoveToLocation
// 0x0018 (0x0018 - 0x0000)
struct NavigationSystem_SimpleMoveToLocation final
{
public:
	class AController*                            Controller;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Goal;                                              // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavigationSystem_SimpleMoveToLocation) == 0x000008, "Wrong alignment on NavigationSystem_SimpleMoveToLocation");
static_assert(sizeof(NavigationSystem_SimpleMoveToLocation) == 0x000018, "Wrong size on NavigationSystem_SimpleMoveToLocation");
static_assert(offsetof(NavigationSystem_SimpleMoveToLocation, Controller) == 0x000000, "Member 'NavigationSystem_SimpleMoveToLocation::Controller' has a wrong offset!");
static_assert(offsetof(NavigationSystem_SimpleMoveToLocation, Goal) == 0x000008, "Member 'NavigationSystem_SimpleMoveToLocation::Goal' has a wrong offset!");

// Function Engine.NavigationSystem.OnNavigationBoundsUpdated
// 0x0008 (0x0008 - 0x0000)
struct NavigationSystem_OnNavigationBoundsUpdated final
{
public:
	class ANavMeshBoundsVolume*                   NavVolume;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_OnNavigationBoundsUpdated) == 0x000008, "Wrong alignment on NavigationSystem_OnNavigationBoundsUpdated");
static_assert(sizeof(NavigationSystem_OnNavigationBoundsUpdated) == 0x000008, "Wrong size on NavigationSystem_OnNavigationBoundsUpdated");
static_assert(offsetof(NavigationSystem_OnNavigationBoundsUpdated, NavVolume) == 0x000000, "Member 'NavigationSystem_OnNavigationBoundsUpdated::NavVolume' has a wrong offset!");

// Function Engine.NavigationSystem.RegisterNavigationInvoker
// 0x0010 (0x0010 - 0x0000)
struct NavigationSystem_RegisterNavigationInvoker final
{
public:
	class AActor*                                 Invoker;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileGenerationRadius;                              // 0x0008(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TileRemovalRadius;                                 // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_RegisterNavigationInvoker) == 0x000008, "Wrong alignment on NavigationSystem_RegisterNavigationInvoker");
static_assert(sizeof(NavigationSystem_RegisterNavigationInvoker) == 0x000010, "Wrong size on NavigationSystem_RegisterNavigationInvoker");
static_assert(offsetof(NavigationSystem_RegisterNavigationInvoker, Invoker) == 0x000000, "Member 'NavigationSystem_RegisterNavigationInvoker::Invoker' has a wrong offset!");
static_assert(offsetof(NavigationSystem_RegisterNavigationInvoker, TileGenerationRadius) == 0x000008, "Member 'NavigationSystem_RegisterNavigationInvoker::TileGenerationRadius' has a wrong offset!");
static_assert(offsetof(NavigationSystem_RegisterNavigationInvoker, TileRemovalRadius) == 0x00000C, "Member 'NavigationSystem_RegisterNavigationInvoker::TileRemovalRadius' has a wrong offset!");

// Function Engine.NavigationSystem.SetGeometryGatheringMode
// 0x0001 (0x0001 - 0x0000)
struct NavigationSystem_SetGeometryGatheringMode final
{
public:
	ENavDataGatheringModeConfig                   NewMode;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_SetGeometryGatheringMode) == 0x000001, "Wrong alignment on NavigationSystem_SetGeometryGatheringMode");
static_assert(sizeof(NavigationSystem_SetGeometryGatheringMode) == 0x000001, "Wrong size on NavigationSystem_SetGeometryGatheringMode");
static_assert(offsetof(NavigationSystem_SetGeometryGatheringMode, NewMode) == 0x000000, "Member 'NavigationSystem_SetGeometryGatheringMode::NewMode' has a wrong offset!");

// Function Engine.NavigationSystem.SetMaxSimultaneousTileGenerationJobsCount
// 0x0004 (0x0004 - 0x0000)
struct NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount final
{
public:
	int32                                         MaxNumberOfJobs;                                   // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount) == 0x000004, "Wrong alignment on NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount");
static_assert(sizeof(NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount) == 0x000004, "Wrong size on NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount");
static_assert(offsetof(NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount, MaxNumberOfJobs) == 0x000000, "Member 'NavigationSystem_SetMaxSimultaneousTileGenerationJobsCount::MaxNumberOfJobs' has a wrong offset!");

// Function Engine.NavigationSystem.UnregisterNavigationInvoker
// 0x0008 (0x0008 - 0x0000)
struct NavigationSystem_UnregisterNavigationInvoker final
{
public:
	class AActor*                                 Invoker;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavigationSystem_UnregisterNavigationInvoker) == 0x000008, "Wrong alignment on NavigationSystem_UnregisterNavigationInvoker");
static_assert(sizeof(NavigationSystem_UnregisterNavigationInvoker) == 0x000008, "Wrong size on NavigationSystem_UnregisterNavigationInvoker");
static_assert(offsetof(NavigationSystem_UnregisterNavigationInvoker, Invoker) == 0x000000, "Member 'NavigationSystem_UnregisterNavigationInvoker::Invoker' has a wrong offset!");

// Function Engine.NavLinkProxy.ReceiveSmartLinkReached
// 0x0018 (0x0018 - 0x0000)
struct NavLinkProxy_ReceiveSmartLinkReached final
{
public:
	class AActor*                                 Agent;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Destination;                                       // 0x0008(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(NavLinkProxy_ReceiveSmartLinkReached) == 0x000008, "Wrong alignment on NavLinkProxy_ReceiveSmartLinkReached");
static_assert(sizeof(NavLinkProxy_ReceiveSmartLinkReached) == 0x000018, "Wrong size on NavLinkProxy_ReceiveSmartLinkReached");
static_assert(offsetof(NavLinkProxy_ReceiveSmartLinkReached, Agent) == 0x000000, "Member 'NavLinkProxy_ReceiveSmartLinkReached::Agent' has a wrong offset!");
static_assert(offsetof(NavLinkProxy_ReceiveSmartLinkReached, Destination) == 0x000008, "Member 'NavLinkProxy_ReceiveSmartLinkReached::Destination' has a wrong offset!");

// Function Engine.NavLinkProxy.ResumePathFollowing
// 0x0008 (0x0008 - 0x0000)
struct NavLinkProxy_ResumePathFollowing final
{
public:
	class AActor*                                 Agent;                                             // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavLinkProxy_ResumePathFollowing) == 0x000008, "Wrong alignment on NavLinkProxy_ResumePathFollowing");
static_assert(sizeof(NavLinkProxy_ResumePathFollowing) == 0x000008, "Wrong size on NavLinkProxy_ResumePathFollowing");
static_assert(offsetof(NavLinkProxy_ResumePathFollowing, Agent) == 0x000000, "Member 'NavLinkProxy_ResumePathFollowing::Agent' has a wrong offset!");

// Function Engine.NavLinkProxy.SetSmartLinkEnabled
// 0x0001 (0x0001 - 0x0000)
struct NavLinkProxy_SetSmartLinkEnabled final
{
public:
	bool                                          bEnabled;                                          // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavLinkProxy_SetSmartLinkEnabled) == 0x000001, "Wrong alignment on NavLinkProxy_SetSmartLinkEnabled");
static_assert(sizeof(NavLinkProxy_SetSmartLinkEnabled) == 0x000001, "Wrong size on NavLinkProxy_SetSmartLinkEnabled");
static_assert(offsetof(NavLinkProxy_SetSmartLinkEnabled, bEnabled) == 0x000000, "Member 'NavLinkProxy_SetSmartLinkEnabled::bEnabled' has a wrong offset!");

// Function Engine.NavLinkProxy.HasMovingAgents
// 0x0001 (0x0001 - 0x0000)
struct NavLinkProxy_HasMovingAgents final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavLinkProxy_HasMovingAgents) == 0x000001, "Wrong alignment on NavLinkProxy_HasMovingAgents");
static_assert(sizeof(NavLinkProxy_HasMovingAgents) == 0x000001, "Wrong size on NavLinkProxy_HasMovingAgents");
static_assert(offsetof(NavLinkProxy_HasMovingAgents, ReturnValue) == 0x000000, "Member 'NavLinkProxy_HasMovingAgents::ReturnValue' has a wrong offset!");

// Function Engine.NavLinkProxy.IsSmartLinkEnabled
// 0x0001 (0x0001 - 0x0000)
struct NavLinkProxy_IsSmartLinkEnabled final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavLinkProxy_IsSmartLinkEnabled) == 0x000001, "Wrong alignment on NavLinkProxy_IsSmartLinkEnabled");
static_assert(sizeof(NavLinkProxy_IsSmartLinkEnabled) == 0x000001, "Wrong size on NavLinkProxy_IsSmartLinkEnabled");
static_assert(offsetof(NavLinkProxy_IsSmartLinkEnabled, ReturnValue) == 0x000000, "Member 'NavLinkProxy_IsSmartLinkEnabled::ReturnValue' has a wrong offset!");

// Function Engine.NavModifierComponent.SetAreaClass
// 0x0008 (0x0008 - 0x0000)
struct NavModifierComponent_SetAreaClass final
{
public:
	TSubclassOf<class UNavArea>                   NewAreaClass;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(NavModifierComponent_SetAreaClass) == 0x000008, "Wrong alignment on NavModifierComponent_SetAreaClass");
static_assert(sizeof(NavModifierComponent_SetAreaClass) == 0x000008, "Wrong size on NavModifierComponent_SetAreaClass");
static_assert(offsetof(NavModifierComponent_SetAreaClass, NewAreaClass) == 0x000000, "Member 'NavModifierComponent_SetAreaClass::NewAreaClass' has a wrong offset!");

// Function Engine.ParticleSystem.ContainsEmitterType
// 0x0010 (0x0010 - 0x0000)
struct ParticleSystem_ContainsEmitterType final
{
public:
	class UClass*                                 TypeData;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0008(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(ParticleSystem_ContainsEmitterType) == 0x000008, "Wrong alignment on ParticleSystem_ContainsEmitterType");
static_assert(sizeof(ParticleSystem_ContainsEmitterType) == 0x000010, "Wrong size on ParticleSystem_ContainsEmitterType");
static_assert(offsetof(ParticleSystem_ContainsEmitterType, TypeData) == 0x000000, "Member 'ParticleSystem_ContainsEmitterType::TypeData' has a wrong offset!");
static_assert(offsetof(ParticleSystem_ContainsEmitterType, ReturnValue) == 0x000008, "Member 'ParticleSystem_ContainsEmitterType::ReturnValue' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationProfileBelow
// 0x0018 (0x0018 - 0x0000)
struct PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ProfileName;                                       // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bClearNotFound;                                    // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow) == 0x000004, "Wrong alignment on PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow");
static_assert(sizeof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow) == 0x000018, "Wrong size on PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow, BodyName) == 0x000000, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow::BodyName' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow, ProfileName) == 0x000008, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow::ProfileName' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow, bIncludeSelf) == 0x000010, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow::bIncludeSelf' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow, bClearNotFound) == 0x000011, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationProfileBelow::bClearNotFound' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettings
// 0x0030 (0x0030 - 0x0000)
struct PhysicalAnimationComponent_ApplyPhysicalAnimationSettings final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicalAnimationData                 PhysicalAnimationData;                             // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettings) == 0x000008, "Wrong alignment on PhysicalAnimationComponent_ApplyPhysicalAnimationSettings");
static_assert(sizeof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettings) == 0x000030, "Wrong size on PhysicalAnimationComponent_ApplyPhysicalAnimationSettings");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettings, BodyName) == 0x000000, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationSettings::BodyName' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettings, PhysicalAnimationData) == 0x000008, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationSettings::PhysicalAnimationData' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.ApplyPhysicalAnimationSettingsBelow
// 0x0038 (0x0038 - 0x0000)
struct PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPhysicalAnimationData                 PhysicalAnimationData;                             // 0x0008(0x0028)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIncludeSelf;                                      // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow) == 0x000008, "Wrong alignment on PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow");
static_assert(sizeof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow) == 0x000038, "Wrong size on PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow, BodyName) == 0x000000, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow::BodyName' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow, PhysicalAnimationData) == 0x000008, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow::PhysicalAnimationData' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow, bIncludeSelf) == 0x000030, "Member 'PhysicalAnimationComponent_ApplyPhysicalAnimationSettingsBelow::bIncludeSelf' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.SetSkeletalMeshComponent
// 0x0008 (0x0008 - 0x0000)
struct PhysicalAnimationComponent_SetSkeletalMeshComponent final
{
public:
	class USkeletalMeshComponent*                 InSkeletalMeshComponent;                           // 0x0000(0x0008)(Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicalAnimationComponent_SetSkeletalMeshComponent) == 0x000008, "Wrong alignment on PhysicalAnimationComponent_SetSkeletalMeshComponent");
static_assert(sizeof(PhysicalAnimationComponent_SetSkeletalMeshComponent) == 0x000008, "Wrong size on PhysicalAnimationComponent_SetSkeletalMeshComponent");
static_assert(offsetof(PhysicalAnimationComponent_SetSkeletalMeshComponent, InSkeletalMeshComponent) == 0x000000, "Member 'PhysicalAnimationComponent_SetSkeletalMeshComponent::InSkeletalMeshComponent' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.SetStrengthMultiplyer
// 0x0004 (0x0004 - 0x0000)
struct PhysicalAnimationComponent_SetStrengthMultiplyer final
{
public:
	float                                         InStrengthMultiplyer;                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicalAnimationComponent_SetStrengthMultiplyer) == 0x000004, "Wrong alignment on PhysicalAnimationComponent_SetStrengthMultiplyer");
static_assert(sizeof(PhysicalAnimationComponent_SetStrengthMultiplyer) == 0x000004, "Wrong size on PhysicalAnimationComponent_SetStrengthMultiplyer");
static_assert(offsetof(PhysicalAnimationComponent_SetStrengthMultiplyer, InStrengthMultiplyer) == 0x000000, "Member 'PhysicalAnimationComponent_SetStrengthMultiplyer::InStrengthMultiplyer' has a wrong offset!");

// Function Engine.PhysicalAnimationComponent.GetBodyTargetTransform
// 0x0040 (0x0040 - 0x0000)
struct PhysicalAnimationComponent_GetBodyTargetTransform final
{
public:
	class FName                                   BodyName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PhysicalAnimationComponent_GetBodyTargetTransform) == 0x000010, "Wrong alignment on PhysicalAnimationComponent_GetBodyTargetTransform");
static_assert(sizeof(PhysicalAnimationComponent_GetBodyTargetTransform) == 0x000040, "Wrong size on PhysicalAnimationComponent_GetBodyTargetTransform");
static_assert(offsetof(PhysicalAnimationComponent_GetBodyTargetTransform, BodyName) == 0x000000, "Member 'PhysicalAnimationComponent_GetBodyTargetTransform::BodyName' has a wrong offset!");
static_assert(offsetof(PhysicalAnimationComponent_GetBodyTargetTransform, ReturnValue) == 0x000010, "Member 'PhysicalAnimationComponent_GetBodyTargetTransform::ReturnValue' has a wrong offset!");

// Function Engine.PlanarReflection.OnInterpToggle
// 0x0001 (0x0001 - 0x0000)
struct PlanarReflection_OnInterpToggle final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlanarReflection_OnInterpToggle) == 0x000001, "Wrong alignment on PlanarReflection_OnInterpToggle");
static_assert(sizeof(PlanarReflection_OnInterpToggle) == 0x000001, "Wrong size on PlanarReflection_OnInterpToggle");
static_assert(offsetof(PlanarReflection_OnInterpToggle, bEnable) == 0x000000, "Member 'PlanarReflection_OnInterpToggle::bEnable' has a wrong offset!");

// Function Engine.PlatformEventsComponent.IsInLaptopMode
// 0x0001 (0x0001 - 0x0000)
struct PlatformEventsComponent_IsInLaptopMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformEventsComponent_IsInLaptopMode) == 0x000001, "Wrong alignment on PlatformEventsComponent_IsInLaptopMode");
static_assert(sizeof(PlatformEventsComponent_IsInLaptopMode) == 0x000001, "Wrong size on PlatformEventsComponent_IsInLaptopMode");
static_assert(offsetof(PlatformEventsComponent_IsInLaptopMode, ReturnValue) == 0x000000, "Member 'PlatformEventsComponent_IsInLaptopMode::ReturnValue' has a wrong offset!");

// Function Engine.PlatformEventsComponent.IsInTabletMode
// 0x0001 (0x0001 - 0x0000)
struct PlatformEventsComponent_IsInTabletMode final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformEventsComponent_IsInTabletMode) == 0x000001, "Wrong alignment on PlatformEventsComponent_IsInTabletMode");
static_assert(sizeof(PlatformEventsComponent_IsInTabletMode) == 0x000001, "Wrong size on PlatformEventsComponent_IsInTabletMode");
static_assert(offsetof(PlatformEventsComponent_IsInTabletMode, ReturnValue) == 0x000000, "Member 'PlatformEventsComponent_IsInTabletMode::ReturnValue' has a wrong offset!");

// Function Engine.PlatformEventsComponent.SupportsConvertibleLaptops
// 0x0001 (0x0001 - 0x0000)
struct PlatformEventsComponent_SupportsConvertibleLaptops final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformEventsComponent_SupportsConvertibleLaptops) == 0x000001, "Wrong alignment on PlatformEventsComponent_SupportsConvertibleLaptops");
static_assert(sizeof(PlatformEventsComponent_SupportsConvertibleLaptops) == 0x000001, "Wrong size on PlatformEventsComponent_SupportsConvertibleLaptops");
static_assert(offsetof(PlatformEventsComponent_SupportsConvertibleLaptops, ReturnValue) == 0x000000, "Member 'PlatformEventsComponent_SupportsConvertibleLaptops::ReturnValue' has a wrong offset!");

// Function Engine.PlatformInterfaceWebResponse.GetHeader
// 0x0028 (0x0028 - 0x0000)
struct PlatformInterfaceWebResponse_GetHeader final
{
public:
	int32                                         HeaderIndex;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Header;                                            // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Value;                                             // 0x0018(0x0010)(Parm, OutParm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformInterfaceWebResponse_GetHeader) == 0x000008, "Wrong alignment on PlatformInterfaceWebResponse_GetHeader");
static_assert(sizeof(PlatformInterfaceWebResponse_GetHeader) == 0x000028, "Wrong size on PlatformInterfaceWebResponse_GetHeader");
static_assert(offsetof(PlatformInterfaceWebResponse_GetHeader, HeaderIndex) == 0x000000, "Member 'PlatformInterfaceWebResponse_GetHeader::HeaderIndex' has a wrong offset!");
static_assert(offsetof(PlatformInterfaceWebResponse_GetHeader, Header) == 0x000008, "Member 'PlatformInterfaceWebResponse_GetHeader::Header' has a wrong offset!");
static_assert(offsetof(PlatformInterfaceWebResponse_GetHeader, Value) == 0x000018, "Member 'PlatformInterfaceWebResponse_GetHeader::Value' has a wrong offset!");

// Function Engine.PlatformInterfaceWebResponse.GetHeaderValue
// 0x0020 (0x0020 - 0x0000)
struct PlatformInterfaceWebResponse_GetHeaderValue final
{
public:
	class FString                                 HeaderName;                                        // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ReturnValue;                                       // 0x0010(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformInterfaceWebResponse_GetHeaderValue) == 0x000008, "Wrong alignment on PlatformInterfaceWebResponse_GetHeaderValue");
static_assert(sizeof(PlatformInterfaceWebResponse_GetHeaderValue) == 0x000020, "Wrong size on PlatformInterfaceWebResponse_GetHeaderValue");
static_assert(offsetof(PlatformInterfaceWebResponse_GetHeaderValue, HeaderName) == 0x000000, "Member 'PlatformInterfaceWebResponse_GetHeaderValue::HeaderName' has a wrong offset!");
static_assert(offsetof(PlatformInterfaceWebResponse_GetHeaderValue, ReturnValue) == 0x000010, "Member 'PlatformInterfaceWebResponse_GetHeaderValue::ReturnValue' has a wrong offset!");

// Function Engine.PlatformInterfaceWebResponse.GetNumHeaders
// 0x0004 (0x0004 - 0x0000)
struct PlatformInterfaceWebResponse_GetNumHeaders final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PlatformInterfaceWebResponse_GetNumHeaders) == 0x000004, "Wrong alignment on PlatformInterfaceWebResponse_GetNumHeaders");
static_assert(sizeof(PlatformInterfaceWebResponse_GetNumHeaders) == 0x000004, "Wrong size on PlatformInterfaceWebResponse_GetNumHeaders");
static_assert(offsetof(PlatformInterfaceWebResponse_GetNumHeaders, ReturnValue) == 0x000000, "Member 'PlatformInterfaceWebResponse_GetNumHeaders::ReturnValue' has a wrong offset!");

// Function Engine.PointLight.SetLightFalloffExponent
// 0x0004 (0x0004 - 0x0000)
struct PointLight_SetLightFalloffExponent final
{
public:
	float                                         NewLightFalloffExponent;                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLight_SetLightFalloffExponent) == 0x000004, "Wrong alignment on PointLight_SetLightFalloffExponent");
static_assert(sizeof(PointLight_SetLightFalloffExponent) == 0x000004, "Wrong size on PointLight_SetLightFalloffExponent");
static_assert(offsetof(PointLight_SetLightFalloffExponent, NewLightFalloffExponent) == 0x000000, "Member 'PointLight_SetLightFalloffExponent::NewLightFalloffExponent' has a wrong offset!");

// Function Engine.PointLight.SetRadius
// 0x0004 (0x0004 - 0x0000)
struct PointLight_SetRadius final
{
public:
	float                                         NewRadius;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PointLight_SetRadius) == 0x000004, "Wrong alignment on PointLight_SetRadius");
static_assert(sizeof(PointLight_SetRadius) == 0x000004, "Wrong size on PointLight_SetRadius");
static_assert(offsetof(PointLight_SetRadius, NewRadius) == 0x000000, "Member 'PointLight_SetRadius::NewRadius' has a wrong offset!");

// Function Engine.PoseableMeshComponent.CopyPoseFromSkeletalComponent
// 0x0008 (0x0008 - 0x0000)
struct PoseableMeshComponent_CopyPoseFromSkeletalComponent final
{
public:
	const class USkeletalMeshComponent*           InComponentToCopy;                                 // 0x0000(0x0008)(ConstParm, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_CopyPoseFromSkeletalComponent) == 0x000008, "Wrong alignment on PoseableMeshComponent_CopyPoseFromSkeletalComponent");
static_assert(sizeof(PoseableMeshComponent_CopyPoseFromSkeletalComponent) == 0x000008, "Wrong size on PoseableMeshComponent_CopyPoseFromSkeletalComponent");
static_assert(offsetof(PoseableMeshComponent_CopyPoseFromSkeletalComponent, InComponentToCopy) == 0x000000, "Member 'PoseableMeshComponent_CopyPoseFromSkeletalComponent::InComponentToCopy' has a wrong offset!");

// Function Engine.PoseableMeshComponent.GetBoneLocationByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_GetBoneLocationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_GetBoneLocationByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_GetBoneLocationByName");
static_assert(sizeof(PoseableMeshComponent_GetBoneLocationByName) == 0x000018, "Wrong size on PoseableMeshComponent_GetBoneLocationByName");
static_assert(offsetof(PoseableMeshComponent_GetBoneLocationByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_GetBoneLocationByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneLocationByName, BoneSpace) == 0x000008, "Member 'PoseableMeshComponent_GetBoneLocationByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneLocationByName, ReturnValue) == 0x00000C, "Member 'PoseableMeshComponent_GetBoneLocationByName::ReturnValue' has a wrong offset!");

// Function Engine.PoseableMeshComponent.GetBoneRotationByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_GetBoneRotationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_GetBoneRotationByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_GetBoneRotationByName");
static_assert(sizeof(PoseableMeshComponent_GetBoneRotationByName) == 0x000018, "Wrong size on PoseableMeshComponent_GetBoneRotationByName");
static_assert(offsetof(PoseableMeshComponent_GetBoneRotationByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_GetBoneRotationByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneRotationByName, BoneSpace) == 0x000008, "Member 'PoseableMeshComponent_GetBoneRotationByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneRotationByName, ReturnValue) == 0x00000C, "Member 'PoseableMeshComponent_GetBoneRotationByName::ReturnValue' has a wrong offset!");

// Function Engine.PoseableMeshComponent.GetBoneScaleByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_GetBoneScaleByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_GetBoneScaleByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_GetBoneScaleByName");
static_assert(sizeof(PoseableMeshComponent_GetBoneScaleByName) == 0x000018, "Wrong size on PoseableMeshComponent_GetBoneScaleByName");
static_assert(offsetof(PoseableMeshComponent_GetBoneScaleByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_GetBoneScaleByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneScaleByName, BoneSpace) == 0x000008, "Member 'PoseableMeshComponent_GetBoneScaleByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneScaleByName, ReturnValue) == 0x00000C, "Member 'PoseableMeshComponent_GetBoneScaleByName::ReturnValue' has a wrong offset!");

// Function Engine.PoseableMeshComponent.GetBoneTransformByName
// 0x0040 (0x0040 - 0x0000)
struct PoseableMeshComponent_GetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_GetBoneTransformByName) == 0x000010, "Wrong alignment on PoseableMeshComponent_GetBoneTransformByName");
static_assert(sizeof(PoseableMeshComponent_GetBoneTransformByName) == 0x000040, "Wrong size on PoseableMeshComponent_GetBoneTransformByName");
static_assert(offsetof(PoseableMeshComponent_GetBoneTransformByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_GetBoneTransformByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneTransformByName, BoneSpace) == 0x000008, "Member 'PoseableMeshComponent_GetBoneTransformByName::BoneSpace' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_GetBoneTransformByName, ReturnValue) == 0x000010, "Member 'PoseableMeshComponent_GetBoneTransformByName::ReturnValue' has a wrong offset!");

// Function Engine.PoseableMeshComponent.ResetBoneTransformByName
// 0x0008 (0x0008 - 0x0000)
struct PoseableMeshComponent_ResetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(PoseableMeshComponent_ResetBoneTransformByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_ResetBoneTransformByName");
static_assert(sizeof(PoseableMeshComponent_ResetBoneTransformByName) == 0x000008, "Wrong size on PoseableMeshComponent_ResetBoneTransformByName");
static_assert(offsetof(PoseableMeshComponent_ResetBoneTransformByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_ResetBoneTransformByName::BoneName' has a wrong offset!");

// Function Engine.PoseableMeshComponent.SetBoneLocationByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_SetBoneLocationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PoseableMeshComponent_SetBoneLocationByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_SetBoneLocationByName");
static_assert(sizeof(PoseableMeshComponent_SetBoneLocationByName) == 0x000018, "Wrong size on PoseableMeshComponent_SetBoneLocationByName");
static_assert(offsetof(PoseableMeshComponent_SetBoneLocationByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_SetBoneLocationByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneLocationByName, InLocation) == 0x000008, "Member 'PoseableMeshComponent_SetBoneLocationByName::InLocation' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneLocationByName, BoneSpace) == 0x000014, "Member 'PoseableMeshComponent_SetBoneLocationByName::BoneSpace' has a wrong offset!");

// Function Engine.PoseableMeshComponent.SetBoneRotationByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_SetBoneRotationByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               InRotation;                                        // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PoseableMeshComponent_SetBoneRotationByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_SetBoneRotationByName");
static_assert(sizeof(PoseableMeshComponent_SetBoneRotationByName) == 0x000018, "Wrong size on PoseableMeshComponent_SetBoneRotationByName");
static_assert(offsetof(PoseableMeshComponent_SetBoneRotationByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_SetBoneRotationByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneRotationByName, InRotation) == 0x000008, "Member 'PoseableMeshComponent_SetBoneRotationByName::InRotation' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneRotationByName, BoneSpace) == 0x000014, "Member 'PoseableMeshComponent_SetBoneRotationByName::BoneSpace' has a wrong offset!");

// Function Engine.PoseableMeshComponent.SetBoneScaleByName
// 0x0018 (0x0018 - 0x0000)
struct PoseableMeshComponent_SetBoneScaleByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InScale3D;                                         // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0014(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_15[0x3];                                       // 0x0015(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PoseableMeshComponent_SetBoneScaleByName) == 0x000004, "Wrong alignment on PoseableMeshComponent_SetBoneScaleByName");
static_assert(sizeof(PoseableMeshComponent_SetBoneScaleByName) == 0x000018, "Wrong size on PoseableMeshComponent_SetBoneScaleByName");
static_assert(offsetof(PoseableMeshComponent_SetBoneScaleByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_SetBoneScaleByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneScaleByName, InScale3D) == 0x000008, "Member 'PoseableMeshComponent_SetBoneScaleByName::InScale3D' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneScaleByName, BoneSpace) == 0x000014, "Member 'PoseableMeshComponent_SetBoneScaleByName::BoneSpace' has a wrong offset!");

// Function Engine.PoseableMeshComponent.SetBoneTransformByName
// 0x0050 (0x0050 - 0x0000)
struct PoseableMeshComponent_SetBoneTransformByName final
{
public:
	class FName                                   BoneName;                                          // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8[0x8];                                        // 0x0008(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             InTransform;                                       // 0x0010(0x0030)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	EBoneSpaces                                   BoneSpace;                                         // 0x0040(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0xF];                                       // 0x0041(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PoseableMeshComponent_SetBoneTransformByName) == 0x000010, "Wrong alignment on PoseableMeshComponent_SetBoneTransformByName");
static_assert(sizeof(PoseableMeshComponent_SetBoneTransformByName) == 0x000050, "Wrong size on PoseableMeshComponent_SetBoneTransformByName");
static_assert(offsetof(PoseableMeshComponent_SetBoneTransformByName, BoneName) == 0x000000, "Member 'PoseableMeshComponent_SetBoneTransformByName::BoneName' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneTransformByName, InTransform) == 0x000010, "Member 'PoseableMeshComponent_SetBoneTransformByName::InTransform' has a wrong offset!");
static_assert(offsetof(PoseableMeshComponent_SetBoneTransformByName, BoneSpace) == 0x000040, "Member 'PoseableMeshComponent_SetBoneTransformByName::BoneSpace' has a wrong offset!");

// Function Engine.PostProcessComponent.AddOrUpdateBlendable
// 0x0018 (0x0018 - 0x0000)
struct PostProcessComponent_AddOrUpdateBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(PostProcessComponent_AddOrUpdateBlendable) == 0x000008, "Wrong alignment on PostProcessComponent_AddOrUpdateBlendable");
static_assert(sizeof(PostProcessComponent_AddOrUpdateBlendable) == 0x000018, "Wrong size on PostProcessComponent_AddOrUpdateBlendable");
static_assert(offsetof(PostProcessComponent_AddOrUpdateBlendable, InBlendableObject) == 0x000000, "Member 'PostProcessComponent_AddOrUpdateBlendable::InBlendableObject' has a wrong offset!");
static_assert(offsetof(PostProcessComponent_AddOrUpdateBlendable, InWeight) == 0x000010, "Member 'PostProcessComponent_AddOrUpdateBlendable::InWeight' has a wrong offset!");

// Function Engine.RadialForceComponent.AddObjectTypeToAffect
// 0x0001 (0x0001 - 0x0000)
struct RadialForceComponent_AddObjectTypeToAffect final
{
public:
	EObjectTypeQuery                              ObjectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RadialForceComponent_AddObjectTypeToAffect) == 0x000001, "Wrong alignment on RadialForceComponent_AddObjectTypeToAffect");
static_assert(sizeof(RadialForceComponent_AddObjectTypeToAffect) == 0x000001, "Wrong size on RadialForceComponent_AddObjectTypeToAffect");
static_assert(offsetof(RadialForceComponent_AddObjectTypeToAffect, ObjectType) == 0x000000, "Member 'RadialForceComponent_AddObjectTypeToAffect::ObjectType' has a wrong offset!");

// Function Engine.RadialForceComponent.RemoveObjectTypeToAffect
// 0x0001 (0x0001 - 0x0000)
struct RadialForceComponent_RemoveObjectTypeToAffect final
{
public:
	EObjectTypeQuery                              ObjectType;                                        // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(RadialForceComponent_RemoveObjectTypeToAffect) == 0x000001, "Wrong alignment on RadialForceComponent_RemoveObjectTypeToAffect");
static_assert(sizeof(RadialForceComponent_RemoveObjectTypeToAffect) == 0x000001, "Wrong size on RadialForceComponent_RemoveObjectTypeToAffect");
static_assert(offsetof(RadialForceComponent_RemoveObjectTypeToAffect, ObjectType) == 0x000000, "Member 'RadialForceComponent_RemoveObjectTypeToAffect::ObjectType' has a wrong offset!");

// Function Engine.SceneCaptureComponent2D.AddOrUpdateBlendable
// 0x0018 (0x0018 - 0x0000)
struct SceneCaptureComponent2D_AddOrUpdateBlendable final
{
public:
	TScriptInterface<class IBlendableInterface>   InBlendableObject;                                 // 0x0000(0x0010)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, NativeAccessSpecifierPublic)
	float                                         InWeight;                                          // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SceneCaptureComponent2D_AddOrUpdateBlendable) == 0x000008, "Wrong alignment on SceneCaptureComponent2D_AddOrUpdateBlendable");
static_assert(sizeof(SceneCaptureComponent2D_AddOrUpdateBlendable) == 0x000018, "Wrong size on SceneCaptureComponent2D_AddOrUpdateBlendable");
static_assert(offsetof(SceneCaptureComponent2D_AddOrUpdateBlendable, InBlendableObject) == 0x000000, "Member 'SceneCaptureComponent2D_AddOrUpdateBlendable::InBlendableObject' has a wrong offset!");
static_assert(offsetof(SceneCaptureComponent2D_AddOrUpdateBlendable, InWeight) == 0x000010, "Member 'SceneCaptureComponent2D_AddOrUpdateBlendable::InWeight' has a wrong offset!");

// Function Engine.SceneCaptureCube.OnInterpToggle
// 0x0001 (0x0001 - 0x0000)
struct SceneCaptureCube_OnInterpToggle final
{
public:
	bool                                          bEnable;                                           // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SceneCaptureCube_OnInterpToggle) == 0x000001, "Wrong alignment on SceneCaptureCube_OnInterpToggle");
static_assert(sizeof(SceneCaptureCube_OnInterpToggle) == 0x000001, "Wrong size on SceneCaptureCube_OnInterpToggle");
static_assert(offsetof(SceneCaptureCube_OnInterpToggle, bEnable) == 0x000000, "Member 'SceneCaptureCube_OnInterpToggle::bEnable' has a wrong offset!");

// Function Engine.SkeletalMesh.FindSocket
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMesh_FindSocket final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class USkeletalMeshSocket*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_FindSocket) == 0x000008, "Wrong alignment on SkeletalMesh_FindSocket");
static_assert(sizeof(SkeletalMesh_FindSocket) == 0x000010, "Wrong size on SkeletalMesh_FindSocket");
static_assert(offsetof(SkeletalMesh_FindSocket, InSocketName) == 0x000000, "Member 'SkeletalMesh_FindSocket::InSocketName' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_FindSocket, ReturnValue) == 0x000008, "Member 'SkeletalMesh_FindSocket::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.FindSocketAndIndex
// 0x0018 (0x0018 - 0x0000)
struct SkeletalMesh_FindSocketAndIndex final
{
public:
	class FName                                   InSocketName;                                      // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutIndex;                                          // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    ReturnValue;                                       // 0x0010(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_FindSocketAndIndex) == 0x000008, "Wrong alignment on SkeletalMesh_FindSocketAndIndex");
static_assert(sizeof(SkeletalMesh_FindSocketAndIndex) == 0x000018, "Wrong size on SkeletalMesh_FindSocketAndIndex");
static_assert(offsetof(SkeletalMesh_FindSocketAndIndex, InSocketName) == 0x000000, "Member 'SkeletalMesh_FindSocketAndIndex::InSocketName' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_FindSocketAndIndex, OutIndex) == 0x000008, "Member 'SkeletalMesh_FindSocketAndIndex::OutIndex' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_FindSocketAndIndex, ReturnValue) == 0x000010, "Member 'SkeletalMesh_FindSocketAndIndex::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.GetBounds
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMesh_GetBounds final
{
public:
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_GetBounds) == 0x000004, "Wrong alignment on SkeletalMesh_GetBounds");
static_assert(sizeof(SkeletalMesh_GetBounds) == 0x000020, "Wrong size on SkeletalMesh_GetBounds");
static_assert(offsetof(SkeletalMesh_GetBounds, ReturnValue) == 0x000000, "Member 'SkeletalMesh_GetBounds::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.GetImportedBounds
// 0x0020 (0x0020 - 0x0000)
struct SkeletalMesh_GetImportedBounds final
{
public:
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_GetImportedBounds) == 0x000004, "Wrong alignment on SkeletalMesh_GetImportedBounds");
static_assert(sizeof(SkeletalMesh_GetImportedBounds) == 0x000020, "Wrong size on SkeletalMesh_GetImportedBounds");
static_assert(offsetof(SkeletalMesh_GetImportedBounds, ReturnValue) == 0x000000, "Member 'SkeletalMesh_GetImportedBounds::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.GetNodeMappingContainer
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMesh_GetNodeMappingContainer final
{
public:
	class UBlueprint*                             SourceAsset;                                       // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UNodeMappingContainer*                  ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_GetNodeMappingContainer) == 0x000008, "Wrong alignment on SkeletalMesh_GetNodeMappingContainer");
static_assert(sizeof(SkeletalMesh_GetNodeMappingContainer) == 0x000010, "Wrong size on SkeletalMesh_GetNodeMappingContainer");
static_assert(offsetof(SkeletalMesh_GetNodeMappingContainer, SourceAsset) == 0x000000, "Member 'SkeletalMesh_GetNodeMappingContainer::SourceAsset' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_GetNodeMappingContainer, ReturnValue) == 0x000008, "Member 'SkeletalMesh_GetNodeMappingContainer::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.GetSocketByIndex
// 0x0010 (0x0010 - 0x0000)
struct SkeletalMesh_GetSocketByIndex final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USkeletalMeshSocket*                    ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_GetSocketByIndex) == 0x000008, "Wrong alignment on SkeletalMesh_GetSocketByIndex");
static_assert(sizeof(SkeletalMesh_GetSocketByIndex) == 0x000010, "Wrong size on SkeletalMesh_GetSocketByIndex");
static_assert(offsetof(SkeletalMesh_GetSocketByIndex, Index_0) == 0x000000, "Member 'SkeletalMesh_GetSocketByIndex::Index_0' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_GetSocketByIndex, ReturnValue) == 0x000008, "Member 'SkeletalMesh_GetSocketByIndex::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.IsSectionUsingCloth
// 0x0008 (0x0008 - 0x0000)
struct SkeletalMesh_IsSectionUsingCloth final
{
public:
	int32                                         InSectionIndex;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCheckCorrespondingSections;                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0005(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkeletalMesh_IsSectionUsingCloth) == 0x000004, "Wrong alignment on SkeletalMesh_IsSectionUsingCloth");
static_assert(sizeof(SkeletalMesh_IsSectionUsingCloth) == 0x000008, "Wrong size on SkeletalMesh_IsSectionUsingCloth");
static_assert(offsetof(SkeletalMesh_IsSectionUsingCloth, InSectionIndex) == 0x000000, "Member 'SkeletalMesh_IsSectionUsingCloth::InSectionIndex' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_IsSectionUsingCloth, bCheckCorrespondingSections) == 0x000004, "Member 'SkeletalMesh_IsSectionUsingCloth::bCheckCorrespondingSections' has a wrong offset!");
static_assert(offsetof(SkeletalMesh_IsSectionUsingCloth, ReturnValue) == 0x000005, "Member 'SkeletalMesh_IsSectionUsingCloth::ReturnValue' has a wrong offset!");

// Function Engine.SkeletalMesh.NumSockets
// 0x0004 (0x0004 - 0x0000)
struct SkeletalMesh_NumSockets final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkeletalMesh_NumSockets) == 0x000004, "Wrong alignment on SkeletalMesh_NumSockets");
static_assert(sizeof(SkeletalMesh_NumSockets) == 0x000004, "Wrong size on SkeletalMesh_NumSockets");
static_assert(offsetof(SkeletalMesh_NumSockets, ReturnValue) == 0x000000, "Member 'SkeletalMesh_NumSockets::ReturnValue' has a wrong offset!");

// Function Engine.SkyLightComponent.SetCubemap
// 0x0008 (0x0008 - 0x0000)
struct SkyLightComponent_SetCubemap final
{
public:
	class UTextureCube*                           NewCubemap;                                        // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetCubemap) == 0x000008, "Wrong alignment on SkyLightComponent_SetCubemap");
static_assert(sizeof(SkyLightComponent_SetCubemap) == 0x000008, "Wrong size on SkyLightComponent_SetCubemap");
static_assert(offsetof(SkyLightComponent_SetCubemap, NewCubemap) == 0x000000, "Member 'SkyLightComponent_SetCubemap::NewCubemap' has a wrong offset!");

// Function Engine.SkyLightComponent.SetCubemapBlend
// 0x0018 (0x0018 - 0x0000)
struct SkyLightComponent_SetCubemapBlend final
{
public:
	class UTextureCube*                           SourceCubemap;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureCube*                           DestinationCubemap;                                // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InBlendFraction;                                   // 0x0010(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SkyLightComponent_SetCubemapBlend) == 0x000008, "Wrong alignment on SkyLightComponent_SetCubemapBlend");
static_assert(sizeof(SkyLightComponent_SetCubemapBlend) == 0x000018, "Wrong size on SkyLightComponent_SetCubemapBlend");
static_assert(offsetof(SkyLightComponent_SetCubemapBlend, SourceCubemap) == 0x000000, "Member 'SkyLightComponent_SetCubemapBlend::SourceCubemap' has a wrong offset!");
static_assert(offsetof(SkyLightComponent_SetCubemapBlend, DestinationCubemap) == 0x000008, "Member 'SkyLightComponent_SetCubemapBlend::DestinationCubemap' has a wrong offset!");
static_assert(offsetof(SkyLightComponent_SetCubemapBlend, InBlendFraction) == 0x000010, "Member 'SkyLightComponent_SetCubemapBlend::InBlendFraction' has a wrong offset!");

// Function Engine.SkyLightComponent.SetIndirectLightingIntensity
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetIndirectLightingIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetIndirectLightingIntensity) == 0x000004, "Wrong alignment on SkyLightComponent_SetIndirectLightingIntensity");
static_assert(sizeof(SkyLightComponent_SetIndirectLightingIntensity) == 0x000004, "Wrong size on SkyLightComponent_SetIndirectLightingIntensity");
static_assert(offsetof(SkyLightComponent_SetIndirectLightingIntensity, NewIntensity) == 0x000000, "Member 'SkyLightComponent_SetIndirectLightingIntensity::NewIntensity' has a wrong offset!");

// Function Engine.SkyLightComponent.SetIntensity
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetIntensity) == 0x000004, "Wrong alignment on SkyLightComponent_SetIntensity");
static_assert(sizeof(SkyLightComponent_SetIntensity) == 0x000004, "Wrong size on SkyLightComponent_SetIntensity");
static_assert(offsetof(SkyLightComponent_SetIntensity, NewIntensity) == 0x000000, "Member 'SkyLightComponent_SetIntensity::NewIntensity' has a wrong offset!");

// Function Engine.SkyLightComponent.SetLightColor
// 0x0010 (0x0010 - 0x0000)
struct SkyLightComponent_SetLightColor final
{
public:
	struct FLinearColor                           NewLightColor;                                     // 0x0000(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetLightColor) == 0x000004, "Wrong alignment on SkyLightComponent_SetLightColor");
static_assert(sizeof(SkyLightComponent_SetLightColor) == 0x000010, "Wrong size on SkyLightComponent_SetLightColor");
static_assert(offsetof(SkyLightComponent_SetLightColor, NewLightColor) == 0x000000, "Member 'SkyLightComponent_SetLightColor::NewLightColor' has a wrong offset!");

// Function Engine.SkyLightComponent.SetMinOcclusion
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetMinOcclusion final
{
public:
	float                                         InMinOcclusion;                                    // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetMinOcclusion) == 0x000004, "Wrong alignment on SkyLightComponent_SetMinOcclusion");
static_assert(sizeof(SkyLightComponent_SetMinOcclusion) == 0x000004, "Wrong size on SkyLightComponent_SetMinOcclusion");
static_assert(offsetof(SkyLightComponent_SetMinOcclusion, InMinOcclusion) == 0x000000, "Member 'SkyLightComponent_SetMinOcclusion::InMinOcclusion' has a wrong offset!");

// Function Engine.SkyLightComponent.SetOcclusionContrast
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetOcclusionContrast final
{
public:
	float                                         InOcclusionContrast;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetOcclusionContrast) == 0x000004, "Wrong alignment on SkyLightComponent_SetOcclusionContrast");
static_assert(sizeof(SkyLightComponent_SetOcclusionContrast) == 0x000004, "Wrong size on SkyLightComponent_SetOcclusionContrast");
static_assert(offsetof(SkyLightComponent_SetOcclusionContrast, InOcclusionContrast) == 0x000000, "Member 'SkyLightComponent_SetOcclusionContrast::InOcclusionContrast' has a wrong offset!");

// Function Engine.SkyLightComponent.SetOcclusionExponent
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetOcclusionExponent final
{
public:
	float                                         InOcclusionExponent;                               // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetOcclusionExponent) == 0x000004, "Wrong alignment on SkyLightComponent_SetOcclusionExponent");
static_assert(sizeof(SkyLightComponent_SetOcclusionExponent) == 0x000004, "Wrong size on SkyLightComponent_SetOcclusionExponent");
static_assert(offsetof(SkyLightComponent_SetOcclusionExponent, InOcclusionExponent) == 0x000000, "Member 'SkyLightComponent_SetOcclusionExponent::InOcclusionExponent' has a wrong offset!");

// Function Engine.SkyLightComponent.SetOcclusionTint
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetOcclusionTint final
{
public:
	struct FColor                                 InTint;                                            // 0x0000(0x0004)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetOcclusionTint) == 0x000004, "Wrong alignment on SkyLightComponent_SetOcclusionTint");
static_assert(sizeof(SkyLightComponent_SetOcclusionTint) == 0x000004, "Wrong size on SkyLightComponent_SetOcclusionTint");
static_assert(offsetof(SkyLightComponent_SetOcclusionTint, InTint) == 0x000000, "Member 'SkyLightComponent_SetOcclusionTint::InTint' has a wrong offset!");

// Function Engine.SkyLightComponent.SetVolumetricScatteringIntensity
// 0x0004 (0x0004 - 0x0000)
struct SkyLightComponent_SetVolumetricScatteringIntensity final
{
public:
	float                                         NewIntensity;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SkyLightComponent_SetVolumetricScatteringIntensity) == 0x000004, "Wrong alignment on SkyLightComponent_SetVolumetricScatteringIntensity");
static_assert(sizeof(SkyLightComponent_SetVolumetricScatteringIntensity) == 0x000004, "Wrong size on SkyLightComponent_SetVolumetricScatteringIntensity");
static_assert(offsetof(SkyLightComponent_SetVolumetricScatteringIntensity, NewIntensity) == 0x000000, "Member 'SkyLightComponent_SetVolumetricScatteringIntensity::NewIntensity' has a wrong offset!");

// Function Engine.SplineComponent.AddPoint
// 0x0048 (0x0048 - 0x0000)
struct SplineComponent_AddPoint final
{
public:
	struct FSplinePoint                           Point;                                             // 0x0000(0x0044)(ConstParm, Parm, OutParm, ReferenceParm, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0044(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_AddPoint) == 0x000004, "Wrong alignment on SplineComponent_AddPoint");
static_assert(sizeof(SplineComponent_AddPoint) == 0x000048, "Wrong size on SplineComponent_AddPoint");
static_assert(offsetof(SplineComponent_AddPoint, Point) == 0x000000, "Member 'SplineComponent_AddPoint::Point' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddPoint, bUpdateSpline) == 0x000044, "Member 'SplineComponent_AddPoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.AddPoints
// 0x0018 (0x0018 - 0x0000)
struct SplineComponent_AddPoints final
{
public:
	TArray<struct FSplinePoint>                   Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x7];                                       // 0x0011(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_AddPoints) == 0x000008, "Wrong alignment on SplineComponent_AddPoints");
static_assert(sizeof(SplineComponent_AddPoints) == 0x000018, "Wrong size on SplineComponent_AddPoints");
static_assert(offsetof(SplineComponent_AddPoints, Points) == 0x000000, "Member 'SplineComponent_AddPoints::Points' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddPoints, bUpdateSpline) == 0x000010, "Member 'SplineComponent_AddPoints::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.AddSplineLocalPoint
// 0x000C (0x000C - 0x0000)
struct SplineComponent_AddSplineLocalPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_AddSplineLocalPoint) == 0x000004, "Wrong alignment on SplineComponent_AddSplineLocalPoint");
static_assert(sizeof(SplineComponent_AddSplineLocalPoint) == 0x00000C, "Wrong size on SplineComponent_AddSplineLocalPoint");
static_assert(offsetof(SplineComponent_AddSplineLocalPoint, Position) == 0x000000, "Member 'SplineComponent_AddSplineLocalPoint::Position' has a wrong offset!");

// Function Engine.SplineComponent.AddSplinePoint
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_AddSplinePoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_AddSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_AddSplinePoint");
static_assert(sizeof(SplineComponent_AddSplinePoint) == 0x000010, "Wrong size on SplineComponent_AddSplinePoint");
static_assert(offsetof(SplineComponent_AddSplinePoint, Position) == 0x000000, "Member 'SplineComponent_AddSplinePoint::Position' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddSplinePoint, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_AddSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddSplinePoint, bUpdateSpline) == 0x00000D, "Member 'SplineComponent_AddSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.AddSplinePointAtIndex
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_AddSplinePointAtIndex final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Index_0;                                           // 0x000C(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_AddSplinePointAtIndex) == 0x000004, "Wrong alignment on SplineComponent_AddSplinePointAtIndex");
static_assert(sizeof(SplineComponent_AddSplinePointAtIndex) == 0x000014, "Wrong size on SplineComponent_AddSplinePointAtIndex");
static_assert(offsetof(SplineComponent_AddSplinePointAtIndex, Position) == 0x000000, "Member 'SplineComponent_AddSplinePointAtIndex::Position' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddSplinePointAtIndex, Index_0) == 0x00000C, "Member 'SplineComponent_AddSplinePointAtIndex::Index_0' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddSplinePointAtIndex, CoordinateSpace) == 0x000010, "Member 'SplineComponent_AddSplinePointAtIndex::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_AddSplinePointAtIndex, bUpdateSpline) == 0x000011, "Member 'SplineComponent_AddSplinePointAtIndex::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.AddSplineWorldPoint
// 0x000C (0x000C - 0x0000)
struct SplineComponent_AddSplineWorldPoint final
{
public:
	struct FVector                                Position;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_AddSplineWorldPoint) == 0x000004, "Wrong alignment on SplineComponent_AddSplineWorldPoint");
static_assert(sizeof(SplineComponent_AddSplineWorldPoint) == 0x00000C, "Wrong size on SplineComponent_AddSplineWorldPoint");
static_assert(offsetof(SplineComponent_AddSplineWorldPoint, Position) == 0x000000, "Member 'SplineComponent_AddSplineWorldPoint::Position' has a wrong offset!");

// Function Engine.SplineComponent.ClearSplinePoints
// 0x0001 (0x0001 - 0x0000)
struct SplineComponent_ClearSplinePoints final
{
public:
	bool                                          bUpdateSpline;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_ClearSplinePoints) == 0x000001, "Wrong alignment on SplineComponent_ClearSplinePoints");
static_assert(sizeof(SplineComponent_ClearSplinePoints) == 0x000001, "Wrong size on SplineComponent_ClearSplinePoints");
static_assert(offsetof(SplineComponent_ClearSplinePoints, bUpdateSpline) == 0x000000, "Member 'SplineComponent_ClearSplinePoints::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.RemoveSplinePoint
// 0x0008 (0x0008 - 0x0000)
struct SplineComponent_RemoveSplinePoint final
{
public:
	int32                                         Index_0;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_RemoveSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_RemoveSplinePoint");
static_assert(sizeof(SplineComponent_RemoveSplinePoint) == 0x000008, "Wrong size on SplineComponent_RemoveSplinePoint");
static_assert(offsetof(SplineComponent_RemoveSplinePoint, Index_0) == 0x000000, "Member 'SplineComponent_RemoveSplinePoint::Index_0' has a wrong offset!");
static_assert(offsetof(SplineComponent_RemoveSplinePoint, bUpdateSpline) == 0x000004, "Member 'SplineComponent_RemoveSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetClosedLoop
// 0x0002 (0x0002 - 0x0000)
struct SplineComponent_SetClosedLoop final
{
public:
	bool                                          bInClosedLoop;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetClosedLoop) == 0x000001, "Wrong alignment on SplineComponent_SetClosedLoop");
static_assert(sizeof(SplineComponent_SetClosedLoop) == 0x000002, "Wrong size on SplineComponent_SetClosedLoop");
static_assert(offsetof(SplineComponent_SetClosedLoop, bInClosedLoop) == 0x000000, "Member 'SplineComponent_SetClosedLoop::bInClosedLoop' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetClosedLoop, bUpdateSpline) == 0x000001, "Member 'SplineComponent_SetClosedLoop::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetClosedLoopAtPosition
// 0x000C (0x000C - 0x0000)
struct SplineComponent_SetClosedLoopAtPosition final
{
public:
	bool                                          bInClosedLoop;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Key;                                               // 0x0004(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetClosedLoopAtPosition) == 0x000004, "Wrong alignment on SplineComponent_SetClosedLoopAtPosition");
static_assert(sizeof(SplineComponent_SetClosedLoopAtPosition) == 0x00000C, "Wrong size on SplineComponent_SetClosedLoopAtPosition");
static_assert(offsetof(SplineComponent_SetClosedLoopAtPosition, bInClosedLoop) == 0x000000, "Member 'SplineComponent_SetClosedLoopAtPosition::bInClosedLoop' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetClosedLoopAtPosition, Key) == 0x000004, "Member 'SplineComponent_SetClosedLoopAtPosition::Key' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetClosedLoopAtPosition, bUpdateSpline) == 0x000008, "Member 'SplineComponent_SetClosedLoopAtPosition::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetDefaultUpVector
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetDefaultUpVector final
{
public:
	struct FVector                                UpVector;                                          // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetDefaultUpVector) == 0x000004, "Wrong alignment on SplineComponent_SetDefaultUpVector");
static_assert(sizeof(SplineComponent_SetDefaultUpVector) == 0x000010, "Wrong size on SplineComponent_SetDefaultUpVector");
static_assert(offsetof(SplineComponent_SetDefaultUpVector, UpVector) == 0x000000, "Member 'SplineComponent_SetDefaultUpVector::UpVector' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetDefaultUpVector, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_SetDefaultUpVector::CoordinateSpace' has a wrong offset!");

// Function Engine.SplineComponent.SetDrawDebug
// 0x0001 (0x0001 - 0x0000)
struct SplineComponent_SetDrawDebug final
{
public:
	bool                                          bShow;                                             // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetDrawDebug) == 0x000001, "Wrong alignment on SplineComponent_SetDrawDebug");
static_assert(sizeof(SplineComponent_SetDrawDebug) == 0x000001, "Wrong size on SplineComponent_SetDrawDebug");
static_assert(offsetof(SplineComponent_SetDrawDebug, bShow) == 0x000000, "Member 'SplineComponent_SetDrawDebug::bShow' has a wrong offset!");

// Function Engine.SplineComponent.SetLocationAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_SetLocationAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetLocationAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_SetLocationAtSplinePoint");
static_assert(sizeof(SplineComponent_SetLocationAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_SetLocationAtSplinePoint");
static_assert(offsetof(SplineComponent_SetLocationAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_SetLocationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetLocationAtSplinePoint, InLocation) == 0x000004, "Member 'SplineComponent_SetLocationAtSplinePoint::InLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetLocationAtSplinePoint, CoordinateSpace) == 0x000010, "Member 'SplineComponent_SetLocationAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetLocationAtSplinePoint, bUpdateSpline) == 0x000011, "Member 'SplineComponent_SetLocationAtSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetSelectedSplineSegmentColor
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetSelectedSplineSegmentColor final
{
public:
	struct FLinearColor                           SegmentColor;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetSelectedSplineSegmentColor) == 0x000004, "Wrong alignment on SplineComponent_SetSelectedSplineSegmentColor");
static_assert(sizeof(SplineComponent_SetSelectedSplineSegmentColor) == 0x000010, "Wrong size on SplineComponent_SetSelectedSplineSegmentColor");
static_assert(offsetof(SplineComponent_SetSelectedSplineSegmentColor, SegmentColor) == 0x000000, "Member 'SplineComponent_SetSelectedSplineSegmentColor::SegmentColor' has a wrong offset!");

// Function Engine.SplineComponent.SetSplineLocalPoints
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetSplineLocalPoints final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetSplineLocalPoints) == 0x000008, "Wrong alignment on SplineComponent_SetSplineLocalPoints");
static_assert(sizeof(SplineComponent_SetSplineLocalPoints) == 0x000010, "Wrong size on SplineComponent_SetSplineLocalPoints");
static_assert(offsetof(SplineComponent_SetSplineLocalPoints, Points) == 0x000000, "Member 'SplineComponent_SetSplineLocalPoints::Points' has a wrong offset!");

// Function Engine.SplineComponent.SetSplinePoints
// 0x0018 (0x0018 - 0x0000)
struct SplineComponent_SetSplinePoints final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x6];                                       // 0x0012(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetSplinePoints) == 0x000008, "Wrong alignment on SplineComponent_SetSplinePoints");
static_assert(sizeof(SplineComponent_SetSplinePoints) == 0x000018, "Wrong size on SplineComponent_SetSplinePoints");
static_assert(offsetof(SplineComponent_SetSplinePoints, Points) == 0x000000, "Member 'SplineComponent_SetSplinePoints::Points' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetSplinePoints, CoordinateSpace) == 0x000010, "Member 'SplineComponent_SetSplinePoints::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetSplinePoints, bUpdateSpline) == 0x000011, "Member 'SplineComponent_SetSplinePoints::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetSplinePointType
// 0x0008 (0x0008 - 0x0000)
struct SplineComponent_SetSplinePointType final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplinePointType                              Type;                                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetSplinePointType) == 0x000004, "Wrong alignment on SplineComponent_SetSplinePointType");
static_assert(sizeof(SplineComponent_SetSplinePointType) == 0x000008, "Wrong size on SplineComponent_SetSplinePointType");
static_assert(offsetof(SplineComponent_SetSplinePointType, PointIndex) == 0x000000, "Member 'SplineComponent_SetSplinePointType::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetSplinePointType, Type) == 0x000004, "Member 'SplineComponent_SetSplinePointType::Type' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetSplinePointType, bUpdateSpline) == 0x000005, "Member 'SplineComponent_SetSplinePointType::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetSplineWorldPoints
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetSplineWorldPoints final
{
public:
	TArray<struct FVector>                        Points;                                            // 0x0000(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetSplineWorldPoints) == 0x000008, "Wrong alignment on SplineComponent_SetSplineWorldPoints");
static_assert(sizeof(SplineComponent_SetSplineWorldPoints) == 0x000010, "Wrong size on SplineComponent_SetSplineWorldPoints");
static_assert(offsetof(SplineComponent_SetSplineWorldPoints, Points) == 0x000000, "Member 'SplineComponent_SetSplineWorldPoints::Points' has a wrong offset!");

// Function Engine.SplineComponent.SetTangentAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_SetTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InTangent;                                         // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_SetTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_SetTangentAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_SetTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_SetTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_SetTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentAtSplinePoint, InTangent) == 0x000004, "Member 'SplineComponent_SetTangentAtSplinePoint::InTangent' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentAtSplinePoint, CoordinateSpace) == 0x000010, "Member 'SplineComponent_SetTangentAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentAtSplinePoint, bUpdateSpline) == 0x000011, "Member 'SplineComponent_SetTangentAtSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetTangentsAtSplinePoint
// 0x0020 (0x0020 - 0x0000)
struct SplineComponent_SetTangentsAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InArriveTangent;                                   // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLeaveTangent;                                    // 0x0010(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x001D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E[0x2];                                       // 0x001E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetTangentsAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_SetTangentsAtSplinePoint");
static_assert(sizeof(SplineComponent_SetTangentsAtSplinePoint) == 0x000020, "Wrong size on SplineComponent_SetTangentsAtSplinePoint");
static_assert(offsetof(SplineComponent_SetTangentsAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_SetTangentsAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentsAtSplinePoint, InArriveTangent) == 0x000004, "Member 'SplineComponent_SetTangentsAtSplinePoint::InArriveTangent' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentsAtSplinePoint, InLeaveTangent) == 0x000010, "Member 'SplineComponent_SetTangentsAtSplinePoint::InLeaveTangent' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentsAtSplinePoint, CoordinateSpace) == 0x00001C, "Member 'SplineComponent_SetTangentsAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetTangentsAtSplinePoint, bUpdateSpline) == 0x00001D, "Member 'SplineComponent_SetTangentsAtSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetUnselectedSplineSegmentColor
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetUnselectedSplineSegmentColor final
{
public:
	struct FLinearColor                           SegmentColor;                                      // 0x0000(0x0010)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetUnselectedSplineSegmentColor) == 0x000004, "Wrong alignment on SplineComponent_SetUnselectedSplineSegmentColor");
static_assert(sizeof(SplineComponent_SetUnselectedSplineSegmentColor) == 0x000010, "Wrong size on SplineComponent_SetUnselectedSplineSegmentColor");
static_assert(offsetof(SplineComponent_SetUnselectedSplineSegmentColor, SegmentColor) == 0x000000, "Member 'SplineComponent_SetUnselectedSplineSegmentColor::SegmentColor' has a wrong offset!");

// Function Engine.SplineComponent.SetUpVectorAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_SetUpVectorAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InUpVector;                                        // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0010(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateSpline;                                     // 0x0011(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_12[0x2];                                       // 0x0012(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_SetUpVectorAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_SetUpVectorAtSplinePoint");
static_assert(sizeof(SplineComponent_SetUpVectorAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_SetUpVectorAtSplinePoint");
static_assert(offsetof(SplineComponent_SetUpVectorAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_SetUpVectorAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetUpVectorAtSplinePoint, InUpVector) == 0x000004, "Member 'SplineComponent_SetUpVectorAtSplinePoint::InUpVector' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetUpVectorAtSplinePoint, CoordinateSpace) == 0x000010, "Member 'SplineComponent_SetUpVectorAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetUpVectorAtSplinePoint, bUpdateSpline) == 0x000011, "Member 'SplineComponent_SetUpVectorAtSplinePoint::bUpdateSpline' has a wrong offset!");

// Function Engine.SplineComponent.SetWorldLocationAtSplinePoint
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_SetWorldLocationAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                InLocation;                                        // 0x0004(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_SetWorldLocationAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_SetWorldLocationAtSplinePoint");
static_assert(sizeof(SplineComponent_SetWorldLocationAtSplinePoint) == 0x000010, "Wrong size on SplineComponent_SetWorldLocationAtSplinePoint");
static_assert(offsetof(SplineComponent_SetWorldLocationAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_SetWorldLocationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_SetWorldLocationAtSplinePoint, InLocation) == 0x000004, "Member 'SplineComponent_SetWorldLocationAtSplinePoint::InLocation' has a wrong offset!");

// Function Engine.SplineComponent.FindDirectionClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindDirectionClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindDirectionClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindDirectionClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindDirectionClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindDirectionClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindDirectionClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindDirectionClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindDirectionClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindDirectionClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindDirectionClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindDirectionClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindInputKeyClosestToWorldLocation
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_FindInputKeyClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x000C(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindInputKeyClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindInputKeyClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindInputKeyClosestToWorldLocation) == 0x000010, "Wrong size on SplineComponent_FindInputKeyClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindInputKeyClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindInputKeyClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindInputKeyClosestToWorldLocation, ReturnValue) == 0x00000C, "Member 'SplineComponent_FindInputKeyClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindLocationClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindLocationClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindLocationClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindLocationClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindLocationClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindLocationClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindLocationClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindLocationClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindLocationClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindLocationClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindLocationClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindLocationClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindRightVectorClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindRightVectorClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindRightVectorClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindRightVectorClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindRightVectorClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindRightVectorClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindRightVectorClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindRightVectorClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRightVectorClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindRightVectorClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRightVectorClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindRightVectorClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindRollClosestToWorldLocation
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_FindRollClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0010(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindRollClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindRollClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindRollClosestToWorldLocation) == 0x000014, "Wrong size on SplineComponent_FindRollClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindRollClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindRollClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRollClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindRollClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRollClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindRollClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindRotationClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindRotationClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindRotationClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindRotationClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindRotationClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindRotationClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindRotationClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindRotationClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRotationClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindRotationClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindRotationClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindRotationClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindScaleClosestToWorldLocation
// 0x0018 (0x0018 - 0x0000)
struct SplineComponent_FindScaleClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x000C(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindScaleClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindScaleClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindScaleClosestToWorldLocation) == 0x000018, "Wrong size on SplineComponent_FindScaleClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindScaleClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindScaleClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindScaleClosestToWorldLocation, ReturnValue) == 0x00000C, "Member 'SplineComponent_FindScaleClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindTangentClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindTangentClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindTangentClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindTangentClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindTangentClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindTangentClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindTangentClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindTangentClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindTangentClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindTangentClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindTangentClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindTangentClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindTransformClosestToWorldLocation
// 0x0040 (0x0040 - 0x0000)
struct SplineComponent_FindTransformClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x000D(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E[0x2];                                        // 0x000E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindTransformClosestToWorldLocation) == 0x000010, "Wrong alignment on SplineComponent_FindTransformClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindTransformClosestToWorldLocation) == 0x000040, "Wrong size on SplineComponent_FindTransformClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindTransformClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindTransformClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindTransformClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindTransformClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindTransformClosestToWorldLocation, bUseScale) == 0x00000D, "Member 'SplineComponent_FindTransformClosestToWorldLocation::bUseScale' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindTransformClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindTransformClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.FindUpVectorClosestToWorldLocation
// 0x001C (0x001C - 0x0000)
struct SplineComponent_FindUpVectorClosestToWorldLocation final
{
public:
	struct FVector                                WorldLocation;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0010(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_FindUpVectorClosestToWorldLocation) == 0x000004, "Wrong alignment on SplineComponent_FindUpVectorClosestToWorldLocation");
static_assert(sizeof(SplineComponent_FindUpVectorClosestToWorldLocation) == 0x00001C, "Wrong size on SplineComponent_FindUpVectorClosestToWorldLocation");
static_assert(offsetof(SplineComponent_FindUpVectorClosestToWorldLocation, WorldLocation) == 0x000000, "Member 'SplineComponent_FindUpVectorClosestToWorldLocation::WorldLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindUpVectorClosestToWorldLocation, CoordinateSpace) == 0x00000C, "Member 'SplineComponent_FindUpVectorClosestToWorldLocation::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_FindUpVectorClosestToWorldLocation, ReturnValue) == 0x000010, "Member 'SplineComponent_FindUpVectorClosestToWorldLocation::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetArriveTangentAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetArriveTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetArriveTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetArriveTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_GetArriveTangentAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetArriveTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_GetArriveTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetArriveTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetArriveTangentAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetArriveTangentAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetArriveTangentAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetArriveTangentAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetDefaultUpVector
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetDefaultUpVector final
{
public:
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetDefaultUpVector) == 0x000004, "Wrong alignment on SplineComponent_GetDefaultUpVector");
static_assert(sizeof(SplineComponent_GetDefaultUpVector) == 0x000010, "Wrong size on SplineComponent_GetDefaultUpVector");
static_assert(offsetof(SplineComponent_GetDefaultUpVector, CoordinateSpace) == 0x000000, "Member 'SplineComponent_GetDefaultUpVector::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDefaultUpVector, ReturnValue) == 0x000004, "Member 'SplineComponent_GetDefaultUpVector::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetDirectionAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetDirectionAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetDirectionAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetDirectionAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetDirectionAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetDirectionAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetDirectionAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetDirectionAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetDirectionAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetDirectionAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetDirectionAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetDirectionAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetDirectionAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetDirectionAtSplinePoint");
static_assert(sizeof(SplineComponent_GetDirectionAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetDirectionAtSplinePoint");
static_assert(offsetof(SplineComponent_GetDirectionAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetDirectionAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetDirectionAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetDirectionAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetDirectionAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetDirectionAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetDirectionAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetDirectionAtTime");
static_assert(sizeof(SplineComponent_GetDirectionAtTime) == 0x000014, "Wrong size on SplineComponent_GetDirectionAtTime");
static_assert(offsetof(SplineComponent_GetDirectionAtTime, Time) == 0x000000, "Member 'SplineComponent_GetDirectionAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetDirectionAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetDirectionAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDirectionAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetDirectionAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetDistanceAlongSplineAtSplinePoint
// 0x0008 (0x0008 - 0x0000)
struct SplineComponent_GetDistanceAlongSplineAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetDistanceAlongSplineAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetDistanceAlongSplineAtSplinePoint");
static_assert(sizeof(SplineComponent_GetDistanceAlongSplineAtSplinePoint) == 0x000008, "Wrong size on SplineComponent_GetDistanceAlongSplineAtSplinePoint");
static_assert(offsetof(SplineComponent_GetDistanceAlongSplineAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetDistanceAlongSplineAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetDistanceAlongSplineAtSplinePoint, ReturnValue) == 0x000004, "Member 'SplineComponent_GetDistanceAlongSplineAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetInputKeyAtDistanceAlongSpline
// 0x0008 (0x0008 - 0x0000)
struct SplineComponent_GetInputKeyAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetInputKeyAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetInputKeyAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetInputKeyAtDistanceAlongSpline) == 0x000008, "Wrong size on SplineComponent_GetInputKeyAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetInputKeyAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetInputKeyAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetInputKeyAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetInputKeyAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetLeaveTangentAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetLeaveTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetLeaveTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetLeaveTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_GetLeaveTangentAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetLeaveTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_GetLeaveTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetLeaveTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLeaveTangentAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetLeaveTangentAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLeaveTangentAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetLeaveTangentAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetLocalLocationAndTangentAtSplinePoint
// 0x001C (0x001C - 0x0000)
struct SplineComponent_GetLocalLocationAndTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalLocation;                                     // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                LocalTangent;                                      // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetLocalLocationAndTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetLocalLocationAndTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_GetLocalLocationAndTangentAtSplinePoint) == 0x00001C, "Wrong size on SplineComponent_GetLocalLocationAndTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_GetLocalLocationAndTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetLocalLocationAndTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocalLocationAndTangentAtSplinePoint, LocalLocation) == 0x000004, "Member 'SplineComponent_GetLocalLocationAndTangentAtSplinePoint::LocalLocation' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocalLocationAndTangentAtSplinePoint, LocalTangent) == 0x000010, "Member 'SplineComponent_GetLocalLocationAndTangentAtSplinePoint::LocalTangent' has a wrong offset!");

// Function Engine.SplineComponent.GetLocationAndTangentAtSplinePoint
// 0x0020 (0x0020 - 0x0000)
struct SplineComponent_GetLocationAndTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0004(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Tangent;                                           // 0x0010(0x000C)(Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x001C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_GetLocationAndTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetLocationAndTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_GetLocationAndTangentAtSplinePoint) == 0x000020, "Wrong size on SplineComponent_GetLocationAndTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_GetLocationAndTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetLocationAndTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAndTangentAtSplinePoint, Location) == 0x000004, "Member 'SplineComponent_GetLocationAndTangentAtSplinePoint::Location' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAndTangentAtSplinePoint, Tangent) == 0x000010, "Member 'SplineComponent_GetLocationAndTangentAtSplinePoint::Tangent' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAndTangentAtSplinePoint, CoordinateSpace) == 0x00001C, "Member 'SplineComponent_GetLocationAndTangentAtSplinePoint::CoordinateSpace' has a wrong offset!");

// Function Engine.SplineComponent.GetLocationAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetLocationAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetLocationAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetLocationAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetLocationAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetLocationAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetLocationAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetLocationAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetLocationAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetLocationAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetLocationAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetLocationAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetLocationAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetLocationAtSplinePoint");
static_assert(sizeof(SplineComponent_GetLocationAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetLocationAtSplinePoint");
static_assert(offsetof(SplineComponent_GetLocationAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetLocationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetLocationAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetLocationAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetLocationAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetLocationAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetLocationAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetLocationAtTime");
static_assert(sizeof(SplineComponent_GetLocationAtTime) == 0x000014, "Wrong size on SplineComponent_GetLocationAtTime");
static_assert(offsetof(SplineComponent_GetLocationAtTime, Time) == 0x000000, "Member 'SplineComponent_GetLocationAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetLocationAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetLocationAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetLocationAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetLocationAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetNumberOfSplinePoints
// 0x0004 (0x0004 - 0x0000)
struct SplineComponent_GetNumberOfSplinePoints final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetNumberOfSplinePoints) == 0x000004, "Wrong alignment on SplineComponent_GetNumberOfSplinePoints");
static_assert(sizeof(SplineComponent_GetNumberOfSplinePoints) == 0x000004, "Wrong size on SplineComponent_GetNumberOfSplinePoints");
static_assert(offsetof(SplineComponent_GetNumberOfSplinePoints, ReturnValue) == 0x000000, "Member 'SplineComponent_GetNumberOfSplinePoints::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRightVectorAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRightVectorAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRightVectorAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetRightVectorAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetRightVectorAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetRightVectorAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetRightVectorAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetRightVectorAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRightVectorAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRightVectorAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRightVectorAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRightVectorAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRightVectorAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetRightVectorAtSplinePoint");
static_assert(sizeof(SplineComponent_GetRightVectorAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetRightVectorAtSplinePoint");
static_assert(offsetof(SplineComponent_GetRightVectorAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetRightVectorAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRightVectorAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRightVectorAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRightVectorAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRightVectorAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRightVectorAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetRightVectorAtTime");
static_assert(sizeof(SplineComponent_GetRightVectorAtTime) == 0x000014, "Wrong size on SplineComponent_GetRightVectorAtTime");
static_assert(offsetof(SplineComponent_GetRightVectorAtTime, Time) == 0x000000, "Member 'SplineComponent_GetRightVectorAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRightVectorAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetRightVectorAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRightVectorAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRightVectorAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRollAtDistanceAlongSpline
// 0x000C (0x000C - 0x0000)
struct SplineComponent_GetRollAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRollAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetRollAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetRollAtDistanceAlongSpline) == 0x00000C, "Wrong size on SplineComponent_GetRollAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetRollAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetRollAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRollAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRollAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRollAtSplinePoint
// 0x000C (0x000C - 0x0000)
struct SplineComponent_GetRollAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRollAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetRollAtSplinePoint");
static_assert(sizeof(SplineComponent_GetRollAtSplinePoint) == 0x00000C, "Wrong size on SplineComponent_GetRollAtSplinePoint");
static_assert(offsetof(SplineComponent_GetRollAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetRollAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRollAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRollAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRollAtTime
// 0x000C (0x000C - 0x0000)
struct SplineComponent_GetRollAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRollAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetRollAtTime");
static_assert(sizeof(SplineComponent_GetRollAtTime) == 0x00000C, "Wrong size on SplineComponent_GetRollAtTime");
static_assert(offsetof(SplineComponent_GetRollAtTime, Time) == 0x000000, "Member 'SplineComponent_GetRollAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRollAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetRollAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRollAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRollAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRotationAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRotationAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRotationAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetRotationAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetRotationAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetRotationAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetRotationAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetRotationAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRotationAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRotationAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRotationAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRotationAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRotationAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetRotationAtSplinePoint");
static_assert(sizeof(SplineComponent_GetRotationAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetRotationAtSplinePoint");
static_assert(offsetof(SplineComponent_GetRotationAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetRotationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRotationAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRotationAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetRotationAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetRotationAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetRotationAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetRotationAtTime");
static_assert(sizeof(SplineComponent_GetRotationAtTime) == 0x000014, "Wrong size on SplineComponent_GetRotationAtTime");
static_assert(offsetof(SplineComponent_GetRotationAtTime, Time) == 0x000000, "Member 'SplineComponent_GetRotationAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetRotationAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetRotationAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetRotationAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetRotationAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetScaleAtDistanceAlongSpline
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetScaleAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetScaleAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetScaleAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetScaleAtDistanceAlongSpline) == 0x000010, "Wrong size on SplineComponent_GetScaleAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetScaleAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetScaleAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetScaleAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetScaleAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetScaleAtSplinePoint
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetScaleAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetScaleAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetScaleAtSplinePoint");
static_assert(sizeof(SplineComponent_GetScaleAtSplinePoint) == 0x000010, "Wrong size on SplineComponent_GetScaleAtSplinePoint");
static_assert(offsetof(SplineComponent_GetScaleAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetScaleAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetScaleAtSplinePoint, ReturnValue) == 0x000004, "Member 'SplineComponent_GetScaleAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetScaleAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetScaleAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetScaleAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetScaleAtTime");
static_assert(sizeof(SplineComponent_GetScaleAtTime) == 0x000014, "Wrong size on SplineComponent_GetScaleAtTime");
static_assert(offsetof(SplineComponent_GetScaleAtTime, Time) == 0x000000, "Member 'SplineComponent_GetScaleAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetScaleAtTime, bUseConstantVelocity) == 0x000004, "Member 'SplineComponent_GetScaleAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetScaleAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetScaleAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetSplineLength
// 0x0004 (0x0004 - 0x0000)
struct SplineComponent_GetSplineLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetSplineLength) == 0x000004, "Wrong alignment on SplineComponent_GetSplineLength");
static_assert(sizeof(SplineComponent_GetSplineLength) == 0x000004, "Wrong size on SplineComponent_GetSplineLength");
static_assert(offsetof(SplineComponent_GetSplineLength, ReturnValue) == 0x000000, "Member 'SplineComponent_GetSplineLength::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetSplinePointType
// 0x0008 (0x0008 - 0x0000)
struct SplineComponent_GetSplinePointType final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplinePointType                              ReturnValue;                                       // 0x0004(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineComponent_GetSplinePointType) == 0x000004, "Wrong alignment on SplineComponent_GetSplinePointType");
static_assert(sizeof(SplineComponent_GetSplinePointType) == 0x000008, "Wrong size on SplineComponent_GetSplinePointType");
static_assert(offsetof(SplineComponent_GetSplinePointType, PointIndex) == 0x000000, "Member 'SplineComponent_GetSplinePointType::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetSplinePointType, ReturnValue) == 0x000004, "Member 'SplineComponent_GetSplinePointType::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTangentAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetTangentAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTangentAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetTangentAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetTangentAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetTangentAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetTangentAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetTangentAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTangentAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetTangentAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTangentAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetTangentAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTangentAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetTangentAtSplinePoint");
static_assert(sizeof(SplineComponent_GetTangentAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetTangentAtSplinePoint");
static_assert(offsetof(SplineComponent_GetTangentAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetTangentAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTangentAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetTangentAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTangentAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetTangentAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTangentAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetTangentAtTime");
static_assert(sizeof(SplineComponent_GetTangentAtTime) == 0x000014, "Wrong size on SplineComponent_GetTangentAtTime");
static_assert(offsetof(SplineComponent_GetTangentAtTime, Time) == 0x000000, "Member 'SplineComponent_GetTangentAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTangentAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetTangentAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTangentAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetTangentAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTransformAtDistanceAlongSpline
// 0x0040 (0x0040 - 0x0000)
struct SplineComponent_GetTransformAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0xA];                                        // 0x0006(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTransformAtDistanceAlongSpline) == 0x000010, "Wrong alignment on SplineComponent_GetTransformAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetTransformAtDistanceAlongSpline) == 0x000040, "Wrong size on SplineComponent_GetTransformAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetTransformAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetTransformAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTransformAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtDistanceAlongSpline, bUseScale) == 0x000005, "Member 'SplineComponent_GetTransformAtDistanceAlongSpline::bUseScale' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtDistanceAlongSpline, ReturnValue) == 0x000010, "Member 'SplineComponent_GetTransformAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTransformAtSplinePoint
// 0x0040 (0x0040 - 0x0000)
struct SplineComponent_GetTransformAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0xA];                                        // 0x0006(0x000A)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTransformAtSplinePoint) == 0x000010, "Wrong alignment on SplineComponent_GetTransformAtSplinePoint");
static_assert(sizeof(SplineComponent_GetTransformAtSplinePoint) == 0x000040, "Wrong size on SplineComponent_GetTransformAtSplinePoint");
static_assert(offsetof(SplineComponent_GetTransformAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetTransformAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTransformAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtSplinePoint, bUseScale) == 0x000005, "Member 'SplineComponent_GetTransformAtSplinePoint::bUseScale' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtSplinePoint, ReturnValue) == 0x000010, "Member 'SplineComponent_GetTransformAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetTransformAtTime
// 0x0040 (0x0040 - 0x0000)
struct SplineComponent_GetTransformAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseScale;                                         // 0x0006(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7[0x9];                                        // 0x0007(0x0009)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTransform                             ReturnValue;                                       // 0x0010(0x0030)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetTransformAtTime) == 0x000010, "Wrong alignment on SplineComponent_GetTransformAtTime");
static_assert(sizeof(SplineComponent_GetTransformAtTime) == 0x000040, "Wrong size on SplineComponent_GetTransformAtTime");
static_assert(offsetof(SplineComponent_GetTransformAtTime, Time) == 0x000000, "Member 'SplineComponent_GetTransformAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetTransformAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetTransformAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtTime, bUseScale) == 0x000006, "Member 'SplineComponent_GetTransformAtTime::bUseScale' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetTransformAtTime, ReturnValue) == 0x000010, "Member 'SplineComponent_GetTransformAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetUpVectorAtDistanceAlongSpline
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetUpVectorAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetUpVectorAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetUpVectorAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetUpVectorAtDistanceAlongSpline) == 0x000014, "Wrong size on SplineComponent_GetUpVectorAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetUpVectorAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetUpVectorAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtDistanceAlongSpline, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetUpVectorAtDistanceAlongSpline::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtDistanceAlongSpline, ReturnValue) == 0x000008, "Member 'SplineComponent_GetUpVectorAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetUpVectorAtSplinePoint
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetUpVectorAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetUpVectorAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetUpVectorAtSplinePoint");
static_assert(sizeof(SplineComponent_GetUpVectorAtSplinePoint) == 0x000014, "Wrong size on SplineComponent_GetUpVectorAtSplinePoint");
static_assert(offsetof(SplineComponent_GetUpVectorAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetUpVectorAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtSplinePoint, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetUpVectorAtSplinePoint::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtSplinePoint, ReturnValue) == 0x000008, "Member 'SplineComponent_GetUpVectorAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetUpVectorAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetUpVectorAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESplineCoordinateSpace                        CoordinateSpace;                                   // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetUpVectorAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetUpVectorAtTime");
static_assert(sizeof(SplineComponent_GetUpVectorAtTime) == 0x000014, "Wrong size on SplineComponent_GetUpVectorAtTime");
static_assert(offsetof(SplineComponent_GetUpVectorAtTime, Time) == 0x000000, "Member 'SplineComponent_GetUpVectorAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtTime, CoordinateSpace) == 0x000004, "Member 'SplineComponent_GetUpVectorAtTime::CoordinateSpace' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtTime, bUseConstantVelocity) == 0x000005, "Member 'SplineComponent_GetUpVectorAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetUpVectorAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetUpVectorAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldDirectionAtDistanceAlongSpline
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetWorldDirectionAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldDirectionAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetWorldDirectionAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetWorldDirectionAtDistanceAlongSpline) == 0x000010, "Wrong size on SplineComponent_GetWorldDirectionAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetWorldDirectionAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetWorldDirectionAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldDirectionAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetWorldDirectionAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldDirectionAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetWorldDirectionAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldDirectionAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetWorldDirectionAtTime");
static_assert(sizeof(SplineComponent_GetWorldDirectionAtTime) == 0x000014, "Wrong size on SplineComponent_GetWorldDirectionAtTime");
static_assert(offsetof(SplineComponent_GetWorldDirectionAtTime, Time) == 0x000000, "Member 'SplineComponent_GetWorldDirectionAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldDirectionAtTime, bUseConstantVelocity) == 0x000004, "Member 'SplineComponent_GetWorldDirectionAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldDirectionAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetWorldDirectionAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldLocationAtDistanceAlongSpline
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetWorldLocationAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldLocationAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetWorldLocationAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetWorldLocationAtDistanceAlongSpline) == 0x000010, "Wrong size on SplineComponent_GetWorldLocationAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetWorldLocationAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetWorldLocationAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldLocationAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetWorldLocationAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldLocationAtSplinePoint
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetWorldLocationAtSplinePoint final
{
public:
	int32                                         PointIndex;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldLocationAtSplinePoint) == 0x000004, "Wrong alignment on SplineComponent_GetWorldLocationAtSplinePoint");
static_assert(sizeof(SplineComponent_GetWorldLocationAtSplinePoint) == 0x000010, "Wrong size on SplineComponent_GetWorldLocationAtSplinePoint");
static_assert(offsetof(SplineComponent_GetWorldLocationAtSplinePoint, PointIndex) == 0x000000, "Member 'SplineComponent_GetWorldLocationAtSplinePoint::PointIndex' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldLocationAtSplinePoint, ReturnValue) == 0x000004, "Member 'SplineComponent_GetWorldLocationAtSplinePoint::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldLocationAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetWorldLocationAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldLocationAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetWorldLocationAtTime");
static_assert(sizeof(SplineComponent_GetWorldLocationAtTime) == 0x000014, "Wrong size on SplineComponent_GetWorldLocationAtTime");
static_assert(offsetof(SplineComponent_GetWorldLocationAtTime, Time) == 0x000000, "Member 'SplineComponent_GetWorldLocationAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldLocationAtTime, bUseConstantVelocity) == 0x000004, "Member 'SplineComponent_GetWorldLocationAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldLocationAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetWorldLocationAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldRotationAtDistanceAlongSpline
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetWorldRotationAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldRotationAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetWorldRotationAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetWorldRotationAtDistanceAlongSpline) == 0x000010, "Wrong size on SplineComponent_GetWorldRotationAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetWorldRotationAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetWorldRotationAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldRotationAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetWorldRotationAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldRotationAtTime
// 0x0014 (0x0014 - 0x0000)
struct SplineComponent_GetWorldRotationAtTime final
{
public:
	float                                         Time;                                              // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseConstantVelocity;                              // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FRotator                               ReturnValue;                                       // 0x0008(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldRotationAtTime) == 0x000004, "Wrong alignment on SplineComponent_GetWorldRotationAtTime");
static_assert(sizeof(SplineComponent_GetWorldRotationAtTime) == 0x000014, "Wrong size on SplineComponent_GetWorldRotationAtTime");
static_assert(offsetof(SplineComponent_GetWorldRotationAtTime, Time) == 0x000000, "Member 'SplineComponent_GetWorldRotationAtTime::Time' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldRotationAtTime, bUseConstantVelocity) == 0x000004, "Member 'SplineComponent_GetWorldRotationAtTime::bUseConstantVelocity' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldRotationAtTime, ReturnValue) == 0x000008, "Member 'SplineComponent_GetWorldRotationAtTime::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.GetWorldTangentAtDistanceAlongSpline
// 0x0010 (0x0010 - 0x0000)
struct SplineComponent_GetWorldTangentAtDistanceAlongSpline final
{
public:
	float                                         Distance;                                          // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ReturnValue;                                       // 0x0004(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_GetWorldTangentAtDistanceAlongSpline) == 0x000004, "Wrong alignment on SplineComponent_GetWorldTangentAtDistanceAlongSpline");
static_assert(sizeof(SplineComponent_GetWorldTangentAtDistanceAlongSpline) == 0x000010, "Wrong size on SplineComponent_GetWorldTangentAtDistanceAlongSpline");
static_assert(offsetof(SplineComponent_GetWorldTangentAtDistanceAlongSpline, Distance) == 0x000000, "Member 'SplineComponent_GetWorldTangentAtDistanceAlongSpline::Distance' has a wrong offset!");
static_assert(offsetof(SplineComponent_GetWorldTangentAtDistanceAlongSpline, ReturnValue) == 0x000004, "Member 'SplineComponent_GetWorldTangentAtDistanceAlongSpline::ReturnValue' has a wrong offset!");

// Function Engine.SplineComponent.IsClosedLoop
// 0x0001 (0x0001 - 0x0000)
struct SplineComponent_IsClosedLoop final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineComponent_IsClosedLoop) == 0x000001, "Wrong alignment on SplineComponent_IsClosedLoop");
static_assert(sizeof(SplineComponent_IsClosedLoop) == 0x000001, "Wrong size on SplineComponent_IsClosedLoop");
static_assert(offsetof(SplineComponent_IsClosedLoop, ReturnValue) == 0x000000, "Member 'SplineComponent_IsClosedLoop::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetBoundaryMax
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_SetBoundaryMax final
{
public:
	float                                         InBoundaryMax;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetBoundaryMax) == 0x000004, "Wrong alignment on SplineMeshComponent_SetBoundaryMax");
static_assert(sizeof(SplineMeshComponent_SetBoundaryMax) == 0x000008, "Wrong size on SplineMeshComponent_SetBoundaryMax");
static_assert(offsetof(SplineMeshComponent_SetBoundaryMax, InBoundaryMax) == 0x000000, "Member 'SplineMeshComponent_SetBoundaryMax::InBoundaryMax' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetBoundaryMax, bUpdateMesh) == 0x000004, "Member 'SplineMeshComponent_SetBoundaryMax::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetBoundaryMin
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_SetBoundaryMin final
{
public:
	float                                         InBoundaryMin;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetBoundaryMin) == 0x000004, "Wrong alignment on SplineMeshComponent_SetBoundaryMin");
static_assert(sizeof(SplineMeshComponent_SetBoundaryMin) == 0x000008, "Wrong size on SplineMeshComponent_SetBoundaryMin");
static_assert(offsetof(SplineMeshComponent_SetBoundaryMin, InBoundaryMin) == 0x000000, "Member 'SplineMeshComponent_SetBoundaryMin::InBoundaryMin' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetBoundaryMin, bUpdateMesh) == 0x000004, "Member 'SplineMeshComponent_SetBoundaryMin::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetEndOffset
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_SetEndOffset final
{
public:
	struct FVector2D                              EndOffset;                                         // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetEndOffset) == 0x000004, "Wrong alignment on SplineMeshComponent_SetEndOffset");
static_assert(sizeof(SplineMeshComponent_SetEndOffset) == 0x00000C, "Wrong size on SplineMeshComponent_SetEndOffset");
static_assert(offsetof(SplineMeshComponent_SetEndOffset, EndOffset) == 0x000000, "Member 'SplineMeshComponent_SetEndOffset::EndOffset' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetEndOffset, bUpdateMesh) == 0x000008, "Member 'SplineMeshComponent_SetEndOffset::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetEndPosition
// 0x0010 (0x0010 - 0x0000)
struct SplineMeshComponent_SetEndPosition final
{
public:
	struct FVector                                EndPos;                                            // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetEndPosition) == 0x000004, "Wrong alignment on SplineMeshComponent_SetEndPosition");
static_assert(sizeof(SplineMeshComponent_SetEndPosition) == 0x000010, "Wrong size on SplineMeshComponent_SetEndPosition");
static_assert(offsetof(SplineMeshComponent_SetEndPosition, EndPos) == 0x000000, "Member 'SplineMeshComponent_SetEndPosition::EndPos' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetEndPosition, bUpdateMesh) == 0x00000C, "Member 'SplineMeshComponent_SetEndPosition::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetEndRoll
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_SetEndRoll final
{
public:
	float                                         EndRoll;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetEndRoll) == 0x000004, "Wrong alignment on SplineMeshComponent_SetEndRoll");
static_assert(sizeof(SplineMeshComponent_SetEndRoll) == 0x000008, "Wrong size on SplineMeshComponent_SetEndRoll");
static_assert(offsetof(SplineMeshComponent_SetEndRoll, EndRoll) == 0x000000, "Member 'SplineMeshComponent_SetEndRoll::EndRoll' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetEndRoll, bUpdateMesh) == 0x000004, "Member 'SplineMeshComponent_SetEndRoll::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetEndScale
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_SetEndScale final
{
public:
	struct FVector2D                              EndScale;                                          // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetEndScale) == 0x000004, "Wrong alignment on SplineMeshComponent_SetEndScale");
static_assert(sizeof(SplineMeshComponent_SetEndScale) == 0x00000C, "Wrong size on SplineMeshComponent_SetEndScale");
static_assert(offsetof(SplineMeshComponent_SetEndScale, EndScale) == 0x000000, "Member 'SplineMeshComponent_SetEndScale::EndScale' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetEndScale, bUpdateMesh) == 0x000008, "Member 'SplineMeshComponent_SetEndScale::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetEndTangent
// 0x0010 (0x0010 - 0x0000)
struct SplineMeshComponent_SetEndTangent final
{
public:
	struct FVector                                EndTangent;                                        // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetEndTangent) == 0x000004, "Wrong alignment on SplineMeshComponent_SetEndTangent");
static_assert(sizeof(SplineMeshComponent_SetEndTangent) == 0x000010, "Wrong size on SplineMeshComponent_SetEndTangent");
static_assert(offsetof(SplineMeshComponent_SetEndTangent, EndTangent) == 0x000000, "Member 'SplineMeshComponent_SetEndTangent::EndTangent' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetEndTangent, bUpdateMesh) == 0x00000C, "Member 'SplineMeshComponent_SetEndTangent::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetForwardAxis
// 0x0002 (0x0002 - 0x0000)
struct SplineMeshComponent_SetForwardAxis final
{
public:
	ESplineMeshAxis                               InForwardAxis;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0001(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_SetForwardAxis) == 0x000001, "Wrong alignment on SplineMeshComponent_SetForwardAxis");
static_assert(sizeof(SplineMeshComponent_SetForwardAxis) == 0x000002, "Wrong size on SplineMeshComponent_SetForwardAxis");
static_assert(offsetof(SplineMeshComponent_SetForwardAxis, InForwardAxis) == 0x000000, "Member 'SplineMeshComponent_SetForwardAxis::InForwardAxis' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetForwardAxis, bUpdateMesh) == 0x000001, "Member 'SplineMeshComponent_SetForwardAxis::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetSplineUpDir
// 0x0010 (0x0010 - 0x0000)
struct SplineMeshComponent_SetSplineUpDir final
{
public:
	struct FVector                                InSplineUpDir;                                     // 0x0000(0x000C)(ConstParm, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetSplineUpDir) == 0x000004, "Wrong alignment on SplineMeshComponent_SetSplineUpDir");
static_assert(sizeof(SplineMeshComponent_SetSplineUpDir) == 0x000010, "Wrong size on SplineMeshComponent_SetSplineUpDir");
static_assert(offsetof(SplineMeshComponent_SetSplineUpDir, InSplineUpDir) == 0x000000, "Member 'SplineMeshComponent_SetSplineUpDir::InSplineUpDir' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetSplineUpDir, bUpdateMesh) == 0x00000C, "Member 'SplineMeshComponent_SetSplineUpDir::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartAndEnd
// 0x0034 (0x0034 - 0x0000)
struct SplineMeshComponent_SetStartAndEnd final
{
public:
	struct FVector                                StartPos;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                StartTangent;                                      // 0x000C(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndPos;                                            // 0x0018(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                EndTangent;                                        // 0x0024(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0030(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartAndEnd) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartAndEnd");
static_assert(sizeof(SplineMeshComponent_SetStartAndEnd) == 0x000034, "Wrong size on SplineMeshComponent_SetStartAndEnd");
static_assert(offsetof(SplineMeshComponent_SetStartAndEnd, StartPos) == 0x000000, "Member 'SplineMeshComponent_SetStartAndEnd::StartPos' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartAndEnd, StartTangent) == 0x00000C, "Member 'SplineMeshComponent_SetStartAndEnd::StartTangent' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartAndEnd, EndPos) == 0x000018, "Member 'SplineMeshComponent_SetStartAndEnd::EndPos' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartAndEnd, EndTangent) == 0x000024, "Member 'SplineMeshComponent_SetStartAndEnd::EndTangent' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartAndEnd, bUpdateMesh) == 0x000030, "Member 'SplineMeshComponent_SetStartAndEnd::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartOffset
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_SetStartOffset final
{
public:
	struct FVector2D                              StartOffset;                                       // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartOffset) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartOffset");
static_assert(sizeof(SplineMeshComponent_SetStartOffset) == 0x00000C, "Wrong size on SplineMeshComponent_SetStartOffset");
static_assert(offsetof(SplineMeshComponent_SetStartOffset, StartOffset) == 0x000000, "Member 'SplineMeshComponent_SetStartOffset::StartOffset' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartOffset, bUpdateMesh) == 0x000008, "Member 'SplineMeshComponent_SetStartOffset::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartPosition
// 0x0010 (0x0010 - 0x0000)
struct SplineMeshComponent_SetStartPosition final
{
public:
	struct FVector                                StartPos;                                          // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartPosition) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartPosition");
static_assert(sizeof(SplineMeshComponent_SetStartPosition) == 0x000010, "Wrong size on SplineMeshComponent_SetStartPosition");
static_assert(offsetof(SplineMeshComponent_SetStartPosition, StartPos) == 0x000000, "Member 'SplineMeshComponent_SetStartPosition::StartPos' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartPosition, bUpdateMesh) == 0x00000C, "Member 'SplineMeshComponent_SetStartPosition::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartRoll
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_SetStartRoll final
{
public:
	float                                         StartRoll;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5[0x3];                                        // 0x0005(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartRoll) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartRoll");
static_assert(sizeof(SplineMeshComponent_SetStartRoll) == 0x000008, "Wrong size on SplineMeshComponent_SetStartRoll");
static_assert(offsetof(SplineMeshComponent_SetStartRoll, StartRoll) == 0x000000, "Member 'SplineMeshComponent_SetStartRoll::StartRoll' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartRoll, bUpdateMesh) == 0x000004, "Member 'SplineMeshComponent_SetStartRoll::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartScale
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_SetStartScale final
{
public:
	struct FVector2D                              StartScale;                                        // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x0008(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartScale) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartScale");
static_assert(sizeof(SplineMeshComponent_SetStartScale) == 0x00000C, "Wrong size on SplineMeshComponent_SetStartScale");
static_assert(offsetof(SplineMeshComponent_SetStartScale, StartScale) == 0x000000, "Member 'SplineMeshComponent_SetStartScale::StartScale' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartScale, bUpdateMesh) == 0x000008, "Member 'SplineMeshComponent_SetStartScale::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.SetStartTangent
// 0x0010 (0x0010 - 0x0000)
struct SplineMeshComponent_SetStartTangent final
{
public:
	struct FVector                                StartTangent;                                      // 0x0000(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUpdateMesh;                                       // 0x000C(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D[0x3];                                        // 0x000D(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(SplineMeshComponent_SetStartTangent) == 0x000004, "Wrong alignment on SplineMeshComponent_SetStartTangent");
static_assert(sizeof(SplineMeshComponent_SetStartTangent) == 0x000010, "Wrong size on SplineMeshComponent_SetStartTangent");
static_assert(offsetof(SplineMeshComponent_SetStartTangent, StartTangent) == 0x000000, "Member 'SplineMeshComponent_SetStartTangent::StartTangent' has a wrong offset!");
static_assert(offsetof(SplineMeshComponent_SetStartTangent, bUpdateMesh) == 0x00000C, "Member 'SplineMeshComponent_SetStartTangent::bUpdateMesh' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetBoundaryMax
// 0x0004 (0x0004 - 0x0000)
struct SplineMeshComponent_GetBoundaryMax final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetBoundaryMax) == 0x000004, "Wrong alignment on SplineMeshComponent_GetBoundaryMax");
static_assert(sizeof(SplineMeshComponent_GetBoundaryMax) == 0x000004, "Wrong size on SplineMeshComponent_GetBoundaryMax");
static_assert(offsetof(SplineMeshComponent_GetBoundaryMax, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetBoundaryMax::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetBoundaryMin
// 0x0004 (0x0004 - 0x0000)
struct SplineMeshComponent_GetBoundaryMin final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetBoundaryMin) == 0x000004, "Wrong alignment on SplineMeshComponent_GetBoundaryMin");
static_assert(sizeof(SplineMeshComponent_GetBoundaryMin) == 0x000004, "Wrong size on SplineMeshComponent_GetBoundaryMin");
static_assert(offsetof(SplineMeshComponent_GetBoundaryMin, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetBoundaryMin::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetEndOffset
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_GetEndOffset final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetEndOffset) == 0x000004, "Wrong alignment on SplineMeshComponent_GetEndOffset");
static_assert(sizeof(SplineMeshComponent_GetEndOffset) == 0x000008, "Wrong size on SplineMeshComponent_GetEndOffset");
static_assert(offsetof(SplineMeshComponent_GetEndOffset, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetEndOffset::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetEndPosition
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_GetEndPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetEndPosition) == 0x000004, "Wrong alignment on SplineMeshComponent_GetEndPosition");
static_assert(sizeof(SplineMeshComponent_GetEndPosition) == 0x00000C, "Wrong size on SplineMeshComponent_GetEndPosition");
static_assert(offsetof(SplineMeshComponent_GetEndPosition, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetEndPosition::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetEndRoll
// 0x0004 (0x0004 - 0x0000)
struct SplineMeshComponent_GetEndRoll final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetEndRoll) == 0x000004, "Wrong alignment on SplineMeshComponent_GetEndRoll");
static_assert(sizeof(SplineMeshComponent_GetEndRoll) == 0x000004, "Wrong size on SplineMeshComponent_GetEndRoll");
static_assert(offsetof(SplineMeshComponent_GetEndRoll, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetEndRoll::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetEndScale
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_GetEndScale final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetEndScale) == 0x000004, "Wrong alignment on SplineMeshComponent_GetEndScale");
static_assert(sizeof(SplineMeshComponent_GetEndScale) == 0x000008, "Wrong size on SplineMeshComponent_GetEndScale");
static_assert(offsetof(SplineMeshComponent_GetEndScale, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetEndScale::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetEndTangent
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_GetEndTangent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetEndTangent) == 0x000004, "Wrong alignment on SplineMeshComponent_GetEndTangent");
static_assert(sizeof(SplineMeshComponent_GetEndTangent) == 0x00000C, "Wrong size on SplineMeshComponent_GetEndTangent");
static_assert(offsetof(SplineMeshComponent_GetEndTangent, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetEndTangent::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetForwardAxis
// 0x0001 (0x0001 - 0x0000)
struct SplineMeshComponent_GetForwardAxis final
{
public:
	ESplineMeshAxis                               ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetForwardAxis) == 0x000001, "Wrong alignment on SplineMeshComponent_GetForwardAxis");
static_assert(sizeof(SplineMeshComponent_GetForwardAxis) == 0x000001, "Wrong size on SplineMeshComponent_GetForwardAxis");
static_assert(offsetof(SplineMeshComponent_GetForwardAxis, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetForwardAxis::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetSplineUpDir
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_GetSplineUpDir final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetSplineUpDir) == 0x000004, "Wrong alignment on SplineMeshComponent_GetSplineUpDir");
static_assert(sizeof(SplineMeshComponent_GetSplineUpDir) == 0x00000C, "Wrong size on SplineMeshComponent_GetSplineUpDir");
static_assert(offsetof(SplineMeshComponent_GetSplineUpDir, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetSplineUpDir::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetStartOffset
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_GetStartOffset final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetStartOffset) == 0x000004, "Wrong alignment on SplineMeshComponent_GetStartOffset");
static_assert(sizeof(SplineMeshComponent_GetStartOffset) == 0x000008, "Wrong size on SplineMeshComponent_GetStartOffset");
static_assert(offsetof(SplineMeshComponent_GetStartOffset, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetStartOffset::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetStartPosition
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_GetStartPosition final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetStartPosition) == 0x000004, "Wrong alignment on SplineMeshComponent_GetStartPosition");
static_assert(sizeof(SplineMeshComponent_GetStartPosition) == 0x00000C, "Wrong size on SplineMeshComponent_GetStartPosition");
static_assert(offsetof(SplineMeshComponent_GetStartPosition, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetStartPosition::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetStartRoll
// 0x0004 (0x0004 - 0x0000)
struct SplineMeshComponent_GetStartRoll final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetStartRoll) == 0x000004, "Wrong alignment on SplineMeshComponent_GetStartRoll");
static_assert(sizeof(SplineMeshComponent_GetStartRoll) == 0x000004, "Wrong size on SplineMeshComponent_GetStartRoll");
static_assert(offsetof(SplineMeshComponent_GetStartRoll, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetStartRoll::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetStartScale
// 0x0008 (0x0008 - 0x0000)
struct SplineMeshComponent_GetStartScale final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetStartScale) == 0x000004, "Wrong alignment on SplineMeshComponent_GetStartScale");
static_assert(sizeof(SplineMeshComponent_GetStartScale) == 0x000008, "Wrong size on SplineMeshComponent_GetStartScale");
static_assert(offsetof(SplineMeshComponent_GetStartScale, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetStartScale::ReturnValue' has a wrong offset!");

// Function Engine.SplineMeshComponent.GetStartTangent
// 0x000C (0x000C - 0x0000)
struct SplineMeshComponent_GetStartTangent final
{
public:
	struct FVector                                ReturnValue;                                       // 0x0000(0x000C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(SplineMeshComponent_GetStartTangent) == 0x000004, "Wrong alignment on SplineMeshComponent_GetStartTangent");
static_assert(sizeof(SplineMeshComponent_GetStartTangent) == 0x00000C, "Wrong size on SplineMeshComponent_GetStartTangent");
static_assert(offsetof(SplineMeshComponent_GetStartTangent, ReturnValue) == 0x000000, "Member 'SplineMeshComponent_GetStartTangent::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetBoundingBox
// 0x001C (0x001C - 0x0000)
struct StaticMesh_GetBoundingBox final
{
public:
	struct FBox                                   ReturnValue;                                       // 0x0000(0x001C)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMesh_GetBoundingBox) == 0x000004, "Wrong alignment on StaticMesh_GetBoundingBox");
static_assert(sizeof(StaticMesh_GetBoundingBox) == 0x00001C, "Wrong size on StaticMesh_GetBoundingBox");
static_assert(offsetof(StaticMesh_GetBoundingBox, ReturnValue) == 0x000000, "Member 'StaticMesh_GetBoundingBox::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetBounds
// 0x0020 (0x0020 - 0x0000)
struct StaticMesh_GetBounds final
{
public:
	struct FBoxSphereBounds                       ReturnValue;                                       // 0x0000(0x0020)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMesh_GetBounds) == 0x000004, "Wrong alignment on StaticMesh_GetBounds");
static_assert(sizeof(StaticMesh_GetBounds) == 0x000020, "Wrong size on StaticMesh_GetBounds");
static_assert(offsetof(StaticMesh_GetBounds, ReturnValue) == 0x000000, "Member 'StaticMesh_GetBounds::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetMaterial
// 0x0010 (0x0010 - 0x0000)
struct StaticMesh_GetMaterial final
{
public:
	int32                                         MaterialIndex;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UMaterialInterface*                     ReturnValue;                                       // 0x0008(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMesh_GetMaterial) == 0x000008, "Wrong alignment on StaticMesh_GetMaterial");
static_assert(sizeof(StaticMesh_GetMaterial) == 0x000010, "Wrong size on StaticMesh_GetMaterial");
static_assert(offsetof(StaticMesh_GetMaterial, MaterialIndex) == 0x000000, "Member 'StaticMesh_GetMaterial::MaterialIndex' has a wrong offset!");
static_assert(offsetof(StaticMesh_GetMaterial, ReturnValue) == 0x000008, "Member 'StaticMesh_GetMaterial::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetMaterialIndex
// 0x0010 (0x0010 - 0x0000)
struct StaticMesh_GetMaterialIndex final
{
public:
	class FName                                   MaterialSlotName;                                  // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0008(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StaticMesh_GetMaterialIndex) == 0x000004, "Wrong alignment on StaticMesh_GetMaterialIndex");
static_assert(sizeof(StaticMesh_GetMaterialIndex) == 0x000010, "Wrong size on StaticMesh_GetMaterialIndex");
static_assert(offsetof(StaticMesh_GetMaterialIndex, MaterialSlotName) == 0x000000, "Member 'StaticMesh_GetMaterialIndex::MaterialSlotName' has a wrong offset!");
static_assert(offsetof(StaticMesh_GetMaterialIndex, ReturnValue) == 0x000008, "Member 'StaticMesh_GetMaterialIndex::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetNumLODs
// 0x0004 (0x0004 - 0x0000)
struct StaticMesh_GetNumLODs final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMesh_GetNumLODs) == 0x000004, "Wrong alignment on StaticMesh_GetNumLODs");
static_assert(sizeof(StaticMesh_GetNumLODs) == 0x000004, "Wrong size on StaticMesh_GetNumLODs");
static_assert(offsetof(StaticMesh_GetNumLODs, ReturnValue) == 0x000000, "Member 'StaticMesh_GetNumLODs::ReturnValue' has a wrong offset!");

// Function Engine.StaticMesh.GetNumSections
// 0x0008 (0x0008 - 0x0000)
struct StaticMesh_GetNumSections final
{
public:
	int32                                         InLOD;                                             // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ReturnValue;                                       // 0x0004(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StaticMesh_GetNumSections) == 0x000004, "Wrong alignment on StaticMesh_GetNumSections");
static_assert(sizeof(StaticMesh_GetNumSections) == 0x000008, "Wrong size on StaticMesh_GetNumSections");
static_assert(offsetof(StaticMesh_GetNumSections, InLOD) == 0x000000, "Member 'StaticMesh_GetNumSections::InLOD' has a wrong offset!");
static_assert(offsetof(StaticMesh_GetNumSections, ReturnValue) == 0x000004, "Member 'StaticMesh_GetNumSections::ReturnValue' has a wrong offset!");

// Function Engine.StereoLayerComponent.SetPriority
// 0x0004 (0x0004 - 0x0000)
struct StereoLayerComponent_SetPriority final
{
public:
	int32                                         InPriority;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_SetPriority) == 0x000004, "Wrong alignment on StereoLayerComponent_SetPriority");
static_assert(sizeof(StereoLayerComponent_SetPriority) == 0x000004, "Wrong size on StereoLayerComponent_SetPriority");
static_assert(offsetof(StereoLayerComponent_SetPriority, InPriority) == 0x000000, "Member 'StereoLayerComponent_SetPriority::InPriority' has a wrong offset!");

// Function Engine.StereoLayerComponent.SetQuadSize
// 0x0008 (0x0008 - 0x0000)
struct StereoLayerComponent_SetQuadSize final
{
public:
	struct FVector2D                              InQuadSize;                                        // 0x0000(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_SetQuadSize) == 0x000004, "Wrong alignment on StereoLayerComponent_SetQuadSize");
static_assert(sizeof(StereoLayerComponent_SetQuadSize) == 0x000008, "Wrong size on StereoLayerComponent_SetQuadSize");
static_assert(offsetof(StereoLayerComponent_SetQuadSize, InQuadSize) == 0x000000, "Member 'StereoLayerComponent_SetQuadSize::InQuadSize' has a wrong offset!");

// Function Engine.StereoLayerComponent.SetTexture
// 0x0008 (0x0008 - 0x0000)
struct StereoLayerComponent_SetTexture final
{
public:
	class UTexture*                               InTexture;                                         // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_SetTexture) == 0x000008, "Wrong alignment on StereoLayerComponent_SetTexture");
static_assert(sizeof(StereoLayerComponent_SetTexture) == 0x000008, "Wrong size on StereoLayerComponent_SetTexture");
static_assert(offsetof(StereoLayerComponent_SetTexture, InTexture) == 0x000000, "Member 'StereoLayerComponent_SetTexture::InTexture' has a wrong offset!");

// Function Engine.StereoLayerComponent.SetUVRect
// 0x0014 (0x0014 - 0x0000)
struct StereoLayerComponent_SetUVRect final
{
public:
	struct FBox2D                                 InUVRect;                                          // 0x0000(0x0014)(Parm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_SetUVRect) == 0x000004, "Wrong alignment on StereoLayerComponent_SetUVRect");
static_assert(sizeof(StereoLayerComponent_SetUVRect) == 0x000014, "Wrong size on StereoLayerComponent_SetUVRect");
static_assert(offsetof(StereoLayerComponent_SetUVRect, InUVRect) == 0x000000, "Member 'StereoLayerComponent_SetUVRect::InUVRect' has a wrong offset!");

// Function Engine.StereoLayerComponent.GetPriority
// 0x0004 (0x0004 - 0x0000)
struct StereoLayerComponent_GetPriority final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_GetPriority) == 0x000004, "Wrong alignment on StereoLayerComponent_GetPriority");
static_assert(sizeof(StereoLayerComponent_GetPriority) == 0x000004, "Wrong size on StereoLayerComponent_GetPriority");
static_assert(offsetof(StereoLayerComponent_GetPriority, ReturnValue) == 0x000000, "Member 'StereoLayerComponent_GetPriority::ReturnValue' has a wrong offset!");

// Function Engine.StereoLayerComponent.GetQuadSize
// 0x0008 (0x0008 - 0x0000)
struct StereoLayerComponent_GetQuadSize final
{
public:
	struct FVector2D                              ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_GetQuadSize) == 0x000004, "Wrong alignment on StereoLayerComponent_GetQuadSize");
static_assert(sizeof(StereoLayerComponent_GetQuadSize) == 0x000008, "Wrong size on StereoLayerComponent_GetQuadSize");
static_assert(offsetof(StereoLayerComponent_GetQuadSize, ReturnValue) == 0x000000, "Member 'StereoLayerComponent_GetQuadSize::ReturnValue' has a wrong offset!");

// Function Engine.StereoLayerComponent.GetTexture
// 0x0008 (0x0008 - 0x0000)
struct StereoLayerComponent_GetTexture final
{
public:
	class UTexture*                               ReturnValue;                                       // 0x0000(0x0008)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_GetTexture) == 0x000008, "Wrong alignment on StereoLayerComponent_GetTexture");
static_assert(sizeof(StereoLayerComponent_GetTexture) == 0x000008, "Wrong size on StereoLayerComponent_GetTexture");
static_assert(offsetof(StereoLayerComponent_GetTexture, ReturnValue) == 0x000000, "Member 'StereoLayerComponent_GetTexture::ReturnValue' has a wrong offset!");

// Function Engine.StereoLayerComponent.GetUVRect
// 0x0014 (0x0014 - 0x0000)
struct StereoLayerComponent_GetUVRect final
{
public:
	struct FBox2D                                 ReturnValue;                                       // 0x0000(0x0014)(Parm, OutParm, ReturnParm, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerComponent_GetUVRect) == 0x000004, "Wrong alignment on StereoLayerComponent_GetUVRect");
static_assert(sizeof(StereoLayerComponent_GetUVRect) == 0x000014, "Wrong size on StereoLayerComponent_GetUVRect");
static_assert(offsetof(StereoLayerComponent_GetUVRect, ReturnValue) == 0x000000, "Member 'StereoLayerComponent_GetUVRect::ReturnValue' has a wrong offset!");

// Function Engine.StereoLayerFunctionLibrary.EnableAutoLoadingSplashScreen
// 0x0001 (0x0001 - 0x0000)
struct StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen final
{
public:
	bool                                          InAutoShowEnabled;                                 // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen) == 0x000001, "Wrong alignment on StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen");
static_assert(sizeof(StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen) == 0x000001, "Wrong size on StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen");
static_assert(offsetof(StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen, InAutoShowEnabled) == 0x000000, "Member 'StereoLayerFunctionLibrary_EnableAutoLoadingSplashScreen::InAutoShowEnabled' has a wrong offset!");

// Function Engine.StereoLayerFunctionLibrary.SetSplashScreen
// 0x0020 (0x0020 - 0x0000)
struct StereoLayerFunctionLibrary_SetSplashScreen final
{
public:
	class UTexture*                               Texture;                                           // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Scale;                                             // 0x0008(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector2D                              Offset;                                            // 0x0010(0x0008)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowLoadingMovie;                                 // 0x0018(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowOnSet;                                        // 0x0019(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1A[0x6];                                       // 0x001A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(StereoLayerFunctionLibrary_SetSplashScreen) == 0x000008, "Wrong alignment on StereoLayerFunctionLibrary_SetSplashScreen");
static_assert(sizeof(StereoLayerFunctionLibrary_SetSplashScreen) == 0x000020, "Wrong size on StereoLayerFunctionLibrary_SetSplashScreen");
static_assert(offsetof(StereoLayerFunctionLibrary_SetSplashScreen, Texture) == 0x000000, "Member 'StereoLayerFunctionLibrary_SetSplashScreen::Texture' has a wrong offset!");
static_assert(offsetof(StereoLayerFunctionLibrary_SetSplashScreen, Scale) == 0x000008, "Member 'StereoLayerFunctionLibrary_SetSplashScreen::Scale' has a wrong offset!");
static_assert(offsetof(StereoLayerFunctionLibrary_SetSplashScreen, Offset) == 0x000010, "Member 'StereoLayerFunctionLibrary_SetSplashScreen::Offset' has a wrong offset!");
static_assert(offsetof(StereoLayerFunctionLibrary_SetSplashScreen, bShowLoadingMovie) == 0x000018, "Member 'StereoLayerFunctionLibrary_SetSplashScreen::bShowLoadingMovie' has a wrong offset!");
static_assert(offsetof(StereoLayerFunctionLibrary_SetSplashScreen, bShowOnSet) == 0x000019, "Member 'StereoLayerFunctionLibrary_SetSplashScreen::bShowOnSet' has a wrong offset!");

// Function Engine.TimelineComponent.SetFloatCurve
// 0x0010 (0x0010 - 0x0000)
struct TimelineComponent_SetFloatCurve final
{
public:
	class UCurveFloat*                            NewFloatCurve;                                     // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   FloatTrackName;                                    // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetFloatCurve) == 0x000008, "Wrong alignment on TimelineComponent_SetFloatCurve");
static_assert(sizeof(TimelineComponent_SetFloatCurve) == 0x000010, "Wrong size on TimelineComponent_SetFloatCurve");
static_assert(offsetof(TimelineComponent_SetFloatCurve, NewFloatCurve) == 0x000000, "Member 'TimelineComponent_SetFloatCurve::NewFloatCurve' has a wrong offset!");
static_assert(offsetof(TimelineComponent_SetFloatCurve, FloatTrackName) == 0x000008, "Member 'TimelineComponent_SetFloatCurve::FloatTrackName' has a wrong offset!");

// Function Engine.TimelineComponent.SetIgnoreTimeDilation
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_SetIgnoreTimeDilation final
{
public:
	bool                                          bNewIgnoreTimeDilation;                            // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetIgnoreTimeDilation) == 0x000001, "Wrong alignment on TimelineComponent_SetIgnoreTimeDilation");
static_assert(sizeof(TimelineComponent_SetIgnoreTimeDilation) == 0x000001, "Wrong size on TimelineComponent_SetIgnoreTimeDilation");
static_assert(offsetof(TimelineComponent_SetIgnoreTimeDilation, bNewIgnoreTimeDilation) == 0x000000, "Member 'TimelineComponent_SetIgnoreTimeDilation::bNewIgnoreTimeDilation' has a wrong offset!");

// Function Engine.TimelineComponent.SetLinearColorCurve
// 0x0010 (0x0010 - 0x0000)
struct TimelineComponent_SetLinearColorCurve final
{
public:
	class UCurveLinearColor*                      NewLinearColorCurve;                               // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LinearColorTrackName;                              // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetLinearColorCurve) == 0x000008, "Wrong alignment on TimelineComponent_SetLinearColorCurve");
static_assert(sizeof(TimelineComponent_SetLinearColorCurve) == 0x000010, "Wrong size on TimelineComponent_SetLinearColorCurve");
static_assert(offsetof(TimelineComponent_SetLinearColorCurve, NewLinearColorCurve) == 0x000000, "Member 'TimelineComponent_SetLinearColorCurve::NewLinearColorCurve' has a wrong offset!");
static_assert(offsetof(TimelineComponent_SetLinearColorCurve, LinearColorTrackName) == 0x000008, "Member 'TimelineComponent_SetLinearColorCurve::LinearColorTrackName' has a wrong offset!");

// Function Engine.TimelineComponent.SetLooping
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_SetLooping final
{
public:
	bool                                          bNewLooping;                                       // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetLooping) == 0x000001, "Wrong alignment on TimelineComponent_SetLooping");
static_assert(sizeof(TimelineComponent_SetLooping) == 0x000001, "Wrong size on TimelineComponent_SetLooping");
static_assert(offsetof(TimelineComponent_SetLooping, bNewLooping) == 0x000000, "Member 'TimelineComponent_SetLooping::bNewLooping' has a wrong offset!");

// Function Engine.TimelineComponent.SetNewTime
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_SetNewTime final
{
public:
	float                                         NewTime;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetNewTime) == 0x000004, "Wrong alignment on TimelineComponent_SetNewTime");
static_assert(sizeof(TimelineComponent_SetNewTime) == 0x000004, "Wrong size on TimelineComponent_SetNewTime");
static_assert(offsetof(TimelineComponent_SetNewTime, NewTime) == 0x000000, "Member 'TimelineComponent_SetNewTime::NewTime' has a wrong offset!");

// Function Engine.TimelineComponent.SetPlaybackPosition
// 0x0008 (0x0008 - 0x0000)
struct TimelineComponent_SetPlaybackPosition final
{
public:
	float                                         NewPosition;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireEvents;                                       // 0x0004(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFireUpdate;                                       // 0x0005(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TimelineComponent_SetPlaybackPosition) == 0x000004, "Wrong alignment on TimelineComponent_SetPlaybackPosition");
static_assert(sizeof(TimelineComponent_SetPlaybackPosition) == 0x000008, "Wrong size on TimelineComponent_SetPlaybackPosition");
static_assert(offsetof(TimelineComponent_SetPlaybackPosition, NewPosition) == 0x000000, "Member 'TimelineComponent_SetPlaybackPosition::NewPosition' has a wrong offset!");
static_assert(offsetof(TimelineComponent_SetPlaybackPosition, bFireEvents) == 0x000004, "Member 'TimelineComponent_SetPlaybackPosition::bFireEvents' has a wrong offset!");
static_assert(offsetof(TimelineComponent_SetPlaybackPosition, bFireUpdate) == 0x000005, "Member 'TimelineComponent_SetPlaybackPosition::bFireUpdate' has a wrong offset!");

// Function Engine.TimelineComponent.SetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_SetPlayRate final
{
public:
	float                                         NewRate;                                           // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetPlayRate) == 0x000004, "Wrong alignment on TimelineComponent_SetPlayRate");
static_assert(sizeof(TimelineComponent_SetPlayRate) == 0x000004, "Wrong size on TimelineComponent_SetPlayRate");
static_assert(offsetof(TimelineComponent_SetPlayRate, NewRate) == 0x000000, "Member 'TimelineComponent_SetPlayRate::NewRate' has a wrong offset!");

// Function Engine.TimelineComponent.SetTimelineLength
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_SetTimelineLength final
{
public:
	float                                         NewLength;                                         // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetTimelineLength) == 0x000004, "Wrong alignment on TimelineComponent_SetTimelineLength");
static_assert(sizeof(TimelineComponent_SetTimelineLength) == 0x000004, "Wrong size on TimelineComponent_SetTimelineLength");
static_assert(offsetof(TimelineComponent_SetTimelineLength, NewLength) == 0x000000, "Member 'TimelineComponent_SetTimelineLength::NewLength' has a wrong offset!");

// Function Engine.TimelineComponent.SetTimelineLengthMode
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_SetTimelineLengthMode final
{
public:
	ETimelineLengthMode                           NewLengthMode;                                     // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetTimelineLengthMode) == 0x000001, "Wrong alignment on TimelineComponent_SetTimelineLengthMode");
static_assert(sizeof(TimelineComponent_SetTimelineLengthMode) == 0x000001, "Wrong size on TimelineComponent_SetTimelineLengthMode");
static_assert(offsetof(TimelineComponent_SetTimelineLengthMode, NewLengthMode) == 0x000000, "Member 'TimelineComponent_SetTimelineLengthMode::NewLengthMode' has a wrong offset!");

// Function Engine.TimelineComponent.SetVectorCurve
// 0x0010 (0x0010 - 0x0000)
struct TimelineComponent_SetVectorCurve final
{
public:
	class UCurveVector*                           NewVectorCurve;                                    // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   VectorTrackName;                                   // 0x0008(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_SetVectorCurve) == 0x000008, "Wrong alignment on TimelineComponent_SetVectorCurve");
static_assert(sizeof(TimelineComponent_SetVectorCurve) == 0x000010, "Wrong size on TimelineComponent_SetVectorCurve");
static_assert(offsetof(TimelineComponent_SetVectorCurve, NewVectorCurve) == 0x000000, "Member 'TimelineComponent_SetVectorCurve::NewVectorCurve' has a wrong offset!");
static_assert(offsetof(TimelineComponent_SetVectorCurve, VectorTrackName) == 0x000008, "Member 'TimelineComponent_SetVectorCurve::VectorTrackName' has a wrong offset!");

// Function Engine.TimelineComponent.GetIgnoreTimeDilation
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_GetIgnoreTimeDilation final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_GetIgnoreTimeDilation) == 0x000001, "Wrong alignment on TimelineComponent_GetIgnoreTimeDilation");
static_assert(sizeof(TimelineComponent_GetIgnoreTimeDilation) == 0x000001, "Wrong size on TimelineComponent_GetIgnoreTimeDilation");
static_assert(offsetof(TimelineComponent_GetIgnoreTimeDilation, ReturnValue) == 0x000000, "Member 'TimelineComponent_GetIgnoreTimeDilation::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.GetPlaybackPosition
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_GetPlaybackPosition final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_GetPlaybackPosition) == 0x000004, "Wrong alignment on TimelineComponent_GetPlaybackPosition");
static_assert(sizeof(TimelineComponent_GetPlaybackPosition) == 0x000004, "Wrong size on TimelineComponent_GetPlaybackPosition");
static_assert(offsetof(TimelineComponent_GetPlaybackPosition, ReturnValue) == 0x000000, "Member 'TimelineComponent_GetPlaybackPosition::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.GetPlayRate
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_GetPlayRate final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_GetPlayRate) == 0x000004, "Wrong alignment on TimelineComponent_GetPlayRate");
static_assert(sizeof(TimelineComponent_GetPlayRate) == 0x000004, "Wrong size on TimelineComponent_GetPlayRate");
static_assert(offsetof(TimelineComponent_GetPlayRate, ReturnValue) == 0x000000, "Member 'TimelineComponent_GetPlayRate::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.GetTimelineLength
// 0x0004 (0x0004 - 0x0000)
struct TimelineComponent_GetTimelineLength final
{
public:
	float                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_GetTimelineLength) == 0x000004, "Wrong alignment on TimelineComponent_GetTimelineLength");
static_assert(sizeof(TimelineComponent_GetTimelineLength) == 0x000004, "Wrong size on TimelineComponent_GetTimelineLength");
static_assert(offsetof(TimelineComponent_GetTimelineLength, ReturnValue) == 0x000000, "Member 'TimelineComponent_GetTimelineLength::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.IsLooping
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_IsLooping final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_IsLooping) == 0x000001, "Wrong alignment on TimelineComponent_IsLooping");
static_assert(sizeof(TimelineComponent_IsLooping) == 0x000001, "Wrong size on TimelineComponent_IsLooping");
static_assert(offsetof(TimelineComponent_IsLooping, ReturnValue) == 0x000000, "Member 'TimelineComponent_IsLooping::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.IsPlaying
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_IsPlaying final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_IsPlaying) == 0x000001, "Wrong alignment on TimelineComponent_IsPlaying");
static_assert(sizeof(TimelineComponent_IsPlaying) == 0x000001, "Wrong size on TimelineComponent_IsPlaying");
static_assert(offsetof(TimelineComponent_IsPlaying, ReturnValue) == 0x000000, "Member 'TimelineComponent_IsPlaying::ReturnValue' has a wrong offset!");

// Function Engine.TimelineComponent.IsReversing
// 0x0001 (0x0001 - 0x0000)
struct TimelineComponent_IsReversing final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TimelineComponent_IsReversing) == 0x000001, "Wrong alignment on TimelineComponent_IsReversing");
static_assert(sizeof(TimelineComponent_IsReversing) == 0x000001, "Wrong size on TimelineComponent_IsReversing");
static_assert(offsetof(TimelineComponent_IsReversing, ReturnValue) == 0x000000, "Member 'TimelineComponent_IsReversing::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.AuthorizeAccounts
// 0x0001 (0x0001 - 0x0000)
struct TwitterIntegrationBase_AuthorizeAccounts final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwitterIntegrationBase_AuthorizeAccounts) == 0x000001, "Wrong alignment on TwitterIntegrationBase_AuthorizeAccounts");
static_assert(sizeof(TwitterIntegrationBase_AuthorizeAccounts) == 0x000001, "Wrong size on TwitterIntegrationBase_AuthorizeAccounts");
static_assert(offsetof(TwitterIntegrationBase_AuthorizeAccounts, ReturnValue) == 0x000000, "Member 'TwitterIntegrationBase_AuthorizeAccounts::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.CanShowTweetUI
// 0x0001 (0x0001 - 0x0000)
struct TwitterIntegrationBase_CanShowTweetUI final
{
public:
	bool                                          ReturnValue;                                       // 0x0000(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwitterIntegrationBase_CanShowTweetUI) == 0x000001, "Wrong alignment on TwitterIntegrationBase_CanShowTweetUI");
static_assert(sizeof(TwitterIntegrationBase_CanShowTweetUI) == 0x000001, "Wrong size on TwitterIntegrationBase_CanShowTweetUI");
static_assert(offsetof(TwitterIntegrationBase_CanShowTweetUI, ReturnValue) == 0x000000, "Member 'TwitterIntegrationBase_CanShowTweetUI::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.GetAccountName
// 0x0018 (0x0018 - 0x0000)
struct TwitterIntegrationBase_GetAccountName final
{
public:
	int32                                         AccountIndex;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ReturnValue;                                       // 0x0008(0x0010)(Parm, OutParm, ZeroConstructor, ReturnParm, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwitterIntegrationBase_GetAccountName) == 0x000008, "Wrong alignment on TwitterIntegrationBase_GetAccountName");
static_assert(sizeof(TwitterIntegrationBase_GetAccountName) == 0x000018, "Wrong size on TwitterIntegrationBase_GetAccountName");
static_assert(offsetof(TwitterIntegrationBase_GetAccountName, AccountIndex) == 0x000000, "Member 'TwitterIntegrationBase_GetAccountName::AccountIndex' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_GetAccountName, ReturnValue) == 0x000008, "Member 'TwitterIntegrationBase_GetAccountName::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.GetNumAccounts
// 0x0004 (0x0004 - 0x0000)
struct TwitterIntegrationBase_GetNumAccounts final
{
public:
	int32                                         ReturnValue;                                       // 0x0000(0x0004)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(TwitterIntegrationBase_GetNumAccounts) == 0x000004, "Wrong alignment on TwitterIntegrationBase_GetNumAccounts");
static_assert(sizeof(TwitterIntegrationBase_GetNumAccounts) == 0x000004, "Wrong size on TwitterIntegrationBase_GetNumAccounts");
static_assert(offsetof(TwitterIntegrationBase_GetNumAccounts, ReturnValue) == 0x000000, "Member 'TwitterIntegrationBase_GetNumAccounts::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.ShowTweetUI
// 0x0038 (0x0038 - 0x0000)
struct TwitterIntegrationBase_ShowTweetUI final
{
public:
	class FString                                 InitialMessage;                                    // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 URL;                                               // 0x0010(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Picture;                                           // 0x0020(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0030(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TwitterIntegrationBase_ShowTweetUI) == 0x000008, "Wrong alignment on TwitterIntegrationBase_ShowTweetUI");
static_assert(sizeof(TwitterIntegrationBase_ShowTweetUI) == 0x000038, "Wrong size on TwitterIntegrationBase_ShowTweetUI");
static_assert(offsetof(TwitterIntegrationBase_ShowTweetUI, InitialMessage) == 0x000000, "Member 'TwitterIntegrationBase_ShowTweetUI::InitialMessage' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_ShowTweetUI, URL) == 0x000010, "Member 'TwitterIntegrationBase_ShowTweetUI::URL' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_ShowTweetUI, Picture) == 0x000020, "Member 'TwitterIntegrationBase_ShowTweetUI::Picture' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_ShowTweetUI, ReturnValue) == 0x000030, "Member 'TwitterIntegrationBase_ShowTweetUI::ReturnValue' has a wrong offset!");

// Function Engine.TwitterIntegrationBase.TwitterRequest
// 0x0030 (0x0030 - 0x0000)
struct TwitterIntegrationBase_TwitterRequest final
{
public:
	class FString                                 URL;                                               // 0x0000(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         ParamKeysAndValues;                                // 0x0010(0x0010)(ConstParm, Parm, OutParm, ZeroConstructor, ReferenceParm, NativeAccessSpecifierPublic)
	ETwitterRequestMethod                         RequestMethod;                                     // 0x0020(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x3];                                       // 0x0021(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AccountIndex;                                      // 0x0024(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          ReturnValue;                                       // 0x0028(0x0001)(Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(TwitterIntegrationBase_TwitterRequest) == 0x000008, "Wrong alignment on TwitterIntegrationBase_TwitterRequest");
static_assert(sizeof(TwitterIntegrationBase_TwitterRequest) == 0x000030, "Wrong size on TwitterIntegrationBase_TwitterRequest");
static_assert(offsetof(TwitterIntegrationBase_TwitterRequest, URL) == 0x000000, "Member 'TwitterIntegrationBase_TwitterRequest::URL' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_TwitterRequest, ParamKeysAndValues) == 0x000010, "Member 'TwitterIntegrationBase_TwitterRequest::ParamKeysAndValues' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_TwitterRequest, RequestMethod) == 0x000020, "Member 'TwitterIntegrationBase_TwitterRequest::RequestMethod' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_TwitterRequest, AccountIndex) == 0x000024, "Member 'TwitterIntegrationBase_TwitterRequest::AccountIndex' has a wrong offset!");
static_assert(offsetof(TwitterIntegrationBase_TwitterRequest, ReturnValue) == 0x000028, "Member 'TwitterIntegrationBase_TwitterRequest::ReturnValue' has a wrong offset!");

// Function Engine.VisualLoggerKismetLibrary.LogBox
// 0x0050 (0x0050 - 0x0000)
struct VisualLoggerKismetLibrary_LogBox final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FBox                                   BoxShape;                                          // 0x0008(0x001C)(Parm, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0028(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ObjectColor;                                       // 0x0038(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LogCategory;                                       // 0x0048(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualLoggerKismetLibrary_LogBox) == 0x000008, "Wrong alignment on VisualLoggerKismetLibrary_LogBox");
static_assert(sizeof(VisualLoggerKismetLibrary_LogBox) == 0x000050, "Wrong size on VisualLoggerKismetLibrary_LogBox");
static_assert(offsetof(VisualLoggerKismetLibrary_LogBox, WorldContextObject) == 0x000000, "Member 'VisualLoggerKismetLibrary_LogBox::WorldContextObject' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogBox, BoxShape) == 0x000008, "Member 'VisualLoggerKismetLibrary_LogBox::BoxShape' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogBox, Text) == 0x000028, "Member 'VisualLoggerKismetLibrary_LogBox::Text' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogBox, ObjectColor) == 0x000038, "Member 'VisualLoggerKismetLibrary_LogBox::ObjectColor' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogBox, LogCategory) == 0x000048, "Member 'VisualLoggerKismetLibrary_LogBox::LogCategory' has a wrong offset!");

// Function Engine.VisualLoggerKismetLibrary.LogLocation
// 0x0048 (0x0048 - 0x0000)
struct VisualLoggerKismetLibrary_LogLocation final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Location;                                          // 0x0008(0x000C)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Text;                                              // 0x0018(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           ObjectColor;                                       // 0x0028(0x0010)(Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Radius;                                            // 0x0038(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LogCategory;                                       // 0x0040(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualLoggerKismetLibrary_LogLocation) == 0x000008, "Wrong alignment on VisualLoggerKismetLibrary_LogLocation");
static_assert(sizeof(VisualLoggerKismetLibrary_LogLocation) == 0x000048, "Wrong size on VisualLoggerKismetLibrary_LogLocation");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, WorldContextObject) == 0x000000, "Member 'VisualLoggerKismetLibrary_LogLocation::WorldContextObject' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, Location) == 0x000008, "Member 'VisualLoggerKismetLibrary_LogLocation::Location' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, Text) == 0x000018, "Member 'VisualLoggerKismetLibrary_LogLocation::Text' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, ObjectColor) == 0x000028, "Member 'VisualLoggerKismetLibrary_LogLocation::ObjectColor' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, Radius) == 0x000038, "Member 'VisualLoggerKismetLibrary_LogLocation::Radius' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogLocation, LogCategory) == 0x000040, "Member 'VisualLoggerKismetLibrary_LogLocation::LogCategory' has a wrong offset!");

// Function Engine.VisualLoggerKismetLibrary.LogText
// 0x0020 (0x0020 - 0x0000)
struct VisualLoggerKismetLibrary_LogText final
{
public:
	class UObject*                                WorldContextObject;                                // 0x0000(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Text;                                              // 0x0008(0x0010)(Parm, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   LogCategory;                                       // 0x0018(0x0008)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(VisualLoggerKismetLibrary_LogText) == 0x000008, "Wrong alignment on VisualLoggerKismetLibrary_LogText");
static_assert(sizeof(VisualLoggerKismetLibrary_LogText) == 0x000020, "Wrong size on VisualLoggerKismetLibrary_LogText");
static_assert(offsetof(VisualLoggerKismetLibrary_LogText, WorldContextObject) == 0x000000, "Member 'VisualLoggerKismetLibrary_LogText::WorldContextObject' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogText, Text) == 0x000008, "Member 'VisualLoggerKismetLibrary_LogText::Text' has a wrong offset!");
static_assert(offsetof(VisualLoggerKismetLibrary_LogText, LogCategory) == 0x000018, "Member 'VisualLoggerKismetLibrary_LogText::LogCategory' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetMaximumGustAmount
// 0x0004 (0x0004 - 0x0000)
struct WindDirectionalSourceComponent_SetMaximumGustAmount final
{
public:
	float                                         InNewMaxGust;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetMaximumGustAmount) == 0x000004, "Wrong alignment on WindDirectionalSourceComponent_SetMaximumGustAmount");
static_assert(sizeof(WindDirectionalSourceComponent_SetMaximumGustAmount) == 0x000004, "Wrong size on WindDirectionalSourceComponent_SetMaximumGustAmount");
static_assert(offsetof(WindDirectionalSourceComponent_SetMaximumGustAmount, InNewMaxGust) == 0x000000, "Member 'WindDirectionalSourceComponent_SetMaximumGustAmount::InNewMaxGust' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetMinimumGustAmount
// 0x0004 (0x0004 - 0x0000)
struct WindDirectionalSourceComponent_SetMinimumGustAmount final
{
public:
	float                                         InNewMinGust;                                      // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetMinimumGustAmount) == 0x000004, "Wrong alignment on WindDirectionalSourceComponent_SetMinimumGustAmount");
static_assert(sizeof(WindDirectionalSourceComponent_SetMinimumGustAmount) == 0x000004, "Wrong size on WindDirectionalSourceComponent_SetMinimumGustAmount");
static_assert(offsetof(WindDirectionalSourceComponent_SetMinimumGustAmount, InNewMinGust) == 0x000000, "Member 'WindDirectionalSourceComponent_SetMinimumGustAmount::InNewMinGust' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetRadius
// 0x0004 (0x0004 - 0x0000)
struct WindDirectionalSourceComponent_SetRadius final
{
public:
	float                                         InNewRadius;                                       // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetRadius) == 0x000004, "Wrong alignment on WindDirectionalSourceComponent_SetRadius");
static_assert(sizeof(WindDirectionalSourceComponent_SetRadius) == 0x000004, "Wrong size on WindDirectionalSourceComponent_SetRadius");
static_assert(offsetof(WindDirectionalSourceComponent_SetRadius, InNewRadius) == 0x000000, "Member 'WindDirectionalSourceComponent_SetRadius::InNewRadius' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetSpeed
// 0x0004 (0x0004 - 0x0000)
struct WindDirectionalSourceComponent_SetSpeed final
{
public:
	float                                         InNewSpeed;                                        // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetSpeed) == 0x000004, "Wrong alignment on WindDirectionalSourceComponent_SetSpeed");
static_assert(sizeof(WindDirectionalSourceComponent_SetSpeed) == 0x000004, "Wrong size on WindDirectionalSourceComponent_SetSpeed");
static_assert(offsetof(WindDirectionalSourceComponent_SetSpeed, InNewSpeed) == 0x000000, "Member 'WindDirectionalSourceComponent_SetSpeed::InNewSpeed' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetStrength
// 0x0004 (0x0004 - 0x0000)
struct WindDirectionalSourceComponent_SetStrength final
{
public:
	float                                         InNewStrength;                                     // 0x0000(0x0004)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetStrength) == 0x000004, "Wrong alignment on WindDirectionalSourceComponent_SetStrength");
static_assert(sizeof(WindDirectionalSourceComponent_SetStrength) == 0x000004, "Wrong size on WindDirectionalSourceComponent_SetStrength");
static_assert(offsetof(WindDirectionalSourceComponent_SetStrength, InNewStrength) == 0x000000, "Member 'WindDirectionalSourceComponent_SetStrength::InNewStrength' has a wrong offset!");

// Function Engine.WindDirectionalSourceComponent.SetWindType
// 0x0001 (0x0001 - 0x0000)
struct WindDirectionalSourceComponent_SetWindType final
{
public:
	EWindSourceType                               InNewType;                                         // 0x0000(0x0001)(Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(WindDirectionalSourceComponent_SetWindType) == 0x000001, "Wrong alignment on WindDirectionalSourceComponent_SetWindType");
static_assert(sizeof(WindDirectionalSourceComponent_SetWindType) == 0x000001, "Wrong size on WindDirectionalSourceComponent_SetWindType");
static_assert(offsetof(WindDirectionalSourceComponent_SetWindType, InNewType) == 0x000000, "Member 'WindDirectionalSourceComponent_SetWindType::InNewType' has a wrong offset!");

}

